{
  "$schema": "https://raw.githubusercontent.com/schemastore/schemastore/master/src/schemas/json/sarif-2.1.0-rtm.5.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "IC",
          "fullName": "Qodana",
          "version": "242.23339.11",
          "rules": [],
          "taxa": [
            {
              "id": "语言注入",
              "name": "语言注入"
            },
            {
              "id": "Maven",
              "name": "Maven"
            },
            {
              "id": "JVM 语言",
              "name": "JVM 语言"
            },
            {
              "id": "Kotlin",
              "name": "Kotlin"
            },
            {
              "id": "Kotlin/样式问题",
              "name": "样式问题",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/冗余结构",
              "name": "冗余结构",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java",
              "name": "Java"
            },
            {
              "id": "Java/可移植性",
              "name": "可移植性",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/线程问题",
              "name": "线程问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/国际化",
              "name": "国际化",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/性能",
              "name": "性能",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/类结构",
              "name": "类结构",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/代码样式问题",
              "name": "代码样式问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/可能的 bug",
              "name": "可能的 bug",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/声明冗余",
              "name": "声明冗余",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/错误处理",
              "name": "错误处理",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/迁移",
              "name": "迁移",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Shell 脚本",
              "name": "Shell 脚本"
            },
            {
              "id": "模式验证",
              "name": "模式验证"
            },
            {
              "id": "Java/序列化问题",
              "name": "序列化问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/性能/嵌入式",
              "name": "嵌入式",
              "relationships": [
                {
                  "target": {
                    "id": "Java/性能",
                    "index": 10,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy",
              "name": "Groovy"
            },
            {
              "id": "Groovy/GPath",
              "name": "GPath",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/导入",
              "name": "导入",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/数据流",
              "name": "数据流",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/可能的 bug",
              "name": "可能的 bug",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/继承问题",
              "name": "继承问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/数值问题",
              "name": "数值问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/控制流问题",
              "name": "控制流问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/初始化",
              "name": "初始化",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "HTML",
              "name": "HTML"
            },
            {
              "id": "Java/安全性",
              "name": "安全性",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "EditorConfig",
              "name": "EditorConfig"
            },
            {
              "id": "属性文件",
              "name": "属性文件"
            },
            {
              "id": "Java/JavaBeans 问题",
              "name": "JavaBeans 问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/赋值问题",
              "name": "赋值问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/命名约定",
              "name": "命名约定",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/打包问题",
              "name": "打包问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/详细或冗余的代码结构",
              "name": "详细或冗余的代码结构",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/线程问题",
              "name": "线程问题",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Gradle",
              "name": "Gradle"
            },
            {
              "id": "Gradle/可能的 bug",
              "name": "可能的 bug",
              "relationships": [
                {
                  "target": {
                    "id": "Gradle",
                    "index": 40,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/错误处理",
              "name": "错误处理",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "HTML/可访问性",
              "name": "可访问性",
              "relationships": [
                {
                  "target": {
                    "id": "HTML",
                    "index": 30,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "常规",
              "name": "常规"
            },
            {
              "id": "JVM 语言/日志记录",
              "name": "日志记录",
              "relationships": [
                {
                  "target": {
                    "id": "JVM 语言",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Javadoc",
              "name": "Javadoc",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/资源管理",
              "name": "资源管理",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Gradle/有效性问题",
              "name": "有效性问题",
              "relationships": [
                {
                  "target": {
                    "id": "Gradle",
                    "index": 40,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/命名约定",
              "name": "命名约定",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/代码成熟度",
              "name": "代码成熟度",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名约定",
              "name": "命名约定",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助",
              "name": "Java 语言级别迁移帮助",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 5",
              "name": "Java 5",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/可能的 bug",
              "name": "可能的 bug",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/其他问题",
              "name": "其他问题",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/可见性",
              "name": "可见性",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/封装",
              "name": "封装",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/并发注解问题",
              "name": "并发注解问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "YAML",
              "name": "YAML"
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 8",
              "name": "Java 8",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级迁移帮助",
              "name": "Java 语言级迁移帮助",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级问题",
              "name": "Java 语言级问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "XML",
              "name": "XML"
            },
            {
              "id": "Java/完成",
              "name": "完成",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/赋值问题",
              "name": "赋值问题",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/模块化问题",
              "name": "模块化问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/Java 互操作问题",
              "name": "Java 互操作问题",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名约定/类",
              "name": "类",
              "relationships": [
                {
                  "target": {
                    "id": "Java/命名约定",
                    "index": 51,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/内存",
              "name": "内存",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/控制流问题",
              "name": "控制流问题",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/可能引起混淆的代码结构",
              "name": "可能引起混淆的代码结构",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/TestNG",
              "name": "TestNG",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JUnit",
              "name": "JUnit"
            },
            {
              "id": "Java/抽象问题",
              "name": "抽象问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 21",
              "name": "Java 21",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 9",
              "name": "Java 9",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/JUnit",
              "name": "JUnit",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/其他",
              "name": "其他",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/克隆问题",
              "name": "克隆问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/样式",
              "name": "样式",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "正则表达式",
              "name": "正则表达式"
            },
            {
              "id": "JavaFX",
              "name": "JavaFX"
            },
            {
              "id": "UI 窗体",
              "name": "UI 窗体"
            },
            {
              "id": "Java/类指标",
              "name": "类指标",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名约定/方法",
              "name": "方法",
              "relationships": [
                {
                  "target": {
                    "id": "Java/命名约定",
                    "index": 51,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/代码迁移",
              "name": "代码迁移",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/依赖性问题",
              "name": "依赖性问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/编译器问题",
              "name": "编译器问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/注解",
              "name": "注解",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "校对",
              "name": "校对"
            },
            {
              "id": "清单",
              "name": "清单"
            },
            {
              "id": "Java/记录",
              "name": "记录",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Markdown",
              "name": "Markdown"
            },
            {
              "id": "JVM 语言/测试框架",
              "name": "测试框架",
              "relationships": [
                {
                  "target": {
                    "id": "JVM 语言",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/方法指标",
              "name": "方法指标",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "安全性",
              "name": "安全性"
            },
            {
              "id": "Java/测试框架",
              "name": "测试框架",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/按位运算问题",
              "name": "按位运算问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/反射访问",
              "name": "反射访问",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "代码覆盖率",
              "name": "代码覆盖率"
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 15",
              "name": "Java 15",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 14",
              "name": "Java 14",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/有效性问题",
              "name": "有效性问题",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/数值问题/转换",
              "name": "转换",
              "relationships": [
                {
                  "target": {
                    "id": "Java/数值问题",
                    "index": 27,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 23",
              "name": "Java 23",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JSON 和 JSON5",
              "name": "JSON 和 JSON5"
            },
            {
              "id": "Groovy/数据流",
              "name": "数据流",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/方法指标",
              "name": "方法指标",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin，迁移",
              "name": "Kotlin，迁移"
            },
            {
              "id": "Kotlin，迁移/Maven",
              "name": "Maven",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin，迁移",
                    "index": 109,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "国际化",
              "name": "国际化"
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 10",
              "name": "Java 10",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 16",
              "name": "Java 16",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 7",
              "name": "Java 7",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "TOML",
              "name": "TOML"
            },
            {
              "id": "版本控制",
              "name": "版本控制"
            },
            {
              "id": "Kotlin，迁移/Gradle",
              "name": "Gradle",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin，迁移",
                    "index": 109,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/可能的 bug/为 null 性问题",
              "name": "为 null 性问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java/可能的 bug",
                    "index": 13,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/日志记录",
              "name": "日志记录",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "结构搜索",
              "name": "结构搜索"
            },
            {
              "id": "Gradle/样式",
              "name": "样式",
              "relationships": [
                {
                  "target": {
                    "id": "Gradle",
                    "index": 40,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/toString() 问题",
              "name": "toString() 问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "RELAX NG",
              "name": "RELAX NG"
            },
            {
              "id": "Java/属性文件",
              "name": "属性文件",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 11",
              "name": "Java 11",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Qodana",
              "name": "Qodana"
            },
            {
              "id": "Kotlin/React",
              "name": "React",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/React/可能的 bug",
              "name": "可能的 bug",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin/React",
                    "index": 127,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "声明式 Gradle",
              "name": "声明式 Gradle"
            },
            {
              "id": "Gradle/最佳做法",
              "name": "最佳做法",
              "relationships": [
                {
                  "target": {
                    "id": "Gradle",
                    "index": 40,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/协程检查",
              "name": "协程检查",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 3,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/声明冗余",
              "name": "声明冗余",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        },
        "extensions": [
          {
            "name": "org.intellij.intelliLang",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "InjectionNotApplicable",
                "shortDescription": {
                  "text": "注入注解不适用"
                },
                "fullDescription": {
                  "text": "报告将 '@Language' 注解应用于 'String' 或 'String[]' 以外类型的元素的情况。 示例： '@Language(\"HTML\") int i;' 在应用快速修复后： 'int i;'",
                  "markdown": "报告将 `@Language` 注解应用于 `String` 或 `String[]` 以外类型的元素的情况。\n\n**示例：**\n\n\n      @Language(\"HTML\") int i;\n\n在应用快速修复后：\n\n\n      int i;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "InjectionNotApplicable",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "语言注入",
                      "index": 0,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternNotApplicable",
                "shortDescription": {
                  "text": "模式注解不适用"
                },
                "fullDescription": {
                  "text": "报告将 '@Pattern' 注解应用于 'String' 之外类型的元素的情况。 示例： '@Pattern(\"\\\\d\\\\d\") int i;'",
                  "markdown": "报告将 `@Pattern` 注解应用于 `String` 之外类型的元素的情况。\n\n**示例：**\n\n\n      @Pattern(\"\\\\d\\\\d\") int i;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PatternNotApplicable",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "模式验证",
                      "index": 18,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnknownLanguage",
                "shortDescription": {
                  "text": "未知语言 ID"
                },
                "fullDescription": {
                  "text": "报告 '@Language' 注解中使用的语言 ID 未知的情况。 示例： '@Language(\"HMTL\") String html;'",
                  "markdown": "报告 `@Language` 注解中使用的语言 ID 未知的情况。\n\n**示例：**\n\n\n      @Language(\"HMTL\") String html;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "UnknownLanguage",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "语言注入",
                      "index": 0,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternOverriddenByNonAnnotatedMethod",
                "shortDescription": {
                  "text": "无注解的方法重写 @Pattern 方法"
                },
                "fullDescription": {
                  "text": "报告不带 '@Pattern' 注解的方法重写带 '@Pattern' 注解方法的情况。 这不会阻止在编辑器中高亮显示错误，但重写方法在运行时将不会被检查。 提供了快速修复，用于添加与超类方法中注解相匹配的 '@Pattern' 注解。 这确保 运行时检查检测正常工作。 示例： 'abstract class Parent {\n    abstract @Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId();\n  }\n  class Child extends Parent {\n    @Override String getId() { // 此处为警告\n      return \"12-345\";\n    }\n  }'",
                  "markdown": "报告不带 `@Pattern` 注解的方法重写带 `@Pattern` 注解方法的情况。 这不会阻止在编辑器中高亮显示错误，但重写方法在运行时将不会被检查。\n\n\n提供了快速修复，用于添加与超类方法中注解相匹配的 `@Pattern` 注解。 这确保\n运行时检查检测正常工作。\n\n**示例：**\n\n\n      abstract class Parent {\n        abstract @Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId();\n      }\n      class Child extends Parent {\n        @Override String getId() { // 此处为警告\n          return \"12-345\";\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternOverriddenByNonAnnotatedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "模式验证",
                      "index": 18,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InjectedReferences",
                "shortDescription": {
                  "text": "已注入的引用"
                },
                "fullDescription": {
                  "text": "报告语言注入所注入的未解析引用。 示例： '@Language(\"file-reference\")\n    String fileName = \"/home/user/nonexistent.file\"; // 文件不存在时高亮显示'",
                  "markdown": "报告[语言注入](https://www.jetbrains.com/help/idea/using-language-injections.html)所注入的未解析引用。\n\n示例：\n\n\n        @Language(\"file-reference\")\n        String fileName = \"/home/user/nonexistent.file\"; // 文件不存在时高亮显示\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "InjectedReferences",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternValidation",
                "shortDescription": {
                  "text": "验证已注解模式"
                },
                "fullDescription": {
                  "text": "报告作为 '@Pattern' 形参的实参传递并从与指定模式不匹配的 '@Pattern' 注解方法返回的表达式。 示例： '@Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId() {\n    return \"1\";\n  }' 使用标记非编译时常量表达式选项，可以让检查报告具有未知值的表达式，并提议添加替换 ('@Subst') 注解",
                  "markdown": "报告作为 `@Pattern` 形参的实参传递并从与指定模式不匹配的 `@Pattern` 注解方法返回的表达式。\n\n**示例：**\n\n\n      @Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId() {\n        return \"1\";\n      }\n\n\n使用**标记非编译时常量表达式** 选项，可以让检查报告具有未知值的表达式，并提议添加替换 (`@Subst`) 注解"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternValidation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "模式验证",
                      "index": 18,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LanguageMismatch",
                "shortDescription": {
                  "text": "语言不匹配"
                },
                "fullDescription": {
                  "text": "报告引用的语言与用法上下文的预期语言不匹配的情况。 示例： '@Language(\"JavaScript\")\n  String JS_CODE = \"var x;\";\n\n  @Language(\"XPath\")\n  String XPATH_CODE = JS_CODE; // 此处为警告'",
                  "markdown": "报告引用的语言与用法上下文的预期语言不匹配的情况。\n\n示例：\n\n\n      @Language(\"JavaScript\")\n      String JS_CODE = \"var x;\";\n\n      @Language(\"XPath\")\n      String XPATH_CODE = JS_CODE; // 此处为警告\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LanguageMismatch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "语言注入",
                      "index": 0,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.idea.maven",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "MavenRedundantGroupId",
                "shortDescription": {
                  "text": "冗余 groupId"
                },
                "fullDescription": {
                  "text": "报告不必要的 <groupId> 定义，因为它已经在父 pom.xml 中定义",
                  "markdown": "报告不必要的 \\<groupId\\> 定义，因为它已经在父 pom.xml 中定义"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MavenRedundantGroupId",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenDuplicatePluginInspection",
                "shortDescription": {
                  "text": "重复的插件声明"
                },
                "fullDescription": {
                  "text": "报告 pom.xml 中插件声明的重复",
                  "markdown": "报告 pom.xml 中插件声明的重复"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MavenDuplicatePluginInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenPropertyInParent",
                "shortDescription": {
                  "text": "在父描述中使用属性"
                },
                "fullDescription": {
                  "text": "报告使用父模块中定义的属性是被禁止的。",
                  "markdown": "报告使用父模块中定义的属性是被禁止的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MavenPropertyInParent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenDuplicateDependenciesInspection",
                "shortDescription": {
                  "text": "重复的依赖项"
                },
                "fullDescription": {
                  "text": "报告重复的依赖项",
                  "markdown": "报告重复的依赖项"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MavenDuplicateDependenciesInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenModelInspection",
                "shortDescription": {
                  "text": "Maven 模型检查"
                },
                "fullDescription": {
                  "text": "报告 Maven 模型中的解析问题",
                  "markdown": "报告 Maven 模型中的解析问题"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MavenModelInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenParentMissedVersionInspection",
                "shortDescription": {
                  "text": "缺少父版本"
                },
                "fullDescription": {
                  "text": "报告不支持使用者 POM 功能的版本缺少父版本元素",
                  "markdown": "报告不支持使用者 POM 功能的版本缺少父版本元素"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MavenParentMissedVersionInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.java",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "OverrideOnly",
                "shortDescription": {
                  "text": "方法只能重写"
                },
                "fullDescription": {
                  "text": "报告对使用 '@ApiStatus.OverrideOnly' 标记的 API 方法的调用。 '@ApiStatus.OverrideOnly' 注解表示该方法是 SPI（服务提供程序接口）的一部分。 声明库的客户端应实现或重写此类方法，而不是直接调用。 使用此注解标记类或接口与使用它标记每个方法相同。",
                  "markdown": "报告对使用 `@ApiStatus.OverrideOnly` 标记的 API 方法的调用。\n\n\n`@ApiStatus.OverrideOnly` 注解表示该方法是 SPI（服务提供程序接口）的一部分。\n声明库的客户端应实现或重写此类方法，而不是直接调用。\n使用此注解标记类或接口与使用它标记每个方法相同。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverrideOnly",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RuntimeExec",
                "shortDescription": {
                  "text": "调用 'Runtime.exec()'"
                },
                "fullDescription": {
                  "text": "报告对 'Runtime.exec()' 或其任何变体的调用。 对 'Runtime.exec()' 的调用本质上不可移植。",
                  "markdown": "报告对 `Runtime.exec()` 或其任何变体的调用。 对 `Runtime.exec()` 的调用本质上不可移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToRuntimeExec",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticInitializerReferencesSubClass",
                "shortDescription": {
                  "text": "static 初始值设定项引用子类"
                },
                "fullDescription": {
                  "text": "报告在 static 初始值设定项或 static 字段中引用其子类的类。 此类引用可能在多线程环境（即一个线程试图加载超类，另一个线程同时试图加载子类）中引起 JVM 级死锁。 示例： 'class Parent {\n    static final Child field = new Child();\n  }\n  class Child extends Parent { }'",
                  "markdown": "报告在 static 初始值设定项或 static 字段中引用其子类的类。\n\n此类引用可能在多线程环境（即一个线程试图加载超类，另一个线程同时试图加载子类）中引起 JVM 级死锁。\n\n**示例：**\n\n\n      class Parent {\n        static final Child field = new Child();\n      }\n      class Child extends Parent { }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticInitializerReferencesSubClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingDeprecatedAnnotationOnScheduledForRemovalApi",
                "shortDescription": {
                  "text": "已计划移除的 API 上缺少 '@Deprecated' 注解"
                },
                "fullDescription": {
                  "text": "报告使用 '@ApiStatus.ScheduledForRemoval'（没有 '@Deprecated'）标记的声明。 示例： '@ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n  public void myLegacyMethod() { }' 应用快速修复后，结果如下所示： '@Deprecated\n  @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n  public void myLegacyMethod() { }'",
                  "markdown": "报告使用 `@ApiStatus.ScheduledForRemoval`（没有 `@Deprecated`）标记的声明。\n\n示例：\n\n\n      @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n      public void myLegacyMethod() { }\n\n应用快速修复后，结果如下所示：\n\n\n      @Deprecated\n      @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n      public void myLegacyMethod() { }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MissingDeprecatedAnnotationOnScheduledForRemovalApi",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToSuspiciousStringMethod",
                "shortDescription": {
                  "text": "调用可疑的 'String' 方法"
                },
                "fullDescription": {
                  "text": "报告对以下各项的调用： 'equals()' 'equalsIgnoreCase()' 'compareTo()' 'compareToIgnoreCase()' 和 'trim()' （发生在 'String' 对象上）。 国际化字符串的比较可能应改用 'java.text.Collator'。 'String.trim()' 只会移除 0x00 和 0x20 之间的控制字符。 Java 11 中引入的 'String.strip()' 方法对 Unicode 的感知更好，可以作为替代。",
                  "markdown": "报告对以下各项的调用：\n\n* `equals()`\n* `equalsIgnoreCase()`\n* `compareTo()`\n* `compareToIgnoreCase()` 和\n* `trim()`\n\n\n（发生在 `String` 对象上）。\n国际化字符串的比较可能应改用 `java.text.Collator`。\n`String.trim()` 只会移除 0x00 和 0x20 之间的控制字符。\nJava 11 中引入的 `String.strip()` 方法对 Unicode 的感知更好，可以作为替代。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSuspiciousStringMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KeySetIterationMayUseEntrySet",
                "shortDescription": {
                  "text": "可以优化对 'keySet()' 的迭代"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Map' 实例的 'keySet()' 的迭代，其中迭代的键用于从映射中检索值。 替换为 'entrySet()' 或 'values()' 的迭代时，此类迭代可能会更有效（如果实际上没有使用键）。 同理，如果在 lambda 中检索值，则 'keySet().forEach(key -> ...)' 可以替换为 'forEach((key, value) -> ...)'。 示例： 'for (Object key : map.keySet()) {\n   Object val = map.get(key);\n  }' 在应用快速修复后： 'for (Object val : map.values()) {}'",
                  "markdown": "报告对 `java.util.Map` 实例的 `keySet()` 的迭代，其中迭代的键用于从映射中检索值。\n\n\n替换为 `entrySet()` 或 `values()` 的迭代时，此类迭代可能会更有效（如果实际上没有使用键）。\n\n\n同理，如果在 lambda 中检索值，则 `keySet().forEach(key -> ...)` 可以替换为 `forEach((key, value) -> ...)`。\n\n**示例：**\n\n\n      for (Object key : map.keySet()) {\n       Object val = map.get(key);\n      }\n\n在应用快速修复后：\n\n\n      for (Object val : map.values()) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KeySetIterationMayUseEntrySet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantDeclaredInAbstractClass",
                "shortDescription": {
                  "text": "在 'abstract' 类中声明的常量"
                },
                "fullDescription": {
                  "text": "报告在 abstract 类中声明的常量（'public static final' 字段）。 有些编码标准要求在接口中声明常量。",
                  "markdown": "报告在 abstract 类中声明的常量（`public static final` 字段）。\n\n有些编码标准要求在接口中声明常量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantDeclaredInAbstractClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryQualifierForThis",
                "shortDescription": {
                  "text": "'this' 或 'super' 的限定符不必要"
                },
                "fullDescription": {
                  "text": "报告不必要的 'this' 或 'super' 限定。 在 'this' 或 'super' 上使用限定符来消除代码引用的歧义可能很容易通过自动重构变得不必要，为了清楚起见应该删除。 示例： 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      Bar.super.foo();\n    }\n  }' 在应用快速修复后： 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      super.foo();\n    }\n  }'",
                  "markdown": "报告不必要的 `this` 或 `super` 限定。\n\n\n在 `this` 或 `super` 上使用限定符来消除代码引用的歧义可能很容易通过自动重构变得不必要，为了清楚起见应该删除。\n\n**示例：**\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          Bar.super.foo();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          super.foo();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryQualifierForThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SubtractionInCompareTo",
                "shortDescription": {
                  "text": "'compareTo()' 中的减法"
                },
                "fullDescription": {
                  "text": "报告 'compareTo()' 方法和实现 'java.util.Comparator.compare()' 的方法中的减法。 虽然使用整数减法的结果作为 'compareTo()' 方法的结果是一种惯常做法，但在整数溢出的情况下，此结构可能会导致难以捉摸的错误。 在大多数情况下，更好的做法是直接比较整数值并返回 '-1'、'0' 或 '1' 。 四舍五入可能导致精度损失，因此也会报告直接转换为整型的浮点值减法。 在静态地确定值范围有限并且决不会发生溢出时，该检查不会报告。 此外，对 'int' 大于或等于 '0' 的数字执行减法绝不会溢出。 因此，在这样的情况下此检查不发出警告。 总是返回零或更大值的方法可以用 'javax.annotation.Nonnegative' 注解进行标记，或者在此检查的选项中指定。 示例： 'class DoubleHolder implements Comparable<DoubleHolder> {\n    double d;\n    public int compareTo(DoubleHolder that) {\n        return (int)(this.d - that.d);\n    }\n }' 这是一个无警告的示例，因为已知 'String.length()' 非负： 'class A implements Comparable<A> {\n    final String s = \"\";\n    public int compareTo(A a) {\n        return s.length() - a.s.length();\n    }\n }' 使用这些选项可列出在减法中安全使用的方法。 方法返回始终大于或等于 '0' 的 'int' 值时，表明方法就是安全的。",
                  "markdown": "报告 `compareTo()` 方法和实现 `java.util.Comparator.compare()` 的方法中的减法。\n\n\n虽然使用整数减法的结果作为 `compareTo()` 方法的结果是一种惯常做法，但在整数溢出的情况下，此结构可能会导致难以捉摸的错误。\n在大多数情况下，更好的做法是直接比较整数值并返回 `-1`、`0` 或 `1` 。\n\n\n四舍五入可能导致精度损失，因此也会报告直接转换为整型的浮点值减法。\n\n\n在静态地确定值范围有限并且决不会发生溢出时，该检查不会报告。\n此外，对 `int` 大于或等于 `0` 的数字执行减法绝不会溢出。\n因此，在这样的情况下此检查不发出警告。\n\n\n总是返回零或更大值的方法可以用 `javax.annotation.Nonnegative` 注解进行标记，或者在此检查的选项中指定。\n\n**示例：**\n\n\n      class DoubleHolder implements Comparable<DoubleHolder> {\n        double d;\n        public int compareTo(DoubleHolder that) {\n            return (int)(this.d - that.d);\n        }\n     }\n\n这是一个无警告的示例，因为已知 `String.length()` 非负：\n\n\n      class A implements Comparable<A> {\n        final String s = \"\";\n        public int compareTo(A a) {\n            return s.length() - a.s.length();\n        }\n     }\n\n\n使用这些选项可列出在减法中安全使用的方法。\n方法返回始终大于或等于 `0` 的 `int` 值时，表明方法就是安全的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SubtractionInCompareTo",
                    "cweIds": [
                      682
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedReturnValue",
                "shortDescription": {
                  "text": "方法可以为 'void'"
                },
                "fullDescription": {
                  "text": "报告调用时从不使用其返回值的方法。 此类方法的返回类型可以设置为 'void'。 不会报告使用 Error Prone 或 AssertJ 的 '@CanIgnoreReturnValue' 注解进行注解的方法。 该快速修复会更新方法签名，并移除方法中的 'return' 语句。 示例： '// 可见性设置为 Protected 或 Public 时报告\n  protected String myToUpperCase(String s) {\n    return s.toUpperCase();\n  }\n\n  // 简单的 setter，根据设置进行报告\n  public String setStr(String str) {\n    myStr = str;\n    return myStr;\n  }\n\n  void test() {\n    setStr(\"value\");          // 未使用返回值\n    myToUpperCase(\"result\");  // 未使用返回值\n  }' 对这两种方法应用该快速修复后： 'protected void myToUpperCase(String s) {\n      // 完全移除了 'return'\n      // 因为 's.toUpperCase()' 没有任何副作用\n    }\n\n    public void setStr(String str) {\n      myStr = str;\n      // 移除了 'return'\n    }\n  ...' 注意：由于性能原因，在编辑器中高亮显示时可能不会报告某些方法。 要查看所有结果，请通过代码 | 检查代码或代码 | 分析代码 | 按名称运行检查来运行检查> 使用忽略可链接方法选项可以忽略可链接调用中未使用的返回值。 使用报告方法最大可见性选项可以控制要报告的方法的最大可见性。",
                  "markdown": "报告调用时从不使用其返回值的方法。 此类方法的返回类型可以设置为 `void`。\n\n不会报告使用 Error Prone 或 AssertJ 的 `@CanIgnoreReturnValue` 注解进行注解的方法。\n该快速修复会更新方法签名，并移除方法中的 `return` 语句。\n\n**示例：**\n\n\n      // 可见性设置为 Protected 或 Public 时报告\n      protected String myToUpperCase(String s) {\n        return s.toUpperCase();\n      }\n\n      // 简单的 setter，根据设置进行报告\n      public String setStr(String str) {\n        myStr = str;\n        return myStr;\n      }\n\n      void test() {\n        setStr(\"value\");          // 未使用返回值\n        myToUpperCase(\"result\");  // 未使用返回值\n      }\n\n对这两种方法应用该快速修复后：\n\n\n        protected void myToUpperCase(String s) {\n          // 完全移除了 'return'\n          // 因为 's.toUpperCase()' 没有任何副作用\n        }\n\n        public void setStr(String str) {\n          myStr = str;\n          // 移除了 'return'\n        }\n      ...\n\n\n**注意** ：由于性能原因，在编辑器中高亮显示时可能不会报告某些方法。\n要查看所有结果，请通过**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 按名称运行检查**来运行检查\\>\n\n使用**忽略可链接方法**选项可以忽略可链接调用中未使用的返回值。\n\n使用**报告方法最大可见性**选项可以控制要报告的方法的最大可见性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedReturnValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UncheckedExceptionClass",
                "shortDescription": {
                  "text": "未检查的 'Exception' 类"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.RuntimeException' 的子类。 某些编码标准要求检查所有用户定义的异常类。 示例： 'class EnigmaException extends RuntimeException {} // 警告：未检查的异常类 'EnigmaException''",
                  "markdown": "报告 `java.lang.RuntimeException` 的子类。\n\n某些编码标准要求检查所有用户定义的异常类。\n\n**示例：**\n\n\n      class EnigmaException extends RuntimeException {} // 警告：未检查的异常类 'EnigmaException'\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UncheckedExceptionClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SizeReplaceableByIsEmpty",
                "shortDescription": {
                  "text": "'size() == 0' 可被替换为 'isEmpty()'"
                },
                "fullDescription": {
                  "text": "报告 '0' 文字可以替换为对 '.isEmpty()' 的调用的 '.size()' 或 '.length()' 比较。 示例： 'boolean emptyList = list.size() == 0;' 在应用快速修复后： 'boolean emptyList = list.isEmpty();' 使用忽略类表可以添加不应为之替换任何 '.size()' 或 '.length()' 比较的类。 使用忽略将替换为 ''!isEmpty()'' 的表达式选项可以忽略任何将替换为 '!isEmpty()' 的表达式。",
                  "markdown": "报告 `0` 文字可以替换为对 `.isEmpty()` 的调用的 `.size()` 或 `.length()` 比较。\n\n**示例：**\n\n\n      boolean emptyList = list.size() == 0;\n\n在应用快速修复后：\n\n\n      boolean emptyList = list.isEmpty();\n      \n\n使用**忽略类** 表可以添加不应为之替换任何 `.size()` 或 `.length()` 比较的类。\n\n使用**忽略将替换为 `'!isEmpty()'` 的表达式** 选项可以忽略任何将替换为 `!isEmpty()` 的表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SizeReplaceableByIsEmpty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsupportedChronoFieldUnitCall",
                "shortDescription": {
                  "text": "使用不受支持的 'java.time.temporal.ChronoUnit' 和 'java.time.temporal.ChronoField' 调用方法"
                },
                "fullDescription": {
                  "text": "报告以不支持的 'java.time.temporal.ChronoField' 或 'java.time.temporal.ChronoUnit' 枚举常量作为实参的 'java.time' 方法调用（'get()'、'getLong()'、 'with()'、'plus()'、'minus()'）。 此类调用将在运行时抛出 'UnsupportedTemporalTypeException'。 示例： 'LocalTime localTime = LocalTime.now();\nint year = localTime.get(ChronoField.YEAR);' 2023.2 最新变化",
                  "markdown": "报告以不支持的 `java.time.temporal.ChronoField` 或 `java.time.temporal.ChronoUnit` 枚举常量作为实参的 `java.time` 方法调用（`get()`、`getLong()`、 `with()`、`plus()`、`minus()`）。 此类调用将在运行时抛出 `UnsupportedTemporalTypeException`。\n\n示例：\n\n\n    LocalTime localTime = LocalTime.now();\n    int year = localTime.get(ChronoField.YEAR);\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsupportedChronoFieldUnitCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NumberEquality",
                "shortDescription": {
                  "text": "使用 '==' 而不是 'equals()' 进行数字比较"
                },
                "fullDescription": {
                  "text": "报告使用 == 或 != 而不是 'equals()' 来测试 'Number' 相等性的代码。 使用自动装箱时很容易犯这样的错误：即不比较两个基元，而是比较包装器类型的两个实例，例如使用 'Integer' 而不是 'int'。 示例： 'void foo(Integer a, Integer b) {\n    final boolean bool = a == b;\n  }' 如果已知 'a' 为非 null，则可以安全地应用“不安全”的快速修复，并获得类似于如下所示的结果： 'void foo(Integer a, Integer b) {\n    final boolean bool = a.equals(b);\n  }'",
                  "markdown": "报告使用 **==** 或 **!=** 而不是 `equals()` 来测试 `Number` 相等性的代码。\n\n\n使用自动装箱时很容易犯这样的错误：即不比较两个基元，而是比较包装器类型的两个实例，例如使用 `Integer` 而不是 `int`。\n\n**示例：**\n\n      void foo(Integer a, Integer b) {\n        final boolean bool = a == b;\n      }\n\n如果已知 `a` 为非 null，则可以安全地应用\"不安全\"的快速修复，并获得类似于如下所示的结果：\n\n      void foo(Integer a, Integer b) {\n        final boolean bool = a.equals(b);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NumberEquality",
                    "cweIds": [
                      480
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorNotSerializable",
                "shortDescription": {
                  "text": "'Comparator' 类未被声明为 'Serializable'"
                },
                "fullDescription": {
                  "text": "报告实现 'java.lang.Comparator' 但不实现 'java.io.Serializable' 的类。 如果使用不可序列化的比较器来构建 'java.util.TreeMap' 或 'java.util.TreeSet' 之类的有序集合，那么该集合也将不可序列化。 这可能会导致意外且难以诊断的错误。 'java.lang.Comparator' 的子类通常无状态，因此只需将它们标记为可序列化，即可轻松避免此类问题。 示例： 'class Foo implements Comparator { // 警告\n      @Override\n      public int compare(Object o1, Object o2) {\n          /* ... */\n      }\n  }' 在应用快速修复后： 'class Foo implements Comparator, Serializable { // 此处无警告\n      @Override\n      public int compare(Object o1, Object o2) {\n          /* ... */\n      }\n  }'",
                  "markdown": "报告实现 `java.lang.Comparator` 但不实现 `java.io.Serializable` 的类。\n\n\n如果使用不可序列化的比较器来构建 `java.util.TreeMap` 或 `java.util.TreeSet` 之类的有序集合，那么该集合也将不可序列化。 这可能会导致意外且难以诊断的错误。\n\n\n`java.lang.Comparator` 的子类通常无状态，因此只需将它们标记为可序列化，即可轻松避免此类问题。\n\n**示例：**\n\n\n      class Foo implements Comparator { // 警告\n          @Override\n          public int compare(Object o1, Object o2) {\n              /* ... */\n          }\n      }\n\n在应用快速修复后：\n\n\n      class Foo implements Comparator, Serializable { // 此处无警告\n          @Override\n          public int compare(Object o1, Object o2) {\n              /* ... */\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorNotSerializable",
                    "cweIds": [
                      502
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithOnlyPrivateConstructors",
                "shortDescription": {
                  "text": "仅包含 'private' 构造函数的类应被声明为 'final'"
                },
                "fullDescription": {
                  "text": "报告仅包含 'private' 构造函数的类。 只有 'private' 构造函数的类不能在文件外扩展，应声明为 'final'。",
                  "markdown": "报告仅包含 `private` 构造函数的类。\n\n只有 `private` 构造函数的类不能在文件外扩展，应声明为 `final`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithOnlyPrivateConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConnectionResource",
                "shortDescription": {
                  "text": "集合已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未在 'try' 块前打开并在相应的 'finally' 块中关闭的 Java ME 'javax.microedition.io.Connection' 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。 示例： 'void example() throws IOException {\n    Connection c = Connector.open(\"foo\");\n  }'",
                  "markdown": "报告未在 `try` 块前打开并在相应的 `finally` 块中关闭的 Java ME `javax.microedition.io.Connection` 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。\n\n**示例：**\n\n\n      void example() throws IOException {\n        Connection c = Connector.open(\"foo\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConnectionOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UNUSED_IMPORT",
                "shortDescription": {
                  "text": "未使用的 import"
                },
                "fullDescription": {
                  "text": "报告冗余的 'import' 语句。 如果不使用源文件中导入的类和软件包，则不必使用常规 'import' 语句。 这同样适用于源文件中未使用但已导入的 'static' 字段和方法。 示例： 'import java.util.ArrayList;\n  public class Example {\n    public static void main(String[] args) {\n      System.out.println(\"Hello World!\");\n    }\n  }' 在应用快速修复后： 'public class Example {\n    public static void main(String[] args) {\n      System.out.println(\"Hello World!\");\n    }\n  }'",
                  "markdown": "报告冗余的 `import` 语句。\n\n如果不使用源文件中导入的类和软件包，则不必使用常规 `import` 语句。\n这同样适用于源文件中未使用但已导入的 `static` 字段和方法。\n\n**示例：**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UNUSED_IMPORT",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanVariableAlwaysNegated",
                "shortDescription": {
                  "text": "布尔变量始终反转"
                },
                "fullDescription": {
                  "text": "报告使用其值时总是否定的布尔变量或字段。 示例： 'void m() {\n        boolean b = true; //始终反转布尔变量 'b'\n        System.out.println(!b);\n      }'",
                  "markdown": "报告使用其值时总是否定的布尔变量或字段。\n\n示例：\n\n\n          void m() {\n            boolean b = true; //始终反转布尔变量 'b'\n            System.out.println(!b);\n          }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanVariableAlwaysNegated",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsAnnotation",
                "shortDescription": {
                  "text": "类扩展注解接口"
                },
                "fullDescription": {
                  "text": "报告声明为注解接口的实现或扩展的类。 尽管扩展注解接口是合法之举，但通常是偶然为之，并且结果不能作为注解使用。 此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。",
                  "markdown": "报告声明为注解接口的实现或扩展的类。\n\n尽管扩展注解接口是合法之举，但通常是偶然为之，并且结果不能作为注解使用。\n\n此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExplicitlyAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldAccessedSynchronizedAndUnsynchronized",
                "shortDescription": {
                  "text": "同时在 'synchronized' 和未同步上下文中访问字段"
                },
                "fullDescription": {
                  "text": "报告在 'synchronized' 和非 'synchronized' 上下文中访问的非 final 字段。 'volatile' 字段以及构造函数和初始值设定项中的访问将被此检查忽略。 此类“部分同步的”访问通常是编码疏忽所致，可能导致意外的不一致数据结构。 示例： 'public class Program {\n    Console console; // 警告：在同步和非同步上下文中都访问字段 'console'\n\n    public synchronized void execute() {\n      console.print(\"running\");\n    }\n\n    public void check() {\n      console.check();\n    }\n  }'\n 使用该选项可以指定简单的 getter 和 setter 是否也算作访问。",
                  "markdown": "报告在 `synchronized` 和非 `synchronized` 上下文中访问的非 final 字段。 `volatile` 字段以及构造函数和初始值设定项中的访问将被此检查忽略。\n\n\n此类\"部分同步的\"访问通常是编码疏忽所致，可能导致意外的不一致数据结构。\n\n**示例：**\n\n\n      public class Program {\n        Console console; // 警告：在同步和非同步上下文中都访问字段 'console'\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\n使用该选项可以指定简单的 getter 和 setter 是否也算作访问。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldAccessedSynchronizedAndUnsynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveLiteralUnderscores",
                "shortDescription": {
                  "text": "数字文字中的下划线"
                },
                "fullDescription": {
                  "text": "报告带下划线的数值文字，并建议通过快速修复将其移除。 如果您需要降低语言级别，这可能会有用。 该快速修复会移除数值文字中的下划线。 例如，'1_000_000' 将转换为 '1000000'。 带下划线的数值文字在 Java 7 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。 2020.2 最新变化",
                  "markdown": "报告带下划线的数值文字，并建议通过快速修复将其移除。 如果您需要降低语言级别，这可能会有用。\n\n该快速修复会移除数值文字中的下划线。 例如，`1_000_000` 将转换为 `1000000`。\n\n\n*带下划线的数值文字*在 Java 7 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。\n\n2020.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveLiteralUnderscores",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedEqualityExpression",
                "shortDescription": {
                  "text": "否定相等表达式"
                },
                "fullDescription": {
                  "text": "报告被前缀表达式否定的等式表达式。 可以使用 '!=' 运算符简化此类表达式。 示例： '!(i == 1)' 在应用快速修复后： 'i != 1'",
                  "markdown": "报告被前缀表达式否定的等式表达式。\n\n可以使用 `!=` 运算符简化此类表达式。\n\n示例：\n\n\n      !(i == 1)\n\n在应用快速修复后：\n\n\n      i != 1\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegatedEqualityExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MathRandomCastToInt",
                "shortDescription": {
                  "text": "'Math.random()' 转换为 'int'"
                },
                "fullDescription": {
                  "text": "报告对立即转换为 'int' 的 'Math.random()' 的调用。 将 '0.0'（包括）和 '1.0'（不包括）之间的 'double' 转换为 'int' 将始终舍入为零。 在将该值转换为 'int' 前，应先将其乘以某个因子，以获取介于零（包括）和乘法因子（不包括）之间的值。 另一种可能的解决办法是使用 'java.util.Random' 的 'nextInt()' 方法。 示例： 'int r = (int)Math.random() * 10;' 在应用快速修复后： 'int r = (int)(Math.random() * 10);'",
                  "markdown": "报告对立即转换为 `int` 的 `Math.random()` 的调用。\n\n将 `0.0`（包括）和 `1.0`（不包括）之间的 `double` 转换为 `int` 将始终舍入为零。 在将该值转换为 `int` 前，应先将其乘以某个因子，以获取介于零（包括）和乘法因子（不包括）之间的值。\n另一种可能的解决办法是使用 `java.util.Random` 的 `nextInt()` 方法。\n\n**示例：**\n\n      int r = (int)Math.random() * 10;\n\n在应用快速修复后：\n\n      int r = (int)(Math.random() * 10);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MathRandomCastToInt",
                    "cweIds": [
                      330,
                      681
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleBraceInitialization",
                "shortDescription": {
                  "text": "双大括号初始化"
                },
                "fullDescription": {
                  "text": "报告双大括号初始化。 与常规初始化相比，双大括号初始化的性能更差，因为它需要加载一个额外的类。 如果 'equals()' 方法不接受子类作为形参，还可能导致 'equals()' 比较失败。 在非 static 上下文中使用双大括号初始化可能导致内存泄漏。 这是因为它会定义一个匿名类，当使用 Java 18 之前版本的 javac 编译时，该类将引用周围的对象。 此外，在 Java 9 以前的版本中，双大括号初始化不能与 Diamond 运算符结合使用，因为它与匿名类不兼容。 示例： 'List<Integer> list = new ArrayList<>() {{\n    add(1);\n    add(2);\n  }};' 在应用快速修复后： 'List<Integer> list = new ArrayList<>();\n  list.add(1);\n  list.add(2);'",
                  "markdown": "报告[双大括号初始化](https://www.c2.com/cgi/wiki?DoubleBraceInitialization)。\n\n与常规初始化相比，双大括号初始化的性能更差，因为它需要加载一个额外的类。\n\n如果 `equals()` 方法不接受子类作为形参，还可能导致 `equals()` 比较失败。\n\n在非 static 上下文中使用双大括号初始化可能导致内存泄漏。 这是因为它会定义一个匿名类，当使用 Java 18 之前版本的 javac 编译时，该类将引用周围的对象。\n\n此外，在 Java 9 以前的版本中，双大括号初始化不能与 Diamond 运算符结合使用，因为它与匿名类不兼容。\n\n**示例：**\n\n\n      List<Integer> list = new ArrayList<>() {{\n        add(1);\n        add(2);\n      }};\n\n在应用快速修复后：\n\n\n      List<Integer> list = new ArrayList<>();\n      list.add(1);\n      list.add(2);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DoubleBraceInitialization",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInLoops",
                "shortDescription": {
                  "text": "字符串串联在循环中"
                },
                "fullDescription": {
                  "text": "报告循环中的 String 串联。 由于每个 String 串联都会复制整个字符串，因此通常最好将其替换为对 'StringBuilder.append()' 或 'StringBuffer.append()' 的显式调用。 示例： 'String str = \"\";\n  for(int i=0; i<10; i++) {\n    str += i;\n  }' 在应用快速修复后： 'String str = \"\";\n  StringBuilder strBuilder = new StringBuilder(str);\n  for(int i = 0; i<10; i++) {\n    strBuilder.append(i);\n  }\n  str = strBuilder.toString();' 有时，通过该快速修复可将 'String' 变量转换为 'StringBuilder' 或引入新的 'StringBuilder'。 原始代码专门处理 'null' 值时应小心，因为替换可能会改变语义。 如果可能为 'null'，建议进行 null 安全修正，生成必要的 null 检查。 此外，也不能保证自动替换总是性能更好。",
                  "markdown": "报告循环中的 String 串联。\n\n\n由于每个 String 串联都会复制整个字符串，因此通常最好将其替换为对 `StringBuilder.append()` 或 `StringBuffer.append()` 的显式调用。\n\n**示例：**\n\n\n      String str = \"\";\n      for(int i=0; i<10; i++) {\n        str += i;\n      }\n\n在应用快速修复后：\n\n\n      String str = \"\";\n      StringBuilder strBuilder = new StringBuilder(str);\n      for(int i = 0; i<10; i++) {\n        strBuilder.append(i);\n      }\n      str = strBuilder.toString();\n\n\n有时，通过该快速修复可将 `String` 变量转换为 `StringBuilder` 或引入新的 `StringBuilder`。 原始代码专门处理 `null` 值时应小心，因为替换可能会改变语义。 如果可能为 `null`，建议进行 null 安全修正，生成必要的 null 检查。 此外，也不能保证自动替换总是性能更好。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "unused",
                "shortDescription": {
                  "text": "未使用的声明"
                },
                "fullDescription": {
                  "text": "报告未使用或无法从入口点访问的类、方法或字段。 入口点可以是 main 方法、测试、来自指定范围之外的类、可从 'module-info.java' 访问的类，等等。 可以通过使用名称模式或注解来配置自定义入口点。 示例： 'public class Department {\n    private Organization myOrganization;\n  }' 在本例中，'Department' 显式引用 'Organization'，但如果 'Department' 类本身未使用，那么该检查将报告这两个类。 该检查还会报告其方法、所有方法实现和重写器未使用的形参，以及已声明但未使用的局部变量。 注意：在编辑器中高亮显示代码期间可能不会报告某些未使用的成员。 由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。 要查看所有结果，请从主菜单中选择代码 | 检查代码或代码 | 分析代码 | 按名称运行检查来运行检查。 使用下面的可见性设置可以配置要报告的成员。 例如，配置报告 'private' 方法只表明将报告 'private' 内部类的 'public' 方法，顶层类的 'protected' 方法将被忽略。 使用入口点标签页可以配置检查运行期间要考虑的入口点。 在检查结果准备就绪后，可以手动添加入口点。 如果您的代码使用不受支持的框架，可以选择以下几个选项： 如果框架依赖于注解，使用注解…按钮可配置框架注解。 如果框架不依赖于注解，可尝试配置框架应有的类名模式。 这样，框架内部项可访问的注解代码将被视为已使用。",
                  "markdown": "报告未使用或无法从入口点访问的类、方法或字段。\n\n入口点可以是 main 方法、测试、来自指定范围之外的类、可从 `module-info.java` 访问的类，等等。 可以通过使用名称模式或注解来配置自定义入口点。\n\n**示例：**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\n在本例中，`Department` 显式引用 `Organization`，但如果 `Department` 类本身未使用，那么该检查将报告这两个类。\n\n\n该检查还会报告其方法、所有方法实现和重写器未使用的形参，以及已声明但未使用的局部变量。\n\n\n**注意** ：在编辑器中高亮显示代码期间可能不会报告某些未使用的成员。 由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。\n要查看所有结果，请从主菜单中选择**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 按名称运行检查**来运行检查。\n\n使用下面的可见性设置可以配置要报告的成员。 例如，配置报告 `private` 方法只表明将报告 `private` 内部类的 `public` 方法，顶层类的 `protected` 方法将被忽略。\n\n\n使用**入口点**标签页可以配置检查运行期间要考虑的入口点。\n\n在检查结果准备就绪后，可以手动添加入口点。\n\n如果您的代码使用不受支持的框架，可以选择以下几个选项：\n\n* 如果框架依赖于注解，使用**注解...**按钮可配置框架注解。\n* 如果框架不依赖于注解，可尝试配置框架应有的类名模式。\n\n这样，框架内部项可访问的注解代码将被视为已使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unused",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneableClassInSecureContext",
                "shortDescription": {
                  "text": "安全上下文中的可克隆类"
                },
                "fullDescription": {
                  "text": "报告可能被克隆的类。 如果一个类支持 'Cloneable' 接口，并且它的 'clone()' 方法没有定义为立即抛出错误，则该类可以被克隆。 在用于安全使用的代码中，可克隆类可能是危险的。 示例： 'class SecureBean implements Cloneable {}' 在应用快速修复后： 'class SecureBean {}' 当类扩展现有的可克隆类或实现可克隆接口时，应用该快速修复后，代码可能如下所示： 'class SecureBean extends ParentBean {\n    @Override\n    protected SecureBean clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException();\n    }\n}'",
                  "markdown": "报告可能被克隆的类。\n\n\n如果一个类支持 `Cloneable` 接口，并且它的 `clone()` 方法没有定义为立即抛出错误，则该类可以被克隆。 在用于安全使用的代码中，可克隆类可能是危险的。\n\n**示例：**\n`class SecureBean implements Cloneable {}`\n\n在应用快速修复后：\n`class SecureBean {}`\n\n\n当类扩展现有的可克隆类或实现可克隆接口时，应用该快速修复后，代码可能如下所示：\n\n    class SecureBean extends ParentBean {\n        @Override\n        protected SecureBean clone() throws CloneNotSupportedException {\n            throw new CloneNotSupportedException();\n        }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneableClassInSecureContext",
                    "cweIds": [
                      498
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentTextBlockIndent",
                "shortDescription": {
                  "text": "文本块中的空格缩进不一致"
                },
                "fullDescription": {
                  "text": "报告同时使用空格和制表符缩进的文本块。 由于空格和制表符会被文本块处理同等对待，此类情况会产生意外的结果。 在下面的示例中，空格和制表符被分别呈现为 '·' 和 '␉'，在编辑器中，一个制表符相当于 4 个空格。 示例： 'String colors = \"\"\"\n········red\n␉   ␉   green\n········blue\"\"\";' 打印此类字符串后，结果为： '······red\ngreen\n······blue' 在编译器从每一行的开头移除相同数量的空格或制表符后，某些行将保留前导空格。 2021.1 最新变化 此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。",
                  "markdown": "报告同时使用空格和制表符缩进的文本块。 由于空格和制表符会被文本块处理同等对待，此类情况会产生意外的结果。\n\n在下面的示例中，空格和制表符被分别呈现为 `·` 和 `␉`，在编辑器中，一个制表符相当于 4 个空格。\n\n**示例：**\n\n\n    String colors = \"\"\"\n    ········red\n    ␉   ␉   green\n    ········blue\"\"\";\n\n打印此类字符串后，结果为：\n\n\n    ······red\n    green\n    ······blue\n\n在编译器从每一行的开头移除相同数量的空格或制表符后，某些行将保留前导空格。\n\n2021.1 最新变化\n\n此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentTextBlockIndent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousGetterSetter",
                "shortDescription": {
                  "text": "可疑的 getter/setter"
                },
                "fullDescription": {
                  "text": "报告所访问字段的名称不是其预期名称的 getter 或 setter 方法。 例如，当 'getY()' 返回 'x' 字段时。 这通常可能表明复制粘贴错误。 示例： 'class Point {\n    private int x;\n    private int y;\n\n    public void setX(int x) { // 警告：setter 'setX()' 分配字段 'y'\n      this.y = x;\n    }\n\n    public int getY() { // 警告：getter 'getY()' 返回字段 'x'\n      return x;\n    }\n  }' 使用下面的复选框可报告类中字段的名称与 getter 或 setter 的名称相匹配的情况。",
                  "markdown": "报告所访问字段的名称不是其预期名称的 getter 或 setter 方法。 例如，当 `getY()` 返回 `x` 字段时。 这通常可能表明复制粘贴错误。\n\n**示例：**\n\n    class Point {\n        private int x;\n        private int y;\n\n        public void setX(int x) { // 警告：setter 'setX()' 分配字段 'y'\n          this.y = x;\n        }\n\n        public int getY() { // 警告：getter 'getY()' 返回字段 'x'\n          return x;\n        }\n      }\n\n\n使用下面的复选框可报告类中字段的名称与 getter 或 setter 的名称相匹配的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousGetterSetter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedStringCase",
                "shortDescription": {
                  "text": "'String' 操作中不匹配的大小写"
                },
                "fullDescription": {
                  "text": "报告因为在仅大写的字符串中搜索小写字符或在仅小写的字符串中搜索大写字符而始终返回相同值（'-1' 或 'false'）的 'String' 方法调用。 报告的方法包括 'equals'、'startsWith'、'endsWith'、'contains'、'indexOf' 和 'lastIndexOf'。 示例：   if (columnName.toLowerCase().equals(\"ID\")) {...}\n 2019.3 最新变化",
                  "markdown": "报告因为在仅大写的字符串中搜索小写字符或在仅小写的字符串中搜索大写字符而始终返回相同值（`-1` 或 `false`）的 `String` 方法调用。\n\n报告的方法包括 `equals`、`startsWith`、`endsWith`、`contains`、`indexOf` 和 `lastIndexOf`。\n\n**示例：**\n\n```\n  if (columnName.toLowerCase().equals(\"ID\")) {...}\n```\n\n2019.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedStringCase",
                    "cweIds": [
                      597
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleNegation",
                "shortDescription": {
                  "text": "双重否定"
                },
                "fullDescription": {
                  "text": "报告可以简化的双重否定。 示例： 'if (!!functionCall()) {}' 在应用快速修复后： 'if (functionCall()) {}' 示例： 'if (!(a != b)) {}' 在应用快速修复后： 'if (a == b) {}'",
                  "markdown": "报告可以简化的双重否定。\n\n示例：\n\n\n      if (!!functionCall()) {}\n\n在应用快速修复后：\n\n\n      if (functionCall()) {}\n\n示例：\n\n\n      if (!(a != b)) {}\n\n在应用快速修复后：\n\n\n      if (a == b) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoubleNegation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertionCanBeIf",
                "shortDescription": {
                  "text": "断言可被替换为 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告 'assert' 语句并建议将它们替换为抛出 'java.lang.AssertionError' 的 'if' 语句。 示例： 'assert param != null;' 在应用快速修复后： 'if (param == null) throw new AssertionError();' 此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。",
                  "markdown": "报告 `assert` 语句并建议将它们替换为抛出 `java.lang.AssertionError` 的 `if` 语句。\n\n示例：\n\n\n      assert param != null;\n\n在应用快速修复后：\n\n\n      if (param == null) throw new AssertionError();\n\n此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AssertionCanBeIf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToNull",
                "shortDescription": {
                  "text": "'null' 赋值"
                },
                "fullDescription": {
                  "text": "报告在声明外被赋值给 'null' 的变量。 Java 中 'null' 的主要用途是表示未初始化的引用变量。 在极少数情况下，将变量显式赋值给 'null' 有助于垃圾回收。 但是，使用 'null' 来表示缺失、未指定、无效值或找不到的元素被认为是一种不好的做法，可能会使您的代码更容易出现 'NullPointerExceptions'。 请改为考虑定义具有预期语义的 sentinel 对象或使用像 'Optional' 这样的库类型来表示没有值。 示例： 'Integer convert(String s) {\n    Integer value;\n    try {\n      value = Integer.parseInt(s);\n    } catch (NumberFormatException e) {\n      // 警告：null 用于表示“无效值”\n      value = null;\n    }\n    return value;\n  }' 使用忽略对字段的赋值选项可忽略对字段的赋值。",
                  "markdown": "报告在声明外被赋值给 `null` 的变量。\n\nJava 中 `null` 的主要用途是表示未初始化的引用变量。 在极少数情况下，将变量显式赋值给 `null` 有助于垃圾回收。 但是，使用 `null` 来表示缺失、未指定、无效值或找不到的元素被认为是一种不好的做法，可能会使您的代码更容易出现 `NullPointerExceptions`。\n请改为考虑定义具有预期语义的 sentinel 对象或使用像 `Optional` 这样的库类型来表示没有值。\n\n**示例：**\n\n\n      Integer convert(String s) {\n        Integer value;\n        try {\n          value = Integer.parseInt(s);\n        } catch (NumberFormatException e) {\n          // 警告：null 用于表示\"无效值\"\n          value = null;\n        }\n        return value;\n      }\n\n\n使用**忽略对字段的赋值**选项可忽略对字段的赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageWithTooFewClasses",
                "shortDescription": {
                  "text": "软件包具有过少类"
                },
                "fullDescription": {
                  "text": "报告包含少于指定最小值的类的软件包。 不报告包含子软件包的软件包。 过小的软件包可能表明设计零散。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用最小类数字段可指定软件包中允许的最小类数。",
                  "markdown": "报告包含少于指定最小值的类的软件包。\n\n不报告包含子软件包的软件包。 过小的软件包可能表明设计零散。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**最小类数**字段可指定软件包中允许的最小类数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageWithTooFewClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceOnLiteralHasNoEffect",
                "shortDescription": {
                  "text": "替换操作不起任何作用"
                },
                "fullDescription": {
                  "text": "报告对 'String' 方法 'replace()'、'replaceAll()' 或 'replaceFirst()' 的无效调用。 当限定符和搜索字符串均为编译时常量，且在限定符中找不到搜索字符串时，可以保证此类调用无效。 这是冗余代码，可能表示存在错误。 示例： '// 替换不起任何作用\n  \"hello\".replace(\"$value$\", value);' 2022.1 最新变化",
                  "markdown": "报告对 `String` 方法 `replace()`、`replaceAll()` 或 `replaceFirst()` 的无效调用。 当限定符和搜索字符串均为编译时常量，且在限定符中找不到搜索字符串时，可以保证此类调用无效。 这是冗余代码，可能表示存在错误。\n\n**示例：**\n\n\n      // 替换不起任何作用\n      \"hello\".replace(\"$value$\", value);\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceOnLiteralHasNoEffect",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleClassImport",
                "shortDescription": {
                  "text": "单个类导入"
                },
                "fullDescription": {
                  "text": "报告导入单个类（而不是整个软件包）的 'import' 语句。 某些编码标准禁止此类 'import' 语句。 您可以将 IntelliJ IDEA 配置为使用优化 import 命令检测和修正此类语句。 转到设置 | 编辑器 | 代码样式 | Java | 导入，并清除使用单个类导入复选框。 因此，对于不打算更改的代码库的脱机报告，此检查非常有用。",
                  "markdown": "报告导入单个类（而不是整个软件包）的 `import` 语句。\n\n某些编码标准禁止此类 `import` 语句。\n\n\n您可以将 IntelliJ IDEA 配置为使用**优化 import** 命令检测和修正此类语句。 转到[设置 \\| 编辑器 \\| 代码样式 \\| Java \\| 导入](settings://preferences.sourceCode.Java?Use%20single%20class%20import)，并清除**使用单个类导入**复选框。 因此，对于不打算更改的代码库的脱机报告，此检查非常有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SingleClassImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitCalledOnCondition",
                "shortDescription": {
                  "text": "在 'java.util.concurrent.locks.Condition' 对象上调用了 'wait()'"
                },
                "fullDescription": {
                  "text": "报告在 'java.util.concurrent.locks.Condition' 对象上进行的 'wait()' 调用。 这可能是编程错误，本应使用 'await()' 方法的某种变体。 示例： 'void acquire(Condition released) throws InterruptedException {\n    while (acquired) {\n      released.wait();\n    }\n  }' 优良的代码应类似于： 'void acquire(Condition released) throws InterruptedException {\n    while (acquired) {\n      released.await();\n    }\n  }'",
                  "markdown": "报告在 `java.util.concurrent.locks.Condition` 对象上进行的 `wait()` 调用。 这可能是编程错误，本应使用 `await()` 方法的某种变体。\n\n**示例：**\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.wait();\n        }\n      }\n\n优良的代码应类似于：\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.await();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitCalledOnCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSynchronizedMethodOverridesSynchronizedMethod",
                "shortDescription": {
                  "text": "未同步方法重写 'synchronized' 方法"
                },
                "fullDescription": {
                  "text": "报告重写 'synchronized' 方法的非 'synchronized' 方法。 如果超类方法被声明为 'synchronized'，重写的方法将不会自动同步。 这可能导致使用子类时出现意外的竞争条件。 示例： 'class Super {\n    synchronized void process() {}\n  }\n  class Sub extends Super {\n    // 非 synchronized 方法 'process()' 重写 synchronized 方法\n    void process() {}\n  }'",
                  "markdown": "报告重写 `synchronized` 方法的非 `synchronized` 方法。\n\n\n如果超类方法被声明为 `synchronized`，重写的方法将不会自动同步。 这可能导致使用子类时出现意外的竞争条件。\n\n**示例：**\n\n\n      class Super {\n        synchronized void process() {}\n      }\n      class Sub extends Super {\n        // 非 synchronized 方法 'process()' 重写 synchronized 方法\n        void process() {}\n      }  \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSynchronizedMethodOverridesSynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedMemberInFinalClass",
                "shortDescription": {
                  "text": "'protected' 成员位于 'final' 类中"
                },
                "fullDescription": {
                  "text": "报告 'final' 类中的 'protected' 成员。 由于无法继承 'final' 类，将方法标记为 'protected' 可能令人困惑。 最好将此类成员声明为 'private' 或软件包可见。 示例： 'record Bar(int a, int b) {\n  protected int sum() { \n     return a + b;\n  }\n}'\n 在应用快速修复后： 'record Bar(int a, int b) {\n  int sum() { \n     return a + b;\n  }\n}' 如本例所示，可以显式或隐式地将类标记为 'final'。",
                  "markdown": "报告 `final` 类中的 `protected` 成员。\n\n由于无法继承 `final` 类，将方法标记为 `protected` 可能令人困惑。 最好将此类成员声明为 `private` 或软件包可见。\n\n**示例：**\n\n    record Bar(int a, int b) {\n      protected int sum() { \n         return a + b;\n      }\n    }\n\n在应用快速修复后：\n\n    record Bar(int a, int b) {\n      int sum() { \n         return a + b;\n      }\n    }\n\n如本例所示，可以显式或隐式地将类标记为 `final`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProtectedMemberInFinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TooBroadCatch",
                "shortDescription": {
                  "text": "过宽的 'catch' 块"
                },
                "fullDescription": {
                  "text": "报告形参比相应的 'try' 块抛出的异常更通用的 'catch' 块。 示例： 'try  {\n    File file = new File(pathToFile);\n    return file.getAbsolutePath();\n  } catch (Exception ex) { // warning: 'catch' of 'Exception' is too broad, masking exceptions 'RuntimeException'\n    return defaultFilePath;\n  }' 在应用快速修复后： 'try  {\n    File file = new File(pathToFile);\n    return file.getAbsolutePath();\n  } catch (RuntimeException ex) {\n    return defaultFilePath;\n  }' 配置检查： 使用仅对 RuntimeException、异常、错误或 Throwable 发出警告选项可使此检查仅对最常见的异常发出警告。 使用忽略隐藏其他异常但自身被抛出的异常选项可忽略任何隐藏其他异常但仍可能被抛出的异常，因此在技术上不会过于宽泛。",
                  "markdown": "报告形参比相应的 `try` 块抛出的异常更通用的 `catch` 块。\n\n**示例：**\n\n\n      try  {\n        File file = new File(pathToFile);\n        return file.getAbsolutePath();\n      } catch (Exception ex) { // warning: 'catch' of 'Exception' is too broad, masking exceptions 'RuntimeException'\n        return defaultFilePath;\n      }\n\n在应用快速修复后：\n\n\n      try  {\n        File file = new File(pathToFile);\n        return file.getAbsolutePath();\n      } catch (RuntimeException ex) {\n        return defaultFilePath;\n      }\n\n配置检查：\n\n* 使用**仅对 RuntimeException、异常、错误或 Throwable 发出警告**选项可使此检查仅对最常见的异常发出警告。\n* 使用**忽略隐藏其他异常但自身被抛出的异常**选项可忽略任何隐藏其他异常但仍可能被抛出的异常，因此在技术上不会过于宽泛。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyBroadCatchBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingConditionDisagreesWithLogLevelStatement",
                "shortDescription": {
                  "text": "日志条件与日志记录调用不匹配"
                },
                "fullDescription": {
                  "text": "报告与包含的日志记录调用的日志级别不匹配的 'if' 语句的 is log enabled for 条件。 示例： 'if (LOG.isTraceEnabled()) {\n    // 已记录调试级别，但已检查跟踪级别\n    LOG.debug(\"some log message\");\n  }' 此检查能够理解 java.util.logging、Log4j、Log4j2、Apache Commons Logging 和 SLF4J 日志记录框架。",
                  "markdown": "报告与包含的日志记录调用的日志级别不匹配的 `if` 语句的 *is log enabled for* 条件。\n\n\n示例：\n\n\n      if (LOG.isTraceEnabled()) {\n        // 已记录调试级别，但已检查跟踪级别\n        LOG.debug(\"some log message\");\n      }\n\n此检查能够理解 *java.util.logging* 、*Log4j* 、*Log4j2* 、*Apache Commons Logging* 和 *SLF4J* 日志记录框架。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggingConditionDisagreesWithLogLevelStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DanglingJavadoc",
                "shortDescription": {
                  "text": "悬空的 Javadoc 注释"
                },
                "fullDescription": {
                  "text": "报告不属于任何类、方法或字段的 Javadoc 注释。 Javadoc 工具会忽略悬空的 Javadoc 注释，并且不会将它们包含在其生成的 HTML 文档中。 示例： 'class A {\n    /**\n     * Dangling comment\n     */\n    /**\n     * Method javadoc\n     */\n     public void m(){}\n  }' 可以通过快速修复完全删除此类注释或将它们转换为块注释。 在应用快速修复后： 'class A {\n    /*\n      Dangling comment\n    */\n    /**\n     * Method javadoc\n     */\n    public void m(){}\n  }' 使用忽略 JavaDoc 格式的文件头注释选项可以忽略 Java 文件开头的注释。 这些通常是版权消息。",
                  "markdown": "报告不属于任何类、方法或字段的 Javadoc 注释。 Javadoc 工具会忽略悬空的 Javadoc 注释，并且不会将它们包含在其生成的 HTML 文档中。\n\n**示例：**\n\n\n      class A {\n        /**\n         * Dangling comment\n         */\n        /**\n         * Method javadoc\n         */\n         public void m(){}\n      }\n\n可以通过快速修复完全删除此类注释或将它们转换为块注释。 在应用快速修复后：\n\n\n      class A {\n        /*\n          Dangling comment\n        */\n        /**\n         * Method javadoc\n         */\n        public void m(){}\n      }\n\n使用**忽略 JavaDoc 格式的文件头注释**选项可以忽略 Java 文件开头的注释。\n这些通常是版权消息。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DanglingJavadoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadOddness",
                "shortDescription": {
                  "text": "可疑的奇数检查"
                },
                "fullDescription": {
                  "text": "报告以下形式的奇偶校验：'x % 2 == 1'。 当与负奇数一起使用时，此类检查将会失败。 请考虑改用 'x % 2 != 0' 或 '(x & 1) == 1'。",
                  "markdown": "报告以下形式的奇偶校验：`x % 2 == 1`。 当与负奇数一起使用时，此类检查将会失败。 请考虑改用 `x % 2 != 0` 或 `(x & 1) == 1`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BadOddness",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HibernateResource",
                "shortDescription": {
                  "text": "Hibernate 资源已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "如果返回的 'org.hibernate.Session' 资源没有被安全关闭，报告对 'openSession()' 方法的调用。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'void doHibernateQuery(SessionFactory factory) {\n    Session session = factory.openSession(); //警告\n    session.createQuery(\"...\");\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开 'org.hibernate.Session' 资源。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "如果返回的 `org.hibernate.Session` 资源没有被安全关闭，报告对 `openSession()` 方法的调用。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      void doHibernateQuery(SessionFactory factory) {\n        Session session = factory.openSession(); //警告\n        session.createQuery(\"...\");\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开 `org.hibernate.Session` 资源。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HibernateResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryInitCause",
                "shortDescription": {
                  "text": "对 'Throwable.initCause()' 的调用不必要"
                },
                "fullDescription": {
                  "text": "报告对 'Throwable.initCause()' 的调用，其中异常构造函数还包含 'Throwable cause' 实参。 在本例中，可以移除 'initCause()' 调用，并将其实参添加到对异常构造函数的调用中。 示例： 'try {\n      process();\n  }\n  catch (RuntimeException ex) {\n    RuntimeException wrapper = new RuntimeException(\"Error while processing\");\n    wrapper.initCause(ex); // 不必要调用 'Throwable.initCause()'\n    throw wrapper;\n  }' 可通过快速修复将 cause 实参传递给构造函数。 在应用快速修复后： 'try {\n      process();\n  }\n  catch (RuntimeException ex) {\n    RuntimeException wrapper = new RuntimeException(\"Error while processing\", ex);\n    throw wrapper;\n  }'",
                  "markdown": "报告对 `Throwable.initCause()` 的调用，其中异常构造函数还包含 `Throwable cause` 实参。\n\n在本例中，可以移除 `initCause()` 调用，并将其实参添加到对异常构造函数的调用中。\n\n**示例：**\n\n\n      try {\n          process();\n      }\n      catch (RuntimeException ex) {\n        RuntimeException wrapper = new RuntimeException(\"Error while processing\");\n        wrapper.initCause(ex); // 不必要调用 'Throwable.initCause()'\n        throw wrapper;\n      }\n\n可通过快速修复将 cause 实参传递给构造函数。 在应用快速修复后：\n\n\n      try {\n          process();\n      }\n      catch (RuntimeException ex) {\n        RuntimeException wrapper = new RuntimeException(\"Error while processing\", ex);\n        throw wrapper;\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryInitCause",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparisonOfShortAndChar",
                "shortDescription": {
                  "text": "比较 'short' 和 'char' 值"
                },
                "fullDescription": {
                  "text": "报告 'short' 与 'char' 值之间的相等比较。 此类比较可能会导致难以捉摸的错误，因为虽然两个值都是 2 字节长，'short' 值有符号，而 'char' 值无符号。 示例： 'if (Character.MAX_VALUE == shortValue()) {} // 永远不能为 true'",
                  "markdown": "报告 `short` 与 `char` 值之间的相等比较。\n\n此类比较可能会导致难以捉摸的错误，因为虽然两个值都是 2 字节长，`short` 值有符号，而 `char` 值无符号。\n\n**示例：**\n\n\n    if (Character.MAX_VALUE == shortValue()) {} // 永远不能为 true\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparisonOfShortAndChar",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayCanBeReplacedWithEnumValues",
                "shortDescription": {
                  "text": "可以将数组替换为枚举值"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'EnumType.values()' 调用的枚举常量数组。 通常，在更新这样一个枚举时，您必须同时更新数组。 但是，如果您改用 'EnumType.values()'，则无需修改。 示例： 'enum States {\n     NOT_RUN, IN_PROGRESS, FINISHED;\n  }\n  \n  handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});' 在应用快速修复后： 'handleStates(States.values());' 2019.1 最新变化",
                  "markdown": "报告可以替换为 `EnumType.values()` 调用的枚举常量数组。\n\n通常，在更新这样一个枚举时，您必须同时更新数组。 但是，如果您改用 `EnumType.values()`，则无需修改。\n\n示例：\n\n\n      enum States {\n         NOT_RUN, IN_PROGRESS, FINISHED;\n      }\n      \n      handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});\n\n在应用快速修复后：\n\n\n      handleStates(States.values());\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ArrayCanBeReplacedWithEnumValues",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitNotifyNotInSynchronizedContext",
                "shortDescription": {
                  "text": "'wait()' 或 'notify()' 不在同步的上下文中"
                },
                "fullDescription": {
                  "text": "报告不是在相应的 synchronized 语句或 synchronized 方法进行中的 'wait()'、'notify()' 和 'notifyAll()' 调用。 在没有持有锁定的对象上调用这些方法会导 'IllegalMonitorStateException'。 此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。 示例： 'class Sync {\n    private final Object lock = new Object();\n\n    void test() throws InterruptedException {\n      synchronized (this) {\n        lock.wait(); // 'lock.wait()' 未在 'lock' 上同步\n      }\n    }\n  }'",
                  "markdown": "报告不是在相应的 synchronized 语句或 synchronized 方法进行中的 `wait()`、`notify()` 和 `notifyAll()` 调用。\n\n\n在没有持有锁定的对象上调用这些方法会导 `IllegalMonitorStateException`。\n此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。\n\n**示例：**\n\n\n      class Sync {\n        private final Object lock = new Object();\n\n        void test() throws InterruptedException {\n          synchronized (this) {\n            lock.wait(); // 'lock.wait()' 未在 'lock' 上同步\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitNotifyWhileNotSynced",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemOutErr",
                "shortDescription": {
                  "text": "使用 'System.out' 或 'System.err'"
                },
                "fullDescription": {
                  "text": "报告 'System.out' 或 'System.err' 的用法。 此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。 提供的快速修复支持 SLF4J 和 Log4j 2。 它会将 'System.out' 和 'System.err' 调用替换为日志调用 示例： 'public static void test(Object o) {\n    System.out.println(\"Test: \"+ o);\n  }' 在应用快速修复后： 'private static final Logger log = LoggerFactory.getLogger(Test.class);\n\n  public static void test(Object o) {\n      log.info(\"Test: {}\", o);;\n  }' 使用用于 'System.err' 的日志方法选项可以指定用于为 'System.err' 调用记录消息的方法。 使用用于 'System.out' 的日志方法选项可以指定用于为 'System.out' 调用记录消息的方法。",
                  "markdown": "报告 `System.out` 或 `System.err` 的用法。\n\n此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。\n\n提供的快速修复支持 **SLF4J** 和 **Log4j 2** 。\n它会将 `System.out` 和 `System.err` 调用替换为日志调用\n\n**示例：**\n\n\n      public static void test(Object o) {\n        System.out.println(\"Test: \"+ o);\n      }\n\n在应用快速修复后：\n\n\n      private static final Logger log = LoggerFactory.getLogger(Test.class);\n\n      public static void test(Object o) {\n          log.info(\"Test: {}\", o);;\n      }\n\n\n使用**用于 'System.err' 的日志方法** 选项可以指定用于为 'System.err' 调用记录消息的方法。\n使用**用于 'System.out' 的日志方法**选项可以指定用于为 'System.out' 调用记录消息的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UseOfSystemOutOrSystemErr",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DollarSignInName",
                "shortDescription": {
                  "text": "在标识符中使用 '$'"
                },
                "fullDescription": {
                  "text": "报告名称中带有美元符号 ('$') 的变量、方法和类。 虽然此类名称是合法的 Java，但强烈建议不要在生成的 Java 代码之外使用它们。 示例： 'class SalaryIn${}' 仅在编辑器中建议重命名快速修复。",
                  "markdown": "报告名称中带有美元符号 (`$`) 的变量、方法和类。 虽然此类名称是合法的 Java，但强烈建议不要在生成的 Java 代码之外使用它们。\n\n**示例：**\n\n\n      class SalaryIn${}\n\n仅在编辑器中建议重命名快速修复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DollarSignInName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckedExceptionClass",
                "shortDescription": {
                  "text": "已检查的异常类"
                },
                "fullDescription": {
                  "text": "报告已检查的异常类（即，非 'java.lang.RuntimeException' 子类的 'java.lang.Exception' 的子类）。 某些编码标准禁止已检查的用户定义的异常类。 示例： 'class IllegalMoveException extends Exception {}'",
                  "markdown": "报告已检查的异常类（即，非 `java.lang.RuntimeException` 子类的 `java.lang.Exception` 的子类）。\n\n某些编码标准禁止已检查的用户定义的异常类。\n\n**示例：**\n\n\n      class IllegalMoveException extends Exception {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckedExceptionClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DynamicRegexReplaceableByCompiledPattern",
                "shortDescription": {
                  "text": "动态正则表达式可被替换为已编译的 'Pattern'"
                },
                "fullDescription": {
                  "text": "报告使用常量实参对 'java.lang.String' 的正则表达式方法（例如 'matches()' 或 'split()'）的调用。 此类调用可以有利地替换为 'private static final Pattern' 字段，从而不必在每次使用正则表达式时都对其进行编译。 示例： 'text.replaceAll(\"abc\", replacement);' 在应用快速修复后： 'private static final Pattern ABC = Pattern.compile(\"abc\", Pattern.LITERAL);\n  ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));'",
                  "markdown": "报告使用常量实参对 `java.lang.String` 的正则表达式方法（例如 `matches()` 或 `split()`）的调用。\n\n\n此类调用可以有利地替换为 `private static final Pattern` 字段，从而不必在每次使用正则表达式时都对其进行编译。\n\n**示例：**\n\n\n      text.replaceAll(\"abc\", replacement);\n\n在应用快速修复后：\n\n\n      private static final Pattern ABC = Pattern.compile(\"abc\", Pattern.LITERAL);\n      ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DynamicRegexReplaceableByCompiledPattern",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyInitializer",
                "shortDescription": {
                  "text": "空类初始值设定项"
                },
                "fullDescription": {
                  "text": "报告空类初始值设定项块。",
                  "markdown": "报告空类初始值设定项块。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyClassInitializer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableStoresNonSerializable",
                "shortDescription": {
                  "text": "'Serializable' 对象隐式存储非 'Serializable' 对象"
                },
                "fullDescription": {
                  "text": "报告任何对 'Serializable' lambda、局部类和匿名类外部的非 'Serializable' 局部变量的引用。 从匿名类引用局部变量时，它的值存储在该类的隐式字段中。 对于局部类和 lambda 也是如此。 如果变量类型为非 'Serializable'，序列化将失败。 示例： 'interface A extends Serializable {\n      abstract void foo();\n  }\n  class B {}\n  class C {\n      void foo() {\n          B b = new B();\n          A a = new A() {\n              @Override\n              public void foo() {\n                  System.out.println(b); // 警告\n              }\n          };\n      }\n  }'",
                  "markdown": "报告任何对 `Serializable` lambda、局部类和匿名类外部的非 `Serializable` 局部变量的引用。\n\n\n从匿名类引用局部变量时，它的值存储在该类的隐式字段中。 对于局部类和 lambda 也是如此。 如果变量类型为非 `Serializable`，序列化将失败。\n\n**示例：**\n\n\n      interface A extends Serializable {\n          abstract void foo();\n      }\n      class B {}\n      class C {\n          void foo() {\n              B b = new B();\n              A a = new A() {\n                  @Override\n                  public void foo() {\n                      System.out.println(b); // 警告\n                  }\n              };\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableStoresNonSerializable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryBreak",
                "shortDescription": {
                  "text": "不必要的 'break' 语句"
                },
                "fullDescription": {
                  "text": "报告任何不必要的 'break' 语句。 如果 'break' 语句在被移除后没有执行其他语句，则该语句是不必要的语句。 示例： 'switch (e) {\n    case A -> {\n        System.out.println(\"A\");\n        break; // 报告 'break' 为不必要的语句\n    }\n    default -> {\n        System.out.println(\"Default\");\n        break; // 报告 'break' 为不必要的语句\n    }\n  }'",
                  "markdown": "报告任何不必要的 `break` 语句。\n\n如果 `break` 语句在被移除后没有执行其他语句，则该语句是不必要的语句。\n\n**示例：**\n\n\n      switch (e) {\n        case A -> {\n            System.out.println(\"A\");\n            break; // 报告 'break' 为不必要的语句\n        }\n        default -> {\n            System.out.println(\"Default\");\n            break; // 报告 'break' 为不必要的语句\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryBreak",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InsertLiteralUnderscores",
                "shortDescription": {
                  "text": "不可读的数字文字"
                },
                "fullDescription": {
                  "text": "报告不带下划线的长数值文字并建议添加它们。 下划线使此类文字更易于阅读。 示例： '1000000' 在应用快速修复后： '1_000_000' 仅当项目或模块的语言级别为 7 级或更高级别时，此检查才会报告。 2020.2 最新变化",
                  "markdown": "报告不带下划线的长数值文字并建议添加它们。 下划线使此类文字更易于阅读。\n\n示例：\n\n\n      1000000\n\n在应用快速修复后：\n\n\n      1_000_000\n\n仅当项目或模块的语言级别为 7 级或更高级别时，此检查才会报告。\n\n2020.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "InsertLiteralUnderscores",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BreakStatement",
                "shortDescription": {
                  "text": "'break' 语句"
                },
                "fullDescription": {
                  "text": "报告在 'switch' 语句分支结尾以外的位置使用的 'break' 语句。 'break' 语句导致重构复杂化，可能令人困惑。 示例： 'void foo(List<String> strs) {\n  for (String str : strs) {\n    if (str.contains(\"stop\")) break;\n    handleStr(str);\n  }\n}'",
                  "markdown": "报告在 `switch` 语句分支结尾以外的位置使用的 `break` 语句。\n\n`break` 语句导致重构复杂化，可能令人困惑。\n\n示例：\n\n\n    void foo(List<String> strs) {\n      for (String str : strs) {\n        if (str.contains(\"stop\")) break;\n        handleStr(str);\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BreakStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RawUseOfParameterizedType",
                "shortDescription": {
                  "text": "形参化类的原始使用"
                },
                "fullDescription": {
                  "text": "报告类型形参被忽略的泛型类。 这种对泛型类型的原始使用在 Java 中虽然有效，但它违背了类型形参的用途，并且可能掩盖错误。 此检查反映出 'javac' 的 'rawtypes' 警告。 示例： '//警告：形参化类 'List' 的原始使用\nList list = new ArrayList<String>();\n//创建了字符串列表，但也接受整数\nlist.add(1);' '//无警告，因为在数组创建期间无法提供类型实参\nIntFunction<List<?>[]> fun = List[]::new;' 配置检查： 使用忽略新对象的构造选项，可忽略对象构造中使用的原始类型。 使用忽略类型转换选项，可忽略类型转换中使用的原始类型。 使用忽略类型形参无法编译的位置选项，可忽略类型形参编译失败的情况（例如创建数组或重写库方法的情况）。 使用忽略重写方法的形参类型选项，可忽略重写方法的形参中使用的类型形参。 使用在自动快速修复不可用时忽略选项，可忽略快速修复不可用的情况。 此检查取决于 Java 功能 '泛型'，该功能自 Java 5 起可用。",
                  "markdown": "报告类型形参被忽略的泛型类。 这种对泛型类型的*原始* 使用在 Java 中虽然有效，但它违背了类型形参的用途，并且可能掩盖错误。 此检查反映出 `javac` 的 `rawtypes` 警告。\n\n**示例：**\n\n\n    //警告：形参化类 'List' 的原始使用\n    List list = new ArrayList<String>();\n    //创建了字符串列表，但也接受整数\n    list.add(1);\n\n\n    //无警告，因为在数组创建期间无法提供类型实参\n    IntFunction<List<?>[]> fun = List[]::new;\n\n配置检查：\n\n* 使用**忽略新对象的构造**选项，可忽略对象构造中使用的原始类型。\n* 使用**忽略类型转换**选项，可忽略类型转换中使用的原始类型。\n* 使用**忽略类型形参无法编译的位置**选项，可忽略类型形参编译失败的情况（例如创建数组或重写库方法的情况）。\n* 使用**忽略重写方法的形参类型**选项，可忽略重写方法的形参中使用的类型形参。\n* 使用**在自动快速修复不可用时忽略**选项，可忽略快速修复不可用的情况。\n\n此检查取决于 Java 功能 '泛型'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "rawtypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JDBCExecuteWithNonConstantString",
                "shortDescription": {
                  "text": "'Statement.execute()' 调用具有非常量字符串"
                },
                "fullDescription": {
                  "text": "报告对 'java.sql.Statement.execute()' 或其任何变体的调用，这些变体会将动态构造的字符串作为要执行的查询。 构造的 SQL 语句是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。 示例： 'ResultSet execute(Statement statement, String name) throws SQLException {\n    return statement.executeQuery(\"select * from \" + name); // 报告警告\n  }' 使用检查选项可以将任何 'static' 'final' 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略： 'private static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";'",
                  "markdown": "报告对 `java.sql.Statement.execute()` 或其任何变体的调用，这些变体会将动态构造的字符串作为要执行的查询。\n\n构造的 SQL 语句是安全漏洞的常见来源。\n默认情况下，此检查会忽略编译时常量。\n\n**示例：**\n\n\n      ResultSet execute(Statement statement, String name) throws SQLException {\n        return statement.executeQuery(\"select * from \" + name); // 报告警告\n      }\n\n\n使用检查选项可以将任何 `static` `final` 字段视为常量。\n请小心，因为启用该选项时，像下面这样的字符串将被忽略：\n\n\n      private static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JDBCExecuteWithNonConstantString",
                    "cweIds": [
                      89,
                      564
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicConstructorInNonPublicClass",
                "shortDescription": {
                  "text": "'public' 构造函数位于非 public 类中"
                },
                "fullDescription": {
                  "text": "报告非 'public' 类中的所有 'public' 构造函数。 在访问级别较低的类中，通常没有理由创建 'public' 构造函数。 但请注意，此检查会改变某些反射调用的行为。 特别是，'Class.getConstructor()' 将无法找到更新的构造函数（应改为使用 'Class.getDeclaredConstructor()'）。 如果您的代码或某些已使用的框架的代码通过 'getConstructor()' 依赖于构造函数的可访问性，请不要使用该检查。 示例： 'class House {\n    public House() {}\n  }' 在应用快速修复后： 'class House {\n    House() {}\n  }'",
                  "markdown": "报告非 `public` 类中的所有 `public` 构造函数。\n\n在访问级别较低的类中，通常没有理由创建 `public` 构造函数。\n但请注意，此检查会改变某些反射调用的行为。 特别是，`Class.getConstructor()` 将无法找到更新的构造函数（应改为使用 `Class.getDeclaredConstructor()`）。 如果您的代码或某些已使用的框架的代码通过 `getConstructor()` 依赖于构造函数的可访问性，请不要使用该检查。\n\n**示例：**\n\n\n      class House {\n        public House() {}\n      }\n\n在应用快速修复后：\n\n\n      class House {\n        House() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicConstructorInNonPublicClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantValueVariableUse",
                "shortDescription": {
                  "text": "使用已知值为常量的变量"
                },
                "fullDescription": {
                  "text": "报告已知为常量的变量的所有用法。 如果（读取）使用的变量被 'if'、'while' 或 'for' 语句包围，且存在该变量与常量相比较的 '==' 条件时，就会发生这种情况。 在这种情况下，使用的已知为常量的变量可以替换为实际常量。 示例： 'private static void foo(double number) {\n        if (number == 1.0) {\n            f(number);\n        }\n    }\n    private static void f(double number) {}' 在应用快速修复后： 'private static void foo(double number) {\n        if (number == 1.0) {\n            f(1.0);\n        }\n    }\n    private static void f(double number) {}'",
                  "markdown": "报告已知为常量的变量的所有用法。\n\n如果（读取）使用的变量被 `if`、`while` 或 `for` 语句包围，且存在该变量与常量相比较的 `==` 条件时，就会发生这种情况。\n在这种情况下，使用的已知为常量的变量可以替换为实际常量。\n\n示例：\n\n\n        private static void foo(double number) {\n            if (number == 1.0) {\n                f(number);\n            }\n        }\n        private static void f(double number) {}\n\n在应用快速修复后：\n\n\n        private static void foo(double number) {\n            if (number == 1.0) {\n                f(1.0);\n            }\n        }\n        private static void f(double number) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantValueVariableUse",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewStringBufferWithCharArgument",
                "shortDescription": {
                  "text": "StringBuilder 构造函数调用具有 'char' 实参"
                },
                "fullDescription": {
                  "text": "报告对 'char' 作为实参的 'StringBuffer' 和 'StringBuilder' 构造函数的调用。 在本例中，'char' 无提示地转换为整数，并解读为缓冲区的初始容量。 示例： 'new StringBuilder('(').append(\"1\").append(')');' 在应用快速修复后： 'new StringBuilder(\"(\").append(\"1\").append(')');'",
                  "markdown": "报告对 `char` 作为实参的 `StringBuffer` 和 `StringBuilder` 构造函数的调用。 在本例中，`char` 无提示地转换为整数，并解读为缓冲区的初始容量。\n\n**示例：**\n\n\n      new StringBuilder('(').append(\"1\").append(')');\n\n在应用快速修复后：\n\n\n      new StringBuilder(\"(\").append(\"1\").append(')');\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewStringBufferWithCharArgument",
                    "cweIds": [
                      628,
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedInnerClass",
                "shortDescription": {
                  "text": "protected 嵌套类"
                },
                "fullDescription": {
                  "text": "报告 'protected' 嵌套类。 示例： 'public class Outer {\n    protected static class Nested {} // 警告\n    protected class Inner {}         // 警告\n    protected enum Mode {}           // 警告取决于设置\n    protected interface I {}         // 警告取决于设置\n  }' 配置检查： 使用忽略 'protected' 内部枚举选项可忽略 'protected' 内部枚举。 使用忽略 'protected' 内部接口选项可忽略 'protected' 内部接口。",
                  "markdown": "报告 `protected` 嵌套类。\n\n**示例：**\n\n\n      public class Outer {\n        protected static class Nested {} // 警告\n        protected class Inner {}         // 警告\n        protected enum Mode {}           // 警告取决于设置\n        protected interface I {}         // 警告取决于设置\n      }\n\n配置检查：\n\n* 使用**忽略 'protected' 内部枚举** 选项可忽略 `protected` 内部枚举。\n* 使用**忽略 'protected' 内部接口** 选项可忽略 `protected` 内部接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProtectedInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedStaticUsage",
                "shortDescription": {
                  "text": "非限定静态访问"
                },
                "fullDescription": {
                  "text": "报告未用类名称限定的 static 成员的用法。 如果 static 成员在同一个类中，是合法的，但可能令人困惑。 示例： 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      foo();\n      System.out.println(x);\n    }\n\n    static void baz() { foo(); }\n  }' 在应用快速修复后： 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      Foo.foo();\n      System.out.println(Foo.x);\n    }\n\n    static void baz() { Foo.foo(); }\n  }' 使用检查设置可以切换以下各项的报告： static 字段访问 'void bar() { System.out.println(x); }' 对 static 方法的调用 'void bar() { foo(); }' 'static void baz() { foo(); }' 您还可以将检查配置为仅报告来自非 static 上下文的 static 成员用法。 在上面的示例中，不会报告 'static void baz() { foo(); }'。",
                  "markdown": "报告未用类名称限定的 static 成员的用法。\n\n\n如果 static 成员在同一个类中，是合法的，但可能令人困惑。\n\n**示例：**\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          foo();\n          System.out.println(x);\n        }\n\n        static void baz() { foo(); }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          Foo.foo();\n          System.out.println(Foo.x);\n        }\n\n        static void baz() { Foo.foo(); }\n      }\n\n使用检查设置可以切换以下各项的报告：\n\n*\n  static 字段访问  \n\n  `void bar() { System.out.println(x); }`\n\n*\n  对 static 方法的调用  \n\n  `void bar() { foo(); }`  \n\n  `static void baz() { foo(); }`\n\n\n您还可以将检查配置为仅报告来自非 static 上下文的 static 成员用法。\n在上面的示例中，不会报告 `static void baz() { foo(); }`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedStaticUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticGuardedByInstance",
                "shortDescription": {
                  "text": "由实例字段或 this 防护的 static 成员"
                },
                "fullDescription": {
                  "text": "报告其中的保护符为非 static 字段或 'this' 的 'static' 字段或方法上的 '@GuardedBy' 注解。 使用非 static 元素保护 static 元素可能会导致过度并发，多个线程可能在不同的对象上下文中锁定，以同时访问保护字段。 示例： 'private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    @GuardedBy(\"lock\")\n    public static void bar() {\n        // ...\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告其中的保护符为非 static 字段或 `this` 的 `static` 字段或方法上的 `@GuardedBy` 注解。\n\n使用非 static 元素保护 static 元素可能会导致过度并发，多个线程可能在不同的对象上下文中锁定，以同时访问保护字段。\n\n示例：\n\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n        @GuardedBy(\"lock\")\n        public static void bar() {\n            // ...\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticGuardedByInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassGetClass",
                "shortDescription": {
                  "text": "'Class.getClass()' 调用可疑"
                },
                "fullDescription": {
                  "text": "报告在 'java.lang.Class' 实例上调用的 'getClass()' 方法。 这通常是一个错误，因为结果总是等同于 'Class.class'。 如果是错误，那么最好移除 'getClass()' 调用并直接使用限定符。 如果行为是故意的，最好显式编写 'Class.class' 以避免混淆。 示例： 'void test(Class<?> clazz) {\n    String name = clazz.getClass().getName();\n  }' 在应用可能的快速修复之一后： 'void test(Class<?> clazz) {\n    String name = clazz.getName();\n  }' 2018.2 最新变化",
                  "markdown": "报告在 `java.lang.Class` 实例上调用的 `getClass()` 方法。\n\n这通常是一个错误，因为结果总是等同于 `Class.class`。\n如果是错误，那么最好移除 `getClass()` 调用并直接使用限定符。\n如果行为是故意的，最好显式编写 `Class.class` 以避免混淆。\n\n示例：\n\n\n      void test(Class<?> clazz) {\n        String name = clazz.getClass().getName();\n      }\n\n在应用可能的快速修复之一后：\n\n\n      void test(Class<?> clazz) {\n        String name = clazz.getName();\n      }\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassGetClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExternalizableWithoutPublicNoArgConstructor",
                "shortDescription": {
                  "text": "没有 'public' 无实参构造函数的 'Externalizable' 类"
                },
                "fullDescription": {
                  "text": "报告没有 public 无实参构造函数的 'Externalizable' 类。 在重新构造 'Externalizable' 对象时，将在调用 'readExternal' 方法前使用 public 无实参构造函数创建一个实例。 如果 public 无实参构造函数不可用，在运行时会抛出 'java.io.InvalidClassException'。",
                  "markdown": "报告没有 public 无实参构造函数的 `Externalizable` 类。\n\n在重新构造 `Externalizable` 对象时，将在调用 `readExternal` 方法前使用 public 无实参构造函数创建一个实例。 如果 public 无实参构造函数不可用，在运行时会抛出 `java.io.InvalidClassException`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExternalizableWithoutPublicNoArgConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ResultOfObjectAllocationIgnored",
                "shortDescription": {
                  "text": "对象分配的结果已忽略"
                },
                "fullDescription": {
                  "text": "报告其中分配的对象被忽略，并且既不分配给变量，也不以其他方式使用的对象分配。 此类分配表达式虽然在 Java 中合法，但通常要么是无意为之，要么表明存在非常奇怪的对象初始化策略。 使用这些选项可列出此检查应忽略其分配的类。",
                  "markdown": "报告其中分配的对象被忽略，并且既不分配给变量，也不以其他方式使用的对象分配。\n\n\n此类分配表达式虽然在 Java 中合法，但通常要么是无意为之，要么表明存在非常奇怪的对象初始化策略。\n\n\n使用这些选项可列出此检查应忽略其分配的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ResultOfObjectAllocationIgnored",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedLibrary",
                "shortDescription": {
                  "text": "未使用的库"
                },
                "fullDescription": {
                  "text": "报告附加到指定检查范围但未直接在代码中使用的库。",
                  "markdown": "报告附加到指定检查范围但未直接在代码中使用的库。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedLibrary",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ManualArrayCopy",
                "shortDescription": {
                  "text": "手动数组复制"
                },
                "fullDescription": {
                  "text": "报告可被替换为 'System.arraycopy()' 调用的数组内容的手动复制。 示例： 'for (int i = 0; i < array.length; i++) {\n    newArray[i] = array[i];\n  }' 在应用快速修复后： 'System.arraycopy(array, 0, newArray, 0, array.length);'",
                  "markdown": "报告可被替换为 `System.arraycopy()` 调用的数组内容的手动复制。\n\n**示例：**\n\n\n      for (int i = 0; i < array.length; i++) {\n        newArray[i] = array[i];\n      }\n\n在应用快速修复后：\n\n\n      System.arraycopy(array, 0, newArray, 0, array.length);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ManualArrayCopy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObsoleteCollection",
                "shortDescription": {
                  "text": "使用废弃的集合类型"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Vector'、'java.util.Hashtable' 和 'java.util.Stack' 的用法。 这些类的用法通常可以分别替换为 'java.util.ArrayList'、'java.util.HashMap' 和 'java.util.ArrayDeque' 的用法。 虽然仍受支持，但以前的类已被 JDK1.2 集合类废弃，在新开发中或许不宜使用。 使用在需要的位置忽略废弃的集合类型选项可以忽略任何将废弃的集合用作方法实参或分配给需要废弃类型的变量的情况。 启用此选项可能会消耗大量处理器资源。",
                  "markdown": "报告 `java.util.Vector`、`java.util.Hashtable` 和 `java.util.Stack` 的用法。\n\n这些类的用法通常可以分别替换为 `java.util.ArrayList`、`java.util.HashMap` 和 `java.util.ArrayDeque` 的用法。\n虽然仍受支持，但以前的类已被 JDK1.2 集合类废弃，在新开发中或许不宜使用。\n\n\n使用**在需要的位置忽略废弃的集合类型**选项可以忽略任何将废弃的集合用作方法实参或分配给需要废弃类型的变量的情况。\n启用此选项可能会消耗大量处理器资源。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfObsoleteCollectionType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticPseudoFunctionalStyleMethod",
                "shortDescription": {
                  "text": "Guava 伪函数调用可被转换为 Stream API 调用"
                },
                "fullDescription": {
                  "text": "当 'Java Stream API' 可用时报告 Guava 伪函数代码的用法。 虽然 'Guava Iterable API' 提供类似于 'Java Streams API' 的功能，但它略有不同，可能会缺少某些功能。 特别是，'IntStream' 等基元专门化的流变体比一般变体的性能更好。 示例： 'List<String> transformedIterable = Iterables.transform(someList, someTransformFunction);//警告：伪函数样式代码' 在应用快速修复后： 'List<String> transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());' 注意：代码语义可能改变；例如 Guava 的 'Iterable.transform' 产生延迟求值的可迭代对象，但替换为及早求值。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "当 `Java Stream API` 可用时报告 Guava 伪函数代码的用法。\n\n虽然 `Guava Iterable API` 提供类似于 `Java Streams API` 的功能，但它略有不同，可能会缺少某些功能。\n特别是，`IntStream` 等基元专门化的流变体比一般变体的性能更好。\n\n**示例：**\n\n\n    List<String> transformedIterable = Iterables.transform(someList, someTransformFunction);//警告：伪函数样式代码\n\n在应用快速修复后：\n\n    List<String> transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());\n\n\n**注意** ：代码语义可能改变；例如 Guava 的 `Iterable.transform` 产生延迟求值的可迭代对象，但替换为及早求值。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticPseudoFunctionalStyleMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ControlFlowStatementWithoutBraces",
                "shortDescription": {
                  "text": "不带大括号的控制流语句"
                },
                "fullDescription": {
                  "text": "报告没有大括号的 'if'、'while'、'do' 或 'for' 语句。 一些代码样式，例如 Google Java 样式指南，要求所有控制语句都要带大括号。 在向不带大括号的控制语句添加更多语句时，重要的是不要忘记添加大括号。 在注释掉一行代码时，在不使用大括号时也必须更加小心，以免无意中使下一条语句成为控制流语句的一部分。 始终使用大括号可以更安全地插入或注释掉一行代码。 如果始终遵循使用大括号的代码样式，则很可能不会发生 goto fail 漏洞。 带大括号的控制语句使控制流更易于查看，而无需依赖于可能不正确的缩进。 示例： 'class Strange {\n    void x(boolean one, boolean two) {\n      if(one)\n        if(two)\n          foo();\n      else\n        bar();\n    }\n\n    void foo() {}\n    void bar() {}\n  }' 快速修复用大括号包装语句体： 'class Strange {\n    void x(boolean one, boolean two) {\n      if(one) {\n        if(two) {\n          foo();\n        } else {\n          bar();\n        }\n      }\n    }\n\n    void foo() {}\n    void bar() {}\n  }'",
                  "markdown": "报告没有大括号的 `if`、`while`、`do` 或 `for` 语句。 一些代码样式，例如 [Google Java 样式指南](https://google.github.io/styleguide/javaguide.html)，要求所有控制语句都要带大括号。\n\n\n在向不带大括号的控制语句添加更多语句时，重要的是不要忘记添加大括号。\n在注释掉一行代码时，在不使用大括号时也必须更加小心，以免无意中使下一条语句成为控制流语句的一部分。\n始终使用大括号可以更安全地插入或注释掉一行代码。\n\n\n如果始终遵循使用大括号的代码样式，则很可能不会发生 [goto fail 漏洞](https://www.imperialviolet.org/2014/02/22/applebug.html)。\n带大括号的控制语句使控制流更易于查看，而无需依赖于可能不正确的缩进。\n\n示例：\n\n\n      class Strange {\n        void x(boolean one, boolean two) {\n          if(one)\n            if(two)\n              foo();\n          else\n            bar();\n        }\n\n        void foo() {}\n        void bar() {}\n      }\n\n快速修复用大括号包装语句体：\n\n\n      class Strange {\n        void x(boolean one, boolean two) {\n          if(one) {\n            if(two) {\n              foo();\n            } else {\n              bar();\n            }\n          }\n        }\n\n        void foo() {}\n        void bar() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ControlFlowStatementWithoutBraces",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisspelledEquals",
                "shortDescription": {
                  "text": "'equal()' 代替 'equals()'"
                },
                "fullDescription": {
                  "text": "报告带有单个形参的 'equal()' 的声明。 通常，这是拼写错误，'equals()' 实际上是有意的。 建议通过快速修复将方法重命名为 'equals'。 示例： 'class Main {\n    public boolean equal(Object obj) {\n      return true;\n    }\n  }' 在应用快速修复后： 'class Main {\n    public boolean equals(Object obj) {\n      return true;\n    }\n  }'",
                  "markdown": "报告带有单个形参的 `equal()` 的声明。 通常，这是拼写错误，`equals()` 实际上是有意的。\n\n建议通过快速修复将方法重命名为 `equals`。\n\n**示例：**\n\n\n      class Main {\n        public boolean equal(Object obj) {\n          return true;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        public boolean equals(Object obj) {\n          return true;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MisspelledEquals",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LengthOneStringInIndexOf",
                "shortDescription": {
                  "text": "'String.indexOf()' 调用中的单字符字符串实参"
                },
                "fullDescription": {
                  "text": "报告在 'String.indexOf()' 和 'String.lastIndexOf()' 调用中用作实参的单字符字符串。 建议通过快速修复将此类字符串文字替换为等效的字符文字，从而获得一些性能增强。 示例： 'return s.indexOf(\"x\");' 在应用快速修复后： 'return s.indexOf('x');'",
                  "markdown": "报告在 `String.indexOf()` 和 `String.lastIndexOf()` 调用中用作实参的单字符字符串。\n\n建议通过快速修复将此类字符串文字替换为等效的字符文字，从而获得一些性能增强。\n\n**示例：**\n\n\n      return s.indexOf(\"x\");\n\n在应用快速修复后：\n\n\n      return s.indexOf('x');\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SingleCharacterStringConcatenation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalFieldInEnum",
                "shortDescription": {
                  "text": "'enum' 中的非 final 字段"
                },
                "fullDescription": {
                  "text": "报告枚举类型中的非 final 字段。 非 final 字段会引入全局可变状态，这通常会被认为不可取。 示例： 'enum Enum {\n    FIRST(\"first\"),\n    SECOND(\"second\");\n\n    public String str;\n\n    Enum(String str) {\n        this.str = str;\n    }\n  }' 在应用快速修复后： 'enum Enum {\n    FIRST(\"first\"),\n    SECOND(\"second\");\n\n    public final String str;\n\n    Enum(String str) {\n        this.str = str;\n    }\n  }' 使用“忽略不能设为 'final' 的字段”选项可以仅对可使用快速修复设为 final 的字段发出警告。",
                  "markdown": "报告枚举类型中的非 final 字段。 非 final 字段会引入全局可变状态，这通常会被认为不可取。\n\n**示例：**\n\n\n      enum Enum {\n        FIRST(\"first\"),\n        SECOND(\"second\");\n\n        public String str;\n\n        Enum(String str) {\n            this.str = str;\n        }\n      }\n\n在应用快速修复后：\n\n\n      enum Enum {\n        FIRST(\"first\"),\n        SECOND(\"second\");\n\n        public final String str;\n\n        Enum(String str) {\n            this.str = str;\n        }\n      }\n\n使用\"忽略不能设为 'final' 的字段\"选项可以仅对可使用快速修复设为 final 的字段发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldInEnum",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForEachWithRecordPatternCanBeUsed",
                "shortDescription": {
                  "text": "可以使用带有记录模式的增强 'for'"
                },
                "fullDescription": {
                  "text": "报告局部变量声明和访问器，以记录增强型 'for' 语句（这些语句通常更紧凑）中可被替换为模式变量的组件。 示例： 'record Record(Integer x, String y) {\n}\n\npublic static void test(List<Record> records) {\n    for (Record record : records) {\n        System.out.println(record.y());\n        Integer x = record.x;\n        System.out.println(x);\n    }\n}' 可以替换为： 'record Record(Integer x, String y) {\n}\n\npublic static void test(List<Record> records) {\n    for (Record(Integer x, String y) : records) {\n        System.out.println(y);\n        System.out.println(x);\n    }\n}' 使用嵌套深度限制选项指定要报告的最大嵌套析构模式数 使用要析构的记录组件的最大数量选项指定要在析构模式中使用的记录可以包含的组件的最大数量 使用未使用的记录组件的最大数量选项指定 'for' 语句中未使用的组件的最大数量 2023.1 最新变化 此检查取决于 Java 功能 '在 for-each 循环中记录模式'，该功能自 Java X 起可用。",
                  "markdown": "报告局部变量声明和访问器，以记录增强型 'for' 语句（这些语句通常更紧凑）中可被替换为模式变量的组件。\n\n**示例：**\n\n\n    record Record(Integer x, String y) {\n    }\n\n    public static void test(List<Record> records) {\n        for (Record record : records) {\n            System.out.println(record.y());\n            Integer x = record.x;\n            System.out.println(x);\n        }\n    }\n\n可以替换为：\n\n\n    record Record(Integer x, String y) {\n    }\n\n    public static void test(List<Record> records) {\n        for (Record(Integer x, String y) : records) {\n            System.out.println(y);\n            System.out.println(x);\n        }\n    }\n\n* 使用**嵌套深度限制**选项指定要报告的最大嵌套析构模式数\n* 使用**要析构的记录组件的最大数量**选项指定要在析构模式中使用的记录可以包含的组件的最大数量\n* 使用**未使用的记录组件的最大数量** 选项指定 `for` 语句中未使用的组件的最大数量\n\n2023.1 最新变化\n\n此检查取决于 Java 功能 '在 for-each 循环中记录模式'，该功能自 Java X 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForEachWithRecordPatternCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级迁移帮助",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumClass",
                "shortDescription": {
                  "text": "枚举类"
                },
                "fullDescription": {
                  "text": "报告 enum 类。 Java 1.4 和更早版本的 JVM 不支持此类语句。",
                  "markdown": "报告 **enum** 类。 Java 1.4 和更早版本的 JVM 不支持此类语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialFunctionalExpressionUsage",
                "shortDescription": {
                  "text": "函数表达式的普通用法"
                },
                "fullDescription": {
                  "text": "报告在 lambda、方法引用或匿名类的定义中直接调用的函数接口方法调用。 此类方法调用可以替换为函数接口实现体。 示例： 'boolean contains(List<String> names, String name) {\n    return ((Predicate<String>)x -> {\n      return names.contains(x);\n    }).test(name);\n  }' 应用快速修复后，方法调用变为： 'boolean contains(List<String> names, String name) {\n    return names.contains(name);\n  }'",
                  "markdown": "报告在 lambda、方法引用或匿名类的定义中直接调用的函数接口方法调用。 此类方法调用可以替换为函数接口实现体。\n\n**示例：**\n\n\n      boolean contains(List<String> names, String name) {\n        return ((Predicate<String>)x -> {\n          return names.contains(x);\n        }).test(name);\n      }\n\n应用快速修复后，方法调用变为：\n\n\n      boolean contains(List<String> names, String name) {\n        return names.contains(name);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TrivialFunctionalExpressionUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedStringBuilderQueryUpdate",
                "shortDescription": {
                  "text": "'StringBuilder' 的查询和更新不匹配"
                },
                "fullDescription": {
                  "text": "报告其内容已读取但未写入，或已写入但未读取的 'StringBuilder'、'StringBuffer' 或 'StringJoiner' 对象。 此类不一致读写毫无意义，可能表明死码、代码不完整或错误。 示例： 'public void m1() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"a\");\n  }'",
                  "markdown": "报告其内容已读取但未写入，或已写入但未读取的 `StringBuilder`、`StringBuffer` 或 `StringJoiner` 对象。\n\n此类不一致读写毫无意义，可能表明死码、代码不完整或错误。\n\n**示例：**\n\n\n      public void m1() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"a\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedQueryAndUpdateOfStringBuilder",
                    "cweIds": [
                      561,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousHasLambdaAlternative",
                "shortDescription": {
                  "text": "匿名类型有较短的 lambda 替代项"
                },
                "fullDescription": {
                  "text": "报告可以转换为构造函数或带有 lambda 表达式实参的工厂方法调用的匿名类。 本次检查报告以下类别： 扩展 'ThreadLocal' 的匿名类，其具有 'initialValue()' 方法（可以替换为 'ThreadLocal.withInitial'） 扩展 'Thread' 的匿名类，其具有 'run()' 方法（可以替换为 'new Thread(Runnable)'） 示例： 'new Thread() {\n    @Override\n    public void run() {\n      System.out.println(\"Hello from thread!\");\n    }\n  }.start();' 在应用快速修复后： 'new Thread(() -> {\n    System.out.println(\"Hello from thread!\");\n  }).start();' 此检查取决于 Java 功能 'ThreadLocal.withInitial()'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以转换为构造函数或带有 lambda 表达式实参的工厂方法调用的匿名类。\n\n本次检查报告以下类别：\n\n* 扩展 `ThreadLocal` 的匿名类，其具有 `initialValue()` 方法（可以替换为 `ThreadLocal.withInitial`）\n* 扩展 `Thread` 的匿名类，其具有 `run()` 方法（可以替换为 `new Thread(Runnable)`）\n\n示例：\n\n\n      new Thread() {\n        @Override\n        public void run() {\n          System.out.println(\"Hello from thread!\");\n        }\n      }.start();\n\n在应用快速修复后：\n\n\n      new Thread(() -> {\n        System.out.println(\"Hello from thread!\");\n      }).start();\n\n此检查取决于 Java 功能 'ThreadLocal.withInitial()'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousHasLambdaAlternative",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalizeNotProtected",
                "shortDescription": {
                  "text": "'finalize()' 应为 protected，不应为 public"
                },
                "fullDescription": {
                  "text": "报告被声明为 'public' 的 'Object.finalize()' 方法的任何实现。 根据 'Object.finalize()' 的约定，只有垃圾回收器调用此方法。 将此方法设为 public 可能令人困惑，因为这意味着该方法可以从其他代码中使用。 可以通过快速修复将该方法设为 'protected'，以防止它被其他类调用。 示例： 'class X {\n    public void finalize() {\n      /* ... */\n    }\n  }' 在应用快速修复后： 'class X {\n    protected void finalize() {\n      /* ... */\n    }\n  }'",
                  "markdown": "报告被声明为 `public` 的 `Object.finalize()` 方法的任何实现。\n\n\n根据 `Object.finalize()` 的约定，只有垃圾回收器调用此方法。 将此方法设为 public 可能令人困惑，因为这意味着该方法可以从其他代码中使用。\n\n\n可以通过快速修复将该方法设为 `protected`，以防止它被其他类调用。\n\n**示例：**\n\n\n      class X {\n        public void finalize() {\n          /* ... */\n        }\n      }\n\n在应用快速修复后：\n\n\n      class X {\n        protected void finalize() {\n          /* ... */\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalizeNotProtected",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/完成",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsThread",
                "shortDescription": {
                  "text": "类直接扩展 'Thread'"
                },
                "fullDescription": {
                  "text": "报告直接扩展 'java.lang.Thread' 的类。 通常建议使用组合而不是继承来创建更便于日后修改的可重用代码。 示例： 'class MainThread extends Thread {\n  }'",
                  "markdown": "报告直接扩展 `java.lang.Thread` 的类。 通常建议使用组合而不是继承来创建更便于日后修改的可重用代码。\n\n**示例：**\n\n\n      class MainThread extends Thread {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExplicitlyExtendsThread",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ModuleWithTooManyClasses",
                "shortDescription": {
                  "text": "类过多的模块"
                },
                "fullDescription": {
                  "text": "报告包含的类太多的模块。 模块过大可能表明缺乏设计清晰度。 Java、Kotlin 和 Groovy 类均计算在内。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用最大类数字段可指定模块可以拥有的最大类数。",
                  "markdown": "报告包含的类太多的模块。 模块过大可能表明缺乏设计清晰度。 Java、Kotlin 和 Groovy 类均计算在内。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**最大类数**字段可指定模块可以拥有的最大类数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ModuleWithTooManyClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyOptionalCallChains",
                "shortDescription": {
                  "text": "可以简化 Optional 调用链"
                },
                "fullDescription": {
                  "text": "报告可以简化的 Optional 调用链。 下面是一些简化的例子： 'optional.map(x -> true).orElse(false)' → 'optional.isPresent()' 'optional.map(x -> Optional.of(x.trim())).orElseGet(Optional::empty)' → 'optional.map(String::trim)' 'optional.map(x -> (String)x).orElse(null)' → '(String) optional.orElse(null)' 'Optional.ofNullable(optional.orElse(null))' → 'optional' 'val = optional.orElse(null); val != null ? val : defaultExpr' → 'optional.orElse(defaultExpr)' 'val = optional.orElse(null); if(val != null) expr(val)' → 'optional.ifPresent(val -> expr(val))' 2017.2 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以简化的 **Optional** 调用链。 下面是一些简化的例子：\n\n* `optional.map(x -> true).orElse(false)` → `optional.isPresent()`\n* `optional.map(x -> Optional.of(x.trim())).orElseGet(Optional::empty)` → `optional.map(String::trim)`\n* `optional.map(x -> (String)x).orElse(null)` → `(String) optional.orElse(null)`\n* `Optional.ofNullable(optional.orElse(null))` → `optional`\n* `val = optional.orElse(null); val != null ? val : defaultExpr ` → `optional.orElse(defaultExpr)`\n* `val = optional.orElse(null); if(val != null) expr(val) ` → `optional.ifPresent(val -> expr(val))`\n\n2017.2 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifyOptionalCallChains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfiniteLoopStatement",
                "shortDescription": {
                  "text": "无限循环语句"
                },
                "fullDescription": {
                  "text": "报告只能通过抛出异常退出的 'for'、'while' 或 'do' 语句。 虽然此类语句可能是正确的，但它们经常由编码错误导致。 示例： 'for (;;) {\n  }' 使用 放置在 Thread.run 中时忽略 选项忽略 'Thread.run' 中的无限循环语句。 它可能对守护线程有用。 示例： 'new Thread(() -> {\n    while (true) {\n    }\n  }).start();'",
                  "markdown": "报告只能通过抛出异常退出的 `for`、`while` 或 `do` 语句。 虽然此类语句可能是正确的，但它们经常由编码错误导致。\n\n示例：\n\n\n      for (;;) {\n      }\n\n\n使用 **放置在 Thread.run 中时忽略** 选项忽略 `Thread.run` 中的无限循环语句。\n它可能对守护线程有用。\n\n示例：\n\n\n      new Thread(() -> {\n        while (true) {\n        }\n      }).start();\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InfiniteLoopStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RandomDoubleForRandomInteger",
                "shortDescription": {
                  "text": "使用 'Random.nextDouble()' 获取随机整数"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Random.nextDouble()' 的调用，这些调用用于通过将调用乘以一个系数并转换为整数来创建正整数。 对于在一定范围内生成随机正整数，'java.util.Random.nextInt(int)' 更加简单和高效。 示例： 'int getRandomInt() {\n    return (int) ((new Random()).nextDouble() * SIZE);\n  }'\n 在应用快速修复后： 'int getRandomInt() {\n    return (new Random()).nextInt(SIZE);\n  }'",
                  "markdown": "报告对 `java.util.Random.nextDouble()` 的调用，这些调用用于通过将调用乘以一个系数并转换为整数来创建正整数。\n\n\n对于在一定范围内生成随机正整数，`java.util.Random.nextInt(int)` 更加简单和高效。\n\n**示例：**\n\n\n      int getRandomInt() {\n        return (int) ((new Random()).nextDouble() * SIZE);\n      }\n      \n在应用快速修复后：\n\n\n      int getRandomInt() {\n        return (new Random()).nextInt(SIZE);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UsingRandomNextDoubleForRandomInteger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocHtmlLint",
                "shortDescription": {
                  "text": "Javadoc中的HTML问题(DocLint)"
                },
                "fullDescription": {
                  "text": "报告自 Java 8 以来 DocLint 报告的 Javadoc 注释中的相同 HTML 问题。 该检查发现以下问题： 自闭合、未闭合、未知、放错位置或空的标记 未知或错误的特性 放错位置的文本 示例： '/**\n * 未知标记：List<String>\n * 未闭合标记：error</b>\n * 放错位置的文本或标记：<ul><li>one</li>, <li>two</li></ul>\n * 错误或空的特性：<a href=\"\"></a>\n * 自闭合标记：<br/>\n * …\n */\nvoid sample(){ }'",
                  "markdown": "报告自 Java 8 以来 DocLint 报告的 Javadoc 注释中的相同 HTML 问题。\n\n该检查发现以下问题：\n\n* 自闭合、未闭合、未知、放错位置或空的标记\n* 未知或错误的特性\n* 放错位置的文本\n\n示例：\n\n\n    /**\n     * 未知标记：List<String>\n     * 未闭合标记：error</b>\n     * 放错位置的文本或标记：<ul><li>one</li>, <li>two</li></ul>\n     * 错误或空的特性：<a href=\"\"></a>\n     * 自闭合标记：<br/>\n     * ...\n     */\n    void sample(){ }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JavadocHtmlLint",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousArrayCast",
                "shortDescription": {
                  "text": "可疑的数组转换"
                },
                "fullDescription": {
                  "text": "报告可疑的数组转换。 当数组转换为更具体的数组类型时，数组转换被视为可疑。 虽然此类转换在编译时是合法的，但在运行时可能会因 'ClassCastException' 而失败。 示例： 'Number[] numbers = new Number[]{1L, 2L, 4L};\n  Long[] longs = (Long[])numbers;'",
                  "markdown": "报告可疑的数组转换。 当数组转换为更具体的数组类型时，数组转换被视为可疑。 虽然此类转换在编译时是合法的，但在运行时可能会因 `ClassCastException` 而失败。\n\n**示例：**\n\n\n      Number[] numbers = new Number[]{1L, 2L, 4L};\n      Long[] longs = (Long[])numbers;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousArrayCast",
                    "cweIds": [
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassUnconnectedToPackage",
                "shortDescription": {
                  "text": "独立于其软件包的类"
                },
                "fullDescription": {
                  "text": "报告如下类：不依赖于其软件包中的任何其他类，也不是其软件包中任何其他类的依赖项。 这种类表明临时或不连贯的打包策略，并且通常可以有利地移动。 不报告作为其软件包中唯一类的类。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告如下类：不依赖于其软件包中的任何其他类，也不是其软件包中任何其他类的依赖项。 这种类表明临时或不连贯的打包策略，并且通常可以有利地移动。 不报告作为其软件包中唯一类的类。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassUnconnectedToPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionNameDoesntEndWithException",
                "shortDescription": {
                  "text": "异常类名不以 'Exception' 结尾"
                },
                "fullDescription": {
                  "text": "报告名称不以 'Exception' 结束的异常类。 示例：'class NotStartedEx extends Exception {}' 只能在编辑器中采用快速修复来重命名这种类。",
                  "markdown": "报告名称不以 `Exception` 结束的异常类。\n\n**示例** ：`class NotStartedEx extends Exception {}`\n\n只能在编辑器中采用快速修复来重命名这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExceptionClassNameDoesntEndWithException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ZeroLengthArrayInitialization",
                "shortDescription": {
                  "text": "零长度数组分配"
                },
                "fullDescription": {
                  "text": "报告已知长度为零的数组的分配。 由于 Java 中的数组长度不可修改，几乎总是可以共享零长度数组，而不是重复分配新数组。 此类共享可以在程序运行时或占用空间中提供有用的优化。 请注意，检查不会报告分配为 static final 字段的零长度数组，因为会假设这些数组用于实现数组共享。",
                  "markdown": "报告已知长度为零的数组的分配。\n\n\n由于 Java 中的数组长度不可修改，几乎总是可以共享零长度数组，而不是重复分配新数组。 此类共享可以在程序运行时或占用空间中提供有用的优化。\n\n\n请注意，检查不会报告分配为 static final 字段的零长度数组，因为会假设这些数组用于实现数组共享。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ZeroLengthArrayAllocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalStaticVariableUsedInClassInitialization",
                "shortDescription": {
                  "text": "在类初始化期间使用非 final static 字段"
                },
                "fullDescription": {
                  "text": "报告在类初始化期间使用 'final' 'static' 变量的情况。 在此类情况下，代码语义可能会依赖于类的创建顺序。 此外，此类情况可能会导致在变量初始化之前使用变量，并且通常会导致困难和令人困惑的错误。 示例： 'class Foo {\n    public static int bar = 0;\n\n    static {\n      System.out.println(bar);\n    }\n  }'",
                  "markdown": "报告在类初始化期间使用 `final` `static` 变量的情况。\n\n在此类情况下，代码语义可能会依赖于类的创建顺序。 此外，此类情况可能会导致在变量初始化之前使用变量，并且通常会导致困难和令人困惑的错误。\n\n**示例：**\n\n\n      class Foo {\n        public static int bar = 0;\n\n        static {\n          System.out.println(bar);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalStaticVariableUsedInClassInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DivideByZero",
                "shortDescription": {
                  "text": "除以零"
                },
                "fullDescription": {
                  "text": "报告除以 0 或对 0 取余。 对于双精度或浮点数，此类表达式将产生 'Infinity'、'-Infinity' 或 'NaN' 结果；对于整数，则抛出 'ArithmeticException'。 当表达式的结果为 'NaN' 时，该修正会建议将除法表达式替换为 'NaN' 常量。",
                  "markdown": "报告除以 0 或对 0 取余。 对于双精度或浮点数，此类表达式将产生 `Infinity`、`-Infinity` 或 `NaN` 结果；对于整数，则抛出 `ArithmeticException`。\n\n当表达式的结果为 `NaN` 时，该修正会建议将除法表达式替换为 `NaN` 常量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "divzero",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadStopSuspendResume",
                "shortDescription": {
                  "text": "调用 'Thread.stop()'、'suspend()' 或 'resume()'"
                },
                "fullDescription": {
                  "text": "报告对 'Thread.stop()'、'Thread.suspend()' 和 'Thread.resume()' 的调用。 这些调用本质上容易导致数据损坏和死锁，强烈建议不要使用。 最好使用合作取消代替 'stop'，使用中断代替直接调用 'suspend' 和 'resume'。",
                  "markdown": "报告对 `Thread.stop()`、`Thread.suspend()` 和 `Thread.resume()` 的调用。\n\n\n这些调用本质上容易导致数据损坏和死锁，强烈建议不要使用。\n最好使用合作取消代替 `stop`，使用中断代替直接调用 `suspend` 和 `resume`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadStopSuspendOrResumeManager",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryTemporaryOnConversionFromString",
                "shortDescription": {
                  "text": "从 'String' 转换时有不必要的临时对象"
                },
                "fullDescription": {
                  "text": "报告从 'String' 转换为基元类型时创建的不必要的临时对象。 示例： 'new Integer(\"3\").intValue()' 在应用快速修复后： 'Integer.valueOf(\"3\")'",
                  "markdown": "报告从 `String` 转换为基元类型时创建的不必要的临时对象。\n\n**示例：**\n\n\n      new Integer(\"3\").intValue()\n\n在应用快速修复后：\n\n\n      Integer.valueOf(\"3\")\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryTemporaryOnConversionFromString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingSerialAnnotation",
                "shortDescription": {
                  "text": "可以使用 '@Serial' 注解"
                },
                "fullDescription": {
                  "text": "报告 'Serializable' 和 'Externalizable' 类中适合使用 'java.io.Serial' 注解进行注解的方法和字段。 该快速修复会添加注解。 示例： 'class Main implements Serializable {\n  private static final long serialVersionUID = 7874493593505141603L;\n\n  private void writeObject(ObjectOutputStream out) throws IOException {\n  }\n}' 在应用快速修复后： 'class Main implements Serializable {\n    @Serial\n    private static final long serialVersionUID = 7874493593505141603L;\n\n    @Serial\n    private void writeObject(ObjectOutputStream out) throws IOException {\n    }\n}' 示例： 'class Main implements Externalizable {\n    protected Object readResolve() throws ObjectStreamException {\n      return \"SomeObject\";\n    }\n  }' 在应用快速修复后： 'class Main implements Externalizable {\n    @Serial\n    protected Object readResolve() throws ObjectStreamException {\n        return \"SomeObject\";\n    }\n  }' 有关所有可能情况的更多信息，请参阅 'java.io.Serial' 类的 Javadoc。 2020.3 最新变化 此检查取决于 Java 功能 '@Serial 注解'，该功能自 Java 14 起可用。",
                  "markdown": "报告 `Serializable` 和 `Externalizable` 类中适合使用 `java.io.Serial` 注解进行注解的方法和字段。 该快速修复会添加注解。\n\n**示例：**\n\n\n    class Main implements Serializable {\n      private static final long serialVersionUID = 7874493593505141603L;\n\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\n在应用快速修复后：\n\n\n      class Main implements Serializable {\n        @Serial\n        private static final long serialVersionUID = 7874493593505141603L;\n\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n    }\n\n**示例：**\n\n\n      class Main implements Externalizable {\n        protected Object readResolve() throws ObjectStreamException {\n          return \"SomeObject\";\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Main implements Externalizable {\n        @Serial\n        protected Object readResolve() throws ObjectStreamException {\n            return \"SomeObject\";\n        }\n      }\n\n有关所有可能情况的更多信息，请参阅 `java.io.Serial` 类的 Javadoc。\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '@Serial 注解'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingSerialAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationMissingWhitespace",
                "shortDescription": {
                  "text": "字符串串联中可能缺少空格"
                },
                "fullDescription": {
                  "text": "报告缺少空格的字符串串联，即左侧以 Unicode 字母或数字结束，右侧以 Unicode 字母或数字开始。 示例： 'String sql = \"SELECT column\" +\n               \"FROM table\";' 使用忽略具有变量字符串的串联选项，只在串联的左右两侧都为文字时报告。",
                  "markdown": "报告缺少空格的字符串串联，即左侧以 Unicode 字母或数字结束，右侧以 Unicode 字母或数字开始。\n\n**示例：**\n\n\n      String sql = \"SELECT column\" +\n                   \"FROM table\";\n\n\n使用**忽略具有变量字符串的串联**选项，只在串联的左右两侧都为文字时报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationMissingWhitespace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StandardVariableNames",
                "shortDescription": {
                  "text": "标准变量名称"
                },
                "fullDescription": {
                  "text": "报告具有与其类型不对应的“标准”名称的变量。 此类名称可能令人困惑。 特定类型有以下标准名称： i, j, k, m, n - 'int' f - 'float' d - 'double' b - 'byte' c, ch - 'char' l - 'long' s, str - 'String' 仅在编辑器中建议重命名快速修复。 使用该选项可以忽略与直接 super 方法中的形参名称相同的形参名称。",
                  "markdown": "报告具有与其类型不对应的\"标准\"名称的变量。 此类名称可能令人困惑。 特定类型有以下标准名称：\n\n* i, j, k, m, n - `int`\n* f - `float`\n* d - `double`\n* b - `byte`\n* c, ch - `char`\n* l - `long`\n* s, str - `String`\n\n仅在编辑器中建议重命名快速修复。\n\n\n使用该选项可以忽略与直接 super 方法中的形参名称相同的形参名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StandardVariableNames",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfConcreteClass",
                "shortDescription": {
                  "text": "具体类的使用"
                },
                "fullDescription": {
                  "text": "报告使用具体类而非接口的情况。 此类声明可能代表抽象失败，并可能使测试更加困难。 此检查不会报告其类来自系统或第三方库的声明。 'equals()' 方法实现中不会报告转换、instanceof 和局部变量。 此外，'clone()' 方法实现中不会报告转换。 示例： 'interface Entity {}\n  class EntityImpl implements Entity {}\n\n  void processObject(Object obj) {\n    // 警告：具体类的 instanceof\n    if (obj instanceof EntityImpl) {\n      // 警告：转换为具体类，\n      // 而不是接口\n      processEntity((EntityImpl)obj);\n    }\n  }\n  // 警告：具体类的形参\n  void processEntity(EntityImpl obj) {\n  }' 使用忽略抽象类类型选项可以忽略对抽象类的转换。 使用后续选项可控制报告问题的上下文。",
                  "markdown": "报告使用具体类而非接口的情况。 此类声明可能代表抽象失败，并可能使测试更加困难。\n\n\n此检查不会报告其类来自系统或第三方库的声明。\n`equals()` 方法实现中不会报告转换、instanceof 和局部变量。\n此外，`clone()` 方法实现中不会报告转换。\n\n示例：\n\n\n      interface Entity {}\n      class EntityImpl implements Entity {}\n\n      void processObject(Object obj) {\n        // 警告：具体类的 instanceof\n        if (obj instanceof EntityImpl) {\n          // 警告：转换为具体类，\n          // 而不是接口\n          processEntity((EntityImpl)obj);\n        }\n      }\n      // 警告：具体类的形参\n      void processEntity(EntityImpl obj) {\n      }\n\n\n使用**忽略抽象类类型**选项可以忽略对抽象类的转换。\n\n使用后续选项可控制报告问题的上下文。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfConcreteClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeconstructionCanBeUsed",
                "shortDescription": {
                  "text": "可以使用记录模式"
                },
                "fullDescription": {
                  "text": "报告可被替换为记录模式的模式。 示例： 'record Point(int x, int y) {}\n\n  static void printSum(Object obj) {\n    if (obj instanceof Point p) {\n      int x = p.x();\n      int y = p.y();\n      System.out.println(x + y);\n    }\n  }' 在应用快速修复后： 'record Point(int x, int y) {}\n\n  static void printSum(Object obj) {\n    if (obj instanceof Point(int x, int y)) {\n      System.out.println(x + y);\n    }\n  }' 2023.1 最新变化 此检查取决于 Java 功能 '模式保护和记录模式'，该功能自 Java 21 起可用。",
                  "markdown": "报告可被替换为记录模式的模式。\n\n示例：\n\n\n      record Point(int x, int y) {}\n\n      static void printSum(Object obj) {\n        if (obj instanceof Point p) {\n          int x = p.x();\n          int y = p.y();\n          System.out.println(x + y);\n        }\n      }\n\n在应用快速修复后：\n\n\n      record Point(int x, int y) {}\n\n      static void printSum(Object obj) {\n        if (obj instanceof Point(int x, int y)) {\n          System.out.println(x + y);\n        }\n      }\n\n2023.1 最新变化\n\n此检查取决于 Java 功能 '模式保护和记录模式'，该功能自 Java 21 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DeconstructionCanBeUsed",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLabeledSwitchRuleCodeBlock",
                "shortDescription": {
                  "text": "标记的 switch 规则具有冗余代码块"
                },
                "fullDescription": {
                  "text": "报告带有冗余代码块的 'switch' 语句或 'switch' 表达式的标记规则。 示例： 'String s = switch (n) {\n    case 1 -> { yield Integer.toString(n); }\n    default -> \"default\";\n  };' 在应用快速修复后： 'String s = switch (n) {\n    case 1 -> Integer.toString(n);\n    default -> \"default\";\n  };' 2019.1 最新变化 此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。",
                  "markdown": "报告带有冗余代码块的 `switch` 语句或 `switch` 表达式的标记规则。\n\n示例：\n\n\n      String s = switch (n) {\n        case 1 -> { yield Integer.toString(n); }\n        default -> \"default\";\n      };\n\n在应用快速修复后：\n\n\n      String s = switch (n) {\n        case 1 -> Integer.toString(n);\n        default -> \"default\";\n      };\n\n2019.1 最新变化\n\n此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantLabeledSwitchRuleCodeBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IOStreamConstructor",
                "shortDescription": {
                  "text": "可以使用 'Files' 方法构建 'InputStream' 和 'OutputStream'"
                },
                "fullDescription": {
                  "text": "报告可被分别替换为 'Files.newInputStream()' 或 'Files.newOutputStream()' 调用的 'new FileInputStream()' 或 'new FileOutputStream()' 表达式。 使用 'Files' 方法创建的流通常比使用流构造函数创建的流更有效。 示例： 'InputStream is = new BufferedInputStream(new FileInputStream(file));' 在应用快速修复后： 'InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));' 如果语言级别为 10 或更高，则此检查不会显示警告，但快速修复仍然可用。 仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。 2022.1 最新变化",
                  "markdown": "报告可被分别替换为 `Files.newInputStream()` 或 `Files.newOutputStream()` 调用的 `new FileInputStream()` 或 `new FileOutputStream()` 表达式。   \n使用 `Files` 方法创建的流通常比使用流构造函数创建的流更有效。\n\n示例：\n\n\n      InputStream is = new BufferedInputStream(new FileInputStream(file));\n\n在应用快速修复后：\n\n\n      InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));\n\n如果语言级别为 10 或更高，则此检查不会显示警告，但快速修复仍然可用。\n\n仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IOStreamConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToForLoopParameter",
                "shortDescription": {
                  "text": "赋值给 'for' 循环形参"
                },
                "fullDescription": {
                  "text": "报告对循环体内 'for' 循环形参的赋值或修改。 虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量引起。 该快速修复会添加新变量的声明。 示例： 'for (String s : list) {\n    // 警告：s 在循环内被更改\n    s = s.trim();\n    System.out.println(\"String: \" + s);\n  }' 在应用快速修复后： 'for (String s : list) {\n    String trimmed = s.trim();\n    System.out.println(\"String: \" + trimmed);\n  }' 不报告没有 update 语句的基本 'for' 循环中的赋值。 在此类情况下，赋值很可能是预期的，不能轻易移动到 'for' 循环的更新部分。 示例： 'for (int i = 0; i < list.size(); ) {\n    if (element.equals(list.get(i))) {\n      list.remove(i);\n    } else {\n      // 因为没有 update 语句\n      // 所以不报告 for 循环形参的修改\n      i++;\n    }\n  }' 使用检查增强型 'for' 循环形参选项可指定是否还应报告增强的 'for' 循环形参的修改。",
                  "markdown": "报告对循环体内 `for` 循环形参的赋值或修改。\n\n虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量引起。\n\n该快速修复会添加新变量的声明。\n\n**示例：**\n\n\n      for (String s : list) {\n        // 警告：s 在循环内被更改\n        s = s.trim();\n        System.out.println(\"String: \" + s);\n      }\n\n在应用快速修复后：\n\n\n      for (String s : list) {\n        String trimmed = s.trim();\n        System.out.println(\"String: \" + trimmed);\n      }\n\n不报告没有 update 语句的基本 `for` 循环中的赋值。\n在此类情况下，赋值很可能是预期的，不能轻易移动到 `for` 循环的更新部分。\n\n**示例：**\n\n\n      for (int i = 0; i < list.size(); ) {\n        if (element.equals(list.get(i))) {\n          list.remove(i);\n        } else {\n          // 因为没有 update 语句\n          // 所以不报告 for 循环形参的修改\n          i++;\n        }\n      }\n\n使用**检查增强型 'for' 循环形参** 选项可指定是否还应报告增强的 `for` 循环形参的修改。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToForLoopParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9CollectionFactory",
                "shortDescription": {
                  "text": "不可变集合创建可被替换为集合工厂调用"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Collections' 不可修改的集合调用，这些调用可以转换为更新的集合工厂方法。 例如，这些可以替换为在 Java 9 中引入的 'List.of()' 或 'Set.of()' 或在 Java 10 中引入的 'List.copyOf()'。 请注意，与 'java.util.Collections' 方法相比，Java 9 集合工厂方法： 不接受 'null' 值。 需要唯一的集合元素和映射键。 不要接受 'null' 实参来查询返回集合的 'List.contains()' 或 'Map.get()' 等方法。 当这些情况被违反时，会抛出异常。 这可以在迁移后更改代码的语义。 示例： 'List<Integer> even = Collections.unmodifiableList(\n    Arrays.asList(2, 4, 6, 8, 10, 2));\n  List<Integer> evenCopy = Collections.unmodifiableList(\n    new ArrayList<>(list1));' 在应用快速修复后： 'List<Integer> even = List.of(2, 4, 6, 8, 10, 2);\n  List<Integer> evenCopy = List.copyOf(list);' 使用当内容为非常量时不发出警告选项可以仅在提供的实参是编译时常量的情况下报告。 这减少了行为改变的机会，因为并不总是可以静态检查原始元素是否唯一且为非 'null'。 使用建议 'Map.ofEntries' 选项可建议使用 'Map.ofEntries()' 替换超过 10 个条目的不可修改的映射。 2017.2 最新变化 此检查取决于 Java 功能 '集合工厂方法'，该功能自 Java 9 起可用。",
                  "markdown": "报告 `java.util.Collections` 不可修改的集合调用，这些调用可以转换为更新的集合工厂方法。 例如，这些可以替换为在 Java 9 中引入的 `List.of()` 或 `Set.of()` 或在 Java 10 中引入的 `List.copyOf()`。\n\n请注意，与 `java.util.Collections` 方法相比，Java 9 集合工厂方法：\n\n* 不接受 `null` 值。\n* 需要唯一的集合元素和映射键。\n* 不要接受 `null` 实参来查询返回集合的 `List.contains()` 或 `Map.get()` 等方法。\n\n当这些情况被违反时，会抛出异常。\n这可以在迁移后更改代码的语义。\n\n示例：\n\n\n      List<Integer> even = Collections.unmodifiableList(\n        Arrays.asList(2, 4, 6, 8, 10, 2));\n      List<Integer> evenCopy = Collections.unmodifiableList(\n        new ArrayList<>(list1));\n\n在应用快速修复后：\n\n\n      List<Integer> even = List.of(2, 4, 6, 8, 10, 2);\n      List<Integer> evenCopy = List.copyOf(list);\n\n\n使用**当内容为非常量时不发出警告** 选项可以仅在提供的实参是编译时常量的情况下报告。\n这减少了行为改变的机会，因为并不总是可以静态检查原始元素是否唯一且为非 `null`。\n\n\n使用**建议 'Map.ofEntries'** 选项可建议使用 `Map.ofEntries()` 替换超过 10 个条目的不可修改的映射。\n\n2017.2 最新变化\n\n此检查取决于 Java 功能 '集合工厂方法'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Java9CollectionFactory",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 9",
                      "index": 76,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionFromCatchWhichDoesntWrap",
                "shortDescription": {
                  "text": "'throw' 位于忽略已捕获异常的 'catch' 块内"
                },
                "fullDescription": {
                  "text": "报告从 'catch' 块内部抛出但不“包装”所捕获异常的异常。 当异常被抛出以响应异常时，包装初始异常可防止丢失有价值的上下文信息，如堆栈帧和行号。 示例： '...\n  catch (IOException e) {\n    closeAllConnections();\n    throw new ConnectException(\"Connection problem.\"); // 警告：'catch' 块内的 'throw' 忽略捕获的异常 'e'\n  }' 配置检查： 使用如果使用异常方法调用的结果，则忽略选项可指示检查是否应忽略实参为原始异常方法调用结果的异常，例如 'getMessage()'。 使用如果抛出的异常无法包装异常，则忽略选项可忽略在没有接受 'Throwable' 子句的构造函数的情况下抛出异常的 'throw' 语句。",
                  "markdown": "报告从 `catch` 块内部抛出但不\"包装\"所捕获异常的异常。\n\n当异常被抛出以响应异常时，包装初始异常可防止丢失有价值的上下文信息，如堆栈帧和行号。\n\n**示例：**\n\n\n      ...\n      catch (IOException e) {\n        closeAllConnections();\n        throw new ConnectException(\"Connection problem.\"); // 警告：'catch' 块内的 'throw' 忽略捕获的异常 'e'\n      }\n\n配置检查：\n\n* 使用**如果使用异常方法调用的结果，则忽略** 选项可指示检查是否应忽略实参为原始异常方法调用结果的异常，例如 `getMessage()`。\n* 使用**如果抛出的异常无法包装异常，则忽略** 选项可忽略在没有接受 `Throwable` 子句的构造函数的情况下抛出异常的 `throw` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowInsideCatchBlockWhichIgnoresCaughtException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOnlyUsedFromInnerClass",
                "shortDescription": {
                  "text": "仅在内部类中使用 private 方法"
                },
                "fullDescription": {
                  "text": "报告仅从包含该方法的类的内部类调用的 'private' 方法。 此类方法可以安全地移到该内部类中。 示例： 'public class Outer {\n  public static void main(String[] args) {\n    new Inner().run(args[0]);\n  }\n\n  static class Inner {\n    void run(String arg) {\n      // 方法 isEmpty() 仅从内部类使用\n      // 考虑将其移到内部类\n      if (!isEmpty(arg)) {\n        System.out.println(\"Argument is supplied\");\n      }\n    }\n  }\n\n  private static boolean isEmpty(String s) {\n    return s != null && s.trim().isEmpty();\n  }\n}' 使用下面的第一个复选框可忽略从匿名类或本地类调用的 'private' 方法。 使用第三个复选框可仅报告 'static' 方法。",
                  "markdown": "报告仅从包含该方法的类的内部类调用的 `private` 方法。 此类方法可以安全地移到该内部类中。\n\n示例：\n\n\n    public class Outer {\n      public static void main(String[] args) {\n        new Inner().run(args[0]);\n      }\n\n      static class Inner {\n        void run(String arg) {\n          // 方法 isEmpty() 仅从内部类使用\n          // 考虑将其移到内部类\n          if (!isEmpty(arg)) {\n            System.out.println(\"Argument is supplied\");\n          }\n        }\n      }\n\n      private static boolean isEmpty(String s) {\n        return s != null && s.trim().isEmpty();\n      }\n    }\n\n\n使用下面的第一个复选框可忽略从匿名类或本地类调用的 `private` 方法。\n\n\n使用第三个复选框可仅报告 `static` 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOnlyUsedFromInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparisonToNaN",
                "shortDescription": {
                  "text": "与 'Double.NaN' 或 'Float.NaN' 比较"
                },
                "fullDescription": {
                  "text": "报告任何与 'Double.NaN' 或 'Float.NaN' 的比较。 此类比较毫无意义，因为 NaN 不等于任何内容，包括不等于自身。 改用 'Double.isNaN()' 或 'Float.isNaN()' 方法。 示例： 'if (x == Double.NaN) {...}' 在应用快速修复后： 'if (Double.isNaN(x)) {...}'",
                  "markdown": "报告任何与 `Double.NaN` 或 `Float.NaN` 的比较。 此类比较毫无意义，因为 NaN 不等于任何内容，包括不等于自身。 改用 `Double.isNaN()` 或 `Float.isNaN()` 方法。\n\n**示例：**\n\n\n      if (x == Double.NaN) {...}\n\n在应用快速修复后：\n\n\n      if (Double.isNaN(x)) {...}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparisonToNaN",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultiCatchCanBeSplit",
                "shortDescription": {
                  "text": "多 catch 可拆分为单独的 catch 块"
                },
                "fullDescription": {
                  "text": "报告多个 'catch' 部分并建议将它们拆分为单独的 'catch' 块。 示例： 'try {\n    int i = getIndex();\n  } catch (NullPointerException|IndexOutOfBoundsException e) {\n    e.printStackTrace();\n  }' 在应用快速修复后： 'try {\n    int i = getIndex();\n  } catch (NullPointerException e) {\n    e.printStackTrace();\n  } catch (IndexOutOfBoundsException e) {\n    e.printStackTrace();\n  }' 此检查取决于 Java 功能 '多 catch'，该功能自 Java 7 起可用。",
                  "markdown": "报告多个 `catch` 部分并建议将它们拆分为单独的 `catch` 块。\n\n示例：\n\n\n      try {\n        int i = getIndex();\n      } catch (NullPointerException|IndexOutOfBoundsException e) {\n        e.printStackTrace();\n      }\n\n在应用快速修复后：\n\n\n      try {\n        int i = getIndex();\n      } catch (NullPointerException e) {\n        e.printStackTrace();\n      } catch (IndexOutOfBoundsException e) {\n        e.printStackTrace();\n      }\n\n此检查取决于 Java 功能 '多 catch'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MultiCatchCanBeSplit",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ResultSetIndexZero",
                "shortDescription": {
                  "text": "在 JDBC ResultSet 中使用索引 0"
                },
                "fullDescription": {
                  "text": "报告访问 'java.sql.ResultSet' 或 'java.sql.PreparedStatement' 的第 0 列的尝试。 由于历史原因，'java.sql.ResultSet' 和 'java.sql.PreparedStatement' 的列不是从 0 开始编号，而是从 1 开始编号，并且访问第 0 列是 JDBC 编程中的常见错误。 示例： 'String getName(ResultSet rs) {\n    return rs.getString(0);\n  }'",
                  "markdown": "报告访问 `java.sql.ResultSet` 或 `java.sql.PreparedStatement` 的第 0 列的尝试。 由于历史原因，`java.sql.ResultSet` 和 `java.sql.PreparedStatement` 的列不是从 **0** 开始编号，而是从 **1** 开始编号，并且访问第 0 列是 JDBC 编程中的常见错误。\n\n**示例：**\n\n\n      String getName(ResultSet rs) {\n        return rs.getString(0);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfIndexZeroInJDBCResultSet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionCoveredByFurtherCondition",
                "shortDescription": {
                  "text": "条件由进一步的条件覆盖"
                },
                "fullDescription": {
                  "text": "报告由于后续条件完全覆盖而变得冗余的条件。 例如，在 'value != -1 && value > 0' 条件下，第一部分是冗余的：如果它为 false，那么第二部分也为 false。 或者在像 'obj != null && obj instanceof String' 这样的条件下，null 检查是冗余的，因为 'instanceof' 运算符意味着非 null。 2018.3 最新变化",
                  "markdown": "报告由于后续条件完全覆盖而变得冗余的条件。\n\n例如，在 `value != -1 && value > 0` 条件下，第一部分是冗余的：如果它为 false，那么第二部分也为 false。\n或者在像 `obj != null && obj instanceof String` 这样的条件下，null 检查是冗余的，因为 `instanceof` 运算符意味着非 null。\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionCoveredByFurtherCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MetaAnnotationWithoutRuntimeRetention",
                "shortDescription": {
                  "text": "不含 '@Retention(RUNTIME)' 注解的测试注解"
                },
                "fullDescription": {
                  "text": "报告 JUnit 5 应当使用的包含 'SOURCE' 或 'CLASS' 保留策略的注解。 此类注解在运行时不可用，很可能应当修正其保留策略，才能通过反射进行访问。 请注意，如果未指定保留策略，则使用默认保留策略 'CLASS'。 示例： '@Testable\n  public @interface UnitTest {}' 在应用快速修复后： '@Retention(RetentionPolicy.RUNTIME)\n  @Testable\n  public @interface UnitTest {}'",
                  "markdown": "报告 JUnit 5 应当使用的包含 `SOURCE` 或 `CLASS` 保留策略的注解。 此类注解在运行时不可用，很可能应当修正其保留策略，才能通过反射进行访问。\n\n请注意，如果未指定保留策略，则使用默认保留策略 `CLASS`。\n\n**示例：**\n\n\n      @Testable\n      public @interface UnitTest {}\n\n在应用快速修复后：\n\n\n      @Retention(RetentionPolicy.RUNTIME)\n      @Testable\n      public @interface UnitTest {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MetaAnnotationWithoutRuntimeRetention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JUnit",
                      "index": 77,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternVariableHidesField",
                "shortDescription": {
                  "text": "模式变量隐藏字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的模式变量。 由于此类命名，在有意使用同名字段的情况下，您可能会误用该模式变量。 建议通过快速修复重命名该变量。 示例： 'class Pointless {\n    Point p = new Point();\n\n    public void test(Object a) {\n      if (a instanceof Point p) {\n        System.out.print(\"a is a point (\" + p.x + \", \" + p.y + ')');\n      } else {\n        System.out.print(\"p is a point (\" + p.x + \", \" + p.y + ')');\n      }\n    }\n  }' 2022.2 最新变化",
                  "markdown": "报告与周围类的字段同名的模式变量。 由于此类命名，在有意使用同名字段的情况下，您可能会误用该模式变量。\n\n\n建议通过快速修复重命名该变量。\n\n**示例：**\n\n\n      class Pointless {\n        Point p = new Point();\n\n        public void test(Object a) {\n          if (a instanceof Point p) {\n            System.out.print(\"a is a point (\" + p.x + \", \" + p.y + ')');\n          } else {\n            System.out.print(\"p is a point (\" + p.x + \", \" + p.y + ')');\n          }\n        }\n      }\n\n2022.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternVariableHidesField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JoinDeclarationAndAssignmentJava",
                "shortDescription": {
                  "text": "赋值可与声明联接"
                },
                "fullDescription": {
                  "text": "报告可以与变量声明联接的变量赋值。 示例： 'int x;\n  x = 1;' 快速修复将赋值转换为初始值设定项： 'int x = 1;' 2018.3 最新变化",
                  "markdown": "报告可以与变量声明联接的变量赋值。\n\n示例：\n\n\n      int x;\n      x = 1;\n\n快速修复将赋值转换为初始值设定项：\n\n\n      int x = 1;\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JoinDeclarationAndAssignmentJava",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassVariableHidesOuterClassVariable",
                "shortDescription": {
                  "text": "内部类字段隐藏外部类字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的内部类字段。 由于进行此类命名，在周围类有意使用同名字段的情况下，您可能会误用内部类的字段。 建议通过快速修复重命名该内部类字段。 示例： 'class Outer {\n    private String name;\n\n    class Inner {\n      private String name;\n    }\n  }' 使用此选项可选择此检查应报告所有名称冲突，还是只报告与内部类可见的字段的冲突。",
                  "markdown": "报告与周围类的字段同名的内部类字段。 由于进行此类命名，在周围类有意使用同名字段的情况下，您可能会误用内部类的字段。\n\n建议通过快速修复重命名该内部类字段。\n\n**示例：**\n\n\n      class Outer {\n        private String name;\n\n        class Inner {\n          private String name;\n        }\n      }\n\n\n使用此选项可选择此检查应报告所有名称冲突，还是只报告与内部类可见的字段的冲突。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassFieldHidesOuterClassField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryContinue",
                "shortDescription": {
                  "text": "不必要的 'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告循环中最后能够到达的 'continue' 语句。 这些 'continue' 语句是不必要的语句，可以安全移除。 示例： 'for (String element: elements) {\n    System.out.println();\n    continue;\n  }' 在应用快速修复后： 'for (String element: elements) {\n    System.out.println();\n  }' 该检查不分析 JSP 文件。 使用在具有 'else' 分支的 'if' 语句的 then 分支中忽略选项可以忽略位于完整 'if'-'else' 语句的 'then' 分支中的 'continue'语句。 示例： 'for (String element: elements) {\n    if(element.isEmpty()) {\n      continue;\n    } else {\n      //...\n    }\n  }'",
                  "markdown": "报告循环中最后能够到达的 `continue` 语句。 这些 `continue` 语句是不必要的语句，可以安全移除。\n\n示例：\n\n\n      for (String element: elements) {\n        System.out.println();\n        continue;\n      }\n\n在应用快速修复后：\n\n\n      for (String element: elements) {\n        System.out.println();\n      }\n\n该检查不分析 JSP 文件。\n\n\n使用**在具有 'else' 分支的 'if' 语句的 then 分支中忽略** 选项可以忽略位于完整 `if`-`else` 语句的 `then` 分支中的 `continue`语句。\n\n示例：\n\n\n      for (String element: elements) {\n        if(element.isEmpty()) {\n          continue;\n        } else {\n          //...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryContinue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MISSORTED_IMPORTS",
                "shortDescription": {
                  "text": "错误排序的 import"
                },
                "fullDescription": {
                  "text": "报告未根据当前代码样式排列的 'import' 语句（请参阅“设置|编辑|代码样式”）。 示例： 'import java.util.List;\n  import java.util.ArrayList;\n\n  public class Example {\n    List list = new ArrayList();\n  }' 在应用“优化 import”快速修复后： 'import java.util.ArrayList;\n  import java.util.List;\n\n  public class Example {\n    List list = new ArrayList();\n  }'",
                  "markdown": "报告未根据当前代码样式排列的 `import` 语句（请参阅\"设置\\|编辑\\|代码样式\"）。\n\n**示例：**\n\n\n      import java.util.List;\n      import java.util.ArrayList;\n\n      public class Example {\n        List list = new ArrayList();\n      }\n\n在应用\"优化 import\"快速修复后：\n\n\n      import java.util.ArrayList;\n      import java.util.List;\n\n      public class Example {\n        List list = new ArrayList();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MISSORTED_IMPORTS",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryModifier",
                "shortDescription": {
                  "text": "不必要的修饰符"
                },
                "fullDescription": {
                  "text": "报告冗余的修饰符并建议移除它们。 结果代码会更短，但其行为和含义将保持不变。 示例 1： '// 在 Java 17 和更高版本下，所有代码都是隐式 strictfp\n  strictfp class X {\n\n    // 内部枚举为隐式 static\n    static enum Inner {\n        A, B, C\n    }\n\n    // 内部记录为隐式 static\n    static record R() {\n    }\n  }' 示例 2： 'final record R() {\n    // 所有记录均为隐式 final\n  }' 示例 3： '// 所有接口均为隐式 abstract\n  abstract interface Printer {\n\n    // 所有接口成员均为隐式 public\n    public int size();\n\n    // 接口的所有内部类均为隐式 static\n    static class Inner {}\n  }'",
                  "markdown": "报告冗余的修饰符并建议移除它们。 结果代码会更短，但其行为和含义将保持不变。\n\n**示例 1：**\n\n\n      // 在 Java 17 和更高版本下，所有代码都是隐式 strictfp\n      strictfp class X {\n\n        // 内部枚举为隐式 static\n        static enum Inner {\n            A, B, C\n        }\n\n        // 内部记录为隐式 static\n        static record R() {\n        }\n      }\n\n**示例 2：**\n\n\n      final record R() {\n        // 所有记录均为隐式 final\n      }\n\n**示例 3：**\n\n\n      // 所有接口均为隐式 abstract\n      abstract interface Printer {\n\n        // 所有接口成员均为隐式 public\n        public int size();\n\n        // 接口的所有内部类均为隐式 static\n        static class Inner {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonThreadSafeLazyInitialization",
                "shortDescription": {
                  "text": "不安全的 'static' 字段延迟初始化"
                },
                "fullDescription": {
                  "text": "报告以非线程安全方式延迟初始化的 'static' 变量。 应该使用适当的同步构造来完成 'static' 变量的延迟初始化，以防止不同的线程执行冲突的初始化。 如果适用，建议使用引入延迟初始化容器类习惯用法的快速修复。 这个习惯用法利用了 JVM 会保证类在使用之前不会被初始化的事实。 示例： 'class X {\n    private static List<String> list;\n\n    public List<String> getList() {\n      if (list == null) {\n        list = List.of(\"one\", \"two\", \"tree\");\n      }\n      return list;\n    }\n  }' 在应用快速修复后： 'class X {\n    private static final class ListHolder {\n      static final List<String> list = List.of(\"one\", \"two\", \"tree\");\n    }\n\n    public List<String> getList() {\n      return ListHolder.list;\n    }\n  }'",
                  "markdown": "报告以非线程安全方式延迟初始化的 `static` 变量。\n\n应该使用适当的同步构造来完成 `static` 变量的延迟初始化，以防止不同的线程执行冲突的初始化。\n\n如果适用，建议使用引入[延迟初始化容器类习惯用法](https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom)的快速修复。\n这个习惯用法利用了 JVM 会保证类在使用之前不会被初始化的事实。\n\n**示例：**\n\n\n      class X {\n        private static List<String> list;\n\n        public List<String> getList() {\n          if (list == null) {\n            list = List.of(\"one\", \"two\", \"tree\");\n          }\n          return list;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class X {\n        private static final class ListHolder {\n          static final List<String> list = List.of(\"one\", \"two\", \"tree\");\n        }\n\n        public List<String> getList() {\n          return ListHolder.list;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonThreadSafeLazyInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalCanBePushedInsideExpression",
                "shortDescription": {
                  "text": "可以将条件推送到分支表达式内部"
                },
                "fullDescription": {
                  "text": "报告满足以下条件表达式：带有 'then' 和 else 分支，且足够相似，以便表达式可以移入内部。 此操作会缩短代码。 示例： 'double g(int a, int b) {\n    return a == b ? Math.cos(0) : Math.cos(1);\n  }' 在应用快速修复后： 'double g(int a, int b) {\n    return Math.cos(a == b ? 0 : 1);\n  }' 2017.2 最新变化",
                  "markdown": "报告满足以下条件表达式：带有 `then` 和 else 分支，且足够相似，以便表达式可以移入内部。 此操作会缩短代码。\n\n示例：\n\n\n      double g(int a, int b) {\n        return a == b ? Math.cos(0) : Math.cos(1);\n      }\n\n在应用快速修复后：\n\n\n      double g(int a, int b) {\n        return Math.cos(a == b ? 0 : 1);\n      }\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConditionalCanBePushedInsideExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneInNonCloneableClass",
                "shortDescription": {
                  "text": "不可克隆类中的 'clone()' 方法"
                },
                "fullDescription": {
                  "text": "报告重写 'clone()' 方法但不实现 'Cloneable' 接口的类。 这通常表示编程错误。 使用仅对 'public' 克隆方法发出警告选项可以忽略不是 'public' 的方法。 对于设计为继承的类，您可以选择不实现 'Cloneable' 接口，而是重写 'clone()' 并将其声明为 'protected'，并决定是否在子类中实现 'Cloneable' 接口。",
                  "markdown": "报告重写 `clone()` 方法但不实现 `Cloneable` 接口的类。 这通常表示编程错误。\n\n\n使用**仅对 'public' 克隆方法发出警告** 选项可以忽略不是 `public` 的方法。\n\n对于设计为继承的类，您可以选择不实现 `Cloneable` 接口，而是重写 `clone()` 并将其声明为 `protected`，并决定是否在子类中实现 `Cloneable` 接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneInNonCloneableClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CStyleArrayDeclaration",
                "shortDescription": {
                  "text": "C 样式数组声明"
                },
                "fullDescription": {
                  "text": "报告以 C 样式语法编写的数组声明，其中数组中括号放置在变量名称之后或方法形参列表之后。 大多数代码样式更喜欢 Java 样式的数组声明，其中数组中括号放置在类型名称之后。 示例： 'public String process(String value[])[] {\n    return value;\n  }' 在应用快速修复后： 'public String[] process(String[] value) {\n    return value;\n  }' 配置检查： 使用 忽略变量中的C样式声明 选项仅报告方法返回类型的 C 样式数组声明。",
                  "markdown": "报告以 C 样式语法编写的数组声明，其中数组中括号放置在变量名称之后或方法形参列表之后。 大多数代码样式更喜欢 Java 样式的数组声明，其中数组中括号放置在类型名称之后。\n\n**示例：**\n\n\n      public String process(String value[])[] {\n        return value;\n      }\n\n在应用快速修复后：\n\n\n      public String[] process(String[] value) {\n        return value;\n      }\n\n配置检查：\n\n\n使用 **忽略变量中的C样式声明** 选项仅报告方法返回类型的 C 样式数组声明。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CStyleArrayDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8ListReplaceAll",
                "shortDescription": {
                  "text": "循环可被替换为 'List.replaceAll()'"
                },
                "fullDescription": {
                  "text": "报告可以折叠为单个 'List.replaceAll()' 调用的循环。 示例： 'for (int i = 0; i < strings.size(); i++) {\n    String str = strings.get(i).toLowerCase();\n    strings.set(i, str);\n  }' 在应用快速修复后： 'strings.replaceAll(String::toLowerCase);' 2022.1 最新变化 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以折叠为单个 `List.replaceAll()` 调用的循环。\n\n**示例：**\n\n\n      for (int i = 0; i < strings.size(); i++) {\n        String str = strings.get(i).toLowerCase();\n        strings.set(i, str);\n      }\n\n在应用快速修复后：\n\n\n      strings.replaceAll(String::toLowerCase);\n\n2022.1 最新变化\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8ListReplaceAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemExit",
                "shortDescription": {
                  "text": "调用 'System.exit()' 或相关方法"
                },
                "fullDescription": {
                  "text": "报告对 'System.exit()'、'Runtime.exit()' 和 'Runtime.halt()' 的调用。 调用 'System.exit()' 或 'Runtime.exit()' 会调用关闭挂钩并终止当前运行的 Java 虚拟机。 调用 'Runtime.halt()' 会强行终止 JVM，而不会导致启动关闭挂钩。 这些方法中的每一种都应极其谨慎地使用。 对这些方法的调用使得调用代码对于大多数应用程序服务器来说不可移植。 使用该选项可以忽略主方法中的调用。",
                  "markdown": "报告对 `System.exit()`、`Runtime.exit()` 和 `Runtime.halt()` 的调用。\n\n\n调用 `System.exit()` 或 `Runtime.exit()` 会调用关闭挂钩并终止当前运行的 Java 虚拟机。 调用 `Runtime.halt()` 会强行终止 JVM，而不会导致启动关闭挂钩。\n这些方法中的每一种都应极其谨慎地使用。 对这些方法的调用使得调用代码对于大多数应用程序服务器来说不可移植。\n\n\n使用该选项可以忽略主方法中的调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemExit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BigDecimalLegacyMethod",
                "shortDescription": {
                  "text": "调用了 'BigDecimal' 遗留方法"
                },
                "fullDescription": {
                  "text": "报告对使用整数常量指定舍入模式的 'BigDecimal.divide()' 或 'BigDecimal.setScale()' 的调用。 自 JDK 1.5 起，可以考虑使用接受 'RoundingMode' 'enum' 形参的方法。 示例： 'new BigDecimal(\"42\").setScale(2, BigDecimal.ROUND_FLOOR);' 在应用快速修复后： 'new BigDecimal(\"42\").setScale(2, RoundingMode.FLOOR);'",
                  "markdown": "报告对使用整数常量指定舍入模式的 `BigDecimal.divide()` 或 `BigDecimal.setScale()` 的调用。 自 JDK 1.5 起，可以考虑使用接受 `RoundingMode` `enum` 形参的方法。\n\n**示例：**\n\n    new BigDecimal(\"42\").setScale(2, BigDecimal.ROUND_FLOOR);\n\n在应用快速修复后：\n\n    new BigDecimal(\"42\").setScale(2, RoundingMode.FLOOR);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BigDecimalLegacyMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeclareCollectionAsInterface",
                "shortDescription": {
                  "text": "按类 (而不是接口) 声明的集合"
                },
                "fullDescription": {
                  "text": "报告使用集合类作为类型而不是使用相应接口进行的 'Collection' 变量的声明。 如果削弱变量类型会导致编译错误，则不发出警告。 示例： '// 警告：使用了具体集合类 ArrayList。\n  int getTotalLength(ArrayList<String> list) {\n    return list.stream().mapToInt(String::length).sum();\n  }\n\n  // 无警告，因为 trimToSize() 方法\n  // 在 List 接口中不可用\n  void addData(ArrayList<String> data) {\n    data.add(\"Hello\");\n    data.add(\"World\");\n    data.trimToSize();\n  }' 建议通过快速修复使用相应集合接口（例如 'Collection'、'Set' 或 'List'）。",
                  "markdown": "报告使用集合类作为类型而不是使用相应接口进行的 `Collection` 变量的声明。 如果削弱变量类型会导致编译错误，则不发出警告。\n\n示例：\n\n\n      // 警告：使用了具体集合类 ArrayList。\n      int getTotalLength(ArrayList<String> list) {\n        return list.stream().mapToInt(String::length).sum();\n      }\n\n      // 无警告，因为 trimToSize() 方法\n      // 在 List 接口中不可用\n      void addData(ArrayList<String> data) {\n        data.add(\"Hello\");\n        data.add(\"World\");\n        data.trimToSize();\n      }\n\n建议通过快速修复使用相应集合接口（例如 `Collection`、`Set` 或 `List`）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionDeclaredAsConcreteClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialStringConcatenation",
                "shortDescription": {
                  "text": "与空字符串串联"
                },
                "fullDescription": {
                  "text": "报告字符串串联中的空字符串操作数。 与空字符串的串联可以用于将非 'String' 对象或基元转换为 'String'，但使用 'String.valueOf()' 方法调用会更清晰。 建议通过快速修复来简化串联。 示例： 'void foo(int x, int y) {\n    String s = \"\" + x + \" ; \" + y;\n  }' 在应用快速修复后： 'void foo(int x, int y) {\n    String s = x + \" ; \" + y;\n  }' 使用仅报告无需其他更改即可移除空字符串的情况选项可以忽略移除空字符串需要添加另一个操作数的 'String.valueOf()' 转换的情况。",
                  "markdown": "报告字符串串联中的空字符串操作数。 与空字符串的串联可以用于将非 `String` 对象或基元转换为 `String`，但使用 `String.valueOf()` 方法调用会更清晰。\n\n\n建议通过快速修复来简化串联。\n\n**示例：**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\n在应用快速修复后：\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n\n\n使用**仅报告无需其他更改即可移除空字符串的情况** 选项可以忽略移除空字符串需要添加另一个操作数的 `String.valueOf()` 转换的情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConcatenationWithEmptyString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousInvocationHandlerImplementation",
                "shortDescription": {
                  "text": "可疑的 'InvocationHandler' 实现"
                },
                "fullDescription": {
                  "text": "报告不代理 'hashCode()'、'equals()' 和 'toString()' 等标准 'Object' 方法的 'InvocationHandler' 的实现。 未能处理这些方法可能会在代理实例上调用它们时导致意外问题。 示例： 'InvocationHandler myHandler = (proxy, method, params) -> {\n    System.out.println(\"Hello World!\");\n    return null;\n  };\n  Runnable myProxy = (Runnable) Proxy.newProxyInstance(\n    Thread.currentThread().getContextClassLoader(),\n    new Class[] {Runnable.class}, myHandler\n  );' 此代码段的宗旨是仅代理 'Runnable.run()' 方法。 但是，也会代理对 'hashCode()' 等任何 'Object' 方法的调用。 这可能导致 'NullPointerException' 等问题，例如在将 'myProxy' 添加到 'HashSet' 时。 2020.2 最新变化",
                  "markdown": "报告不代理 `hashCode()`、`equals()` 和 `toString()` 等标准 `Object` 方法的 `InvocationHandler` 的实现。\n\n未能处理这些方法可能会在代理实例上调用它们时导致意外问题。\n\n**示例：**\n\n\n      InvocationHandler myHandler = (proxy, method, params) -> {\n        System.out.println(\"Hello World!\");\n        return null;\n      };\n      Runnable myProxy = (Runnable) Proxy.newProxyInstance(\n        Thread.currentThread().getContextClassLoader(),\n        new Class[] {Runnable.class}, myHandler\n      );\n\n\n此代码段的宗旨是仅代理 `Runnable.run()` 方法。\n但是，也会代理对 `hashCode()` 等任何 `Object` 方法的调用。\n这可能导致 `NullPointerException` 等问题，例如在将 `myProxy` 添加到 `HashSet` 时。\n\n2020.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousInvocationHandlerImplementation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingPackageInfo",
                "shortDescription": {
                  "text": "缺少 'package-info.java'"
                },
                "fullDescription": {
                  "text": "报告包含类但不包含 'package-info.java' 或 'package.html' 文件并因此缺少软件包文档的软件包。 该快速修复会创建一个初始的 'package-info.java' 文件。",
                  "markdown": "报告包含类但不包含 `package-info.java` 或 `package.html` 文件并因此缺少软件包文档的软件包。\n\n该快速修复会创建一个初始的 `package-info.java` 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingPackageInfo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryConstructor",
                "shortDescription": {
                  "text": "冗余无实参构造函数"
                },
                "fullDescription": {
                  "text": "报告不必要的构造函数。 如果构造函数是类的唯一构造函数，没有形参，与其包含类具有相同的访问修饰符，并且除了显式或隐式调用不带实参的超类构造函数外，不执行任何初始化，则不需要构造函数。 此类构造函数可以安全地移除，因为即使没有指定，它也会由编译器生成。 示例： 'public class Foo {\n    public Foo() {}\n  }' 在应用快速修复后： 'public class Foo {}' 使用检查设置可以忽略具有注解的不必要的构造函数。",
                  "markdown": "报告不必要的构造函数。\n\n\n如果构造函数是类的唯一构造函数，没有形参，与其包含类具有相同的访问修饰符，并且除了显式或隐式调用不带实参的超类构造函数外，不执行任何初始化，则不需要构造函数。\n此类构造函数可以安全地移除，因为即使没有指定，它也会由编译器生成。\n\n**示例：**\n\n\n      public class Foo {\n        public Foo() {}\n      }\n\n在应用快速修复后：\n\n\n      public class Foo {}\n\n\n使用检查设置可以忽略具有注解的不必要的构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantNoArgConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnreachableCode",
                "shortDescription": {
                  "text": "不可到达的代码"
                },
                "fullDescription": {
                  "text": "报告从未在任何控制流中执行并且可以安全移除的代码段。",
                  "markdown": "报告从未在任何控制流中执行并且可以安全移除的代码段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnreachableCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlTagCanBeJavadocTag",
                "shortDescription": {
                  "text": "'<code>...</code>' 可被替换为 '{@code ...}'"
                },
                "fullDescription": {
                  "text": "报告 '<code>' 标记在 Javadoc 注释中的用法。 从 Java 5 起，这些标记可以替换为 '{@code ...}' 结构。 这允许在注释中使用尖括号 '<' 和 '>' 而不是 HTML 字符实体。 示例： '/**\n   * @return empty <code>ArrayList&lt;Integer&gt;</code>\n   */\n  List<Integer> getList(){ ... }' 在应用快速修复后： '/**\n   * @return empty {@code ArrayList<Integer>}\n   */\n  List<Integer> getList(){ ... }'",
                  "markdown": "报告 `<code>` 标记在 Javadoc 注释中的用法。 从 Java 5 起，这些标记可以替换为 `{@code ...}` 结构。 这允许在注释中使用尖括号 `<` 和 `>` 而不是 HTML 字符实体。\n\n**示例：**\n\n\n      /**\n       * @return empty <code>ArrayList&lt;Integer&gt;</code>\n       */\n      List<Integer> getList(){ ... }\n\n在应用快速修复后：\n\n\n      /**\n       * @return empty {@code ArrayList<Integer>}\n       */\n      List<Integer> getList(){ ... }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlTagCanBeJavadocTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferField",
                "shortDescription": {
                  "text": "'StringBuilder' 字段"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.StringBuffer' 或 'java.lang.StringBuilder' 类型的字段。 此类字段可以无限增长，并且通常会导致内存泄漏。 示例： 'public class Example {\n    private StringBuilder builder = new StringBuilder();\n\n  }'",
                  "markdown": "报告 `java.lang.StringBuffer` 或 `java.lang.StringBuilder` 类型的字段。 此类字段可以无限增长，并且通常会导致内存泄漏。\n\n**示例：**\n\n\n      public class Example {\n        private StringBuilder builder = new StringBuilder();\n\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassEscapesItsScope",
                "shortDescription": {
                  "text": "类暴露在其可见性作用域之外"
                },
                "fullDescription": {
                  "text": "当字段或方法签名中的类的可见性不如使用它的成员的可见性时，报告该类的用法。 虽然此类成员是合法的 Java，但不能在它们引用的类类型的可见性作用域之外使用。 示例： 'public class Parent {\n    public Child getChild() {\n      return new Child();\n    }\n\n    private class Child {}\n  }' 此外，在 Java 9 和更高版本中，模块可以通过不导出它们的软件包来向其他模块隐藏它的某些类。 不过，如果属于导出的 API 的成员在其签名中引用了非导出类，则不能在模块外部使用此类成员。 配置检查： 使用报告在模块 API 中公开的非导出类(Java 9+) 选项可以报告公开非导出类的模块 API 成员。 请注意，对于此选项，项目或模块的语言级别必须为 9 或更高。 使用报告在公开 API 中公开的不可访问类选项可以报告公开可见性作用域较小的类的 public 成员。 使用报告在 package-local API 中公开的 private 类选项可以报告公开 'private' 类的 package-local 成员。",
                  "markdown": "当字段或方法签名中的类的可见性不如使用它的成员的可见性时，报告该类的用法。 虽然此类成员是合法的 Java，但不能在它们引用的类类型的可见性作用域之外使用。\n\n**示例：**\n\n\n      public class Parent {\n        public Child getChild() {\n          return new Child();\n        }\n\n        private class Child {}\n      }\n\n\n此外，在 Java 9 和更高版本中，模块可以通过不导出它们的软件包来向其他模块隐藏它的某些类。\n不过，如果属于导出的 API 的成员在其签名中引用了非导出类，则不能在模块外部使用此类成员。\n\n配置检查：\n\n* 使用**报告在模块 API 中公开的非导出类(Java 9+)** 选项可以报告公开非导出类的模块 API 成员。  \n  请注意，对于此选项，项目或模块的语言级别必须为 9 或更高。\n* 使用**报告在公开 API 中公开的不可访问类**选项可以报告公开可见性作用域较小的类的 public 成员。\n* 使用**报告在 package-local API 中公开的 private 类** 选项可以报告公开 `private` 类的 package-local 成员。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassEscapesDefinedScope",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNameSameAsAncestorName",
                "shortDescription": {
                  "text": "类名与上级名称相同"
                },
                "fullDescription": {
                  "text": "报告与其某个超类的名称相同，而其完全限定名称仍然不同的类。 这种类名可能令人困惑。 示例： 'package util;\n  abstract class Iterable<T> implements java.lang.Iterable<T> {}' 只能在编辑器中采用快速修复来重命名这种类。",
                  "markdown": "报告与其某个超类的名称相同，而其完全限定名称仍然不同的类。 这种类名可能令人困惑。\n\n**示例：**\n\n\n      package util;\n      abstract class Iterable<T> implements java.lang.Iterable<T> {}\n\n只能在编辑器中采用快速修复来重命名这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNameSameAsAncestorName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsUsesNonFinalVariable",
                "shortDescription": {
                  "text": "'equals()' 中引用了非 final 字段"
                },
                "fullDescription": {
                  "text": "报告访问非 'final' 变量的 'equals()' 的实现。 此类访问可能导致 'equals()' 在该对象生命周期的不同时刻返回不同的结果，进而可能在使用标准集合类时导致问题。 示例： 'public class Person {\n    private String lastName;\n\n    @Override\n    public boolean equals(Object obj) {\n      ...\n      Person other = (Person) obj;\n      if (lastName == null) {\n        if (!lastName.equals(other.lastName)) {\n        return false;\n      ...\n      }\n    }\n  }'",
                  "markdown": "报告访问非 `final` 变量的 `equals()` 的实现。 此类访问可能导致 `equals()` 在该对象生命周期的不同时刻返回不同的结果，进而可能在使用标准集合类时导致问题。\n\n**示例：**\n\n\n      public class Person {\n        private String lastName;\n\n        @Override\n        public boolean equals(Object obj) {\n          ...\n          Person other = (Person) obj;\n          if (lastName == null) {\n            if (!lastName.equals(other.lastName)) {\n            return false;\n          ...\n          }\n        }\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldReferenceInEquals",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantMethodOverride",
                "shortDescription": {
                  "text": "方法与其 super 方法相同"
                },
                "fullDescription": {
                  "text": "报告与其 super 方法相同的方法。 此类方法与其 super 方法的签名相同，并且要么方法体相同，要么其主体仅包含对 super 方法的调用。 这些方法冗余，可以移除。 使用下面的第一个复选框，对重写库方法的方法进行检查。 检查库方法可能会减慢检查速度。 使用下面的第二个复选框，忽略只将调用委托给其 super 方法的方法。",
                  "markdown": "报告与其 super 方法相同的方法。 此类方法与其 super 方法的签名相同，并且要么方法体相同，要么其主体仅包含对 super 方法的调用。 这些方法冗余，可以移除。\n\n\n使用下面的第一个复选框，对重写库方法的方法进行检查。\n检查库方法可能会减慢检查速度。\n\n\n使用下面的第二个复选框，忽略只将调用委托给其 super 方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantMethodOverride",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueStatementWithLabel",
                "shortDescription": {
                  "text": "带标签的 'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告包含标签的 'continue' 语句。 'continue' 标签语句导致重构复杂化，可能令人困惑。 示例： 'void handle(List<String> strs) {\n    outer:\n    for (String s: strs) {\n      for (char ch : s.toCharArray()) {\n        if ('s' == ch) continue outer;\n        handleChar(ch);\n      }\n    }\n  }'",
                  "markdown": "报告包含标签的 `continue` 语句。\n\n`continue` 标签语句导致重构复杂化，可能令人困惑。\n\n示例：\n\n\n      void handle(List<String> strs) {\n        outer:\n        for (String s: strs) {\n          for (char ch : s.toCharArray()) {\n            if ('s' == ch) continue outer;\n            handleChar(ch);\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueStatementWithLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedAssignment",
                "shortDescription": {
                  "text": "嵌套赋值"
                },
                "fullDescription": {
                  "text": "报告嵌套在其他表达式中的赋值表达式。 此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。 示例： 'String userName;\n  // 警告：使用了对 'userName' 赋值的结果\n  String message = \"Hello \" + (userName = \"Alice\") + \"!\"\n  System.out.println(message);\n  System.out.println(\"Goodbye \" + userName);'",
                  "markdown": "报告嵌套在其他表达式中的赋值表达式。\n\n此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。\n\n**示例：**\n\n\n      String userName;\n      // 警告：使用了对 'userName' 赋值的结果\n      String message = \"Hello \" + (userName = \"Alice\") + \"!\"\n      System.out.println(message);\n      System.out.println(\"Goodbye \" + userName);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableBooleanExpression",
                "shortDescription": {
                  "text": "可简化的布尔表达式"
                },
                "fullDescription": {
                  "text": "报告可以简化的布尔表达式。 示例： 'void f(boolean foo, boolean bar) {\n    boolean b = !(foo ^ bar);\n  }' 在应用快速修复后： 'void f(boolean foo, boolean bar) {\n    boolean b = foo == bar;\n  }' 示例： 'void f(boolean foo, boolean bar) {\n    boolean b = (foo && bar) || !foo;\n  }' 在应用快速修复后： 'void f(boolean foo, boolean bar) {\n    boolean b = !foo || bar;\n  }'",
                  "markdown": "报告可以简化的布尔表达式。\n\n示例：\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = !(foo ^ bar);\n      }\n\n在应用快速修复后：\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = foo == bar;\n      }\n\n示例：\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = (foo && bar) || !foo;\n      }\n      \n在应用快速修复后：\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = !foo || bar;\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AutoUnboxing",
                "shortDescription": {
                  "text": "自动拆箱"
                },
                "fullDescription": {
                  "text": "报告受拆箱转换（自动将对象解开为基元值）影响的表达式。 尽量不使用对象，而是使用基元。 它可能会显著影响性能。 示例： 'int x = new Integer(42);' 该快速修复会将转换设为显式： 'int x = new Integer(42).intValue();' 自动拆箱在 Java 5 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告受拆箱转换（自动将对象解开为基元值）影响的表达式。 尽量不使用对象，而是使用基元。 它可能会显著影响性能。\n\n**示例：**\n\n    int x = new Integer(42);\n\n该快速修复会将转换设为显式：\n\n    int x = new Integer(42).intValue();\n\n\n*自动拆箱*在 Java 5 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AutoUnboxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInMessageFormatCall",
                "shortDescription": {
                  "text": "字符串串联作为 'MessageFormat.format()' 调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作对 'MessageFormat.format()' 的调用实参的非常量字符串串联。 虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中包含 '{' 等特殊字符时，甚至可能导致异常。 此外，有时这可能是在本应键入 ',' 时键入了 '+' 而错误串联字符串格式实参所致。 示例： 'String formatGreeting(String userName, int balance) {\n    return MessageFormat.format(\"Hello, \" + userName + \"! Your balance is {0}.\", balance);\n  }' 这里的 'userName' 解读为格式字符串的一部分，这可能导致 'IllegalArgumentException'（例如，如果 'userName' 为 '\"{\"'）。 此调用或许应当替换为 'MessageFormat.format(\"Hello, {0}! Your balance is {1}.\", userName, balance)'。",
                  "markdown": "报告用作对 `MessageFormat.format()` 的调用实参的非常量字符串串联。\n\n\n虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中包含 `{` 等特殊字符时，甚至可能导致异常。\n\n\n此外，有时这可能是在本应键入 `,` 时键入了 `+` 而错误串联字符串格式实参所致。\n\n**示例：**\n\n\n      String formatGreeting(String userName, int balance) {\n        return MessageFormat.format(\"Hello, \" + userName + \"! Your balance is {0}.\", balance);\n      }\n\n\n这里的 `userName` 解读为格式字符串的一部分，这可能导致 `IllegalArgumentException`（例如，如果 `userName` 为 `\"{\"`）。\n此调用或许应当替换为 `MessageFormat.format(\"Hello, {0}! Your balance is {1}.\", userName, balance)`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInMessageFormatCall",
                    "cweIds": [
                      116,
                      134
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalFieldInImmutable",
                "shortDescription": {
                  "text": "'@Immutable' 类中有非 final 字段"
                },
                "fullDescription": {
                  "text": "报告包含 '@Immutable' 注解的类中的任何非 final 字段。 这违反了 '@Immutable' 注解的约定。 示例： 'import javax.annotation.concurrent.Immutable;\n  @Immutable\n  class Foo {\n    String bar = \"foo\";\n  }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告包含 `@Immutable` 注解的类中的任何非 final 字段。 这违反了 `@Immutable` 注解的约定。\n\n示例：\n\n\n      import javax.annotation.concurrent.Immutable;\n      @Immutable\n      class Foo {\n        String bar = \"foo\";\n      }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldInImmutable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToStringConcatCanBeReplacedByOperator",
                "shortDescription": {
                  "text": "对 'String.concat()' 的调用可被替换为 '+'"
                },
                "fullDescription": {
                  "text": "报告对 'java.lang.String.concat()' 的调用。 如果在带有常量实参的常量上调用该方法，可以将此类调用替换为 '+' 运算符，以提高清晰度和性能。 示例： 'String foo(String name) {\n    return name.concat(\"foo\");\n  }' 在应用快速修复后： 'String foo(String name) {\n    return name + \"foo\";\n  }'",
                  "markdown": "报告对 `java.lang.String.concat()` 的调用。\n\n\n如果在带有常量实参的常量上调用该方法，可以将此类调用替换为 `+` 运算符，以提高清晰度和性能。\n\n**示例：**\n\n\n      String foo(String name) {\n        return name.concat(\"foo\");\n      }\n\n在应用快速修复后：\n\n\n      String foo(String name) {\n        return name + \"foo\";\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToStringConcatCanBeReplacedByOperator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SignalWithoutCorrespondingAwait",
                "shortDescription": {
                  "text": "没有相应 'await()' 的 'signal()'"
                },
                "fullDescription": {
                  "text": "报告对无法为之找到相应 'Condition.await()' 调用的 'Condition.signal()' 或 'Condition.signalAll()' 的调用。 此检查仅报告以当前类的目标字段为目标的调用。 示例： 'class Queue {\n    private final Condition isEmpty = ...;\n\n    void add(Object elem) {\n      // ...\n      isEmpty.signal(); // 警告：在没有相应 'await()' 的情况下调用 'signal()'\n      // ...\n    }\n\n    void remove(Object elem) throws InterruptedException {\n      // ...\n      //      isEmpty.await();\n      // ...\n    }\n  }'",
                  "markdown": "报告对无法为之找到相应 `Condition.await()` 调用的 `Condition.signal()` 或 `Condition.signalAll()` 的调用。\n\n此检查仅报告以当前类的目标字段为目标的调用。\n\n**示例：**\n\n\n      class Queue {\n        private final Condition isEmpty = ...;\n\n        void add(Object elem) {\n          // ...\n          isEmpty.signal(); // 警告：在没有相应 'await()' 的情况下调用 'signal()'\n          // ...\n        }\n\n        void remove(Object elem) throws InterruptedException {\n          // ...\n          //      isEmpty.await();\n          // ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SignalWithoutCorrespondingAwait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FoldExpressionIntoStream",
                "shortDescription": {
                  "text": "表达式可以折叠到流链中"
                },
                "fullDescription": {
                  "text": "报告所具有的重复模式可以替换为 Stream API 或 'String.join()' 调用的表达式。 示例： 'boolean allStartWith(String a, String b, String c, String d, String prefix) {\n    return a.startsWith(prefix) && b.startsWith(prefix) && c.startsWith(prefix) && d.startsWith(prefix);\n  }' 在应用快速修复后： 'boolean foo(String a, String b, String c, String d, String prefix) {\n    return Stream.of(a, b, c, d).allMatch(s -> s.startsWith(prefix));\n  }' 示例： 'String joinAll(String a, String b, String c, String d) {\n    return a + \",\" + b + \",\" + c + \",\" + d;\n  }' 在应用快速修复后： 'String joinAll(String a, String b, String c, String d) {\n    return String.join(\",\", a, b, c, d);\n  }' 2018.2 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告所具有的重复模式可以替换为 *Stream API* 或 `String.join()` 调用的表达式。\n\n示例：\n\n\n      boolean allStartWith(String a, String b, String c, String d, String prefix) {\n        return a.startsWith(prefix) && b.startsWith(prefix) && c.startsWith(prefix) && d.startsWith(prefix);\n      }\n\n在应用快速修复后：\n\n\n      boolean foo(String a, String b, String c, String d, String prefix) {\n        return Stream.of(a, b, c, d).allMatch(s -> s.startsWith(prefix));\n      }\n\n示例：\n\n\n      String joinAll(String a, String b, String c, String d) {\n        return a + \",\" + b + \",\" + c + \",\" + d;\n      }\n\n在应用快速修复后：\n\n\n      String joinAll(String a, String b, String c, String d) {\n        return String.join(\",\", a, b, c, d);\n      }\n\n2018.2 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FoldExpressionIntoStream",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HardcodedFileSeparators",
                "shortDescription": {
                  "text": "硬编码文件分隔符"
                },
                "fullDescription": {
                  "text": "报告字符串或字符文字中的正斜杠 ('/') 或反斜杠 ('\\')。 这些字符通常用作文件分隔符，如果它们被硬编码，则可移植性可能会受到影响。 该检查不会报告转义序列内的反斜杠和紧跟在 '<' 字符之后或紧接在 '>' 字符之前的正斜杠，因为它们通常表示 XML 或 HTML 标记而不是文件名。 表示 'java.util.TimeZone' ID 的字符串、作为有效正则表达式的字符串或与 IANA 注册的 MIME 媒体类型等效的字符串也不会被报告。 示例： 'new File(\"C:\\\\Users\\\\Name\");' 使用该选项可将 'example/*' 包含在已识别的媒体类型集中。 通常，在示例之外（例如在 'Content-Type' 标头中）使用 'example/*' MIME 媒体类型是错误的。",
                  "markdown": "报告字符串或字符文字中的正斜杠 (`/`) 或反斜杠 (`\\`)。 这些字符通常用作文件分隔符，如果它们被硬编码，则可移植性可能会受到影响。\n\n\n该检查不会报告转义序列内的反斜杠和紧跟在 '\\<' 字符之后或紧接在 '\\>' 字符之前的正斜杠，因为它们通常表示 XML 或 HTML 标记而不是文件名。\n表示 `java.util.TimeZone` ID 的字符串、作为有效正则表达式的字符串或与 IANA 注册的 MIME 媒体类型等效的字符串也不会被报告。\n\n**示例：**\n\n\n      new File(\"C:\\\\Users\\\\Name\");\n\n\n使用该选项可将 `example/*` 包含在已识别的媒体类型集中。\n通常，在示例之外（例如在 `Content-Type` 标头中）使用 `example/*` MIME 媒体类型是错误的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HardcodedFileSeparator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableDeserializableClassInSecureContext",
                "shortDescription": {
                  "text": "安全上下文中的可序列化类"
                },
                "fullDescription": {
                  "text": "报告可以被序列化或反序列化的类。 如果一个类支持 'Serializable' 接口，并且它的 'readObject()' 和 'writeObject()' 方法未被定义为总是抛出异常，那么就可以被序列化。 在供安全使用的代码中，可序列化的类可能比较危险。 示例： 'class DeserializableClass implements Serializable { // 该类不包含抛出异常的 'writeObject()' 方法\n    private int sensitive = 736326;\n\n    private void readObject(ObjectInputStream in) {\n        throw new Error();\n    }\n}' 在应用快速修复后： 'class DeserializableClass implements Serializable {\n    private int sensitive = 736326;\n\n    private void readObject(ObjectInputStream in) {\n        throw new Error();\n    }\n\n    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n        throw new java.io.NotSerializableException(\"DeserializableClass\");\n    }\n  }' 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 请注意，与其忽略这些类，添加始终抛出异常的 'readObject()' 和 'writeObject()' 方法可能更安全。 是否忽略可序列化的匿名类。",
                  "markdown": "报告可以被序列化或反序列化的类。\n\n\n如果一个类支持 `Serializable` 接口，并且它的 `readObject()` 和 `writeObject()` 方法未被定义为总是抛出异常，那么就可以被序列化。 在供安全使用的代码中，可序列化的类可能比较危险。\n\n**示例：**\n\n\n      class DeserializableClass implements Serializable { // 该类不包含抛出异常的 'writeObject()' 方法\n        private int sensitive = 736326;\n\n        private void readObject(ObjectInputStream in) {\n            throw new Error();\n        }\n    }\n\n在应用快速修复后：\n\n\n      class DeserializableClass implements Serializable {\n        private int sensitive = 736326;\n\n        private void readObject(ObjectInputStream in) {\n            throw new Error();\n        }\n\n        private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n            throw new java.io.NotSerializableException(\"DeserializableClass\");\n        }\n      }\n\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。 请注意，与其忽略这些类，添加始终抛出异常的 `readObject()` 和 `writeObject()` 方法可能更安全。\n* 是否忽略可序列化的匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableDeserializableClassInSecureContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingFloatingPointLiteral",
                "shortDescription": {
                  "text": "引起混淆的浮点文字"
                },
                "fullDescription": {
                  "text": "报告任何没有小数点的浮点数、小数点前的数字或小数点后的数字。 此类文字可能令人困惑，并且违反多种编码标准。 示例： 'double d = .03;' 在应用快速修复后： 'double d = 0.03;' 使用忽略科学记数法中的浮点文字选项可以忽略科学记数法中的浮点数。",
                  "markdown": "报告任何没有小数点的浮点数、小数点前的数字或小数点后的数字。\n\n此类文字可能令人困惑，并且违反多种编码标准。\n\n**示例：**\n\n    double d = .03;\n\n在应用快速修复后：\n\n    double d = 0.03;\n\n\n使用**忽略科学记数法中的浮点文字**选项可以忽略科学记数法中的浮点数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingFloatingPointLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaModuleNaming",
                "shortDescription": {
                  "text": "Java 模块名称与约定相矛盾"
                },
                "fullDescription": {
                  "text": "报告模块名称与 Java Platform Module System 建议相矛盾的情况。 其中一种建议是避免在模块名称末尾使用数字。 示例： 'module foo1.bar2 {}'",
                  "markdown": "报告模块名称与 Java Platform Module System 建议相矛盾的情况。\n\n其中一种[建议](http://mail.openjdk.org/pipermail/jpms-spec-experts/2017-March/000659.html)是避免在模块名称末尾使用数字。\n\n**示例：**\n\n\n    module foo1.bar2 {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaModuleNaming",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocReference",
                "shortDescription": {
                  "text": "声明在Javadoc引用中有问题"
                },
                "fullDescription": {
                  "text": "报告 Javadoc 注释中未解析的引用。 在以下示例中，由于缺少 'someParam' 形参，将高亮显示该形参： 'class A {\n    /**\n     * @param someParam description\n     **/\n    void foo() {\n    }\n}' 禁用报告无法访问的符号选项，可忽略引用缺少的方法形参、类、字段和方法的标记。",
                  "markdown": "报告 Javadoc 注释中未解析的引用。\n\n在以下示例中，由于缺少 `someParam` 形参，将高亮显示该形参：\n\n\n    class A {\n        /**\n         * @param someParam description\n         **/\n        void foo() {\n        }\n    }\n\n\n禁用**报告无法访问的符号**选项，可忽略引用缺少的方法形参、类、字段和方法的标记。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnaryPlus",
                "shortDescription": {
                  "text": "一元正号"
                },
                "fullDescription": {
                  "text": "报告使用 '+' 一元运算符的情况。 一元加号通常为 null 运算，它的存在可能代表编码错误。 例如，与递增运算符（如 '+++' 中）或相等运算符（如 '=+' 中）结合使用。 示例： 'void unaryPlus(int i) {\n    int x = + +i;\n  }' 建议使用以下快速修复： 移除 'i' 变量前的 '+' 运算符： 'void unaryPlus(int i) {\n    int x = i;\n  }' 使用前缀递增运算符替换 '+' 运算符： 'void unaryPlus(int i) {\n    int x = ++i;\n  }' 使用下面的复选框可以报告与二进制或另一个一元表达式一起使用的一元加号。 这意味着检查将不会报告将一元加号表达式用于数组初始值设定项表达式或用作方法实参的情况。",
                  "markdown": "报告使用 `+` 一元运算符的情况。 一元加号通常为 null 运算，它的存在可能代表编码错误。 例如，与递增运算符（如 `+++` 中）或相等运算符（如 `=+` 中）结合使用。\n\n**示例：**\n\n\n      void unaryPlus(int i) {\n        int x = + +i;\n      }\n\n建议使用以下快速修复：\n\n* 移除 `i` 变量前的 `+` 运算符：\n\n\n        void unaryPlus(int i) {\n          int x = i;\n        }\n\n* 使用前缀递增运算符替换 `+` 运算符：\n\n\n        void unaryPlus(int i) {\n          int x = ++i;\n        }\n\n\n使用下面的复选框可以报告与二进制或另一个一元表达式一起使用的一元加号。\n这意味着检查将不会报告将一元加号表达式用于数组初始值设定项表达式或用作方法实参的情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnaryPlus",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstructorCount",
                "shortDescription": {
                  "text": "构造函数过多的类"
                },
                "fullDescription": {
                  "text": "报告构造函数数量超过指定最大值的类。 具有太多构造函数的类容易出现初始化错误，通常建议将这种类建模为多个子类。 配置检查： 使用构造函数计数限制字段可指定类中允许的构造函数的最大数量。 使用忽略弃用的构造函数选项可避免将已弃用的构造函数添加到总计数中。",
                  "markdown": "报告构造函数数量超过指定最大值的类。\n\n具有太多构造函数的类容易出现初始化错误，通常建议将这种类建模为多个子类。\n\n配置检查：\n\n* 使用**构造函数计数限制**字段可指定类中允许的构造函数的最大数量。\n* 使用**忽略弃用的构造函数**选项可避免将已弃用的构造函数添加到总计数中。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncrementDecrementUsedAsExpression",
                "shortDescription": {
                  "text": "使用 '++' 或 '--' 的结果"
                },
                "fullDescription": {
                  "text": "报告嵌套在其他表达式中的增量或减量表达式。 此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。 该快速修复会将递增或递减运算提取到单独的表达式语句中。 示例： 'int i = 10;\n  while (i-- > 0) {\n    System.out.println(i);\n  }' 在应用快速修复后： 'int i = 10;\n  while (i > 0) {\n    i--;\n    System.out.println(i);\n  }\n  i--;'",
                  "markdown": "报告嵌套在其他表达式中的增量或减量表达式。 此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。\n\n该快速修复会将递增或递减运算提取到单独的表达式语句中。\n\n**示例：**\n\n\n      int i = 10;\n      while (i-- > 0) {\n        System.out.println(i);\n      }\n\n在应用快速修复后：\n\n\n      int i = 10;\n      while (i > 0) {\n        i--;\n        System.out.println(i);\n      }\n      i--;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ValueOfIncrementOrDecrementUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DisjointPackage",
                "shortDescription": {
                  "text": "具有不相交依赖关系图的软件包"
                },
                "fullDescription": {
                  "text": "报告类可以分成相互独立的子集的软件包。 此类非连续软件包表示临时打包或缺乏概念上的连通性。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告类可以分成相互独立的子集的软件包。\n\n此类非连续软件包表示临时打包或缺乏概念上的连通性。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DisjointPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOverloadsParentMethod",
                "shortDescription": {
                  "text": "可能是超类方法意外重载"
                },
                "fullDescription": {
                  "text": "报告形参名称和数量与超类中的方法相同，但其中至少一个形参为不同的不兼容类型的实例方法。 在本例中，子类中的方法将重载而不是重写超类中的方法。 如果不是有意为之，可能会导致潜在错误。 示例： 'public class Foo {\n    void foo(int x) {}\n  }\n\n  public class Bar extends Foo {\n    void foo(Number x) {} // 在重写可能是有意为之的情况下，\n                          // 方法 'foo()' 重载超类的兼容方法\n  }' 使用此选项可选择该检查是否也应报告形参类型不兼容的情况。",
                  "markdown": "报告形参名称和数量与超类中的方法相同，但其中至少一个形参为不同的不兼容类型的实例方法。\n\n\n在本例中，子类中的方法将重载而不是重写超类中的方法。 如果不是有意为之，可能会导致潜在错误。\n\n**示例：**\n\n\n      public class Foo {\n        void foo(int x) {}\n      }\n\n      public class Bar extends Foo {\n        void foo(Number x) {} // 在重写可能是有意为之的情况下，\n                              // 方法 'foo()' 重载超类的兼容方法\n      }\n\n\n使用此选项可选择该检查是否也应报告形参类型不兼容的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOverloadsMethodOfSuperclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UpperCaseFieldNameNotConstant",
                "shortDescription": {
                  "text": "具有大写名称的非常量字段"
                },
                "fullDescription": {
                  "text": "报告名称全部为大写的非 'static' 非 'final' 字段。 此类字段可能会因违反通用命名约定而引起混淆，并且经常被错误使用。 示例： 'public static int THE_ANSWER = 42; // 此处警告：final 修饰符缺失' 只能在编辑器中使用重命名此类字段的快速修复。",
                  "markdown": "报告名称全部为大写的非 `static` 非 `final` 字段。\n\n此类字段可能会因违反通用命名约定而引起混淆，并且经常被错误使用。\n\n**示例：**\n\n\n      public static int THE_ANSWER = 42; // 此处警告：final 修饰符缺失\n\n只能在编辑器中使用重命名此类字段的快速修复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonConstantFieldWithUpperCaseName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodMayBeSynchronized",
                "shortDescription": {
                  "text": "只有一个 'synchronized' 块的方法可被替换为 'synchronized' 方法"
                },
                "fullDescription": {
                  "text": "报告其主体只包含一条 'synchronized' 语句的方法。 对于实例方法，此 'synchronized' 语句的锁定表达式必须等于 'this'；对于 static 方法，必须等于 '[ClassName].class'。 为改善此类方法的可读性，可以移除 'synchronized' 包装器，并将方法标记为 'synchronized'。 示例： 'public int generateInt(int x) {\n    synchronized (this) {\n      return 1;\n    }\n  }' 在应用快速修复后： 'public synchronized int generateInt(int x) {\n    return 1;\n  }'",
                  "markdown": "报告其主体只包含一条 `synchronized` 语句的方法。 对于实例方法，此 `synchronized` 语句的锁定表达式必须等于 `this`；对于 static 方法，必须等于 `[ClassName].class`。\n\n\n为改善此类方法的可读性，可以移除 `synchronized` 包装器，并将方法标记为 `synchronized`。\n\n**示例：**\n\n\n      public int generateInt(int x) {\n        synchronized (this) {\n          return 1;\n        }\n      }\n\n在应用快速修复后：\n\n\n      public synchronized int generateInt(int x) {\n        return 1;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodMayBeSynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingPlaceholderCountMatchesArgumentCount",
                "shortDescription": {
                  "text": "占位符数量与日志记录调用中的实参数量不匹配"
                },
                "fullDescription": {
                  "text": "报告 SLF4J、Log4j2 和 akka.event.LoggingAdapter 日志记录调用，例如 'logger.info(\"{}: {}\", key)'，其中记录器消息中 '{}' 占位符的数量与日志调用的其他实参的数量不匹配。 使用检查选项可以指定 SLF4J 使用哪个实现。 如果选择自动检查，则在类路径中搜索 'org.apache.logging.slf4j.Log4jLogger'。 如果找到此文件或选择是，将不为 SLFJ4 API 报告带有异常类型的最后一个形参具有占位符的情况。 例如： '//如果选中“是”选项，则不会报告此情况\nlog.error(\"For id {}: {}\", \"1\", new RuntimeException());' 在这种情况下，将使用 'toString()' 打印 'new RuntimeException()'（不会打印其堆栈跟踪）： 'For id 1: java.lang.RuntimeException' 否则，它将高亮显示，因为未使用最后一个占位符： 'For id 1: {}\njava.lang.RuntimeException: null' 否选项可用于在占位符用于异常时始终高亮显示此类情况，即使 'org.apache.logging.slf4j.Log4jLogger' 用作后端也是如此。 此选项仅适用于SLF4J。",
                  "markdown": "报告 SLF4J、Log4j2 和 akka.event.LoggingAdapter 日志记录调用，例如 `logger.info(\"{}: {}\", key)`，其中记录器消息中 `{}` 占位符的数量与日志调用的其他实参的数量不匹配。\n\n\n使用检查选项可以指定 SLF4J 使用哪个实现。\n如果选择**自动检查** ，则在类路径中搜索 `org.apache.logging.slf4j.Log4jLogger`。\n如果找到此文件或选择**是** ，将不为 SLFJ4 API 报告带有异常类型的最后一个形参具有占位符的情况。  \n\n例如：\n\n\n    //如果选中\"是\"选项，则不会报告此情况\n    log.error(\"For id {}: {}\", \"1\", new RuntimeException());\n\n在这种情况下，将使用 'toString()' 打印 'new RuntimeException()'（不会打印其堆栈跟踪）：\n\n\n    For id 1: java.lang.RuntimeException\n\n否则，它将高亮显示，因为未使用最后一个占位符：\n\n\n    For id 1: {}\n    java.lang.RuntimeException: null\n\n**否** 选项可用于在占位符用于异常时始终高亮显示此类情况，即使 `org.apache.logging.slf4j.Log4jLogger` 用作后端也是如此。  \n此选项仅适用于SLF4J。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggingPlaceholderCountMatchesArgumentCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2streamapi",
                "shortDescription": {
                  "text": "可以通过 Stream API 收起循环"
                },
                "fullDescription": {
                  "text": "报告使用 lambda 表达式替换为流 API 调用的循环。 此类替换将命令式样式更改为功能式样式，代码也变得更加紧凑。 示例： 'boolean check(List<String> data) {\n    for (String e : data) {\n      String trimmed = e.trim();\n      if (!trimmed.startsWith(\"xyz\")) {\n        return false;\n      }\n    }\n    return true;\n  }' 在应用快速修复后： 'boolean check(List<String> data) {\n    return data.stream().map(String::trim).allMatch(trimmed -> trimmed.startsWith(\"xyz\"));\n  }' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告使用 lambda 表达式替换为流 API 调用的循环。\n\n此类替换将命令式样式更改为功能式样式，代码也变得更加紧凑。\n\n示例：\n\n\n      boolean check(List<String> data) {\n        for (String e : data) {\n          String trimmed = e.trim();\n          if (!trimmed.startsWith(\"xyz\")) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n在应用快速修复后：\n\n\n      boolean check(List<String> data) {\n        return data.stream().map(String::trim).allMatch(trimmed -> trimmed.startsWith(\"xyz\"));\n      }\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Convert2streamapi",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerialPersistentFieldsWithWrongSignature",
                "shortDescription": {
                  "text": "'serialPersistentFields' 字段未被声明为 'private static final ObjectStreamField[]'"
                },
                "fullDescription": {
                  "text": "报告 'serialPersistentFields' 字段未被声明为 'private static final ObjectStreamField[]' 的 'Serializable' 类。 如果 'serialPersistentFields' 字段未使用这些修饰符进行声明，序列化行为将与根本未声明该字段如出一辙。 示例： 'class List implements Serializable {\n    private List next;\n\n    ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"next\", List.class)};\n\n  }'",
                  "markdown": "报告 `serialPersistentFields` 字段未被声明为 `private static final ObjectStreamField[]` 的 `Serializable` 类。\n\n\n如果 `serialPersistentFields` 字段未使用这些修饰符进行声明，序列化行为将与根本未声明该字段如出一辙。\n\n**示例：**\n\n\n      class List implements Serializable {\n        private List next;\n\n        ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"next\", List.class)};\n\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerialPersistentFieldsWithWrongSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorResultComparison",
                "shortDescription": {
                  "text": "compare 方法的可疑用法"
                },
                "fullDescription": {
                  "text": "报告 'Comparator.compare()' 或 'Comparable.compareTo()' 调用结果与非零常量的比较。 根据约定，这些方法可以返回任何整数（不只是 -1、0 或 1），因此与特定数字比较是一种不好的做法。 某些广泛使用的比较方法（例如 'String.compareTo()'）实际上返回 [-1..1] 范围之外的值，此类比较可能会导致不正确的程序行为。 示例： 'void validate(String s1, String s2) {\n    // 与 1 比较不正确\n    if (s1.compareTo(s2) == 1) {\n      throw new IllegalArgumentException(\"Incorrect order\");\n    }\n  }' 在应用快速修复后： 'void validate(String s1, String s2) {\n    if (s1.compareTo(s2) > 0) {\n      throw new IllegalArgumentException(\"Incorrect order\");\n    }\n  }' 2017.2 最新变化",
                  "markdown": "报告 `Comparator.compare()` 或 `Comparable.compareTo()` 调用结果与非零常量的比较。 根据约定，这些方法可以返回任何整数（不只是 -1、0 或 1），因此与特定数字比较是一种不好的做法。 某些广泛使用的比较方法（例如 `String.compareTo()`）实际上返回 \\[-1..1\\] 范围之外的值，此类比较可能会导致不正确的程序行为。\n\n示例：\n\n\n      void validate(String s1, String s2) {\n        // 与 1 比较不正确\n        if (s1.compareTo(s2) == 1) {\n          throw new IllegalArgumentException(\"Incorrect order\");\n        }\n      }\n\n在应用快速修复后：\n\n\n      void validate(String s1, String s2) {\n        if (s1.compareTo(s2) > 0) {\n          throw new IllegalArgumentException(\"Incorrect order\");\n        }\n      }\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorResultComparison",
                    "cweIds": [
                      253
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ListIndexOfReplaceableByContains",
                "shortDescription": {
                  "text": "'List.indexOf()' 表达式可被替换为 'contains()'"
                },
                "fullDescription": {
                  "text": "报告可以用 'List.contains()' 方法替换的任何 'List.indexOf()' 表达式。 示例： 'boolean hasEmptyString(List<String> list) {\n    // 警告：可以简化\n    return list.indexOf(\"\") >= 0;\n  }' 提供的快速修复将 'indexOf' 调用替换为 'contains' 调用： 'boolean hasEmptyString(List<String> list) {\n    // 快速修复已应用\n    return list.contains(\"\");\n  }'",
                  "markdown": "报告可以用 `List.contains()` 方法替换的任何 `List.indexOf()` 表达式。\n\n示例：\n\n\n      boolean hasEmptyString(List<String> list) {\n        // 警告：可以简化\n        return list.indexOf(\"\") >= 0;\n      }\n\n提供的快速修复将 `indexOf` 调用替换为 `contains` 调用：\n\n\n      boolean hasEmptyString(List<String> list) {\n        // 快速修复已应用\n        return list.contains(\"\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ListIndexOfReplaceableByContains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonStrictComparisonCanBeEquality",
                "shortDescription": {
                  "text": "非严格不等式 '>=' 或 '<=' 可被替换为 '=='"
                },
                "fullDescription": {
                  "text": "报告根据数据流分析只能对单个操作数值满足的不等条件。 此类条件可被替换为相等条件，以使代码更清晰。 示例： 'if (x >= 10) {\n    ...\n    if (x <= 10) { // can be replaced with 'x == 10'\n    }\n  }' 2022.2 最新变化",
                  "markdown": "报告根据数据流分析只能对单个操作数值满足的不等条件。 此类条件可被替换为相等条件，以使代码更清晰。\n\n示例：\n\n\n      if (x >= 10) {\n        ...\n        if (x <= 10) { // can be replaced with 'x == 10'\n        }\n      }\n\n2022.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NonStrictComparisonCanBeEquality",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryParentheses",
                "shortDescription": {
                  "text": "不必要的圆括号"
                },
                "fullDescription": {
                  "text": "报告任何不必要的圆括号。 如果移除圆括号后表达式的评估顺序保持不变，则不需要圆括号。 示例： 'int n = 3 + (9 * 8);' 在应用快速修复后： 'int n = 3 + 9 * 8;' 配置检查： 使用忽略澄清圆括号选项可忽略有助于明确二元表达式的圆括号。 圆括号澄清被括起来的表达式是一个 'instanceof' 更大表达式一部分的表达式或包含与父表达式不同运算符。 使用忽略条件表达式条件周围的圆括号选项以忽略条件表达式条件周围的任何圆括号。 一些编码标准规定所有这些条件都必须用圆括号括起来。 使用忽略单个非正式类型 lambda 形参周围的圆括号选项可忽略 lambda 表达式中单个 lambda 形参周围的圆括号。",
                  "markdown": "报告任何不必要的圆括号。\n\n如果移除圆括号后表达式的评估顺序保持不变，则不需要圆括号。\n\n示例：\n\n\n      int n = 3 + (9 * 8);\n\n在应用快速修复后：\n\n\n      int n = 3 + 9 * 8;\n\n配置检查：\n\n* 使用**忽略澄清圆括号** 选项可忽略有助于明确二元表达式的圆括号。 圆括号澄清被括起来的表达式是一个 `instanceof` 更大表达式一部分的表达式或包含与父表达式不同运算符。\n* 使用**忽略条件表达式条件周围的圆括号**选项以忽略条件表达式条件周围的任何圆括号。 一些编码标准规定所有这些条件都必须用圆括号括起来。\n* 使用**忽略单个非正式类型 lambda 形参周围的圆括号**选项可忽略 lambda 表达式中单个 lambda 形参周围的圆括号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryParentheses",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitArrayToString",
                "shortDescription": {
                  "text": "调用数组上的 'toString()'"
                },
                "fullDescription": {
                  "text": "报告 'String' 连接中使用的数组，或作为形参传递给 'java.io.PrintStream' 方法的数组，如 'System.out.println()'。 通常使用数组的内容，而不是使用数组对象本身。 示例： 'void print(Object[] objects) {\n    System.out.println(objects);\n  }' 在应用快速修复后： 'void print(Object[] objects) {\n    System.out.println(Arrays.toString(objects));\n  }'",
                  "markdown": "报告 `String` 连接中使用的数组，或作为形参传递给 `java.io.PrintStream` 方法的数组，如 `System.out.println()`。\n\n\n通常使用数组的内容，而不是使用数组对象本身。\n\n**示例：**\n\n\n      void print(Object[] objects) {\n        System.out.println(objects);\n      }\n\n在应用快速修复后：\n\n\n      void print(Object[] objects) {\n        System.out.println(Arrays.toString(objects));\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitArrayToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReuseOfLocalVariable",
                "shortDescription": {
                  "text": "局部变量的重用"
                },
                "fullDescription": {
                  "text": "报告使用与其原始用途无关的新值覆盖其值而进行“重用”的局部变量。 此类局部变量重用可能令人困惑，因为局部变量的预期语义可能随每种用法而异。 如果由于代码更改，视为被覆盖的值实际看似处于活动状态，它也可能容易出现错误。 保持变量生命周期尽可能短不失为一种好做法，不要为了简洁而重用局部变量。 示例： 'void x() {\n        String s = \"one\";\n        System.out.println(\"s = \" + s);\n        s = \"two\"; //重用局部变量 's'\n        System.out.println(\"s = \" + s);\n    }'",
                  "markdown": "报告使用与其原始用途无关的新值覆盖其值而进行\"重用\"的局部变量。\n\n此类局部变量重用可能令人困惑，因为局部变量的预期语义可能随每种用法而异。 如果由于代码更改，视为被覆盖的值实际看似处于活动状态，它也可能容易出现错误。 保持变量生命周期尽可能短不失为一种好做法，不要为了简洁而重用局部变量。\n\n示例：\n\n\n        void x() {\n            String s = \"one\";\n            System.out.println(\"s = \" + s);\n            s = \"two\"; //重用局部变量 's'\n            System.out.println(\"s = \" + s);\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReuseOfLocalVariable",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanMethodNameMustStartWithQuestion",
                "shortDescription": {
                  "text": "布尔方法名称必须以疑问词开头"
                },
                "fullDescription": {
                  "text": "报告名称不以疑问词开头的布尔方法。 此检查将忽略重写库方法的布尔方法。 示例： 'boolean empty(List<String> list) {\n  return list.isEmpty();\n}' 只能在编辑器中使用重命名此类方法的快速修复。 配置检查： 使用布尔方法名称前缀列表可指定布尔方法名称开头可以接受的疑问词。 使用忽略具有 'java.lang.Boolean' 返回类型的方法选项，可忽略返回类型为 'java.lang.Boolean' 的方法。 使用忽略 @&interface 中的布尔方法选项，可忽略注解返回类型 ('@interface') 的布尔方法。 使用忽略重写/实现 super 方法的方法选项，可忽略具有 super 方法的方法。",
                  "markdown": "报告名称不以疑问词开头的布尔方法。\n\n此检查将忽略重写库方法的布尔方法。\n\n**示例：**\n\n    boolean empty(List<String> list) {\n      return list.isEmpty();\n    }\n\n只能在编辑器中使用重命名此类方法的快速修复。\n\n配置检查：\n\n* 使用**布尔方法名称前缀**列表可指定布尔方法名称开头可以接受的疑问词。\n* 使用**忽略具有 'java.lang.Boolean' 返回类型的方法** 选项，可忽略返回类型为 `java.lang.Boolean` 的方法。\n* 使用**忽略 @\\&interface 中的布尔方法** 选项，可忽略注解返回类型 (`@interface`) 的布尔方法。\n* 使用**忽略重写/实现 super 方法的方法**选项，可忽略具有 super 方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanMethodNameMustStartWithQuestion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousToArrayCall",
                "shortDescription": {
                  "text": "可疑的 'Collection.toArray()' 调用"
                },
                "fullDescription": {
                  "text": "报告对 'Collection.toArray()' 的可疑调用。 以下类型的调用视为可疑： 数组实参的类型与结果被转换成的数组类型不相同。 数组实参的类型与集合声明中的类型形参不匹配。 示例： 'void m1(List list) {\n  Number[] ns = (Number[]) list.toArray(new String[0]);\n}\n\nvoid m2(List<Number> list) {\n  Number[] ns = list.toArray(new String[0]);\n}'",
                  "markdown": "报告对 `Collection.toArray()` 的可疑调用。\n\n以下类型的调用视为可疑：\n\n* 数组实参的类型与结果被转换成的数组类型不相同。\n* 数组实参的类型与集合声明中的类型形参不匹配。\n\n**示例：**\n\n\n    void m1(List list) {\n      Number[] ns = (Number[]) list.toArray(new String[0]);\n    }\n\n    void m2(List<Number> list) {\n      Number[] ns = list.toArray(new String[0]);\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousToArrayCall",
                    "cweIds": [
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringToUpperWithoutLocale",
                "shortDescription": {
                  "text": "调用无区域设置的 'String.toUpperCase()' 或 'toLowerCase()'"
                },
                "fullDescription": {
                  "text": "报告未指定 'java.util.Locale' 的 'String' 对象上的 'toUpperCase()' 或 'toLowerCase()' 调用。 这些情况下使用默认的系统区域设置，可能会在国际化环境中导致问题。 例如，代码 '\"i\".toUpperCase().equals(\"I\")' 在土耳其语和阿塞拜疆语区域设置中返回 'false'，其中带点和无点的 'i' 是单独的字母。 在土耳其语区域设置中运行时，对包含 'i' 的英文字符串调用 'toUpperCase()' 将返回不正确的结果。 或者，在处理应被视为与区域设置无关的字符串（如 HTML 标记）时，可能会导致错误。",
                  "markdown": "报告未指定 `java.util.Locale` 的 `String` 对象上的 `toUpperCase()` 或 `toLowerCase()` 调用。 这些情况下使用默认的系统区域设置，可能会在国际化环境中导致问题。\n\n\n例如，代码 `\"i\".toUpperCase().equals(\"I\")` 在土耳其语和阿塞拜疆语区域设置中返回 `false`，其中带点和无点的 'i' 是单独的字母。 在土耳其语区域设置中运行时，对包含 'i' 的英文字符串调用 `toUpperCase()` 将返回不正确的结果。 或者，在处理应被视为与区域设置无关的字符串（如 HTML 标记）时，可能会导致错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringToUpperCaseOrToLowerCaseWithoutLocale",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitToImplicitClassMigration",
                "shortDescription": {
                  "text": "显式类声明可被转换为隐式声明的类"
                },
                "fullDescription": {
                  "text": "报告可转换为隐式声明的类的普通类。 示例： 'public class Sample {\n      public static void main(String[] args) {\n          System.out.println(\"Hello, world!\");\n      }\n  }' 在应用快速修复后： 'public static void main(String[] args) {\n      System.out.println(\"Hello, world!\");\n  }' 2024.1 最新变化 此检查取决于 Java 功能 '隐式声明的类'，该功能自 Java 21-preview 起可用。",
                  "markdown": "报告可转换为隐式声明的类的普通类。\n\n**示例：**\n\n\n      public class Sample {\n          public static void main(String[] args) {\n              System.out.println(\"Hello, world!\");\n          }\n      }\n\n在应用快速修复后：\n\n\n      public static void main(String[] args) {\n          System.out.println(\"Hello, world!\");\n      }\n\n2024.1 最新变化\n\n此检查取决于 Java 功能 '隐式声明的类'，该功能自 Java 21-preview 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExplicitToImplicitClassMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizationOnLocalVariableOrMethodParameter",
                "shortDescription": {
                  "text": "在局部变量或方法形参上同步"
                },
                "fullDescription": {
                  "text": "报告局部变量或形参的同步。 使用此类同步时，很难保证正确的运算。 可以改进此类代码，例如，通过使用 synchronized 包装器类控制访问或通过在字段上进行同步。 示例： 'void bar() {\n    final Object lock = new Object();\n    synchronized (lock) { }\n  }'",
                  "markdown": "报告局部变量或形参的同步。\n\n\n使用此类同步时，很难保证正确的运算。\n可以改进此类代码，例如，通过使用 synchronized 包装器类控制访问或通过在字段上进行同步。\n\n**示例：**\n\n\n      void bar() {\n        final Object lock = new Object();\n        synchronized (lock) { }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizationOnLocalVariableOrMethodParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedMethodCall",
                "shortDescription": {
                  "text": "嵌套方法调用"
                },
                "fullDescription": {
                  "text": "报告用作另一个方法调用的形参的方法调用。 该快速修复会引入一个变量，使代码更简单，也更易于调试。 示例： 'public int y() { return 1; }\n  public int f(int x) { return 2 * x; }\n\n  public void foo() {\n      int x = f(y());\n  }' 在应用快速修复后： 'public int y() { return 1; }\n  public int f(int x) { return 2 * x; }\n\n  public void foo() {\n      int y = y();\n      int x = f(y);\n  }' 使用检查选项可以切换以下各项的报告： 字段初始值设定项中的方法调用 对 static 方法的调用 对简单 getter 的调用",
                  "markdown": "报告用作另一个方法调用的形参的方法调用。\n\n该快速修复会引入一个变量，使代码更简单，也更易于调试。\n\n**示例：**\n\n\n      public int y() { return 1; }\n      public int f(int x) { return 2 * x; }\n\n      public void foo() {\n          int x = f(y());\n      }\n\n在应用快速修复后：\n\n\n      public int y() { return 1; }\n      public int f(int x) { return 2 * x; }\n\n      public void foo() {\n          int y = y();\n          int x = f(y);\n      }\n\n\n使用检查选项可以切换以下各项的报告：\n\n* 字段初始值设定项中的方法调用\n* 对 static 方法的调用\n* 对简单 getter 的调用"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedConditionalExpression",
                "shortDescription": {
                  "text": "否定条件表达式"
                },
                "fullDescription": {
                  "text": "报告使用前缀表达式否定的条件表达式，因为此类结构可能令人困惑。 可以通过修正将外部否定同时传播到两个分支。 示例： '!(i == 1 ? a : b)' 在应用快速修复后： 'i == 1 ? !a : !b'",
                  "markdown": "报告使用前缀表达式否定的条件表达式，因为此类结构可能令人困惑。\n\n可以通过修正将外部否定同时传播到两个分支。\n\n示例：\n\n\n      !(i == 1 ? a : b)\n\n在应用快速修复后：\n\n\n      i == 1 ? !a : !b\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegatedConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalMethod",
                "shortDescription": {
                  "text": "不能重写方法"
                },
                "fullDescription": {
                  "text": "报告被声明为 'final' 的方法。 此类方法不能被重写，并且可能表明缺乏面向对象的设计。 某些编码标准不鼓励 'final' 方法。",
                  "markdown": "报告被声明为 `final` 的方法。 此类方法不能被重写，并且可能表明缺乏面向对象的设计。 某些编码标准不鼓励 `final` 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyTransitiveDependents",
                "shortDescription": {
                  "text": "传递依赖项过多的类"
                },
                "fullDescription": {
                  "text": "报告被过多其他类直接或间接依赖的类。 对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。 仅报告顶级类。 使用最大传递依赖项数字段可指定类允许的最大直接或间接依赖项数。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告被过多其他类直接或间接依赖的类。\n\n对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。\n\n仅报告顶级类。\n\n使用**最大传递依赖项数**字段可指定类允许的最大直接或间接依赖项数。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyTransitiveDependents",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CompareToUsesNonFinalVariable",
                "shortDescription": {
                  "text": "'compareTo()' 中引用了非 final 字段"
                },
                "fullDescription": {
                  "text": "报告对 'compareTo()' 实现中的非 'final' 字段的访问。 此类访问可能导致 'compareTo()' 在对象生命周期的不同时刻返回不同的结果，进而可能在使用 'java.util.TreeSet' 等标准集合类时导致问题。 只有在对该字段不具备写入访问权限时，才可以通过快速修复将该字段设为 'final'，否则不建议进行修正。 示例： 'class Foo implements Comparable<Foo>{\n    private int index;\n    Foo(int idx) {\n      index = idx;\n    }\n    @Override\n    public int compareTo(Foo foo) {\n     return Integer.compare(this.index, foo.index);\n    }\n  }' 在应用快速修复后： 'class Foo implements Comparable<Foo>{\n    private final int index;\n    Foo(int idx) {\n      index = idx;\n    }\n    @Override\n    public int compareTo(Foo foo) {\n      return Integer.compare(this.index, foo.index);\n    }\n  }'",
                  "markdown": "报告对 `compareTo()` 实现中的非 `final` 字段的访问。\n\n\n此类访问可能导致 `compareTo()` 在对象生命周期的不同时刻返回不同的结果，进而可能在使用 `java.util.TreeSet` 等标准集合类时导致问题。\n\n\n只有在对该字段不具备写入访问权限时，才可以通过快速修复将该字段设为 `final`，否则不建议进行修正。\n\n**示例：**\n\n\n      class Foo implements Comparable<Foo>{\n        private int index;\n        Foo(int idx) {\n          index = idx;\n        }\n        @Override\n        public int compareTo(Foo foo) {\n         return Integer.compare(this.index, foo.index);\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo implements Comparable<Foo>{\n        private final int index;\n        Foo(int idx) {\n          index = idx;\n        }\n        @Override\n        public int compareTo(Foo foo) {\n          return Integer.compare(this.index, foo.index);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CompareToUsesNonFinalVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousSystemArraycopy",
                "shortDescription": {
                  "text": "可疑的 'System.arraycopy()' 调用"
                },
                "fullDescription": {
                  "text": "报告对 'System.arraycopy()' 的可疑调用。 此类调用在以下情况下可疑： 源或目标非数组类型 源和目标的类型不同 复制的块长度大于 'src.length - srcPos' 复制的块长度大于 'dest.length - destPos' 当源和目标为同一个数组时，范围始终相交 示例： 'void foo() {\n    int[] src = new int[] { 1, 2, 3, 4 };\n    System.arraycopy(src, 0, src, 1, 2); // 警告：复制到具有相交范围的同一数组\n  }'",
                  "markdown": "报告对 `System.arraycopy()` 的可疑调用。\n\n此类调用在以下情况下可疑：\n\n* 源或目标非数组类型\n* 源和目标的类型不同\n* 复制的块长度大于 `src.length - srcPos`\n* 复制的块长度大于 `dest.length - destPos`\n* 当源和目标为同一个数组时，范围始终相交\n\n**示例：**\n\n\n      void foo() {\n        int[] src = new int[] { 1, 2, 3, 4 };\n        System.arraycopy(src, 0, src, 1, 2); // 警告：复制到具有相交范围的同一数组\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousSystemArraycopy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavacQuirks",
                "shortDescription": {
                  "text": "Javac 杂项"
                },
                "fullDescription": {
                  "text": "报告现有的 Javac 问题、性能问题和不兼容性。 例如，当需要处理许多嵌套调用时，类型推断会变慢。 以下代码会触发警告，因为 vararg 方法调用包含 50 个以上的多态实参： 'Arrays.asList(\n      Arrays.asList(\"a1\", \"b1\"),\n      Arrays.asList(\"a2\", \"b2\"),\n      ...\n      Arrays.asList(\"a100\", \"b100\"));' 快速修复程序添加了显式类型实参，可以加快编译和 IDE 的速度。 '//noinspection RedundantTypeArguments\n  Arrays.<List<String>>asList(\n      Arrays.asList(\"a1\", \"b1\"),\n      Arrays.asList(\"a2\", \"b2\"),\n      ...\n      Arrays.asList(\"a100\", \"b100\"));'",
                  "markdown": "报告现有的 Javac 问题、性能问题和不兼容性。 例如，当需要处理许多嵌套调用时，类型推断会变慢。\n\n以下代码会触发警告，因为 vararg 方法调用包含 50 个以上的多态实参：\n\n\n      Arrays.asList(\n          Arrays.asList(\"a1\", \"b1\"),\n          Arrays.asList(\"a2\", \"b2\"),\n          ...\n          Arrays.asList(\"a100\", \"b100\"));\n\n快速修复程序添加了显式类型实参，可以加快编译和 IDE 的速度。\n\n\n      //noinspection RedundantTypeArguments\n      Arrays.<List<String>>asList(\n          Arrays.asList(\"a1\", \"b1\"),\n          Arrays.asList(\"a2\", \"b2\"),\n          ...\n          Arrays.asList(\"a100\", \"b100\"));\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavacQuirks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/编译器问题",
                      "index": 88,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatement",
                "shortDescription": {
                  "text": "'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句。 'switch' 语句通常（但并非总是）表明面向对象的设计欠佳。 示例： 'switch (i) {\n    // 代码\n  }'",
                  "markdown": "报告 `switch` 语句。\n\n`switch` 语句通常（但并非总是）表明面向对象的设计欠佳。\n\n示例：\n\n\n      switch (i) {\n        // 代码\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbsoluteAlignmentInUserInterface",
                "shortDescription": {
                  "text": "AWT/Swing 代码中的绝对对齐"
                },
                "fullDescription": {
                  "text": "报告 AWT 和 Swing 中的绝对对齐常量的用法。 国际化应用程序使用相对对齐，因为它遵循区域设置组件的方向设置。 示例： 'JPanel panel = new JPanel(new BorderLayout(2, 2));\n  JLabel label = new JLabel(\"Hello World\");\n  panel.add(label, BorderLayout.NORTH);' 在应用快速修复后： 'JPanel panel = new JPanel(new BorderLayout(2, 2));\n  JLabel label = new JLabel(\"Hello World\");\n  panel.add(label, BorderLayout.PAGE_START);'",
                  "markdown": "报告 AWT 和 Swing 中的绝对对齐常量的用法。 国际化应用程序使用相对对齐，因为它遵循区域设置组件的方向设置。\n\n**示例：**\n\n\n      JPanel panel = new JPanel(new BorderLayout(2, 2));\n      JLabel label = new JLabel(\"Hello World\");\n      panel.add(label, BorderLayout.NORTH);\n\n在应用快速修复后：\n\n\n      JPanel panel = new JPanel(new BorderLayout(2, 2));\n      JLabel label = new JLabel(\"Hello World\");\n      panel.add(label, BorderLayout.PAGE_START);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbsoluteAlignmentInUserInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferReplaceableByString",
                "shortDescription": {
                  "text": "'StringBuilder' 可被替换为 'String'"
                },
                "fullDescription": {
                  "text": "报告可以用单个 'String' 串联替换的 'StringBuffer'、'StringBuilder' 或 'StringJoiner' 的用法。 使用 'String' 串联会使代码更短更简单。 此检查仅在建议的替换不会导致现代 JVM 的性能显著下降时报告。 在许多情况下，'String' 串联可能执行效果更好。 示例： 'StringBuilder result = new StringBuilder();\n  result.append(\"i = \");\n  result.append(i);\n  result.append(\";\");\n  return result.toString();' 在应用快速修复后： 'String result = \"i = \" + i + \";\";\n  return result;'",
                  "markdown": "报告可以用单个 `String` 串联替换的 `StringBuffer`、`StringBuilder` 或 `StringJoiner` 的用法。\n\n使用 `String` 串联会使代码更短更简单。\n\n\n此检查仅在建议的替换不会导致现代 JVM 的性能显著下降时报告。 在许多情况下，`String` 串联可能执行效果更好。\n\n**示例：**\n\n\n      StringBuilder result = new StringBuilder();\n      result.append(\"i = \");\n      result.append(i);\n      result.append(\";\");\n      return result.toString();\n\n在应用快速修复后：\n\n\n      String result = \"i = \" + i + \";\";\n      return result;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferReplaceableByString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SourceToSinkFlow",
                "shortDescription": {
                  "text": "不安全字符串被传递至安全方法"
                },
                "fullDescription": {
                  "text": "报告将非安全对象传递给带形参的方法的情况，该方法使用 '@Untainted' 注解标记、从注解的方法返回，或被分配给注解的字段、形参或局部变量。 不支持将字段的 Kotlin 'set' 和 'get' 方法作为入口点。 （相同类中的）安全对象为： 字符串文字、接口实例或枚举对象 对标记为 '@Untainted' 的方法进行调用的结果 private 字段，仅使用字符串文字赋值，并具有安全的初始值设定项 final 字段，具有安全的初始值设定项 标记为 '@Untainted' 且不是从非安全对象赋值的局部变量或形参 此字段、局部变量或形参不得作为实参传递给方法或用作限定符，或者必须是基元、其包装器或不可变对象。 此外，static final 字段也被认为是安全的。 分析仅在一个文件内执行。 要处理来自其他类的依赖项，请使用选项。 分析会扩展到 private 或 static 方法，并且具有深度传播限值。 示例： 'void doSmth(boolean b) {\n    String s = safe();\n    String s1 = \"other\";\n    if (b) s1 = s;\n    sink(s);\n  }\n\n  String sink(@Untainted String s) {}'\n 此处没有将非安全字符串赋值给 's'，因此没有产生警告。 另一方面： 'void doSmth(boolean b) {\n    String s = safe();\n    String s1 = \"other\";\n    s1 = foo();\n    if (b) s = s1;\n    sink(s);        // 此处为警告\n  }\n  \n  String foo();\n\n  String sink(@Untainted String s) {}'\n 这里有一条警告，因为 's1' 在 'foo' 调用结果赋值后具有未知状态。 2021.2 最新变化",
                  "markdown": "报告将非安全对象传递给带形参的方法的情况，该方法使用 `@Untainted` 注解标记、从注解的方法返回，或被分配给注解的字段、形参或局部变量。 不支持将字段的 Kotlin `set` 和 `get` 方法作为入口点。\n\n\n（相同类中的）安全对象为：\n\n* 字符串文字、接口实例或枚举对象\n* 对标记为 `@Untainted` 的方法进行调用的结果\n* private 字段，仅使用字符串文字赋值，并具有安全的初始值设定项\n* final 字段，具有安全的初始值设定项\n* 标记为 `@Untainted` 且不是从非安全对象赋值的局部变量或形参\n此字段、局部变量或形参不得作为实参传递给方法或用作限定符，或者必须是基元、其包装器或不可变对象。\n\n此外，static final 字段也被认为是安全的。\n\n\n分析仅在一个文件内执行。 要处理来自其他类的依赖项，请使用选项。\n分析会扩展到 private 或 static 方法，并且具有深度传播限值。\n\n\n示例：\n\n\n      void doSmth(boolean b) {\n        String s = safe();\n        String s1 = \"other\";\n        if (b) s1 = s;\n        sink(s);\n      }\n\n      String sink(@Untainted String s) {}\n\n\n此处没有将非安全字符串赋值给 `s`，因此没有产生警告。 另一方面：\n\n\n      void doSmth(boolean b) {\n        String s = safe();\n        String s1 = \"other\";\n        s1 = foo();\n        if (b) s = s1;\n        sink(s);        // 此处为警告\n      }\n      \n      String foo();\n\n      String sink(@Untainted String s) {}\n\n\n这里有一条警告，因为 `s1` 在 `foo` 调用结果赋值后具有未知状态。\n\n2021.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "tainting",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecordCanBeClass",
                "shortDescription": {
                  "text": "记录可以转换为类"
                },
                "fullDescription": {
                  "text": "报告记录类并建议将它们转换为普通类。 通过将快速修复应用到此记录，此检查可以将 Java 记录移动到使用早期 Java 版本的代码库。 请注意，生成的类并不完全等同于原始记录： 结果的类不再扩展 'java.lang.Record'，因此 'instanceof Record' 返回 'false'。 'Class.isRecord()' 和 'Class.getRecordComponents()' 等反射方法会产生不同的结果。 生成的 'hashCode()' 实现可能会产生不同的结果，因为故意没有指定计算记录 'hashCode' 的公式。 记录序列化机制不同于普通类。 有关详细信息，请参阅 Java 对象序列化规范。 示例： 'record Point(int x, int y) {}' 在应用快速修复后： 'final class Point {\n    private final int x;\n    private final int y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    public int x() { return x; }\n\n    public int y() { return y; }\n\n    @Override\n    public boolean equals(Object obj) {\n      if (obj == this) return true;\n      if (obj == null || obj.getClass() != this.getClass()) return false;\n      var that = (Point)obj;\n      return this.x == that.x &&\n             this.y == that.y;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"Point[\" +\n             \"x=\" + x + \", \" +\n             \"y=\" + y + ']';\n    }\n  }' 2020.3 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告记录类并建议将它们转换为普通类。\n\n通过将快速修复应用到此记录，此检查可以将 Java 记录移动到使用早期 Java 版本的代码库。\n\n\n请注意，生成的类并不完全等同于原始记录：\n\n* 结果的类不再扩展 `java.lang.Record`，因此 `instanceof Record` 返回 `false`。\n* `Class.isRecord()` 和 `Class.getRecordComponents()` 等反射方法会产生不同的结果。\n* 生成的 `hashCode()` 实现可能会产生不同的结果，因为故意没有指定计算记录 `hashCode` 的公式。\n* 记录序列化机制不同于普通类。 有关详细信息，请参阅 *Java 对象序列化规范*。\n\n示例：\n\n\n      record Point(int x, int y) {}\n\n在应用快速修复后：\n\n\n      final class Point {\n        private final int x;\n        private final int y;\n\n        Point(int x, int y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        public int x() { return x; }\n\n        public int y() { return y; }\n\n        @Override\n        public boolean equals(Object obj) {\n          if (obj == this) return true;\n          if (obj == null || obj.getClass() != this.getClass()) return false;\n          var that = (Point)obj;\n          return this.x == that.x &&\n                 this.y == that.y;\n        }\n\n        @Override\n        public int hashCode() {\n          return Objects.hash(x, y);\n        }\n\n        @Override\n        public String toString() {\n          return \"Point[\" +\n                 \"x=\" + x + \", \" +\n                 \"y=\" + y + ']';\n        }\n      }\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RecordCanBeClass",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLambdaParameterType",
                "shortDescription": {
                  "text": "冗余 lambda 形参类型"
                },
                "fullDescription": {
                  "text": "报告由于可以从上下文中推断而冗余的 lambda 形参类型。 示例： 'Map<String, Integer> map = ...\n  map.forEach((String s, Integer i) -> log.info(s + \"=\" + i));' 该快速修复会从 lambda 中移除这些形参类型。 'Map<String, Integer> map = ...\n  map.forEach((s, i) -> log.info(s + \"=\" + i));'",
                  "markdown": "报告由于可以从上下文中推断而冗余的 lambda 形参类型。\n\n**示例：**\n\n\n      Map<String, Integer> map = ...\n      map.forEach((String s, Integer i) -> log.info(s + \"=\" + i));\n\n该快速修复会从 lambda 中移除这些形参类型。\n\n\n      Map<String, Integer> map = ...\n      map.forEach((s, i) -> log.info(s + \"=\" + i));\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLambdaParameterType",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MalformedFormatString",
                "shortDescription": {
                  "text": "字符串的格式错误"
                },
                "fullDescription": {
                  "text": "报告不符合标准 Java 语法的格式字符串。 默认情况下，如果编译时常量被用作 'java.util.Formatter'、'java.lang.String'、'java.io.PrintWriter' 或 'java.io.PrintStream' 上相应方法的实参，则该检查会将其视为格式字符串。 示例： 'String.format(\"x = %d, y = %d\", 42);' 使用检查设置可以将其他类和方法标记为与字符串格式相关。 作为替代方案，您可以使用 'org.intellij.lang.annotations.PrintFormat' 注解 来标记格式字符串方法形参。 在这种情况下，格式实参形参必须紧跟在格式字符串之后，并且必须是最后一个方法形参。 示例： 'void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}' 以这种方式注解的方法也将被此检查识别。",
                  "markdown": "报告不符合标准 Java 语法的格式字符串。\n\n默认情况下，如果编译时常量被用作 `java.util.Formatter`、`java.lang.String`、`java.io.PrintWriter` 或\n`java.io.PrintStream` 上相应方法的实参，则该检查会将其视为格式字符串。\n\n**示例：**\n\n\n      String.format(\"x = %d, y = %d\", 42);\n\n使用检查设置可以将其他类和方法标记为与字符串格式相关。\n\n作为替代方案，您可以使用 `org.intellij.lang.annotations.PrintFormat` 注解\n来标记格式字符串方法形参。 在这种情况下，格式实参形参必须紧跟在格式字符串之后，并且必须是最后一个方法形参。 示例：\n\n\n      void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}\n\n\n以这种方式注解的方法也将被此检查识别。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MalformedFormatString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousReturnByteInputStream",
                "shortDescription": {
                  "text": "从 'InputStream.read()' 返回的可疑字节"
                },
                "fullDescription": {
                  "text": "报告从实现 'InputStream.read()' 方法的方法返回的 'byte' 类型的表达式。 这很可疑，因为 'InputStream.read()' 应返回范围从 '0' 到 '255' 的值，而字节类型的表达式包含从 '-128' 到 '127' 的值。 该快速修复会通过应用位掩码 '0xFF' 将表达式转换为无符号 'byte'。 示例： 'class MyInputStream extends InputStream {\n  int pos = 0;\n  byte[] data;\n\n  MyInputStream(byte[] input) {\n    data = input;\n  }\n\n  @Override\n  public int read() {\n    if (pos == data.length) {\n      return -1;\n    }\n    return data[pos++]; // 问题\n  }\n}' 应用快速修复后： 'class MyInputStream extends InputStream {\n  int pos = 0;\n  byte[] data;\n\n  MyInputStream(byte[] input) {\n    data = input;\n  }\n\n  @Override\n  public int read() {\n    if (pos == data.length) {\n      return -1;\n    }\n    return data[pos++] & 0xFF;\n  }\n}' 2023.2 最新变化",
                  "markdown": "报告从实现 `InputStream.read()` 方法的方法返回的 `byte` 类型的表达式。\n\n\n这很可疑，因为 `InputStream.read()` 应返回范围从 `0` 到 `255` 的值，而字节类型的表达式包含从 `-128` 到 `127` 的值。\n该快速修复会通过应用位掩码 `0xFF` 将表达式转换为无符号 `byte`。\n\n**示例：**\n\n\n    class MyInputStream extends InputStream {\n      int pos = 0;\n      byte[] data;\n\n      MyInputStream(byte[] input) {\n        data = input;\n      }\n\n      @Override\n      public int read() {\n        if (pos == data.length) {\n          return -1;\n        }\n        return data[pos++]; // 问题\n      }\n    }\n\n应用快速修复后：\n\n\n    class MyInputStream extends InputStream {\n      int pos = 0;\n      byte[] data;\n\n      MyInputStream(byte[] input) {\n        data = input;\n      }\n\n      @Override\n      public int read() {\n        if (pos == data.length) {\n          return -1;\n        }\n        return data[pos++] & 0xFF;\n      }\n    }\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousReturnByteInputStream",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalExpression",
                "shortDescription": {
                  "text": "条件表达式"
                },
                "fullDescription": {
                  "text": "报告三元条件运算符的用法并建议将它们转换为 'if'/'else' 语句。 一些代码标准禁止使用条件运算符。 示例： 'Object result = (condition) ? foo() : bar();' 在应用快速修复后： 'Object result;\n  if (condition) {\n    comp = foo();\n  }\n  else {\n    comp = bar();\n  }' 配置检查： 使用 对简单赋值和返回值忽略 选项忽略简单的赋值和返回并允许以下结构： 'String s = (foo == null) ? \"\" : foo.toString();' 在不可能用 if 语句自动替换的上下文中（例如，当条件表达式用作 'super()' 构造函数调用），使用 忽略无法使用 if 语句的位置 选项来忽略条件表达式。",
                  "markdown": "报告三元条件运算符的用法并建议将它们转换为 `if`/`else` 语句。\n\n一些代码标准禁止使用条件运算符。\n\n示例：\n\n\n      Object result = (condition) ? foo() : bar();\n\n在应用快速修复后：\n\n\n      Object result;\n      if (condition) {\n        comp = foo();\n      }\n      else {\n        comp = bar();\n      }\n\n配置检查：\n\n使用 **对简单赋值和返回值忽略** 选项忽略简单的赋值和返回并允许以下结构：\n\n\n      String s = (foo == null) ? \"\" : foo.toString();\n\n\n在不可能用 if 语句自动替换的上下文中（例如，当条件表达式用作 `super()` 构造函数调用），使用 **忽略无法使用 if 语句的位置** 选项来忽略条件表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConditionalExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadYield",
                "shortDescription": {
                  "text": "调用 'Thread.yield()'"
                },
                "fullDescription": {
                  "text": "报告对 'Thread.yield()' 的调用。 'yield()' 的行为是不确定的并且依赖于平台，很少适合使用此方法。 它的使用应当与详细的分析和基准测试相结合，以确保真正达到预期效果。 示例： 'public static void main(String[] args) {\n    Runnable r = () -> {\n      for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n        Thread.yield();\n      }\n    };\n    new Thread(r).start();\n    new Thread(r).start();\n  }'",
                  "markdown": "报告对 `Thread.yield()` 的调用。\n\n\n`yield()` 的行为是不确定的并且依赖于平台，很少适合使用此方法。\n它的使用应当与详细的分析和基准测试相结合，以确保真正达到预期效果。\n\n**示例：**\n\n\n      public static void main(String[] args) {\n        Runnable r = () -> {\n          for (int i = 0; i < 10; i++) {\n            System.out.println(i);\n            Thread.yield();\n          }\n        };\n        new Thread(r).start();\n        new Thread(r).start();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadYield",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfClone",
                "shortDescription": {
                  "text": "使用 'clone()' 或 'Cloneable'"
                },
                "fullDescription": {
                  "text": "报告 'clone()' 方法的实现、对它的调用，以及 'java.lang.Cloneable' 接口的使用。 某些编码标准禁止使用 'clone()'，建议改用复制构造函数或 'static' 工厂方法。 该检查会忽略在数组上对 'clone()' 的调用，因为这是一种正确而又紧凑的数组复制方式。 示例： 'class Copy implements Cloneable /*警告*/ {\n\n    public Copy clone() /*警告*/ {\n      try {\n        return (Copy) super.clone(); // 警告\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }'",
                  "markdown": "报告 `clone()` 方法的实现、对它的调用，以及 `java.lang.Cloneable` 接口的使用。\n\n某些编码标准禁止使用 `clone()`，建议改用复制构造函数或 `static` 工厂方法。\n\n该检查会忽略在数组上对 `clone()` 的调用，因为这是一种正确而又紧凑的数组复制方式。\n\n**示例：**\n\n\n      class Copy implements Cloneable /*警告*/ {\n\n        public Copy clone() /*警告*/ {\n          try {\n            return (Copy) super.clone(); // 警告\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingFinalNewline",
                "shortDescription": {
                  "text": "缺少最终新行"
                },
                "fullDescription": {
                  "text": "如果清单文件未按照 JAR 文件规范的要求以最后的换行符结尾，则报告。",
                  "markdown": "如果清单文件未按照 JAR 文件规范的要求以最后的换行符结尾，则报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MissingFinalNewline",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "清单",
                      "index": 91,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaCanBeMethodCall",
                "shortDescription": {
                  "text": "lambda 可被替换为方法调用"
                },
                "fullDescription": {
                  "text": "报告可被替换为 JDK 方法调用的 lambda 表达式。 例如，'Function<T, T>' 类型的表达式 'x -> x' 可被替换为 'Function.identity()' 调用。 2017.1 最新变化 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告可被替换为 JDK 方法调用的 lambda 表达式。\n\n例如，`Function<T, T>` 类型的表达式 `x -> x` 可被替换为 `Function.identity()` 调用。\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaCanBeMethodCall",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedTryStatement",
                "shortDescription": {
                  "text": "嵌套 'try' 语句"
                },
                "fullDescription": {
                  "text": "报告嵌套的 'try' 语句。 嵌套的 'try' 语句可能会导致代码不清晰，并且可能会合并它们的 'catch' 和 'finally' 部分。",
                  "markdown": "报告嵌套的 `try` 语句。\n\n嵌套的 `try` 语句可能会导致代码不清晰，并且可能会合并它们的 `catch` 和 `finally` 部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedTryStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EndlessStream",
                "shortDescription": {
                  "text": "非短路操作消耗无限流"
                },
                "fullDescription": {
                  "text": "报告消耗无限流的非短路运算。 此类运算只能通过抛出异常来完成。 示例： 'Stream.iterate(0, i -> i + 1).collect(Collectors.toList())' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告消耗无限流的非短路运算。 此类运算只能通过抛出异常来完成。\n\n示例：\n\n\n      Stream.iterate(0, i -> i + 1).collect(Collectors.toList())\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EndlessStream",
                    "cweIds": [
                      835
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonStaticFinalLogger",
                "shortDescription": {
                  "text": "非常量记录器"
                },
                "fullDescription": {
                  "text": "报告未被声明为 'static' 和/或 'final' 的记录器字段。 确保每个类记录器都是有效的常量并绑定到该类可以简化为应用程序提供统一日志记录实现的任务。 提供了一个快速修复来将记录器修饰符更改为 'static final'。 示例： 'public class Significant {\n    private Logger LOG = Logger.getLogger(Critical.class);\n  }' 在应用快速修复后： 'public class Significant {\n    private static final Logger LOG = Logger.getLogger(Critical.class);\n  }' 配置检查： 使用记录器类名表可以指定记录器类名。 该检查将报告不是 'static' 和 'final' 并且类型等同于指定类名之一的字段。",
                  "markdown": "报告未被声明为 `static` 和/或 `final` 的记录器字段。 确保每个类记录器都是有效的常量并绑定到该类可以简化为应用程序提供统一日志记录实现的任务。\n\n提供了一个快速修复来将记录器修饰符更改为 `static final`。\n\n**示例：**\n\n\n      public class Significant {\n        private Logger LOG = Logger.getLogger(Critical.class);\n      }\n\n在应用快速修复后：\n\n\n      public class Significant {\n        private static final Logger LOG = Logger.getLogger(Critical.class);\n      }\n\n\n配置检查：\n\n* 使用**记录器类名** 表可以指定记录器类名。 该检查将报告不是 `static` 和 `final` 并且类型等同于指定类名之一的字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonConstantLogger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Singleton",
                "shortDescription": {
                  "text": "单例"
                },
                "fullDescription": {
                  "text": "报告单例类。 单例类按照只能实例化该类一个实例的方式进行声明。 单例类导致测试复杂化，存在这种情况可能表明欠缺面向对象的设计。 示例： 'class Singleton {\n    private static final Singleton ourInstance = new Singleton();\n\n    private Singleton() {\n    }\n\n    public Singleton getInstance() {\n        return ourInstance;\n    }\n  }'",
                  "markdown": "报告单例类。\n\n单例类按照只能实例化该类一个实例的方式进行声明。 单例类导致测试复杂化，存在这种情况可能表明欠缺面向对象的设计。\n\n**示例：**\n\n\n      class Singleton {\n        private static final Singleton ourInstance = new Singleton();\n\n        private Singleton() {\n        }\n\n        public Singleton getInstance() {\n            return ourInstance;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Singleton",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalUtilityClass",
                "shortDescription": {
                  "text": "实用程序类不为 'final'"
                },
                "fullDescription": {
                  "text": "报告非 'final' 或 'abstract' 的实用程序类。 实用程序类将所有字段和方法声明为 'static'。 使之为 'final' 可防止意外地被子类化。 示例： 'public class UtilityClass {\n    public static void foo() {}\n  }' 在应用快速修复后： 'public final class UtilityClass {\n    public static void foo() {}\n  }'",
                  "markdown": "报告非 `final` 或 `abstract` 的实用程序类。\n\n实用程序类将所有字段和方法声明为 `static`。\n使之为 `final` 可防止意外地被子类化。\n\n**示例：**\n\n\n      public class UtilityClass {\n        public static void foo() {}\n      }\n\n在应用快速修复后：\n\n\n      public final class UtilityClass {\n        public static void foo() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalUtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FuseStreamOperations",
                "shortDescription": {
                  "text": "后续步骤可以融合到Stream API链中"
                },
                "fullDescription": {
                  "text": "检测 Stream API 链之外的可以合并到其中的转换。 示例： 'List<String> list = stream.collect(Collectors.toList());\n  list.sort(null);\n  return list.toArray(new String[list.size()]);' 转换后： 'return stream.sorted().toArray(String[]::new);' 请注意，有时转换后的 Stream 链可能会将显式 'ArrayList' 替换为 'Collectors.toList()' 或将显式 'HashSet' 替换为 'Collectors.toSet()'。 当前库实现会在内部使用这些集合。 但是，这种方法不是很可靠，将来可能会更改代码的语义。 如果您对此感到担心，请使用不建议使用 'toList()' 或 'toSet()' 收集器选项来建议使用 'Collectors.toCollection()' 而不是 'toList' 和 'toSet' 收集器。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "检测 Stream API 链之外的可以合并到其中的转换。\n\n示例：\n\n\n      List<String> list = stream.collect(Collectors.toList());\n      list.sort(null);\n      return list.toArray(new String[list.size()]);\n\n转换后：\n\n\n      return stream.sorted().toArray(String[]::new);\n\n\n请注意，有时转换后的 Stream 链可能会将显式 `ArrayList` 替换为 `Collectors.toList()` 或将显式 `HashSet` 替换为 `Collectors.toSet()`。 当前库实现会在内部使用这些集合。 但是，这种方法不是很可靠，将来可能会更改代码的语义。\n\n如果您对此感到担心，请使用**不建议使用 'toList()' 或 'toSet()' 收集器** 选项来建议使用 `Collectors.toCollection()` 而不是 `toList` 和 `toSet` 收集器。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FuseStreamOperations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalExpressionWithIdenticalBranches",
                "shortDescription": {
                  "text": "具有相同分支的条件表达式"
                },
                "fullDescription": {
                  "text": "报告包含相同 'then' 和 'else' 分支的条件表达式。 此类表达式几乎肯定表明有错误。 该检查提供了一种折叠条件表达式的修正。 示例： 'int y = x == 10 ? 4 : 4;' 在应用快速修复后： 'int y = 4;'",
                  "markdown": "报告包含相同 `then` 和 `else` 分支的条件表达式。\n\n此类表达式几乎肯定表明有错误。 该检查提供了一种折叠条件表达式的修正。\n\n示例：\n\n\n      int y = x == 10 ? 4 : 4;\n\n在应用快速修复后：\n\n\n      int y = 4;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalExpressionWithIdenticalBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DefaultNotLastCaseInSwitch",
                "shortDescription": {
                  "text": "'default' 不是 'switch' 中的最后一个 case"
                },
                "fullDescription": {
                  "text": "报告其中的 'default' 分支位于另一个 case 前面的 'switch' 语句或表达式。 此类构造会造成不必要的困惑。 如果可能，可以通过快速修复将 'default' 分支移到最后位置。 示例： 'switch (n) {\n      default:\n          System.out.println();\n          break;\n      case 1:\n          break;\n  }' 在应用快速修复后： 'switch (n) {\n    case 1:\n        break;\n    default:\n        System.out.println();\n        break;\n  }'",
                  "markdown": "报告其中的 `default` 分支位于另一个 case 前面的 `switch` 语句或表达式。 此类构造会造成不必要的困惑。 如果可能，可以通过快速修复将 `default` 分支移到最后位置。\n\n**示例：**\n\n\n      switch (n) {\n          default:\n              System.out.println();\n              break;\n          case 1:\n              break;\n      }\n\n在应用快速修复后：\n\n\n      switch (n) {\n        case 1:\n            break;\n        default:\n            System.out.println();\n            break;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DefaultNotLastCaseInSwitch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullThrown",
                "shortDescription": {
                  "text": "已抛出 'null'"
                },
                "fullDescription": {
                  "text": "报告用作 'throw' 语句实参的 'null' 文字。 此类结构会产生通常不应以编程方式抛出的 'java.lang.NullPointerException'。",
                  "markdown": "报告用作 `throw` 语句实参的 `null` 文字。\n\n此类结构会产生通常不应以编程方式抛出的 `java.lang.NullPointerException`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NullThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalCanBeFinal",
                "shortDescription": {
                  "text": "局部变量或形参可以是 'final'"
                },
                "fullDescription": {
                  "text": "报告可能在其声明中添加了 'final' 修饰符的形参或局部变量。 示例： 'ArrayList<Integer> list = new ArrayList();\n  fill(list);\n  return list;' 在应用快速修复后： 'final ArrayList<Integer> list = new ArrayList();\n  fill(list);\n  return list;' 使用该检查的选项可定义是否应报告形参或局部变量。",
                  "markdown": "报告可能在其声明中添加了 `final` 修饰符的形参或局部变量。\n\n示例：\n\n\n      ArrayList<Integer> list = new ArrayList();\n      fill(list);\n      return list;\n\n在应用快速修复后：\n\n\n      final ArrayList<Integer> list = new ArrayList();\n      fill(list);\n      return list;\n\n\n使用该检查的选项可定义是否应报告形参或局部变量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalCanBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldMayBeStatic",
                "shortDescription": {
                  "text": "字段可以为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以安全地设为 'static' 的实例变量。 如果字段被声明为 'final' 并用常量初始化，则该字段可以为 static 字段。 示例： 'public final String str = \"sample\";' 该检查不会报告可以隐式写入的 final 字段。 使用“注解”按钮修改假定隐式字段写入的注解列表。",
                  "markdown": "报告可以安全地设为 `static` 的实例变量。 如果字段被声明为 `final` 并用常量初始化，则该字段可以为 static 字段。\n\n**示例：**\n\n\n      public final String str = \"sample\";\n\n\n该检查不会报告可以隐式写入的 final 字段。 使用\"注解\"按钮修改假定隐式字段写入的注解列表。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayEquals",
                "shortDescription": {
                  "text": "在数组上调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告可以比较两个数组的 'equals()' 调用。 对数组调用 'equals()' 可以比较同一性，相当于使用 '=='。 使用 'Arrays.equals()' 比较两个数组的内容，或使用 'Arrays.deepEquals()' 比较多维数组的内容。 示例： 'void sample(int[] first, int[] second){\n    if (first.equals(second)) return;\n  }' 在应用快速修复后： 'void sample(int[] first, int[] second){\n    if (Arrays.equals(first, second)) return;\n  }'",
                  "markdown": "报告可以比较两个数组的 `equals()` 调用。\n\n对数组调用 `equals()` 可以比较同一性，相当于使用 `==`。\n使用 `Arrays.equals()` 比较两个数组的内容，或使用 `Arrays.deepEquals()` 比较多维数组的内容。\n\n**示例：**\n\n\n      void sample(int[] first, int[] second){\n        if (first.equals(second)) return;\n      }\n\n在应用快速修复后：\n\n\n      void sample(int[] first, int[] second){\n        if (Arrays.equals(first, second)) return;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProblematicVarargsMethodOverride",
                "shortDescription": {
                  "text": "非 vararg 方法重写 vararg 方法"
                },
                "fullDescription": {
                  "text": "报告重写可变 arity（亦称 vararg）方法但将可变 arity 形参替换为数组形参的方法。 尽管这段代码有效，但它可能令人困惑，因而应当避免。",
                  "markdown": "报告重写可变 arity（亦称 vararg）方法但将可变 arity 形参替换为数组形参的方法。 尽管这段代码有效，但它可能令人困惑，因而应当避免。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProblematicVarargsMethodOverride",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OnlyOneElementUsed",
                "shortDescription": {
                  "text": "仅使用了一个元素"
                },
                "fullDescription": {
                  "text": "报告其中有且只有一个元素在创建时被查询的列表、数组和字符串。 此类表达式可能会在重构之后出现，并且通常可被替换为访问的元素。 示例： 'System.out.println(new int[] {1,2,3,4,5}[2]);' 在应用快速修复后： 'System.out.println(3);' 2022.3 最新变化",
                  "markdown": "报告其中有且只有一个元素在创建时被查询的列表、数组和字符串。 此类表达式可能会在重构之后出现，并且通常可被替换为访问的元素。\n\n示例：\n\n\n      System.out.println(new int[] {1,2,3,4,5}[2]);\n\n在应用快速修复后：\n\n\n      System.out.println(3);\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OnlyOneElementUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisspelledHeader",
                "shortDescription": {
                  "text": "未知或拼写错误的标头名称"
                },
                "fullDescription": {
                  "text": "报告任何未知的和可能拼写错误的标头名称，并提供可能的变体。",
                  "markdown": "报告任何未知的和可能拼写错误的标头名称，并提供可能的变体。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MisspelledHeader",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "清单",
                      "index": 91,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AtomicFieldUpdaterIssues",
                "shortDescription": {
                  "text": "'AtomicFieldUpdater' 声明不一致"
                },
                "fullDescription": {
                  "text": "报告 'AtomicLongFieldUpdater'、'AtomicIntegerFieldUpdater' 或 'AtomicReferenceFieldUpdater' 字段（'java.util.concurrent.atomic' 软件包）的问题。 报告的问题与原子字段更新程序可能发生的运行时问题相同：找不到指定字段、指定字段不可访问、指定字段类型错误等。 示例： 'class A {\n    private static volatile int value = 0;\n    private static final AtomicIntegerFieldUpdater updater =\n    AtomicIntegerFieldUpdater.newUpdater((A.class), \"value\"); // 警告：字段 'value' 具有 'static' 修饰符\n  }' 'class B {\n    private static final AtomicIntegerFieldUpdater updater =\n      AtomicIntegerFieldUpdater.newUpdater(B.class, \"value\"); // 警告：在类 'B' 中找不到名为 'Value' 的字段\n  }'",
                  "markdown": "报告 `AtomicLongFieldUpdater`、`AtomicIntegerFieldUpdater` 或 `AtomicReferenceFieldUpdater` 字段（`java.util.concurrent.atomic` 软件包）的问题。\n\n报告的问题与原子字段更新程序可能发生的运行时问题相同：找不到指定字段、指定字段不可访问、指定字段类型错误等。\n\n**示例：**\n\n*\n\n\n        class A {\n          private static volatile int value = 0;\n          private static final AtomicIntegerFieldUpdater updater =\n          AtomicIntegerFieldUpdater.newUpdater((A.class), \"value\"); // 警告：字段 'value' 具有 'static' 修饰符\n        }\n        \n*\n\n\n        class B {\n          private static final AtomicIntegerFieldUpdater updater =\n            AtomicIntegerFieldUpdater.newUpdater(B.class, \"value\"); // 警告：在类 'B' 中找不到名为 'Value' 的字段\n        }\n        \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AtomicFieldUpdaterIssues",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExceptionThrown",
                "shortDescription": {
                  "text": "已抛出禁止异常"
                },
                "fullDescription": {
                  "text": "报告抛出不适当异常的 'throw' 语句。 例如，异常可能因为过于通用而不适当，例如 'java.lang.Exception' 或 'java.io.IOException'。 示例： 'void setup(Mode mode) {\n      if (mode == null)\n          throw new RuntimeException(\"Problem during setup\"); // 警告：抛出了禁止的异常 'RuntimeException'\n      ...\n  }' 使用被禁止的异常列表可指定应报告哪些异常。",
                  "markdown": "报告抛出不适当异常的 `throw` 语句。 例如，异常可能因为过于通用而不适当，例如 `java.lang.Exception` 或 `java.io.IOException`。\n\n**示例：**\n\n\n      void setup(Mode mode) {\n          if (mode == null)\n              throw new RuntimeException(\"Problem during setup\"); // 警告：抛出了禁止的异常 'RuntimeException'\n          ...\n      }\n\n使用**被禁止的异常**列表可指定应报告哪些异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProhibitedExceptionThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryBoxing",
                "shortDescription": {
                  "text": "不必要的装箱"
                },
                "fullDescription": {
                  "text": "报告显式装箱，即将基元值包装到对象中。 对于 Java 5 和更高版本，显式手动装箱不必要，并且可以安全移除。 示例： 'Integer i = new Integer(1);' → 'Integer i = Integer.valueOf(1);' 'int i = Integer.valueOf(1);' → 'int i = 1;' 使用仅报告真正多余的装箱表达式选项，可仅报告真正多余的装箱，其中的装箱值立即隐式或显式地拆箱。 在本例中，可以移除整个装箱-拆箱步骤。 该检查不报告简单的显式装箱。 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告显式装箱，即将基元值包装到对象中。\n\n对于 Java 5 和更高版本，显式手动装箱不必要，并且可以安全移除。\n\n**示例：**\n\n* `Integer i = new Integer(1);` → `Integer i = Integer.valueOf(1);`\n* `int i = Integer.valueOf(1);` → `int i = 1;`\n\n\n使用**仅报告真正多余的装箱表达式**选项，可仅报告真正多余的装箱，其中的装箱值立即隐式或显式地拆箱。\n在本例中，可以移除整个装箱-拆箱步骤。 该检查不报告简单的显式装箱。\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryBoxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageNamingConvention",
                "shortDescription": {
                  "text": "软件包命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的软件包。 示例： 'package io;' 使用选项可以指定软件包名称的最小长度和最大长度，以及匹配有效软件包名称的正则表达式（正则表达式采用标准 'java.util.regex' 格式）。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的软件包。\n\n**示例：**\n\n\n      package io;\n\n\n使用选项可以指定软件包名称的最小长度和最大长度，以及匹配有效软件包名称的正则表达式（正则表达式采用标准 `java.util.regex` 格式）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Anonymous2MethodRef",
                "shortDescription": {
                  "text": "匿名类型可被替换为方法引用"
                },
                "fullDescription": {
                  "text": "报告可以替换为方法引用的匿名类。 请注意，如果将匿名类转换为未绑定的方法引用，则 Java 运行时可以在后续调用期间重用相同的方法引用对象。 另一方面，使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 'HashMap' 键时。 示例： 'Runnable r = new Runnable() {\n    @Override\n    public void run() {\n      System.out.println();\n    }\n  };' 在应用快速修复后： 'Runnable r = System.out::println;' 使用在接口未使用 @FunctionalInterface 注解时报告选项可为未使用 '@FunctionalInterface' 注解的接口启用此检查。 此检查取决于 Java 功能 '方法引用'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为方法引用的匿名类。\n\n\n请注意，如果将匿名类转换为未绑定的方法引用，则 Java 运行时可以在后续调用期间重用相同的方法引用对象。 另一方面，使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 `HashMap` 键时。\n\n**示例：**\n\n\n      Runnable r = new Runnable() {\n        @Override\n        public void run() {\n          System.out.println();\n        }\n      };\n\n在应用快速修复后：\n\n\n      Runnable r = System.out::println;\n\n使用**在接口未使用 @FunctionalInterface 注解时报告** 选项可为未使用 `@FunctionalInterface` 注解的接口启用此检查。\n\n此检查取决于 Java 功能 '方法引用'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Anonymous2MethodRef",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicMethodNotExposedInInterface",
                "shortDescription": {
                  "text": "'public' 方法在接口中未公开"
                },
                "fullDescription": {
                  "text": "报告未在接口中公开的类中的 'public' 方法。 通过接口公开所有 'public' 方法对于维护松散耦合非常重要，某些基于组件的编程风格可能需要这样做。 示例： 'interface Person {\n  String getName();\n}\n\nclass PersonImpl implements Person {\n  private String name;\n\n  // 正常：方法在接口中公开\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  // 警告：方法为 public\n  // 但未在接口中公开\n  public void setName() {\n    this.name = name;\n  }\n}' 使用有注解时忽略列表可指定特殊注解。 此检查将忽略使用其中一种注解进行注解的方法。 使用如果包含类未实现非库接口，则忽略选项可以忽略未实现项目中任何接口的类中的方法。",
                  "markdown": "报告未在接口中公开的类中的 `public` 方法。\n\n通过接口公开所有 `public` 方法对于维护松散耦合非常重要，某些基于组件的编程风格可能需要这样做。\n\n示例：\n\n\n    interface Person {\n      String getName();\n    }\n\n    class PersonImpl implements Person {\n      private String name;\n\n      // 正常：方法在接口中公开\n      @Override\n      public String getName() {\n        return name;\n      }\n\n      // 警告：方法为 public\n      // 但未在接口中公开\n      public void setName() {\n        this.name = name;\n      }\n    }\n\n\n使用**有注解时忽略**列表可指定特殊注解。 此检查将忽略使用其中一种注解进行注解的方法。\n\n\n使用**如果包含类未实现非库接口，则忽略**选项可以忽略未实现项目中任何接口的类中的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicMethodNotExposedInInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableHasSerialVersionUIDField",
                "shortDescription": {
                  "text": "不带 'serialVersionUID' 的可序列化类"
                },
                "fullDescription": {
                  "text": "报告实现 'Serializable' 且不声明 'serialVersionUID' 字段的类。 如果没有 'serialVersionUID' 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。 示例： 'class Main implements Serializable {\n  }' 在应用快速修复后： 'class Main implements Serializable {\n      private static final long serialVersionUID = -1446398935944895849L;\n  }' 当使用 JDK 14 或更高版本的语言级别时，该快速修复还将添加 'java.io.Serial' 注解。 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 是否忽略 'Serializable' 匿名类。",
                  "markdown": "报告实现 `Serializable` 且不声明 `serialVersionUID` 字段的类。\n\n\n如果没有 `serialVersionUID` 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。\n\n**示例：**\n\n\n      class Main implements Serializable {\n      }\n\n在应用快速修复后：\n\n\n      class Main implements Serializable {\n          private static final long serialVersionUID = -1446398935944895849L;\n      }\n\n当使用 JDK 14 或更高版本的语言级别时，该快速修复还将添加 `java.io.Serial` 注解。\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 是否忽略 `Serializable` 匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "serial",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowableNotThrown",
                "shortDescription": {
                  "text": "'Throwable' 未抛出"
                },
                "fullDescription": {
                  "text": "当创建的 'Throwable' 从未真正抛出时，报告 'Throwable' 或其子类的实例化。 此外，当方法调用的结果未抛出时，此检查会报告返回 'Throwable' 或其子类实例的方法调用。 不会报告对使用 Error Prone 或 AssertJ 的 '@CanIgnoreReturnValue' 注解进行注解的方法的调用。 示例： 'void check(String s) {\n        if (s == null) {\n            new NullPointerException(\"s\");\n        }\n        // ...\n    }'",
                  "markdown": "当创建的 `Throwable` 从未真正抛出时，报告 `Throwable` 或其子类的实例化。 此外，当方法调用的结果未抛出时，此检查会报告返回 `Throwable` 或其子类实例的方法调用。\n\n不会报告对使用 Error Prone 或 AssertJ 的 `@CanIgnoreReturnValue` 注解进行注解的方法的调用。\n\n**示例：**\n\n\n        void check(String s) {\n            if (s == null) {\n                new NullPointerException(\"s\");\n            }\n            // ...\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowableNotThrown",
                    "cweIds": [
                      390,
                      703
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CapturingCleaner",
                "shortDescription": {
                  "text": "清理器捕获对象引用"
                },
                "fullDescription": {
                  "text": "报告正在对传递给 'Cleaner.register()' 捕获引用的 'Runnable' 进行注册的情况。 如果引用被捕获，它将永远不是虚可达的，且永远不会调用清理操作。 此问题的可能来源： 使用非 static 方法、字段或 'this' 本身的 lambda 非 static 内部类（匿名与否）在 Java 18 及更低版本中始终捕获此引用 实例方法引用 从非 static 内部类访问外部类非 static 成员 将报告的代码示例： 'int fileDescriptor;\n  Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -> {\n    System.out.println(\"adsad\");\n    //this 通过 fileDescriptor 捕获\n    fileDescriptor = 0;\n  });' 仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。 2018.1 最新变化",
                  "markdown": "报告正在对传递给 `Cleaner.register()` 捕获引用的 `Runnable` 进行注册的情况。 如果引用被捕获，它将永远不是虚可达的，且永远不会调用清理操作。\n\n此问题的可能来源：\n\n* 使用非 static 方法、字段或 `this` 本身的 lambda\n* 非 static 内部类（匿名与否）在 Java 18 及更低版本中始终捕获此引用\n* 实例方法引用\n* 从非 static 内部类访问外部类非 static 成员\n\n将报告的代码示例：\n\n\n      int fileDescriptor;\n      Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -> {\n        System.out.println(\"adsad\");\n        //this 通过 fileDescriptor 捕获\n        fileDescriptor = 0;\n      });\n\n仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CapturingCleaner",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadStartInConstruction",
                "shortDescription": {
                  "text": "对象构造期间调用 'Thread.start()'"
                },
                "fullDescription": {
                  "text": "报告对象构造过程中在 'java.lang.Thread' 或其任何子类上对 'start()' 的调用。 虽然此类结构偶尔有用，但由于继承问题，应避免使用。 在对象构造期间启动线程的类的子类在线程启动前不会完成自身的任何初始化逻辑。 如果启动线程的类被声明为 'final'，此检查不会报告。 示例： 'class MyThread extends Thread {\n    MyThread() {\n      start();\n    }\n  }'",
                  "markdown": "报告对象构造过程中在 `java.lang.Thread` 或其任何子类上对 `start()` 的调用。\n\n\n虽然此类结构偶尔有用，但由于继承问题，应避免使用。\n在对象构造期间启动线程的类的子类在线程启动前不会完成自身的任何初始化逻辑。\n\n如果启动线程的类被声明为 `final`，此检查不会报告。\n\n**示例：**\n\n\n      class MyThread extends Thread {\n        MyThread() {\n          start();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadStartDuringObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestCaseWithNoTestMethods",
                "shortDescription": {
                  "text": "没有测试的测试类"
                },
                "fullDescription": {
                  "text": "报告没有任何测试方法的非 'abstract' 测试用例。 此类测试用例通常表示未完成的代码，或者可能是应当移除的重构剩余代码。 示例： 'public class CrucialTest {\n    @Before\n    public void setUp() {\n      System.out.println(\"setting up\");\n    }\n  }' 使用忽略具有带测试方法的超类的测试用例选项可忽略具有带测试方法的超类的测试用例。",
                  "markdown": "报告没有任何测试方法的非 `abstract` 测试用例。 此类测试用例通常表示未完成的代码，或者可能是应当移除的重构剩余代码。\n\n示例：\n\n\n      public class CrucialTest {\n        @Before\n        public void setUp() {\n          System.out.println(\"setting up\");\n        }\n      }\n\n\n使用**忽略具有带测试方法的超类的测试用例**选项可忽略具有带测试方法的超类的测试用例。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitTestCaseWithNoTests",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementWithTooManyBranches",
                "shortDescription": {
                  "text": "最大 'switch' 分支"
                },
                "fullDescription": {
                  "text": "报告 'case' 标签太多的 'switch' 语句或表达式。 如此之长的 switch 语句可能令人困惑，或许应进行重构。 有时这并非问题（例如一个域非常复杂，并且有包含大量常量的枚举）。 示例： 'switch (x) {\n        case 1 -> {}\n        case 2 -> {}\n        case 3 -> {}\n        case 4 -> {}\n        case 5 -> {}\n        case 6 -> {}\n        case 7 -> {}\n        case 8 -> {}\n        case 9 -> {}\n        case 10 -> {}\n        case 11,12,13 -> {}\n        default -> {}\n    }' 使用最大分支数字段可以指定 'case' 标签的预期最大数量。",
                  "markdown": "报告 `case` 标签太多的 `switch` 语句或表达式。\n\n如此之长的 switch 语句可能令人困惑，或许应进行重构。\n有时这并非问题（例如一个域非常复杂，并且有包含大量常量的枚举）。\n\n示例：\n\n\n        switch (x) {\n            case 1 -> {}\n            case 2 -> {}\n            case 3 -> {}\n            case 4 -> {}\n            case 5 -> {}\n            case 6 -> {}\n            case 7 -> {}\n            case 8 -> {}\n            case 9 -> {}\n            case 10 -> {}\n            case 11,12,13 -> {}\n            default -> {}\n        }\n\n使用**最大分支数** 字段可以指定 `case` 标签的预期最大数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatementWithTooManyBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedArrayReadWrite",
                "shortDescription": {
                  "text": "数组的读取和写入不匹配"
                },
                "fullDescription": {
                  "text": "报告其内容已读取但未更新或已更新但未读取的数组。 此类不一致读写毫无意义，可能表明死码、代码不完整或错误。 示例： 'final int[] bar = new int[3];\n  bar[2] = 3;'",
                  "markdown": "报告其内容已读取但未更新或已更新但未读取的数组。 此类不一致读写毫无意义，可能表明死码、代码不完整或错误。\n\n**示例：**\n\n\n      final int[] bar = new int[3];\n      bar[2] = 3;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedReadAndWriteOfArray",
                    "cweIds": [
                      561,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopConditionNotUpdatedInsideLoop",
                "shortDescription": {
                  "text": "循环变量未在循环内更新"
                },
                "fullDescription": {
                  "text": "报告在循环条件中使用且未在循环内更新的任何变量和形参。 此类变量和形参通常被错误使用，因为如果执行它们可能会导致无限循环。 示例： 'void loopDoesNotLoop(boolean b) {\n    while (b) {\n      System.out.println();\n      break;\n    }\n  }' 配置检查： 如果条件可以间接更新（例如，通过调用的方法或从另一个线程并发更新），请使用 忽略可能的非本地更改 选项来禁用此检查。",
                  "markdown": "报告在循环条件中使用且未在循环内更新的任何变量和形参。\n\n此类变量和形参通常被错误使用，因为如果执行它们可能会导致无限循环。\n\n示例：\n\n\n      void loopDoesNotLoop(boolean b) {\n        while (b) {\n          System.out.println();\n          break;\n        }\n      }\n\n配置检查：\n\n\n如果条件可以间接更新（例如，通过调用的方法或从另一个线程并发更新），请使用 **忽略可能的非本地更改** 选项来禁用此检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopConditionNotUpdatedInsideLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarilyQualifiedStaticUsage",
                "shortDescription": {
                  "text": "不必要的限定静态访问"
                },
                "fullDescription": {
                  "text": "报告不必要地使用类名限定的 static 成员的用法。 当 static 成员在周围类或周围类的超类中可用时，不需要对类进行限定。 此类限定可以安全移除。 示例： 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      Foo.foo();\n      System.out.println(Foo.x);\n    }\n\n    static void baz() { Foo.foo(); }\n  }' 在应用快速修复后： 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      foo();\n      System.out.println(x);\n    }\n\n    static void baz() { foo(); }\n  }' 使用检查选项可以切换以下各项的报告： static 字段访问： 'void bar() { System.out.println(Foo.x); }' 对 static 方法的调用： 'void bar() { Foo.foo(); }' 此外，您可以将检查配置为仅报告 static 上下文中的 static 成员用法。 在这种情况下，只会报告 'static void baz() { Foo.foo(); }'。",
                  "markdown": "报告不必要地使用类名限定的 static 成员的用法。\n\n\n当 static 成员在周围类或周围类的超类中可用时，不需要对类进行限定。 此类限定可以安全移除。\n\n**示例：**\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          Foo.foo();\n          System.out.println(Foo.x);\n        }\n\n        static void baz() { Foo.foo(); }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          foo();\n          System.out.println(x);\n        }\n\n        static void baz() { foo(); }\n      }\n\n\n使用检查选项可以切换以下各项的报告：\n\n* static 字段访问：  \n  `void bar() { System.out.println(Foo.x); }`\n\n* 对 static 方法的调用：  \n  `void bar() { Foo.foo(); }`\n\n\n此外，您可以将检查配置为仅报告 static 上下文中的 static 成员用法。 在这种情况下，只会报告 `static void baz() { Foo.foo(); }`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarilyQualifiedStaticUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemGetProperty",
                "shortDescription": {
                  "text": "对 'System.getProperty(str)' 的调用可以简化"
                },
                "fullDescription": {
                  "text": "报告方法 'System.getProperty(str)' 的用法，并在以下 2 种情况下提出修正建议： 'System.getProperty(\"path.separator\")' -> 'File.pathSeparator' 'System.getProperty(\"line.separator\")' -> 'System.lineSeparator()' 第二种方式不仅不太容易出错，而且可能更快，因为 'System.lineSeparator()' 返回缓存值，而 'System.getProperty(\"line.separator\")' 每次都调用属性（Hashtable 或 CHM，具体取决于实现）。",
                  "markdown": "报告方法 `System.getProperty(str)` 的用法，并在以下 2 种情况下提出修正建议：\n\n* `System.getProperty(\"path.separator\")` -\\> `File.pathSeparator`\n* `System.getProperty(\"line.separator\")` -\\> `System.lineSeparator()`\n\n第二种方式不仅不太容易出错，而且可能更快，因为 `System.lineSeparator()` 返回缓存值，而 `System.getProperty(\"line.separator\")` 每次都调用属性（Hashtable 或 CHM，具体取决于实现）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SystemGetProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionsMustHaveInitialCapacity",
                "shortDescription": {
                  "text": "没有初始容量的集合"
                },
                "fullDescription": {
                  "text": "报告在不指定初始容量的情况下实例化新 'Collection' 对象的尝试。 如果未指定初始容量，则使用默认容量，这很少是最佳选择。 如果在超出初始容量时需要重新分配空间和复制内存，则未能为集合指定初始容量可能会导致性能问题。 此检查会检查在检查的设置中列出的类的分配。 示例： 'new HashMap<String, String>();' 使用以下选项配置检查： 列出应检查的集合类。 是否忽略字段初始值设定项。",
                  "markdown": "报告在不指定初始容量的情况下实例化新 `Collection` 对象的尝试。\n\n\n如果未指定初始容量，则使用默认容量，这很少是最佳选择。 如果在超出初始容量时需要重新分配空间和复制内存，则未能为集合指定初始容量可能会导致性能问题。\n此检查会检查在检查的设置中列出的类的分配。\n\n**示例：**\n\n\n      new HashMap<String, String>();\n\n使用以下选项配置检查：\n\n* 列出应检查的集合类。\n* 是否忽略字段初始值设定项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionWithoutInitialCapacity",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleCheckedLocking",
                "shortDescription": {
                  "text": "双重检查锁定"
                },
                "fullDescription": {
                  "text": "报告双重检查锁定。 双重检查锁定会尝试以线程安全的方式按需初始化字段，同时避免同步的开销。 遗憾的是，在未被声明为 'volatile' 的字段上使用时，它不具备线程安全。 在使用 Java 1.4 或更早的版本时，双重检查锁定即便对 'volatile' 字段也不起作用。 阅读上面的链接文章，了解该问题的详细说明。 不正确的双重检查锁定示例： 'class Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n      if (helper == null)\n        synchronized(this) {\n          if (helper == null) helper = new Helper();\n        }\n        return helper;\n      }\n    }\n    // 其他函数和成员…\n  }'",
                  "markdown": "报告[双重检查锁定](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)。\n\n\n双重检查锁定会尝试以线程安全的方式按需初始化字段，同时避免同步的开销。\n遗憾的是，在未被声明为 `volatile` 的字段上使用时，它不具备线程安全。\n在使用 Java 1.4 或更早的版本时，双重检查锁定即便对 `volatile` 字段也不起作用。\n阅读上面的链接文章，了解该问题的详细说明。\n\n不正确的双重检查锁定示例：\n\n\n      class Foo {\n        private Helper helper = null;\n        public Helper getHelper() {\n          if (helper == null)\n            synchronized(this) {\n              if (helper == null) helper = new Helper();\n            }\n            return helper;\n          }\n        }\n        // 其他函数和成员...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoubleCheckedLocking",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassOnlyUsedInOneModule",
                "shortDescription": {
                  "text": "仅在其他模块中使用的类"
                },
                "fullDescription": {
                  "text": "报告符合以下情况的类： 不依赖于其模块中的任何其他类 依赖于来自不同模块的类 仅是来自该其他模块的类的依赖项 这种类可以移动到它们所依赖的模块中。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告符合以下情况的类：\n\n* 不依赖于其模块中的任何其他类\n* 依赖于来自不同模块的类\n* 仅是来自该其他模块的类的依赖项\n\n这种类可以移动到它们所依赖的模块中。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassOnlyUsedInOneModule",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TryStatementWithMultipleResources",
                "shortDescription": {
                  "text": "可以拆分具有多个资源的 'try' 语句"
                },
                "fullDescription": {
                  "text": "报告带有多个资源的 'try' 语句，这些语句可以自动拆分为多条 try-with-resources 语句。 这种转换对于进一步重构很有用 （例如，用于将嵌套的 'try' 语句提取到单独的方法中）。 示例： 'try (FileInputStream in = new FileInputStream(\"in.txt\");\n     FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n     /*读取和写入*/\n  }' 在应用快速修复后： 'try (FileInputStream in = new FileInputStream(\"in.txt\")) {\n    try (FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n      /*读取和写入*/\n    }\n  }'",
                  "markdown": "报告带有多个资源的 `try` 语句，这些语句可以自动拆分为多条 try-with-resources 语句。\n\n这种转换对于进一步重构很有用 （例如，用于将嵌套的 `try` 语句提取到单独的方法中）。\n\n示例：\n\n\n      try (FileInputStream in = new FileInputStream(\"in.txt\");\n         FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n         /*读取和写入*/\n      }\n\n在应用快速修复后：\n\n\n      try (FileInputStream in = new FileInputStream(\"in.txt\")) {\n        try (FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n          /*读取和写入*/\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TryStatementWithMultipleResources",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeMayBeWeakened",
                "shortDescription": {
                  "text": "类型可能被削弱"
                },
                "fullDescription": {
                  "text": "报告可以更改为更抽象（更弱）类型的变量和方法返回类型。 这使代码更抽象，因此可重用性更高。 示例： '// 形参类型可以削弱为 java.util.List\n  void processList(ArrayList<String> list) {\n    if (list.isEmpty()) return;\n    System.out.println(\"Processing\");\n    for (String s : list) {\n      System.out.println(\"String: \" + s);\n    }\n  }' 启用下面的仅削弱为接口复选框可以仅在类型可以削弱为接口类型时报告问题。 启用下面的不建议削弱声明为 'var' 的变量复选框可以防止报告使用 'var' 关键字声明的局部变量 (Java 10+) 停止类意在防止类削弱至低于停止类的程度，即便可能出现这种情况，也能予以防止。 在某些情况下，这可能会提高可读性。",
                  "markdown": "报告可以更改为更抽象（更弱）类型的变量和方法返回类型。 这使代码更抽象，因此可重用性更高。\n\n示例：\n\n\n      // 形参类型可以削弱为 java.util.List\n      void processList(ArrayList<String> list) {\n        if (list.isEmpty()) return;\n        System.out.println(\"Processing\");\n        for (String s : list) {\n          System.out.println(\"String: \" + s);\n        }\n      }\n\n\n启用下面的**仅削弱为接口**复选框可以仅在类型可以削弱为接口类型时报告问题。\n\n\n启用下面的**不建议削弱声明为 'var' 的变量**复选框可以防止报告使用 'var' 关键字声明的局部变量 (Java 10+)\n\n\n**停止类**意在防止类削弱至低于停止类的程度，即便可能出现这种情况，也能予以防止。\n在某些情况下，这可能会提高可读性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeMayBeWeakened",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneableImplementsClone",
                "shortDescription": {
                  "text": "没有 'clone()' 方法的可克隆类"
                },
                "fullDescription": {
                  "text": "报告实现 'Cloneable' 接口但不重写 'clone()' 方法的类。 这种类使用 'clone()' 的默认实现，它不是 'public'，而是 'protected'，并且不复制该类的可变状态。 可以通过快速修复生成基本的 'clone()' 方法，它可以作为 'Cloneable' 类所期望的正常运行的 'clone()' 方法的基础。 示例： 'public class Data implements Cloneable {\n    private String[] names;\n  }' 在应用快速修复后： 'public class Data implements Cloneable {\n    private String[] names;\n\n    @Override\n    public Data clone() {\n      try {\n        Data clone = (Data) super.clone();\n        // TODO：在此处复制可变状态，因此克隆无法更改原始克隆的内部项 \n         return clone;\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }' 使用忽略由于继承而可克隆的类选项可以忽略因继承自 'Cloneable' 类而 'Cloneable' 的类。 使用忽略需要 Cloneable 才能调用超类的 clone() 方法的情况选项可以忽略因从超类调用 'clone()' 方法而需要实现 'Cloneable' 的类。",
                  "markdown": "报告实现 `Cloneable` 接口但不重写 `clone()` 方法的类。\n\n这种类使用 `clone()` 的默认实现，它不是 `public`，而是 `protected`，并且不复制该类的可变状态。\n\n可以通过快速修复生成基本的 `clone()` 方法，它可以作为 `Cloneable` 类所期望的正常运行的 `clone()` 方法的基础。\n\n**示例：**\n\n\n      public class Data implements Cloneable {\n        private String[] names;\n      }\n\n在应用快速修复后：\n\n\n      public class Data implements Cloneable {\n        private String[] names;\n\n        @Override\n        public Data clone() {\n          try {\n            Data clone = (Data) super.clone();\n            // TODO：在此处复制可变状态，因此克隆无法更改原始克隆的内部项 \n             return clone;\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n\n使用**忽略由于继承而可克隆的类** 选项可以忽略因继承自 `Cloneable` 类而 `Cloneable` 的类。\n\n使用**忽略需要 Cloneable 才能调用超类的 clone() 方法的情况** 选项可以忽略因从超类调用 `clone()` 方法而需要实现 `Cloneable` 的类。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneableClassWithoutClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OctalAndDecimalIntegersMixed",
                "shortDescription": {
                  "text": "同一数组中的八进制和十进制整数"
                },
                "fullDescription": {
                  "text": "报告单个数组初始值设定项中混合的八进制和十进制整数文字。 当您将数字列表复制到数组初始值设定项中时，可能会发生这种情况。 数组中的某些数字可能用零填充，编译器会将它们解释为八进制。 示例： 'int[] elapsed = {1, 13, 052};' 应用移除前导零的快速修复后： 'int[] elapsed = {1, 13, 52};' 如果它是一个八进制数（例如，在内联变量之后），那么您可以使用另一个将八进制转换为十进制的快速修复： 'int[] elapsed = {1, 13, 42};'",
                  "markdown": "报告单个数组初始值设定项中混合的八进制和十进制整数文字。 当您将数字列表复制到数组初始值设定项中时，可能会发生这种情况。 数组中的某些数字可能用零填充，编译器会将它们解释为八进制。\n\n**示例：**\n\n    int[] elapsed = {1, 13, 052};\n\n应用移除前导零的快速修复后：\n\n    int[] elapsed = {1, 13, 52};\n\n如果它是一个八进制数（例如，在内联变量之后），那么您可以使用另一个将八进制转换为十进制的快速修复：\n`int[] elapsed = {1, 13, 42};`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OctalAndDecimalIntegersInSameArray",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Deprecation",
                "shortDescription": {
                  "text": "弃用的 API 用法"
                },
                "fullDescription": {
                  "text": "报告已弃用类、字段和方法的用法。 当可以从已弃用成员的 Javadoc 中提取必要的信息时，可以使用快速修复来自动转换已弃用的用法。 示例： 'class Interesting {\n\n    /**\n     * @deprecated 改用 {@link #newHotness()}\n     */\n    @Deprecated\n    public void oldAndBusted() {}\n\n    public void newHotness() {}\n  }\n  class ElseWhere {\n    void x(Interesting i) {\n      i.oldAndBusted(); // 此处为已弃用警告\n    }\n  }' 在应用快速修复后： 'class Interesting {\n\n    /**\n     * @deprecated 改用 {@link #newHotness()}\n     */\n    @Deprecated\n    public void oldAndBusted() {}\n\n    public void newHotness() {}\n  }\n  class ElseWhere {\n    void x(Interesting i) {\n      i.newHotness();\n    }\n  }' 默认情况下，如果不可能或很难避免，则检查不会发出警告。 比如下面的代码就不会被报告： 'abstract class A { //库代码\n     @Deprecated\n     abstract void m();\n  }\n  class B extends A { //项目代码\n     @Override\n     void m() {\n        //doSmth;\n     }\n  }' 配置检查： 使用选项可以在弃用成员、abstract 弃用方法重写、非 static import 语句、弃用类的方法或相同的顶级类中禁用此检查。",
                  "markdown": "报告已弃用类、字段和方法的用法。 当可以从已弃用成员的 Javadoc 中提取必要的信息时，可以使用快速修复来自动转换已弃用的用法。\n\n**示例：**\n\n\n      class Interesting {\n\n        /**\n         * @deprecated 改用 {@link #newHotness()}\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.oldAndBusted(); // 此处为已弃用警告\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Interesting {\n\n        /**\n         * @deprecated 改用 {@link #newHotness()}\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.newHotness();\n        }\n      }\n\n默认情况下，如果不可能或很难避免，则检查不会发出警告。 比如下面的代码就不会被报告：\n\n\n      abstract class A { //库代码\n         @Deprecated\n         abstract void m();\n      }\n      class B extends A { //项目代码\n         @Override\n         void m() {\n            //doSmth;\n         }\n      }\n\n配置检查：\n\n\n使用选项可以在弃用成员、abstract 弃用方法重写、非 static import 语句、弃用类的方法或相同的顶级类中禁用此检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "deprecation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisspelledMethodName",
                "shortDescription": {
                  "text": "方法名称仅大小写不同"
                },
                "fullDescription": {
                  "text": "报告一个类的多个方法的名称仅大小写不同的情况。 此类名称可能非常令人困惑。 示例： 'public int hashcode() { // 已报告，可能应为 hashCode？\n    return 0;\n  }' 只能在编辑器中使用重命名此类方法的快速修复。 使用忽略方法重写/实现 super 方法选项，可以忽略重写或实现超类中方法的方法。",
                  "markdown": "报告一个类的多个方法的名称仅大小写不同的情况。 此类名称可能非常令人困惑。\n\n**示例：**\n\n\n      public int hashcode() { // 已报告，可能应为 hashCode？\n        return 0;\n      }\n\n只能在编辑器中使用重命名此类方法的快速修复。\n\n使用**忽略方法重写/实现 super 方法**选项，可以忽略重写或实现超类中方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodNamesDifferingOnlyByCase",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableObjectBoundToHttpSession",
                "shortDescription": {
                  "text": "不可序列化的对象被绑定到了 'HttpSession'"
                },
                "fullDescription": {
                  "text": "报告未实现用作 'javax.servlet.http.HttpSession.setAttribute()' 或 'javax.servlet.http.HttpSession.putValue()' 实参的 'java.io.Serializable' 的类对象。 如果 'HttpSession' 被钝化或迁移，则不会序列化此类对象，并且可能导致难以诊断的错误。 此检查假定 'java.util.Collection' 和 'java.util.Map' 类型的对象为 'Serializable'，除非类型形参为非 'Serializable'。 示例： 'void foo(HttpSession session) {\n      session.setAttribute(\"foo\", new NonSerializable());\n  }\n  static class NonSerializable {}'",
                  "markdown": "报告未实现用作 `javax.servlet.http.HttpSession.setAttribute()` 或 `javax.servlet.http.HttpSession.putValue()` 实参的 `java.io.Serializable` 的类对象。\n\n\n如果 `HttpSession` 被钝化或迁移，则不会序列化此类对象，并且可能导致难以诊断的错误。\n\n\n此检查假定 `java.util.Collection` 和\n`java.util.Map` 类型的对象为 `Serializable`，除非类型形参为非 `Serializable`。\n\n**示例：**\n\n\n      void foo(HttpSession session) {\n          session.setAttribute(\"foo\", new NonSerializable());\n      }\n      static class NonSerializable {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableObjectBoundToHttpSession",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadLocalNotStaticFinal",
                "shortDescription": {
                  "text": "'ThreadLocal' 字段未被声明为 'static final'"
                },
                "fullDescription": {
                  "text": "报告未被声明为 'static final' 的 'java.lang.ThreadLocal' 类型的字段。 在最常见的情况下，'java.lang.ThreadLocal' 实例会将状态与线程关联。 非 static、非 final 'java.lang.ThreadLocal' 字段会将状态与实例线程组合关联。 这通常是不必要的，而且通常是可能导致内存泄漏和行为不正确的错误。 建议通过快速修复将该字段设为 'static final'。 示例： 'private ThreadLocal tl = ThreadLocal.withInitial(() -> Boolean.TRUE);'",
                  "markdown": "报告未被声明为 `static final` 的 `java.lang.ThreadLocal` 类型的字段。\n\n\n在最常见的情况下，`java.lang.ThreadLocal` 实例会将状态与线程关联。\n非 static、非 final `java.lang.ThreadLocal` 字段会将状态与实例线程组合关联。\n这通常是不必要的，而且通常是可能导致内存泄漏和行为不正确的错误。\n\n\n建议通过快速修复将该字段设为 `static final`。\n\n\n**示例：**\n\n\n      private ThreadLocal tl = ThreadLocal.withInitial(() -> Boolean.TRUE);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThreadLocalNotStaticFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionSignal",
                "shortDescription": {
                  "text": "调用 'signal()' 而不是 'signalAll()'"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.concurrent.locks.Condition.signal()' 的调用。 虽然偶尔有用，但在几乎所有情况下，'signalAll()' 都是更好、更安全的选择。",
                  "markdown": "报告对 `java.util.concurrent.locks.Condition.signal()` 的调用。 虽然偶尔有用，但在几乎所有情况下，`signalAll()` 都是更好、更安全的选择。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSignalInsteadOfSignalAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AccessStaticViaInstance",
                "shortDescription": {
                  "text": "通过实例引用访问 static 成员"
                },
                "fullDescription": {
                  "text": "报告通过类实例而非类本身对 'static' 方法和字段的引用。 虽然 Java 语言规范允许使用实例变量引用 static 成员，但读者可能会误认为该方法依赖于实例，从而使代码令人困惑。 该快速修复会将实例变量替换为类名。 示例： 'String s1 = s.valueOf(0);' 在应用快速修复后： 'String s = String.valueOf(0);'",
                  "markdown": "报告通过类实例而非类本身对 `static` 方法和字段的引用。\n\n虽然 Java 语言规范允许使用实例变量引用 static 成员，但读者可能会误认为该方法依赖于实例，从而使代码令人困惑。\n\n该快速修复会将实例变量替换为类名。\n\n示例：\n\n\n      String s1 = s.valueOf(0);\n\n在应用快速修复后：\n\n\n      String s = String.valueOf(0);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessStaticViaInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicMethodWithoutLogging",
                "shortDescription": {
                  "text": "'public' 方法没有日志记录"
                },
                "fullDescription": {
                  "text": "报告任何不包含日志记录语句的 public 方法。 此检查不报告简单的 getter 和 setter。 示例： 'public class Crucial {\n    private static final Logger LOG = LoggerFactory.getLogger(Crucial.class);\n    public void doImportantStuff() {\n      // 对此方法发出警告\n    }\n\n    public void doOtherStuff() {\n      LOG.info(\"do other stuff\");\n    }\n  }' 使用下表可指定 Logger 类名。 此检查将报告不使用指定类的实例方法的 public 方法。",
                  "markdown": "报告任何不包含日志记录语句的 public 方法。 此检查不报告简单的 getter 和 setter。\n\n示例：\n\n\n      public class Crucial {\n        private static finalLogger LOG = LoggerFactory.getLogger(Crucial.class);\n        public void doImportantStuff() {\n          // 对此方法发出警告\n        }\n\n        public void doOtherStuff() {\n          LOG.info(\"do other stuff\");\n        }\n      }\n\n\n使用下表可指定 Logger 类名。\n此检查将报告不使用指定类的实例方法的 public 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicMethodWithoutLogging",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNestingDepth",
                "shortDescription": {
                  "text": "内部类嵌套太深"
                },
                "fullDescription": {
                  "text": "报告嵌套内部类的数量超过指定最大值的类。 将内部类嵌套在其他内部类中令人困惑，并表明可能有必要重构。 使用嵌套限制字段可指定类允许的最大嵌套深度。",
                  "markdown": "报告嵌套内部类的数量超过指定最大值的类。\n\n将内部类嵌套在其他内部类中令人困惑，并表明可能有必要重构。\n\n使用**嵌套限制**字段可指定类允许的最大嵌套深度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassTooDeeplyNested",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToNativeMethodWhileLocked",
                "shortDescription": {
                  "text": "锁定时调用 'native' 方法"
                },
                "fullDescription": {
                  "text": "报告 'synchronized' 块或方法中的调用 'native' 方法。 如果可能，最好将对 'native' 方法的调用排除在同步上下文之外，因为此类调用会导致开销巨大的上下文切换，并且可能导致性能问题。 示例： 'native void nativeMethod();\n\n  void example(){\n    synchronized (lock){\n      nativeMethod();//警告\n    }\n  }'",
                  "markdown": "报告 `synchronized` 块或方法中的调用 `native` 方法。\n\n\n如果可能，最好将对 `native` 方法的调用排除在同步上下文之外，因为此类调用会导致开销巨大的上下文切换，并且可能导致性能问题。\n\n**示例：**\n\n\n      native void nativeMethod();\n\n      void example(){\n        synchronized (lock){\n          nativeMethod();//警告\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToNativeMethodWhileLocked",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Dependency",
                "shortDescription": {
                  "text": "非法的软件包依赖项"
                },
                "fullDescription": {
                  "text": "根据指定依赖关系规则报告范围之间的非法依赖关系。 依赖关系规则可用于禁止从一个范围到另一个范围的用法。 使用下面的配置依赖关系规则按钮可以自定义验证规则。",
                  "markdown": "根据指定依赖关系规则报告范围之间的非法依赖关系。 依赖关系规则可用于禁止从一个范围到另一个范围的用法。\n\n使用下面的**配置依赖关系规则**按钮可以自定义验证规则。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Dependency",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestingDepth",
                "shortDescription": {
                  "text": "过度嵌套的方法"
                },
                "fullDescription": {
                  "text": "报告主体包含嵌套过深语句的方法。 语句嵌套过深的方法可能令人困惑，并且表明可能有必要重构。 使用嵌套深度限制字段可指定方法允许的最大嵌套深度。",
                  "markdown": "报告主体包含嵌套过深语句的方法。\n\n语句嵌套过深的方法可能令人困惑，并且表明可能有必要重构。\n\n使用**嵌套深度限制**字段可指定方法允许的最大嵌套深度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyNestedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaParameterTypeCanBeSpecified",
                "shortDescription": {
                  "text": "可以指定 lambda 形参类型"
                },
                "fullDescription": {
                  "text": "报告未指定其类型的 lambda 形参并建议添加缺少的类型声明。 示例： 'Function<String, Integer> length = a -> a.length();' 在应用快速修复后： 'Function<String, Integer> length = (String a) -> a.length();' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告未指定其类型的 lambda 形参并建议添加缺少的类型声明。\n\n示例：\n\n\n      Function<String, Integer> length = a -> a.length();\n\n在应用快速修复后：\n\n\n      Function<String, Integer> length = (String a) -> a.length();\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaParameterTypeCanBeSpecified",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitChronoField",
                "shortDescription": {
                  "text": "可以简化对带有显式 'ChronoField' 或 'ChronoUnit' 实参的 'java.time' 方法的调用"
                },
                "fullDescription": {
                  "text": "当将 'java.time.temporal.ChronoField' 和 'java.time.temporal.ChronoUnit' 作为实参的 'java.time' 方法调用可被替换为更具体的方法时，报告这些调用。 示例： 'LocalTime localTime = LocalTime.now();\nint minute = localTime.get(ChronoField.MINUTE_OF_HOUR);' 在应用快速修复后： 'LocalTime localTime = LocalTime.now();\nint minute = localTime.getMinute();' 2023.2 最新变化",
                  "markdown": "当将 `java.time.temporal.ChronoField` 和 `java.time.temporal.ChronoUnit` 作为实参的 `java.time` 方法调用可被替换为更具体的方法时，报告这些调用。\n\n示例：\n\n\n    LocalTime localTime = LocalTime.now();\n    int minute = localTime.get(ChronoField.MINUTE_OF_HOUR);\n\n在应用快速修复后：\n\n\n    LocalTime localTime = LocalTime.now();\n    int minute = localTime.getMinute();\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitChronoField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextLabelInSwitchStatement",
                "shortDescription": {
                  "text": "'switch' 语句中的文本标签"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句中的标签语句。 虽然偶尔是有意为之，但此结构通常由拼写错误所致。 示例： 'switch (x) {\n      case 1:\n      case2:   // 警告：'switch' 语句中存在文本标签 'case2:'\n      case 3:\n          break;\n  }'",
                  "markdown": "报告 `switch` 语句中的标签语句。 虽然偶尔是有意为之，但此结构通常由拼写错误所致。\n\n**示例：**\n\n\n      switch (x) {\n          case 1:\n          case2:   // 警告：'switch' 语句中存在文本标签 'case2:'\n          case 3:\n              break;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TextLabelInSwitchStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageVisibleInnerClass",
                "shortDescription": {
                  "text": "软件包可见的嵌套类"
                },
                "fullDescription": {
                  "text": "报告在没有任何访问修饰符（也称为 package-private）的情况下声明的嵌套类。 示例： 'public class Outer {\n    static class Nested {}  // 警告\n    class Inner {}          // 警告\n    enum Mode {}            // 警告取决于设置\n    interface I {}          // 警告取决于设置\n  }' 配置检查： 使用忽略软件包可见的内部枚举选项可忽略 package-private 内部枚举。 使用忽略软件包可见的内部接口选项可忽略 package-private 内部接口。",
                  "markdown": "报告在没有任何访问修饰符（也称为 package-private）的情况下声明的嵌套类。\n\n**示例：**\n\n\n      public class Outer {\n        static class Nested {}  // 警告\n        class Inner {}          // 警告\n        enum Mode {}            // 警告取决于设置\n        interface I {}          // 警告取决于设置\n      }\n\n配置检查：\n\n* 使用**忽略软件包可见的内部枚举**选项可忽略 package-private 内部枚举。\n* 使用**忽略软件包可见的内部接口**选项可忽略 package-private 内部接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageVisibleInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryUnaryMinus",
                "shortDescription": {
                  "text": "不必要的一元负号"
                },
                "fullDescription": {
                  "text": "报告不必要的一元减号。 此类表达式可能难以理解并且可能包含错误。 示例： 'void unaryMinus(int i) {\n    int x = - -i;\n  }' 此处建议使用以下快速修复： 移除 'i' 变量前的 '-' 运算符： 'void unaryMinus(int i) {\n    int x = i;\n  }' 使用前缀递减运算符替换 '-' 运算符： 'void unaryMinus(int i) {\n    int x = --i;\n  }' 另一个示例： 'void unaryMinus(int i) {\n    i += - 8;\n  }' 在应用快速修复后： 'void unaryMinus(int i) {\n    i -= 8;\n  }'",
                  "markdown": "报告不必要的一元减号。 此类表达式可能难以理解并且可能包含错误。\n\n**示例：**\n\n    void unaryMinus(int i) {\n        int x = - -i;\n      }\n\n此处建议使用以下快速修复：\n\n* 移除 `i` 变量前的 `-` 运算符：\n\n      void unaryMinus(int i) {\n          int x = i;\n        }\n\n* 使用前缀递减运算符替换 `-` 运算符：\n\n      void unaryMinus(int i) {\n          int x = --i;\n        }\n\n**另一个示例：**\n\n    void unaryMinus(int i) {\n        i += - 8;\n      }\n\n在应用快速修复后：\n\n    void unaryMinus(int i) {\n        i -= 8;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryUnaryMinus",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WriteOnlyObject",
                "shortDescription": {
                  "text": "只写入对象"
                },
                "fullDescription": {
                  "text": "报告已修改但从未查询的对象。 该检查依赖于方法突变协定，对于某些库方法，可以推断或预先注解突变协定。 此检查不报告集合、映射和字符串构建器，因为其他更精准的检查会报告这些类型。 示例： 'AtomicReference<String> ref = new AtomicReference<>();\n  ref.set(\"hello\"); // ref 不再使用' 使用忽略不纯的构造函数选项可以控制是否处理由构造函数或纯度未知的方法创建的对象。 如果在构造过程中故意泄漏对象引用，取消选中该选项可能会引起某些误报。 2021.2 最新变化",
                  "markdown": "报告已修改但从未查询的对象。\n\n该检查依赖于方法突变协定，对于某些库方法，可以推断或预先注解突变协定。 此检查不报告集合、映射和字符串构建器，因为其他更精准的检查会报告这些类型。\n\n示例：\n\n\n      AtomicReference<String> ref = new AtomicReference<>();\n      ref.set(\"hello\"); // ref 不再使用\n\n\n使用**忽略不纯的构造函数**选项可以控制是否处理由构造函数或纯度未知的方法创建的对象。\n如果在构造过程中故意泄漏对象引用，取消选中该选项可能会引起某些误报。\n**2021.2 最新变化**"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WriteOnlyObject",
                    "cweIds": [
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodMayBeStatic",
                "shortDescription": {
                  "text": "方法可以为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以安全设置为 'static' 的方法。 尽可能将方法设置为 static 可减少内存消耗并提高代码质量。 如果满足以下条件，则方法可以为 'static'： 不是 'synchronized'、'native' 或 'abstract'， 不引用包含类中的任何非 static 方法和非 static 字段， 不是重写，也不会在子类中被重写。 使用以下选项配置检查： 是否只报告 'private' 和 'final' 方法，从而提高此检查的性能。 是否忽略空方法。 使用 Java 8 或更高版本时是否忽略接口中的默认方法。 是否让该快速修复在调用被设为 'static' 的方法时使用类引用替换实例限定符，即调用 'myClass.m()' 将被替换为 'MyClass.m()'。",
                  "markdown": "报告可以安全设置为 `static` 的方法。 尽可能将方法设置为 static 可减少内存消耗并提高代码质量。\n\n如果满足以下条件，则方法可以为 `static`：\n\n* 不是 `synchronized`、`native` 或 `abstract`，\n* 不引用包含类中的任何非 static 方法和非 static 字段，\n* 不是重写，也不会在子类中被重写。\n\n使用以下选项配置检查：\n\n* 是否只报告 `private` 和 `final` 方法，从而提高此检查的性能。\n* 是否忽略空方法。\n* 使用 Java 8 或更高版本时是否忽略接口中的默认方法。\n* 是否让该快速修复在调用被设为 `static` 的方法时使用类引用替换实例限定符，即调用 `myClass.m()` 将被替换为 `MyClass.m()`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestMethodWithoutAssertion",
                "shortDescription": {
                  "text": "不带断言的测试方法"
                },
                "fullDescription": {
                  "text": "报告不包含任何断言的测试方法。 此类方法可能表示测试用例不完整或薄弱。 示例： 'public class ExtensiveTest {\n\n    @Test\n    public void testAlive() {\n      System.out.println(\"nothing\");\n    }\n  }' 配置检查： 使用该表可以指定应作为断言的完全限定类名和方法名正则表达式的组合。 类名也匹配子类。 使用 'assert' 关键字被视为断言选项可以指定是否应将使用 'assert' 关键字的 Java 'assert' 语句视为断言。 使用忽略声明异常的测试方法选项可以忽略声明异常的测试方法。 当您的测试会在失败时抛出异常并因此不需要任何断言时，这会很有用。",
                  "markdown": "报告不包含任何断言的测试方法。 此类方法可能表示测试用例不完整或薄弱。\n\n**示例：**\n\n\n      public class ExtensiveTest {\n\n        @Test\n        public void testAlive() {\n          System.out.println(\"nothing\");\n        }\n      }\n\n\n配置检查：\n\n* 使用该表可以指定应作为断言的完全限定类名和方法名正则表达式的组合。 类名也匹配子类。\n* 使用 **'assert' 关键字被视为断言** 选项可以指定是否应将使用 `assert` 关键字的 Java `assert` 语句视为断言。\n* 使用**忽略声明异常的测试方法**选项可以忽略声明异常的测试方法。 当您的测试会在失败时抛出异常并因此不需要任何断言时，这会很有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestMethodWithoutAssertion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SocketResource",
                "shortDescription": {
                  "text": "套接字已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的套接字资源。 此检查报告的套接字资源包括 'java.net.Socket'、'java.net.DatagramSocket' 和 'java.net.ServerSocket'。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'byte[] getMessage(ServerSocket socket) throws IOException {\n    Socket client = socket.accept(); //套接字未关闭\n    return client.getInputStream().readAllBytes();\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开套接字。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的套接字资源。 此检查报告的套接字资源包括 `java.net.Socket`、`java.net.DatagramSocket` 和 `java.net.ServerSocket`。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      byte[] getMessage(ServerSocket socket) throws IOException {\n        Socket client = socket.accept(); //套接字未关闭\n        return client.getInputStream().readAllBytes();\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开套接字。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SocketOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeParameterHidesVisibleType",
                "shortDescription": {
                  "text": "类型形参隐藏可见类型"
                },
                "fullDescription": {
                  "text": "报告与当前范围中的可见类型名称相同的类型形参。 此类形参名称可能令人困惑。 示例： 'abstract class MyList<T> extends AbstractList<T> {\n    private List<T> elements;\n    // 类型形参 'T' 隐藏类型形参 'T'\n    public <T> T[] toArray(T[] array) {\n        return elements.toArray(array);\n    }\n}'",
                  "markdown": "报告与当前范围中的可见类型名称相同的类型形参。 此类形参名称可能令人困惑。\n\n示例：\n\n\n      abstract class MyList<T> extends AbstractList<T> {\n        private List<T> elements;\n        // 类型形参 'T' 隐藏类型形参 'T'\n        public <T> T[] toArray(T[] array) {\n            return elements.toArray(array);\n        }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeParameterHidesVisibleType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTokenizerDelimiter",
                "shortDescription": {
                  "text": "'StringTokenizer' 中的分隔符重复"
                },
                "fullDescription": {
                  "text": "报告在分隔符实参中包含重复字符的 'StringTokenizer()' 构造函数调用或 'nextToken()' 方法调用。 示例： 'void printTokens(String text) {\n    StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\\n\");\n    while (tokenizer.hasMoreTokens()) {\n      System.out.println(tokenizer.nextToken());\n    }\n  }' 在应用快速修复后： 'void printTokens(String text) {\n    StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\");\n    while (tokenizer.hasMoreTokens()) {\n      System.out.println(tokenizer.nextToken());\n    }\n  }'",
                  "markdown": "报告在分隔符实参中包含重复字符的 `StringTokenizer()` 构造函数调用或 `nextToken()` 方法调用。\n\n**示例：**\n\n\n      void printTokens(String text) {\n        StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\\n\");\n        while (tokenizer.hasMoreTokens()) {\n          System.out.println(tokenizer.nextToken());\n        }\n      }\n\n在应用快速修复后：\n\n\n      void printTokens(String text) {\n        StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\");\n        while (tokenizer.hasMoreTokens()) {\n          System.out.println(tokenizer.nextToken());\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringTokenizerDelimiter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MaskedAssertion",
                "shortDescription": {
                  "text": "断言通过 'catch' 禁止"
                },
                "fullDescription": {
                  "text": "报告被周围的 catch 块禁止的 'assert' 语句和测试框架断言。 此类断言永远不会失败，因为将捕获并无提示地忽略抛出的 'AssertionError'。 示例 1： 'void javaAssertion() {\n    try {\n      ...\n      assert 1 == 2;\n    } catch (AssertionError e) {\n      // 该断言被无提示地忽略\n    }\n  }' 示例 2： '@Test\n  void testWithAssertJ() {\n    try {\n      ...\n      assertThat(1).as(\"test\").isEqualTo(2);\n    } catch (AssertionError e) {\n      // 该断言被无提示地忽略\n    }\n  }' 示例 3： '@Test\n  void testWithJunit() {\n    try {\n      ...\n      assertEquals(1, 2);\n    } catch (AssertionError e) {\n      // 该断言被无提示地忽略\n    }\n  }' 2020.3 最新变化",
                  "markdown": "报告被周围的 catch 块禁止的 `assert` 语句和测试框架断言。 此类断言永远不会失败，因为将捕获并无提示地忽略抛出的 `AssertionError`。\n\n**示例 1：**\n\n\n      void javaAssertion() {\n        try {\n          ...\n          assert 1 == 2;\n        } catch (AssertionError e) {\n          // 该断言被无提示地忽略\n        }\n      }\n\n**示例 2：**\n\n\n      @Test\n      void testWithAssertJ() {\n        try {\n          ...\n          assertThat(1).as(\"test\").isEqualTo(2);\n        } catch (AssertionError e) {\n          // 该断言被无提示地忽略\n        }\n      }\n\n**示例 3：**\n\n\n      @Test\n      void testWithJunit() {\n        try {\n          ...\n          assertEquals(1, 2);\n        } catch (AssertionError e) {\n          // 该断言被无提示地忽略\n        }\n      }\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MaskedAssertion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 97,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReflectionForUnavailableAnnotation",
                "shortDescription": {
                  "text": "对仅源注解的反射访问"
                },
                "fullDescription": {
                  "text": "报告对非运行时注解的存在与否执行反射性检查的尝试。 使用 'Class.isAnnotationPresent()' 测试保留策略设置为 'SOURCE' 或 'CLASS'（默认值）的注解是否始终得到否定结果。 此错误很容易被忽视。 示例： '{\n    getClass().isAnnotationPresent(SourceAnnotation.class); //始终为 false\n  }\n\n  @Retention(RetentionPolicy.SOURCE)\n  @interface SourceAnnotation {}' 此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。",
                  "markdown": "报告对非运行时注解的存在与否执行反射性检查的尝试。\n\n使用 `Class.isAnnotationPresent()` 测试保留策略设置为 `SOURCE` 或 `CLASS`（默认值）的注解是否始终得到否定结果。 此错误很容易被忽视。\n\n**示例：**\n\n\n      {\n        getClass().isAnnotationPresent(SourceAnnotation.class); //始终为 false\n      }\n\n      @Retention(RetentionPolicy.SOURCE)\n      @interface SourceAnnotation {}\n\n\n此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReflectionForUnavailableAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstantiatingObjectToGetClassObject",
                "shortDescription": {
                  "text": "实例化对象以获取 'Class' 对象"
                },
                "fullDescription": {
                  "text": "报告实例化类以获取其类对象的代码。 直接按名称访问类对象时的性能更好。 示例： 'Class<?> c = new Sample().getClass();' 在应用快速修复后： 'Class<?> c = Sample.class;'",
                  "markdown": "报告实例化类以获取其类对象的代码。\n\n直接按名称访问类对象时的性能更好。\n\n**示例：**\n\n\n      Class<?> c = new Sample().getClass();\n\n在应用快速修复后：\n\n\n      Class<?> c = Sample.class;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstantiatingObjectToGetClassObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithMultipleLoggers",
                "shortDescription": {
                  "text": "具有多个记录器的类"
                },
                "fullDescription": {
                  "text": "报告声明了多个记录器的类。 为应用程序提供统一的日志记录实现的一大重要步骤，是确保每个类都有一个专用的记录器。 示例： 'public class Critical {\n    protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n    protected static final Logger myLogger = Logger.getLogger(getClass());\n  }' 使用下表可指定 Logger 类名。 此检查将报告声明多个字段具有所指定类的类型之一的类。",
                  "markdown": "报告声明了多个记录器的类。 为应用程序提供统一的日志记录实现的一大重要步骤，是确保每个类都有一个专用的记录器。\n\n示例：\n\n\n      public class Critical {\n        protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n        protected static final Logger myLogger = Logger.getLogger(getClass());\n      }\n\n\n使用下表可指定 Logger 类名。\n此检查将报告声明多个字段具有所指定类的类型之一的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithMultipleLoggers",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ShiftOutOfRange",
                "shortDescription": {
                  "text": "按不当常量进行移位运算"
                },
                "fullDescription": {
                  "text": "报告移位值为超出合理范围的常量的移位运算。 报告 '0..31' 范围以外的整数移位运算以及 '0..63' 范围以外的长移位运算。 负值或过大值移位几乎肯定表明存在编码错误。 示例： 'int shiftSize = 32;\n  // 警告：移动 32 位相当于移动 0 位，所以根本没有移位。\n  int mask = (1 << shiftSize) - 1;'",
                  "markdown": "报告移位值为超出合理范围的常量的移位运算。\n\n报告 `0..31` 范围以外的整数移位运算以及 `0..63` 范围以外的长移位运算。 负值或过大值移位几乎肯定表明存在编码错误。\n\n**示例：**\n\n\n      int shiftSize = 32;\n      // 警告：移动 32 位相当于移动 0 位，所以根本没有移位。\n      int mask = (1 << shiftSize) - 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ShiftOutOfRange",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/按位运算问题",
                      "index": 98,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadRun",
                "shortDescription": {
                  "text": "调用 'Thread.run()'"
                },
                "fullDescription": {
                  "text": "报告对 'java.lang.Thread' 或其任何子类进行的 'run()' 调用。 虽然偶尔是有意为之，但这通常表明有错误，因为 'run()' 不会启动新线程。 要在单独的线程中执行代码，应使用 'start()'。",
                  "markdown": "报告对 `java.lang.Thread` 或其任何子类进行的 `run()` 调用。\n\n\n虽然偶尔是有意为之，但这通常表明有错误，因为 `run()` 不会启动新线程。\n要在单独的线程中执行代码，应使用 `start()`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadRun",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EscapedSpace",
                "shortDescription": {
                  "text": "'\\s' 转义序列的非终止使用"
                },
                "fullDescription": {
                  "text": "报告在除文本块行结尾以外的任何位置或在一系列多个转义空格内的 '\\s' 转义序列。 此类用法可能会造成困惑或出错，尤其是在将字符串解释为正则表达式的情况下。 '\\s' 转义序列用于在文本块行末尾编码一个空格，其中，普通空格将被修剪。 在其他位置，以及在常规字符串或字符文字中，'\\s' 与普通空格字符 ('\" \"') 相同。 示例： 'if (str.matches(\"\\s+\")) {...}' 在这里，'\"\\\\s+\"' 可能是有意为之（以匹配任何空白字符）。 如果不是，使用 'str.matches(\" +\")' 则不那么容易造成困惑。 提供的快速修复是将 '\\s' 转义替换为空格字符。 2022.3 最新变化 此检查取决于 Java 功能 ''\\s'转义序列'，该功能自 Java 15 起可用。",
                  "markdown": "报告在除文本块行结尾以外的任何位置或在一系列多个转义空格内的 `\\s` 转义序列。 此类用法可能会造成困惑或出错，尤其是在将字符串解释为正则表达式的情况下。 `\\s` 转义序列用于在文本块行末尾编码一个空格，其中，普通空格将被修剪。 在其他位置，以及在常规字符串或字符文字中，`\\s` 与普通空格字符 (`\" \"`) 相同。\n\n**示例：**\n\n\n      if (str.matches(\"\\s+\")) {...}\n\n在这里，`\"\\\\s+\"` 可能是有意为之（以匹配任何空白字符）。 如果不是，使用 `str.matches(\" +\")` 则不那么容易造成困惑。\n\n\n提供的快速修复是将 `\\s` 转义替换为空格字符。\n\n2022.3 最新变化\n\n此检查取决于 Java 功能 ''\\\\s'转义序列'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EscapedSpace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsThrowable",
                "shortDescription": {
                  "text": "类直接扩展 'Throwable'"
                },
                "fullDescription": {
                  "text": "报告直接扩展 'java.lang.Throwable' 的类。 直接扩展 'java.lang.Throwable' 通常被认为是一种不好的做法。 通常扩展 'java.lang.RuntimeException'、'java.lang.Exception' 或在特殊情况下扩展 'java.lang.Error' 就足够了。 示例： 'class EnigmaThrowable extends Throwable {} // 警告：'EnigmaThrowable' 类会直接扩展 'java.lang.Throwable''",
                  "markdown": "报告直接扩展 `java.lang.Throwable` 的类。\n\n直接扩展 `java.lang.Throwable` 通常被认为是一种不好的做法。\n通常扩展 `java.lang.RuntimeException`、`java.lang.Exception` 或在特殊情况下扩展 `java.lang.Error` 就足够了。\n\n**示例：**\n\n\n      class EnigmaThrowable extends Throwable {} // 警告：'EnigmaThrowable' 类会直接扩展 'java.lang.Throwable'\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExtendsThrowable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AutoBoxing",
                "shortDescription": {
                  "text": "自动装箱"
                },
                "fullDescription": {
                  "text": "报告受自动装箱转换（将基元值自动包装为对象）影响的表达式。 尽量不使用对象，而是使用基元。 它可能会显著影响性能。 示例： 'Integer x = 42;' 该快速修复会将转换设为显式： 'Integer x = Integer.valueOf(42);' 自动装箱在 Java 5 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告受自动装箱转换（将基元值自动包装为对象）影响的表达式。 尽量不使用对象，而是使用基元。 它可能会显著影响性能。\n\n**示例：**\n\n    Integer x = 42;\n\n该快速修复会将转换设为显式：\n\n    Integer x = Integer.valueOf(42);\n\n\n*自动装箱*在 Java 5 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AutoBoxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceNeverImplemented",
                "shortDescription": {
                  "text": "没有具体子类的接口"
                },
                "fullDescription": {
                  "text": "报告没有具体子类的接口。 配置检查： 使用下面的列表可以添加注解。 该检查将忽略使用其中一种注解声明的接口。 使用下面的复选框可以忽略仅声明常量字段的接口。 即使没有实现，仍然可以使用此类接口。",
                  "markdown": "报告没有具体子类的接口。\n\n配置检查：\n\n* 使用下面的列表可以添加注解。 该检查将忽略使用其中一种注解声明的接口。\n* 使用下面的复选框可以忽略仅声明常量字段的接口。 即使没有实现，仍然可以使用此类接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceNeverImplemented",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueStatement",
                "shortDescription": {
                  "text": "'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告 'continue' 语句。 'continue' 语句导致重构复杂化，可能令人困惑。 示例： 'void foo(List<String> strs) {\n    for (String str : strs) {\n      if (str.contains(\"skip\")) continue;\n      handleStr(str);\n    }\n  }'",
                  "markdown": "报告 `continue` 语句。\n\n`continue` 语句导致重构复杂化，可能令人困惑。\n\n示例：\n\n\n      void foo(List<String> strs) {\n        for (String str : strs) {\n          if (str.contains(\"skip\")) continue;\n          handleStr(str);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadDeathRethrown",
                "shortDescription": {
                  "text": "'ThreadDeath' 未重新抛出"
                },
                "fullDescription": {
                  "text": "报告捕获 'java.lang.ThreadDeath' 并且不重新抛出异常的 'try' 语句。 示例： 'try {\n    executeInParallel(request);\n  } catch (ThreadDeath ex) { // warning: ThreadDeath 'ex' not rethrown\n    return false;\n  }'",
                  "markdown": "报告捕获 `java.lang.ThreadDeath` 并且不重新抛出异常的 `try` 语句。\n\n**示例：**\n\n\n      try {\n        executeInParallel(request);\n      } catch (ThreadDeath ex) { // warning: ThreadDeath 'ex' not rethrown\n        return false;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThreadDeathNotRethrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisorderedAssertEqualsArguments",
                "shortDescription": {
                  "text": "顺序错误的 'assertEquals()' 实参"
                },
                "fullDescription": {
                  "text": "报告对预期实参和实际实参的顺序错误的 'assertEquals()' 的调用。 对于 JUnit 3、4 和 5，正确的顺序是'(expected, actual)'。 对于 TestNG，正确的顺序是'(actual, expected)'。 对于通过的断言，此类调用没有问题，但可能会在失败时给出令人困惑的错误报告。 使用该快速修复可以翻转实参顺序。 示例 (JUnit)： 'assertEquals(actual, expected)' 在应用快速修复后： 'assertEquals(expected, actual)'",
                  "markdown": "报告对预期实参和实际实参的顺序错误的 `assertEquals()` 的调用。\n\n\n对于 JUnit 3、4 和 5，正确的顺序是`(expected, actual)`。\n对于 TestNG，正确的顺序是`(actual, expected)`。\n\n\n对于通过的断言，此类调用没有问题，但可能会在失败时给出令人困惑的错误报告。\n使用该快速修复可以翻转实参顺序。\n\n**示例 (JUnit)：**\n\n\n      assertEquals(actual, expected)\n\n在应用快速修复后：\n\n\n      assertEquals(expected, actual)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MisorderedAssertEqualsArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 97,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticVariableInitialization",
                "shortDescription": {
                  "text": "static 字段可能无法初始化"
                },
                "fullDescription": {
                  "text": "报告在类初始化时可能未被初始化的 'static' 变量。 示例： 'class Foo {\n    public static int bar;\n\n    static { }\n  }' 请注意，此检查使用非常保守的数据流算法，并且可能会将 'static' 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。 使用忽略基元字段选项可以忽略未初始化的基元字段。",
                  "markdown": "报告在类初始化时可能未被初始化的 `static` 变量。\n\n**示例：**\n\n\n      class Foo {\n        public static int bar;\n\n        static { }\n      }\n\n请注意，此检查使用非常保守的数据流算法，并且可能会将 `static` 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。\n\n使用**忽略基元字段**选项可以忽略未初始化的基元字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticVariableMayNotBeInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantAssertCondition",
                "shortDescription": {
                  "text": "'assert' 语句中的常量条件"
                },
                "fullDescription": {
                  "text": "报告为常量的 'assert' 语句条件。 具有常量条件的 'assert' 语句要么总是失败，要么总是成功。 此类语句可能在重构后遗留下来，并且可能不是有意的。 示例： 'void foo() {\n        assert true;\n    }' 此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。",
                  "markdown": "报告为常量的 `assert` 语句条件。 具有常量条件的 `assert` 语句要么总是失败，要么总是成功。 此类语句可能在重构后遗留下来，并且可能不是有意的。\n\n**示例：**\n\n\n        void foo() {\n            assert true;\n        }\n\n此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantAssertCondition",
                    "cweIds": [
                      570,
                      571
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaReflectionInvocation",
                "shortDescription": {
                  "text": "反射调用实参不匹配"
                },
                "fullDescription": {
                  "text": "报告提供给 'Method.invoke()' 和 'Constructor.newInstance()' 的实参与 'Class.getMethod()' 和 'Class.getConstructor()' 中指定的签名不匹配的情况。 示例： 'Method m = myObj.getClass().getMethod(\"myMethod\", int.class);\n  //此实参应为 int 值\n  m.invoke(myObj, \"abc\");' 2017.2 最新变化",
                  "markdown": "报告提供给 `Method.invoke()` 和 `Constructor.newInstance()` 的实参与 `Class.getMethod()` 和 `Class.getConstructor()` 中指定的签名不匹配的情况。\n\n示例：\n\n\n      Method m = myObj.getClass().getMethod(\"myMethod\", int.class);\n      //此实参应为 **int** 值\n      m.invoke(myObj, \"abc\");\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaReflectionInvocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/反射访问",
                      "index": 99,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CaughtExceptionImmediatelyRethrown",
                "shortDescription": {
                  "text": "捕获的异常被立即重新抛出"
                },
                "fullDescription": {
                  "text": "报告不对其执行任何操作，而是立即重新抛出所捕获的异常的 'catch' 块。 此类 'catch' 块非必要，并且没有处理错误。 示例： 'try {\n            new FileInputStream(\"\");\n        } catch (FileNotFoundException e) {\n            throw e;\n        }'",
                  "markdown": "报告不对其执行任何操作，而是立即重新抛出所捕获的异常的 `catch` 块。 此类 `catch` 块非必要，并且没有处理错误。\n\n**示例：**\n\n\n            try {\n                new FileInputStream(\"\");\n            } catch (FileNotFoundException e) {\n                throw e;\n            }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CaughtExceptionImmediatelyRethrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryModuleDependencyInspection",
                "shortDescription": {
                  "text": "不必要的模块依赖"
                },
                "fullDescription": {
                  "text": "报告对未使用的模块的依赖。 该快速修复可以安全移除这些未使用的依赖项。",
                  "markdown": "报告对未使用的模块的依赖。 该快速修复可以安全移除这些未使用的依赖项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryModuleDependencyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneCallsConstructors",
                "shortDescription": {
                  "text": "'clone()' 用构造函数实例化对象"
                },
                "fullDescription": {
                  "text": "报告对 'clone()' 方法中的对象构造函数的调用。 与其直接创建这些对象来支持后续的子类，不如调用 'clone()' 来实例化 'clone()' 方法中的对象。 此检查不会报告被声明为 'final' 的 'clone()' 方法或者'final' 类上的 'clone()' 方法。",
                  "markdown": "报告对 `clone()` 方法中的对象构造函数的调用。\n\n与其直接创建这些对象来支持后续的子类，不如调用 `clone()` 来实例化 `clone()` 方法中的对象。\n此检查不会报告被声明为 `final` 的 `clone()` 方法或者`final` 类上的 `clone()` 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneCallsConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayHashCode",
                "shortDescription": {
                  "text": "在数组上调用了 'hashCode()'"
                },
                "fullDescription": {
                  "text": "报告数组的不正确哈希代码计算。 为正确计算数组的哈希代码，请执行以下操作： 为线性数组使用 'Arrays.hashcode()' 为多维数组使用 'Arrays.deepHashcode()' 当输入值序列包含数组时，例如 'Objects.hash(string, Arrays.hashcode(array))'，这些方法还应与 'Objects.hash()' 一起使用：",
                  "markdown": "报告数组的不正确哈希代码计算。\n\n为正确计算数组的哈希代码，请执行以下操作：\n\n* 为线性数组使用 `Arrays.hashcode()`\n* 为多维数组使用 `Arrays.deepHashcode()`\n\n当输入值序列包含数组时，例如 `Objects.hash(string, Arrays.hashcode(array))`，这些方法还应与 `Objects.hash()` 一起使用："
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayHashCode",
                    "cweIds": [
                      328
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitNotInLoop",
                "shortDescription": {
                  "text": "未在循环中调用的 'wait()'"
                },
                "fullDescription": {
                  "text": "报告不是在循环中进行的 'wait()' 调用。 'wait()' 通常用于挂起线程，直到某个条件变为 true 为止。 线程可能出于不同的原因而被唤醒，因此在 'wait()' 调用返回后应检查条件。 使用循环很容易做到这一点。 示例： 'class BoundedCounter {\n    private int count;\n    synchronized void inc() throws InterruptedException {\n      if (count >= 10) wait();\n      ++count;\n    }\n  }' 优良的代码应类似于： 'class BoundedCounter {\n    private int count;\n    synchronized void inc() throws InterruptedException {\n      while (count >= 10) wait();\n      ++count;\n    }\n  }'",
                  "markdown": "报告不是在循环中进行的 `wait()` 调用。\n\n\n`wait()` 通常用于挂起线程，直到某个条件变为 true 为止。\n线程可能出于不同的原因而被唤醒，因此在 `wait()` 调用返回后应检查条件。\n使用循环很容易做到这一点。\n\n**示例：**\n\n\n      class BoundedCounter {\n        private int count;\n        synchronized void inc() throws InterruptedException {\n          if (count >= 10) wait();\n          ++count;\n        }\n      }\n\n优良的代码应类似于：\n\n\n      class BoundedCounter {\n        private int count;\n        synchronized void inc() throws InterruptedException {\n          while (count >= 10) wait();\n          ++count;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitNotInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArraysAsListWithZeroOrOneArgument",
                "shortDescription": {
                  "text": "'Arrays.asList()' 调用的实参过少"
                },
                "fullDescription": {
                  "text": "报告对最多包含一个实参的 'Arrays.asList()' 的调用。 在 JDK 9 及更高版本中，此类调用可以替换为 'Collections.singletonList()'、'Collections.emptyList()' 或 'List.of()'，从而节省内存。 特别是，无实参的 'Collections.emptyList()' 和 'List.of()' 总是返回共享实例，而无实参的 'Arrays.asList()' 每次调用时都会创建一个新对象。 注意：'Collections.singletonList()' 和 'List.of()' 返回的列表不可变，而列表返回的 'Arrays.asList()' 允许调用 'set()' 方法。 这在极少数情况下可能会破坏代码。 示例： 'List<String> empty = Arrays.asList();\n  List<String> one = Arrays.asList(\"one\");' 在应用快速修复后： 'List<String> empty = Collections.emptyList();\n  List<String> one = Collections.singletonList(\"one\");'",
                  "markdown": "报告对最多包含一个实参的 `Arrays.asList()` 的调用。\n\n\n在 JDK 9 及更高版本中，此类调用可以替换为 `Collections.singletonList()`、`Collections.emptyList()` 或 `List.of()`，从而节省内存。\n\n特别是，无实参的 `Collections.emptyList()` 和 `List.of()` 总是返回共享实例，而无实参的 `Arrays.asList()` 每次调用时都会创建一个新对象。\n\n注意：`Collections.singletonList()` 和 `List.of()` 返回的列表不可变，而列表返回的 `Arrays.asList()` 允许调用 `set()` 方法。\n这在极少数情况下可能会破坏代码。\n\n**示例：**\n\n\n      List<String> empty = Arrays.asList();\n      List<String> one = Arrays.asList(\"one\");\n\n在应用快速修复后：\n\n\n      List<String> empty = Collections.emptyList();\n      List<String> one = Collections.singletonList(\"one\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArraysAsListWithZeroOrOneArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExternalizableWithSerializationMethods",
                "shortDescription": {
                  "text": "具有 'readObject()' 或 'writeObject()' 的可外部化类"
                },
                "fullDescription": {
                  "text": "报告定义 'readObject()' 或 'writeObject()' 方法的 'Externalizable' 类。 这些方法并非为了序列化 'Externalizable' 对象而调用。 示例： 'abstract class Crucial implements Externalizable {\n    int value;\n    private void readObject(ObjectInputStream in) {\n      value = in.readInt();\n    }\n  }'",
                  "markdown": "报告定义 `readObject()` 或 `writeObject()` 方法的 `Externalizable` 类。 这些方法并非为了序列化 `Externalizable` 对象而调用。\n\n**示例：**\n\n\n      abstract class Crucial implements Externalizable {\n        int value;\n        private void readObject(ObjectInputStream in) {\n          value = in.readInt();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExternalizableClassWithSerializationMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnstableApiUsage",
                "shortDescription": {
                  "text": "不稳定的 API 用法"
                },
                "fullDescription": {
                  "text": "报告使用一个注解标记为不稳定的 API 的用法。 将来的版本中可能更改或移除此类 API，从而破坏使用这些 API 的代码。 用于标记不稳定 API 的注解显示在以下列表中。 默认情况下，如果不稳定 API 的声明位于同一项目源中，该检查会忽略这些 API 的用法。 在此类情况下，更改 API 时可以更新用法。 但是，如果项目很大，则可能不太方便，因此，您可以关闭忽略此项目中声明的 API 选项，从而报告在项目源和库中均已声明的不稳定 API。",
                  "markdown": "报告使用一个注解标记为不稳定的 API 的用法。 将来的版本中可能更改或移除此类 API，从而破坏使用这些 API 的代码。\n\n用于标记不稳定 API 的注解显示在以下列表中。\n\n默认情况下，如果不稳定 API 的声明位于同一项目源中，该检查会忽略这些 API 的用法。 在此类情况下，更改 API 时可以更新用法。\n但是，如果项目很大，则可能不太方便，因此，您可以关闭**忽略此项目中声明的 API** 选项，从而报告在项目源和库中均已声明的不稳定 API。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnstableApiUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SafeLock",
                "shortDescription": {
                  "text": "已获取但未安全解锁的锁"
                },
                "fullDescription": {
                  "text": "报告没有在 'try' 块前面获取，或者没有在相应的 'finally' 块中解锁的 'java.util.concurrent.locks.Lock' 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。 示例： 'lock.lock(); // 由于缺少 'finally' 块，因此会报告\n  try {\n    doSmthWithLock();\n  } catch (IOException e) {\n    throw new UncheckedIOException(e);\n  }\n  lock.unlock();'",
                  "markdown": "报告没有在 `try` 块前面获取，或者没有在相应的 `finally` 块中解锁的 `java.util.concurrent.locks.Lock` 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。\n\n**示例：**\n\n\n      lock.lock(); // 由于缺少 'finally' 块，因此会报告\n      try {\n        doSmthWithLock();\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      lock.unlock();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LockAcquiredButNotSafelyReleased",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaUnfriendlyMethodOverload",
                "shortDescription": {
                  "text": "方法重载对 lambda 不友好"
                },
                "fullDescription": {
                  "text": "报告采用的函数接口存在抽象方法签名冲突的重载方法。 此类重载会引入歧义，并要求调用方将 lambda 转换为特定类型或显式指定 lambda 形参类型。 最好为重载方法赋予不同的名称，以消除歧义。 示例： 'interface MyExecutor {\n    void execute(Supplier<?> supplier);\n    void execute(Callable<?> callable);\n  }' 这里的 'Supplier' 和 'Callable' 为函数接口，其单抽象方法不接受任何形参并返回非 void 值。 因此，除非使用显式转换，否则无法在调用点推断 lambda 的类型。",
                  "markdown": "报告采用的函数接口存在抽象方法签名冲突的重载方法。\n\n此类重载会引入歧义，并要求调用方将 lambda 转换为特定类型或显式指定 lambda 形参类型。\n最好为重载方法赋予不同的名称，以消除歧义。\n\n示例：\n\n\n      interface MyExecutor {\n        void execute(Supplier<?> supplier);\n        void execute(Callable<?> callable);\n      }\n\n\n这里的 `Supplier` 和 `Callable` 为函数接口，其单抽象方法不接受任何形参并返回非 void 值。\n因此，除非使用显式转换，否则无法在调用点推断 lambda 的类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LambdaUnfriendlyMethodOverload",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaLangInvokeHandleSignature",
                "shortDescription": {
                  "text": "MethodHandle/VarHandle 类型不匹配"
                },
                "fullDescription": {
                  "text": "报告不匹配任何方法或字段的 'MethodHandle' 和 'VarHandle' 工厂方法调用。 也报告不匹配 'MethodHandle' 签名的 'MethodHandle.invoke()' 和类似方法的实参以及不匹配 'VarHandle' 类型的 'VarHandle.set()' 的实参 示例：   MethodHandle mh = MethodHandles.lookup().findVirtual(\n      MyClass.class, \"foo\", MethodType.methodType(void.class, int.class));\n  // 此实参应为 int 值\n  mh.invoke(myObj, \"abc\");\n   // 此实参应为 String.class\n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", int.class);\n   VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", String.class);\n  // 此实参应为 String 值\n  vh.set(myObj, 42);\n 2017.2 最新变化",
                  "markdown": "报告不匹配任何方法或字段的 `MethodHandle` 和 `VarHandle` 工厂方法调用。\n\n也报告不匹配 `MethodHandle` 签名的 `MethodHandle.invoke()` 和类似方法的实参以及不匹配 `VarHandle` 类型的 `VarHandle.set()` 的实参\n\n\n示例：\n\n```\n  MethodHandle mh = MethodHandles.lookup().findVirtual(\n      MyClass.class, \"foo\", MethodType.methodType(void.class, int.class));\n  // 此实参应为 int 值\n  mh.invoke(myObj, \"abc\");\n```\n\n```\n  // 此实参应为 String.class\n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", int.class);\n```\n\n```\n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", String.class);\n  // 此实参应为 String 值\n  vh.set(myObj, 42);\n```\n\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaLangInvokeHandleSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/反射访问",
                      "index": 99,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnThis",
                "shortDescription": {
                  "text": "返回 'this'"
                },
                "fullDescription": {
                  "text": "报告返回 'this' 的方法。 虽然此类返回是有效的，但很少有必要，并且通常表明该方法旨在被用作类似方法调用链的一部分（例如，'buffer.append(\"foo\").append( \"bar\").append(\"baz\")'）。 许多编码标准不赞成此类链。 示例： 'public Builder append(String str) {\n    // [...]\n    return this;\n  }'",
                  "markdown": "报告返回 `this` 的方法。\n\n\n虽然此类返回是有效的，但很少有必要，并且通常表明该方法旨在被用作类似方法调用链的一部分（例如，`buffer.append(\"foo\").append( \"bar\").append(\"baz\")`）。\n许多编码标准不赞成此类链。\n\n**示例：**\n\n\n      public Builder append(String str) {\n        // [...]\n        return this;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnOfThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanBeFinal",
                "shortDescription": {
                  "text": "声明可以有 'final' 修饰符"
                },
                "fullDescription": {
                  "text": "报告可能在其声明中添加了 'final' 修饰符的字段、方法或类。 final 类不能被扩展，final 方法不能被重写，final 字段不能被重新分配。 示例： 'public class Person {\n    private String name;\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n\n    public String toString() {\n      return getName();\n    }\n  }' 在应用快速修复后： 'public final class Person {\n    private final String name;\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public final String getName() {\n      return name;\n    }\n\n    public final String toString() {\n      return getName();\n    }\n  }' 使用报告类和报告方法选项可定义要报告的声明。",
                  "markdown": "报告可能在其声明中添加了 `final` 修饰符的字段、方法或类。\n\nfinal 类不能被扩展，final 方法不能被重写，final 字段不能被重新分配。\n\n**示例：**\n\n\n      public class Person {\n        private String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n\n        public String toString() {\n          return getName();\n        }\n      }\n\n在应用快速修复后：\n\n\n      public final class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public final String getName() {\n          return name;\n        }\n\n        public final String toString() {\n          return getName();\n        }\n      }\n\n使用**报告类** 和**报告方法**选项可定义要报告的声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CanBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableRecordContainsIgnoredMembers",
                "shortDescription": {
                  "text": "'record' 包含被忽略的成员"
                },
                "fullDescription": {
                  "text": "报告在 'record' 类中定义的序列化方法或字段。 序列化方法包括 'writeObject()'、'readObject()'、'readObjectNoData()'、'writeExternal()' 和 'readExternal()'，以及字段 'serialPersistentFields'。 这些成员不用于记录的序列化或反序列化，因此不必要使用。 示例： 'record R1() implements Serializable {\n    // 该字段在记录序列化期间被忽略\n    @Serial\n    private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n\n    // 该方法在记录序列化期间被忽略\n    @Serial\n    private void writeObject(ObjectOutputStream out) throws IOException {\n    }\n  }' 'record R2() implements Externalizable {\n    // 该方法在记录序列化期间被忽略\n    @Override\n    public void writeExternal(ObjectOutput out) throws IOException {\n    }\n\n    // 该方法在记录序列化期间被忽略\n    @Override\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n    }\n  }' 2020.3 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告在 `record` 类中定义的序列化方法或字段。 序列化方法包括 `writeObject()`、`readObject()`、`readObjectNoData()`、`writeExternal()` 和 `readExternal()`，以及字段 `serialPersistentFields`。 这些成员不用于记录的序列化或反序列化，因此不必要使用。\n\n**示例：**\n\n\n      record R1() implements Serializable {\n        // 该字段在记录序列化期间被忽略\n        @Serial\n        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n\n        // 该方法在记录序列化期间被忽略\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n      }\n\n\n      record R2() implements Externalizable {\n        // 该方法在记录序列化期间被忽略\n        @Override\n        public void writeExternal(ObjectOutput out) throws IOException {\n        }\n\n        // 该方法在记录序列化期间被忽略\n        @Override\n        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        }\n      }\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableRecordContainsIgnoredMembers",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLabelOnBreakStatement",
                "shortDescription": {
                  "text": "'break' 语句上的标签不必要"
                },
                "fullDescription": {
                  "text": "报告包含不必要标签的 'break' 语句。 此类标签不会改变控制流，但会导致难以跟随代码。 示例： 'label:\n  for(int i = 0; i < 10; i++) {\n    if (shouldBreak()) break label;\n    //doSmth\n  }' 在应用快速修复后： 'label:\n  for(int i = 0; i < 10; i++) {\n    if (shouldBreak()) break;\n    //doSmth\n  }'",
                  "markdown": "报告包含不必要标签的 `break` 语句。 此类标签不会改变控制流，但会导致难以跟随代码。\n\n**示例：**\n\n\n      label:\n      for(int i = 0; i < 10; i++) {\n        if (shouldBreak()) break label;\n        //doSmth\n      }\n\n在应用快速修复后：\n\n\n      label:\n      for(int i = 0; i < 10; i++) {\n        if (shouldBreak()) break;\n        //doSmth\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLabelOnBreakStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NakedNotify",
                "shortDescription": {
                  "text": "没有相应状态更改的 'notify()' 或 'notifyAll()'"
                },
                "fullDescription": {
                  "text": "报告调用的未发生任何可检测到的状态更改的 'Object.notify()' 或 'Object.notifyAll()'。 'Object.notify()' 和 'Object.notifyAll()' 通常用于通知其他线程发生了状态更改。 该状态更改应发生在包含 'Object.notify()' 或 'Object.notifyAll()' 调用的同步上下文中，并且发生在调用之前。 尽管没有此类状态更改未必就不正确，但肯定值得检查。 示例： 'synchronized (this) {\n    notify();\n  }\n  // 无状态更改\n  synchronized (this) {\n    notify(); // 告知可能冗余\n  }'",
                  "markdown": "报告调用的未发生任何可检测到的状态更改的 `Object.notify()` 或 `Object.notifyAll()`。\n\n\n`Object.notify()` 和 `Object.notifyAll()` 通常用于通知其他线程发生了状态更改。 该状态更改应发生在包含 `Object.notify()` 或\n`Object.notifyAll()` 调用的同步上下文中，并且发生在调用之前。 尽管没有此类状态更改未必就不正确，但肯定值得检查。\n\n**示例：**\n\n\n      synchronized (this) {\n        notify();\n      }\n      // 无状态更改\n      synchronized (this) {\n        notify(); // 告知可能冗余\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NakedNotify",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassCoupling",
                "shortDescription": {
                  "text": "过度耦合的类"
                },
                "fullDescription": {
                  "text": "报告引用过多其他类的类。 耦合度过高的类可能非常脆弱，应该被拆分为较小的类。 配置检查： 使用类耦合限制字段可指定类允许的最大耦合度。 使用包括与 Java 系统类的耦合选项可指定是否应计算对系统类（'java.' 或 'javax.' 软件包中的那些类）的引用。 使用包括与库类的耦合选项可指定是否应该计算对任何库类的引用。",
                  "markdown": "报告引用过多其他类的类。\n\n耦合度过高的类可能非常脆弱，应该被拆分为较小的类。\n\n配置检查：\n\n* 使用**类耦合限制**字段可指定类允许的最大耦合度。\n* 使用**包括与 Java 系统类的耦合** 选项可指定是否应计算对系统类（`java.` 或 `javax.` 软件包中的那些类）的引用。\n* 使用**包括与库类的耦合**选项可指定是否应该计算对任何库类的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyCoupledClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarilyQualifiedInnerClassAccess",
                "shortDescription": {
                  "text": "不必要的限定内部类访问"
                },
                "fullDescription": {
                  "text": "报告对不必要地用封闭类的名称进行了限定的内部类的任何引用。 此类限定可以安全地移除，这有时会为内部类添加导入。 示例： 'class X {\n     X.Y foo;\n     class Y{}\n  }' 在应用快速修复后： 'class X {\n     Y foo;\n     class Y{}\n  }' 使用忽略需要导入的引用选项可忽略对内部类的引用，其中移除限定会添加导入。",
                  "markdown": "报告对不必要地用封闭类的名称进行了限定的内部类的任何引用。\n\n此类限定可以安全地移除，这有时会为内部类添加导入。\n\n示例：\n\n\n      class X {\n         X.Y foo;\n         class Y{}\n      }\n\n在应用快速修复后：\n\n\n      class X {\n         Y foo;\n         class Y{}\n      }\n\n使用**忽略需要导入的引用**选项可忽略对内部类的引用，其中移除限定会添加导入。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessarilyQualifiedInnerClassAccess",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptySynchronizedStatement",
                "shortDescription": {
                  "text": "空 'synchronized' 语句"
                },
                "fullDescription": {
                  "text": "报告语句体为空的 'synchronized' 语句。 空的 'synchronized' 语句有时用于等待其他线程释放特定资源。 但是，不能保证空的 'synchronized' 语句完成后不会再次获取同一资源。 为了正确同步，应当在 'synchronized' 块中使用此资源。 此外，在移除冗余代码后，重构后可能会出现空的 'synchronized' 块。 在本例中，'synchronized' 块本身是冗余的，也应移除。 示例： 'synchronized(lock) {}' 建议通过快速修复移除空的 synchronized 语句。 JSP 文件中禁用了此检查。",
                  "markdown": "报告语句体为空的 `synchronized` 语句。\n\n\n空的 `synchronized` 语句有时用于等待其他线程释放特定资源。 但是，不能保证空的 `synchronized` 语句完成后不会再次获取同一资源。\n为了正确同步，应当在 `synchronized` 块中使用此资源。\n\n\n此外，在移除冗余代码后，重构后可能会出现空的 `synchronized` 块。 在本例中，`synchronized` 块本身是冗余的，也应移除。\n\n示例：\n\n\n      synchronized(lock) {}\n\n\n建议通过快速修复移除空的 synchronized 语句。\n\n\nJSP 文件中禁用了此检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptySynchronizedStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextBlockMigration",
                "shortDescription": {
                  "text": "可以使用文本块"
                },
                "fullDescription": {
                  "text": "报告可通过替换为文本块来简化的 'String' 串联。 要求： '\\n' 发生两次或多次。 文本块未串联。 使用报告单个字符串文字选项高亮显示包含换行符的单个文字。 即使禁用此选项，快速修复仍然可用。 示例： 'String html = \"<html>\\n\" +\n                \"    <body>\\n\" +\n                \"        <p>Hello, world</p>\\n\" +\n                \"    </body>\\n\" +\n                \"</html>\\n\";' 在应用快速修复后： 'String html = \"\"\"\n                <html>\n                    <body>\n                        <p>Hello, world</p>\n                    </body>\n                </html>\n                \"\"\";' 2019.3 最新变化 此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。",
                  "markdown": "报告可通过替换为文本块来简化的 `String` 串联。\n\n要求：\n\n* `\\n` 发生两次或多次。\n* 文本块未串联。\n\n\n使用**报告单个字符串文字**选项高亮显示包含换行符的单个文字。\n即使禁用此选项，快速修复仍然可用。\n\n\n**示例：**\n\n\n      String html = \"<html>\\n\" +\n                    \"    <body>\\n\" +\n                    \"        <p>Hello, world</p>\\n\" +\n                    \"    </body>\\n\" +\n                    \"</html>\\n\";\n\n在应用快速修复后：\n\n\n      String html = \"\"\"\n                    <html>\n                        <body>\n                            <p>Hello, world</p>\n                        </body>\n                    </html>\n                    \"\"\";\n\n2019.3 最新变化\n\n此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TextBlockMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 15",
                      "index": 101,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectAllocationInLoop",
                "shortDescription": {
                  "text": "循环中的对象分配"
                },
                "fullDescription": {
                  "text": "报告循环内的对象或数组分配。 虽然不一定是问题，但循环内的对象分配是查找内存泄漏和性能问题的好地方。 检查会报告以下结构： 通过 'new' 运算符进行的显式分配 已知会返回新对象的方法 实例绑定方法引用 捕获变量或 'this' 引用的 lambda 示例： '// 显式分配\n  for (Status status : Status.values()) {\n    declarationsMap.put(status, new ArrayList<>());\n  }\n\n  // Lambda 捕获变量\n  String message = \"Engine running.\";\n  for (Engine engine : engines) {\n      if (!isRunning(engine)) {\n          logger.warn(() -> {\n              return String.format(message);\n          });\n      }\n  }\n\n  // 实例绑定方法引用\n  for(Node node : nodes) {\n    descriptor = node.getDescription();\n    descriptor.ifPresent(dynamicTestExecutor::execute);\n  }'",
                  "markdown": "报告循环内的对象或数组分配。 虽然不一定是问题，但循环内的对象分配是查找内存泄漏和性能问题的好地方。\n\n\n检查会报告以下结构：\n\n* 通过 `new` 运算符进行的显式分配\n* 已知会返回新对象的方法\n* 实例绑定方法引用\n* 捕获变量或 `this` 引用的 lambda\n\n**示例：**\n\n\n      // 显式分配\n      for (Status status : Status.values()) {\n        declarationsMap.put(status, new ArrayList<>());\n      }\n\n      // Lambda 捕获变量\n      String message = \"Engine running.\";\n      for (Engine engine : engines) {\n          if (!isRunning(engine)) {\n              logger.warn(() -> {\n                  return String.format(message);\n              });\n          }\n      }\n\n      // 实例绑定方法引用\n      for(Node node : nodes) {\n        descriptor = node.getDescription();\n        descriptor.ifPresent(dynamicTestExecutor::execute);\n      }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectAllocationInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocLinkAsPlainText",
                "shortDescription": {
                  "text": "指定为纯文本的链接"
                },
                "fullDescription": {
                  "text": "报告 Javadoc 注释中的纯文本链接。 该快速修复会建议使用 '<a>' 标记包装链接。 示例： 'class Main {\n   /**\n    * https://en.wikipedia.org/\n    */\n    void foo() {}\n  }' 在应用快速修复后： 'class Main {\n   /**\n    * <a href=\"https://en.wikipedia.org/\">https://en.wikipedia.org/</a>\n    */\n    void foo() {}\n  }' 2022.1 最新变化",
                  "markdown": "报告 Javadoc 注释中的纯文本链接。\n\n\n该快速修复会建议使用 `<a>` 标记包装链接。\n\n**示例：**\n\n\n      class Main {\n       /**\n        * https://en.wikipedia.org/\n        */\n        void foo() {}\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n       /**\n        * <a href=\"https://en.wikipedia.org/\">https://en.wikipedia.org/</a>\n        */\n        void foo() {}\n      }\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocLinkAsPlainText",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChainedEquality",
                "shortDescription": {
                  "text": "链式相等比较"
                },
                "fullDescription": {
                  "text": "报告链式相等比较。 此类比较可能令人困惑：'a == b == c' 表示 '(a == b) == c'，但可能 'a == b && a == c' 是有意为之。 示例： 'boolean chainedEquality(boolean a, boolean b, boolean c) {\n    return a == b == c;\n  }' 您可以使用圆括号使比较不那么令人困惑： 'boolean chainedEquality(boolean a, boolean b, boolean c) {\n    return (a == b) == c;\n  }'",
                  "markdown": "报告链式相等比较。\n\n此类比较可能令人困惑：`a == b == c` 表示 `(a == b) == c`，但可能 `a == b && a == c` 是有意为之。\n\n**示例：**\n\n\n      boolean chainedEquality(boolean a, boolean b, boolean c) {\n        return a == b == c;\n      }\n\n您可以使用圆括号使比较不那么令人困惑：\n\n\n      boolean chainedEquality(boolean a, boolean b, boolean c) {\n        return (a == b) == c;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainedEqualityComparisons",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalClone",
                "shortDescription": {
                  "text": "非 final 'clone()' 位于安全上下文中"
                },
                "fullDescription": {
                  "text": "报告没有 'final' 修饰符的 'clone()' 方法。 'clone()' 可以用于在不使用构造函数的情况下实例化对象，因此允许重写 'clone()' 方法可能导致对象损坏，甚至导致安全漏洞。 将 'clone()' 方法或封闭类本身设为 'final' 可以防止这种情况。 示例： 'class Main implements Cloneable {\n      @Override\n      protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n      }\n  }'",
                  "markdown": "报告没有 `final` 修饰符的 `clone()` 方法。\n\n\n`clone()` 可以用于在不使用构造函数的情况下实例化对象，因此允许重写 `clone()` 方法可能导致对象损坏，甚至导致安全漏洞。 将 `clone()` 方法或封闭类本身设为 `final` 可以防止这种情况。\n\n**示例：**\n\n\n      class Main implements Cloneable {\n          @Override\n          protected Object clone() throws CloneNotSupportedException {\n            return super.clone();\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SharedThreadLocalRandom",
                "shortDescription": {
                  "text": "'ThreadLocalRandom' 实例可能是共享的"
                },
                "fullDescription": {
                  "text": "报告可能在线程之间共享的 'java.util.concurrent.ThreadLocalRandom' 实例。 'ThreadLocalRandom' 不应在线程之间共享，因为不具备线程安全。 该检查可以报告分配给用作方法实参的字段，或分配给局部变量并在匿名类或嵌套类中使用的实例，因为它们可能在线程之间共享。 'ThreadLocalRandom' 的用法通常应类似于'ThreadLocalRandom.current().nextInt(...)'（或 'nextDouble(...)' 等）。 当所有用法都采取这种形式时，'ThreadLocalRandom' 实例就不会被多个线程误用。 示例： 'class Main {\n      void printRandomNumbersAsync() {\n        ThreadLocalRandom random = ThreadLocalRandom.current();\n        CompletableFuture.supplyAsync(() -> generateNumbers(random))\n          .thenAccept(numbers -> System.out.println(Arrays.toString(numbers)));\n      }\n\n      private int[] generateNumbers(Random random) {\n        return random.ints(1000, 0, 100).toArray();\n      }\n    }' 使用这些选项可以列出能够作为实参传递给 'ThreadLocalRandom' 实例的方法。 可以将正则表达式用于方法名称。",
                  "markdown": "报告可能在线程之间共享的 `java.util.concurrent.ThreadLocalRandom` 实例。\n\n\n`ThreadLocalRandom` 不应在线程之间共享，因为不具备线程安全。\n该检查可以报告分配给用作方法实参的字段，或分配给局部变量并在匿名类或嵌套类中使用的实例，因为它们可能在线程之间共享。\n\n\n`ThreadLocalRandom` 的用法通常应类似于`ThreadLocalRandom.current().nextInt(...)`（或 `nextDouble(...)` 等）。\n当所有用法都采取这种形式时，`ThreadLocalRandom` 实例就不会被多个线程误用。\n\n**示例：**\n\n\n        class Main {\n          void printRandomNumbersAsync() {\n            ThreadLocalRandom random = ThreadLocalRandom.current();\n            CompletableFuture.supplyAsync(() -> generateNumbers(random))\n              .thenAccept(numbers -> System.out.println(Arrays.toString(numbers)));\n          }\n\n          private int[] generateNumbers(Random random) {\n            return random.ints(1000, 0, 100).toArray();\n          }\n        }\n      \n\n使用这些选项可以列出能够作为实参传递给 `ThreadLocalRandom` 实例的方法。\n可以将正则表达式用于方法名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SharedThreadLocalRandom",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhileCanBeDoWhile",
                "shortDescription": {
                  "text": "'while' 可被替换为 'do while'"
                },
                "fullDescription": {
                  "text": "报告可以更有效地编写为 'do-while' 循环的 'while' 循环。 存在循环之前的代码与循环主体中的代码相同的 'while' 循环。 替换为 'do-while' 循环会移除重复的代码。 对于没有此类重复代码的 'while' 循环，编辑器中也提供了快速修复，但没有高亮显示。 示例： 'foo();\n  while (x) {\n      foo();\n  }' 可以替换为： 'do {\n    foo();\n  } while (x);' 2024.1 最新变化",
                  "markdown": "报告可以更有效地编写为 `do-while` 循环的 `while` 循环。\n存在循环之前的代码与循环主体中的代码相同的 `while` 循环。\n替换为 `do-while` 循环会移除重复的代码。\n对于没有此类重复代码的 `while` 循环，编辑器中也提供了快速修复，但没有高亮显示。\n\n**示例：**\n\n\n      foo();\n      while (x) {\n          foo();\n      }\n\n可以替换为：\n\n\n      do {\n        foo();\n      } while (x);\n\n\n2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WhileCanBeDoWhile",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodOverridesConcreteMethod",
                "shortDescription": {
                  "text": "abstract 方法重写具体方法"
                },
                "fullDescription": {
                  "text": "报告重写具体 super 方法的 'abstract' 方法。 此检查不会报告从 'java.lang.Object' 重写的方法。",
                  "markdown": "报告重写具体 super 方法的 `abstract` 方法。\n\n此检查不会报告从 `java.lang.Object` 重写的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodOverridesConcreteMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LossyConversionCompoundAssignment",
                "shortDescription": {
                  "text": "复合赋值中可能存在有损隐式转换"
                },
                "fullDescription": {
                  "text": "如果右侧操作数的类型与变量的类型不兼容，则报告复合赋值。 在此类复合赋值过程中，会发生隐式强制转换，这可能会导致有损转换。 示例： 'long c = 1;\n  c += 1.2;' 在应用快速修复后： 'long c = 1;\n  c += (long) 1.2;' 2023.2 最新变化",
                  "markdown": "如果右侧操作数的类型与变量的类型不兼容，则报告复合赋值。\n\n\n在此类复合赋值过程中，会发生隐式强制转换，这可能会导致有损转换。\n\n示例：\n\n\n      long c = 1;\n      c += 1.2;\n\n在应用快速修复后：\n\n\n      long c = 1;\n      c += (long) 1.2;\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "lossy-conversions",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowFromFinallyBlock",
                "shortDescription": {
                  "text": "'throw' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块内的 'throw' 语句。 虽然偶尔是有意为之，但此类 'throw' 语句可能隐藏从 'try' 和 'catch' 抛出的异常，并使调试过程变得复杂。 示例： 'class Fascinating {\n    void doTask(Task t) {\n      try {\n        t.activity();\n      } finally {\n        if (!t.finish()) {\n          throw new IllegalStateException();\n        }\n      }\n    }\n  }' 使用在可能抛出已声明异常的每一处发出警告选项，可以在调用声明了异常的方法时也发出警告。",
                  "markdown": "报告 `finally` 块内的 `throw` 语句。 虽然偶尔是有意为之，但此类 `throw` 语句可能隐藏从 `try` 和 `catch` 抛出的异常，并使调试过程变得复杂。\n\n**示例：**\n\n\n      class Fascinating {\n        void doTask(Task t) {\n          try {\n            t.activity();\n          } finally {\n            if (!t.finish()) {\n              throw new IllegalStateException();\n            }\n          }\n        }\n      }\n\n使用**在可能抛出已声明异常的每一处发出警告**选项，可以在调用声明了异常的方法时也发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticNonFinalField",
                "shortDescription": {
                  "text": "'static' 非 'final' 字段"
                },
                "fullDescription": {
                  "text": "报告非 'final' 'static' 字段。 可以通过快速修复将 'final' 修饰符添加到非 'final' 'static' 字段中。 此检查不检查字段的可变性。 例如，将 'final' 修饰符添加到在某个位置设置了值的字段，将导致编译错误。 使用仅报告 'public' 字段选项，使该检查只报告 'public' 字段。",
                  "markdown": "报告非 `final` `static` 字段。\n\n可以通过快速修复将 `final` 修饰符添加到非 `final` `static` 字段中。\n\n此检查不检查字段的可变性。 例如，将 `final` 修饰符添加到在某个位置设置了值的字段，将导致编译错误。\n\n\n使用**仅报告 'public' 字段** 选项，使该检查只报告 `public` 字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticNonFinalField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CodeBlock2Expr",
                "shortDescription": {
                  "text": "语句 lambda 可被替换为表达式 lambda"
                },
                "fullDescription": {
                  "text": "当可以使用表达式样式的主体时，报告包含代码块主体的 lambda 表达式。 转换的结果更短更清晰。 示例： 'Comparable<String> c = o -> {return 0;};' 在应用快速修复后： 'Comparable<String> c = o -> 0;' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "当可以使用表达式样式的主体时，报告包含代码块主体的 lambda 表达式。 转换的结果更短更清晰。\n\n示例：\n\n\n      Comparable<String> c = o -> {return 0;};\n\n在应用快速修复后：\n\n\n      Comparable<String> c = o -> 0;\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CodeBlock2Expr",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyForEach",
                "shortDescription": {
                  "text": "可简化的 forEach() 调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为更简洁的方法或可以从中提取中间步骤的 'forEach()' 调用。 示例： 'List<String> findNStrings(List<String> list, int n) {\n    List<String> other = new ArrayList<>();\n    list.forEach(s -> {\n      if(s.length() > n) other.add(s);\n    });\n    return other;\n  }' 在应用快速修复后： 'List<String> findNStrings(List<String> list, int n) {\n    List<String> other = list.stream()\n      .filter(s -> s.length() > n)\n      .collect(Collectors.toList());\n    return other;\n  }' 2017.3 最新变化 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为更简洁的方法或可以从中提取中间步骤的 `forEach()` 调用。\n\n**示例：**\n\n\n      List<String> findNStrings(List<String> list, int n) {\n        List<String> other = new ArrayList<>();\n        list.forEach(s -> {\n          if(s.length() > n) other.add(s);\n        });\n        return other;\n      }\n\n在应用快速修复后：\n\n\n      List<String> findNStrings(List<String> list, int n) {\n        List<String> other = list.stream()\n          .filter(s -> s.length() > n)\n          .collect(Collectors.toList());\n        return other;\n      }\n\n2017.3 最新变化\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyForEach",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantFieldInitialization",
                "shortDescription": {
                  "text": "冗余字段初始化"
                },
                "fullDescription": {
                  "text": "报告显式初始化为其默认值的字段。 示例： 'class Foo {\n    int foo = 0;\n    List bar = null;\n  }' 在应用快速修复后： 'class Foo {\n    int foo;\n    List bar;\n  }' 使用检查设置可以仅报告显式 'null' 初始化，例如： 'class Foo {\n    int foo = 0;     // 无警告\n    List bar = null; // 冗余字段初始化警告\n  }'",
                  "markdown": "报告显式初始化为其默认值的字段。\n\n**示例：**\n\n\n      class Foo {\n        int foo = 0;\n        List bar = null;\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        int foo;\n        List bar;\n      }\n\n\n使用检查设置可以仅报告显式 `null` 初始化，例如：\n\n\n      class Foo {\n        int foo = 0;     // 无警告\n        List bar = null; // 冗余字段初始化警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantFieldInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyMethod",
                "shortDescription": {
                  "text": "空方法"
                },
                "fullDescription": {
                  "text": "报告可以移除的空方法。 如果方法本身是空的并且仅被空方法重写或实现，则方法被视为空。 请注意，仅包含注释的方法和带有自己形参的 'super()' 调用也被视为空。 该检查会忽略带有特殊注解的方法，例如 'javax.ejb.Init' 和 'javax.ejb.Remove' EJB 注释。 该快速修复会安全地移除不必要的方法。 配置检查： 使用注释和 javadoc 计为内容选项可选择是否应将带有注释的方法视为非空方法。 使用额外的特别注解选项可配置此检查应忽略的其他注解。",
                  "markdown": "报告可以移除的空方法。\n\n如果方法本身是空的并且仅被空方法重写或实现，则方法被视为空。 请注意，仅包含注释的方法和带有自己形参的 `super()` 调用也被视为空。\n\n该检查会忽略带有特殊注解的方法，例如 `javax.ejb.Init` 和 `javax.ejb.Remove` EJB 注释。\n\n该快速修复会安全地移除不必要的方法。\n\n配置检查：\n\n* 使用**注释和 javadoc 计为内容**选项可选择是否应将带有注释的方法视为非空方法。\n* 使用**额外的特别注解**选项可配置此检查应忽略的其他注解。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Since15",
                "shortDescription": {
                  "text": "使用在配置的语言级别下不可用的 API"
                },
                "fullDescription": {
                  "text": "报告在所配置的语言级别不可用的 API 的用法。 此检查有 3 种作用： 当语言级别低于 Java 7 时，高亮显示泛化类的用法。 当默认方法未被重写且语言级别低于 Java 8 时高亮显示。 当语言级别低于在文档中使用 '@since' 标记标记的级别时，高亮显示 API 的用法。 使用禁止使用 API 选项，禁止在项目或自定义语言级别使用 API。",
                  "markdown": "报告在所配置的语言级别不可用的 API 的用法。 此检查有 3 种作用：\n\n* 当语言级别低于 Java 7 时，高亮显示泛化类的用法。\n* 当默认方法未被重写且语言级别低于 Java 8 时高亮显示。\n* 当语言级别低于在文档中使用 `@since` 标记标记的级别时，高亮显示 API 的用法。\n\n\n使用**禁止使用 API** 选项，禁止在项目或自定义语言级别使用 API。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Since15",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableEqualsExpression",
                "shortDescription": {
                  "text": "'equals()' 调用之前的 'null' 检查不必要"
                },
                "fullDescription": {
                  "text": "报告与后接使用常量实参调用 'equals()' 的 'null' 的比较。 示例： 'if (s != null && s.equals(\"literal\")) {}' 在应用快速修复后： 'if (\"literal\".equals(s)) {}' 当 'equals()' 的实参被证明不是 'null' 时，使用检查设置可以报告带有非常量实参的 'equals()' 调用。",
                  "markdown": "报告与后接使用常量实参调用 `equals()` 的 `null` 的比较。\n\n**示例：**\n\n\n      if (s != null && s.equals(\"literal\")) {}\n\n在应用快速修复后：\n\n\n      if (\"literal\".equals(s)) {}\n\n\n当 `equals()` 的实参被证明不是 `null` 时，使用检查设置可以报告带有非常量实参的 `equals()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableEqualsExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonCommentSourceStatements",
                "shortDescription": {
                  "text": "过长的方法"
                },
                "fullDescription": {
                  "text": "报告语句数超过指定最大值的方法。 语句过多的方法可能令人困惑，并且表明可能有必要重构。 以下语句不计算在内： 空语句（分号） 块语句 'for' 循环初始化语句，即 'for(int i = ...;...)' 语句内的 'int i = ...' 'for' 循环 update 语句，即 'for(int i = ...;...; i += 2)' 语句内的 'i += 2' 使用每个方法的最大语句数字段可指定方法中允许的最大语句数。",
                  "markdown": "报告语句数超过指定最大值的方法。\n\n语句过多的方法可能令人困惑，并且表明可能有必要重构。\n\n以下语句不计算在内：\n\n* 空语句（分号）\n* 块语句\n* `for` 循环初始化语句，即 `for(int i = ...;...)` 语句内的 `int i = ...`\n* `for` 循环 update 语句，即 `for(int i = ...;...; i += 2)` 语句内的 `i += 2`\n\n使用**每个方法的最大语句数**字段可指定方法中允许的最大语句数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyLongMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingMainMethod",
                "shortDescription": {
                  "text": "引起混淆的 'main()' 方法"
                },
                "fullDescription": {
                  "text": "在 Java 21 及更低版本中，报告命名为 \"main\" 但没有 'public static void main(String[])' 签名的方法。 从 Java 21 预览版开始，检查不会高亮显示 package-private、protected 或实例 main 方法（也没有形参）。 此外，还会报告位于匿名或局部类中的 main 方法。 匿名类和局部类没有完全限定名称，因此无法运行。 此类方法可能令人困惑，因为命名为 \"main\" 的方法应为应用程序入口点。 示例： 'class Main {\n    void main(String[] args) {} //此处有警告，因为没有“public static”修饰符\n  }' 只能在编辑器中使用重命名此类方法的快速修复。",
                  "markdown": "在 Java 21 及更低版本中，报告命名为 \"main\" 但没有 `public static void main(String[])` 签名的方法。 从 Java 21 预览版开始，检查不会高亮显示 package-private、protected 或实例 main 方法（也没有形参）。 此外，还会报告位于匿名或局部类中的 main 方法。 匿名类和局部类没有完全限定名称，因此无法运行。\n\n此类方法可能令人困惑，因为命名为 \"main\" 的方法应为应用程序入口点。\n\n**示例：**\n\n\n      class Main {\n        void main(String[] args) {} //此处有警告，因为没有\"public static\"修饰符\n      }\n\n只能在编辑器中使用重命名此类方法的快速修复。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingMainMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadObjectInitialization",
                "shortDescription": {
                  "text": "实例字段可能无法被 'readObject()' 初始化"
                },
                "fullDescription": {
                  "text": "报告在 'readObject()' 方法反序列化对象后不保证被初始化的字段。 该检查不报告 transient 字段。 注意：此检查使用非常保守的控制流算法，可能会将字段误报告为未初始化。 示例： 'class DataObject implements Serializable {\n  String s; // s 在 readObject 中未初始化\n  int i;\n\n  private void readObject(ObjectInputStream stream) throws IOException {\n    i = stream.readInt();\n  }\n}'",
                  "markdown": "报告在 `readObject()` 方法反序列化对象后不保证被初始化的字段。\n\n该检查不报告 transient 字段。\n\n\n注意：此检查使用非常保守的控制流算法，可能会将字段误报告为未初始化。\n\n**示例：**\n\n\n    class DataObject implements Serializable {\n      String s; // s 在 readObject 中未初始化\n      int i;\n\n      private void readObject(ObjectInputStream stream) throws IOException {\n        i = stream.readInt();\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceVariableMayNotBeInitializedByReadObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonAtomicOperationOnVolatileField",
                "shortDescription": {
                  "text": "'volatile' 字段上的非原子操作"
                },
                "fullDescription": {
                  "text": "报告对 volatile 字段的非原子操作。 非原子操作的示例之一是使用增量运算符更新字段。 由于操作涉及读写，并且在此之间可能发生其他修改，因此可能损坏数据。 使用 'synchronized' 块进行环绕，或使用 'java.util.concurrent.atomic' 软件包中的一个类，可以使该项操作成为原子操作。 示例： 'private volatile int v = 1;\n\n  void foo() {\n    v = 2 * v;\n  }'",
                  "markdown": "报告对 volatile 字段的非原子操作。\n\n\n非原子操作的示例之一是使用增量运算符更新字段。\n由于操作涉及读写，并且在此之间可能发生其他修改，因此可能损坏数据。\n使用 `synchronized` 块进行环绕，或使用 `java.util.concurrent.atomic` 软件包中的一个类，可以使该项操作成为原子操作。\n\n**示例：**\n\n\n      private volatile int v = 1;\n\n      void foo() {\n        v = 2 * v;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonAtomicOperationOnVolatileField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "QuestionableName",
                "shortDescription": {
                  "text": "可疑名称"
                },
                "fullDescription": {
                  "text": "报告名称有问题，而不是真正的描述性名称的变量、方法或类。 此类名称无助于理解代码，而且很可能是临时创建，但后来被遗忘了。 示例： 'int aa = 42;' 仅在编辑器中建议重命名快速修复。 使用该选项可以列出应被报告的名称。",
                  "markdown": "报告名称有问题，而不是真正的描述性名称的变量、方法或类。 此类名称无助于理解代码，而且很可能是临时创建，但后来被遗忘了。\n\n**示例：**\n\n\n      int aa = 42;\n\n仅在编辑器中建议重命名快速修复。\n\n\n使用该选项可以列出应被报告的名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "QuestionableName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleVariablesInDeclaration",
                "shortDescription": {
                  "text": "一个声明中的多个变量"
                },
                "fullDescription": {
                  "text": "报告在单个声明中声明的多个变量，并建议为每个变量创建单独的声明。 一些编码标准禁止此类声明。 示例： 'int x = 1, y = 2;' 在应用快速修复后： 'int x = 1;\n  int y = 2;' 配置检查： 使用 忽略 'for' 循环声明 选项可忽略在 'for' 循环语句的初始化中声明的多个变量，例如： 'for (int i = 0, max = list.size(); i > max; i++) {}' 使用 仅在单个声明中对不同的数组维度发出警告 选项，以仅在单个声明中声明具有不同数组维度的变量时发出警告，例如： 'String s = \"\", array[];' 2019.2 最新变化",
                  "markdown": "报告在单个声明中声明的多个变量，并建议为每个变量创建单独的声明。\n\n一些编码标准禁止此类声明。\n\n示例：\n\n\n      int x = 1, y = 2;\n\n在应用快速修复后：\n\n\n      int x = 1;\n      int y = 2;\n\n配置检查：\n\n* 使用 **忽略 'for' 循环声明** 选项可忽略在 'for' 循环语句的初始化中声明的多个变量，例如：\n\n\n        for (int i = 0, max = list.size(); i > max; i++) {}\n\n* 使用 **仅在单个声明中对不同的数组维度发出警告** 选项，以仅在单个声明中声明具有不同数组维度的变量时发出警告，例如：\n\n\n        String s = \"\", array[];\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MultipleVariablesInDeclaration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IOResource",
                "shortDescription": {
                  "text": "I/O 资源已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的 I/O 资源。 此检查所检查的 I/O 资源包括 'java.io.InputStream'、'java.io.OutputStream'、'java.io.Reader'、'java.io.Writer'、'java.util.zip.ZipFile'、'java.io.Closeable' 和 'java.io.RandomAccessFile'。 不报告由其他 I/O 资源包装的 I/O 资源，因为包装资源将关闭被包装资源。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'void save() throws IOException {\n    FileWriter writer = new FileWriter(\"filename.txt\"); //警告\n    writer.write(\"sample\");\n  }' 使用以下选项配置检查： 列出不需关闭并且此检查应当忽略的 I/O 资源类。 是否允许在 'try' 块内打开 I/O 资源。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的 I/O 资源。 此检查所检查的 I/O 资源包括 `java.io.InputStream`、`java.io.OutputStream`、`java.io.Reader`、`java.io.Writer`、`java.util.zip.ZipFile`、`java.io.Closeable` 和 `java.io.RandomAccessFile`。\n\n\n不报告由其他 I/O 资源包装的 I/O 资源，因为包装资源将关闭被包装资源。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      void save() throws IOException {\n        FileWriter writer = new FileWriter(\"filename.txt\"); //警告\n        writer.write(\"sample\");\n      }\n\n\n使用以下选项配置检查：\n\n* 列出不需关闭并且此检查应当忽略的 I/O 资源类。\n* 是否允许在 `try` 块内打开 I/O 资源。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IOResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UNCHECKED_WARNING",
                "shortDescription": {
                  "text": "未检查的警告"
                },
                "fullDescription": {
                  "text": "报告 javac 编译器发出未检查的警告的代码。 每个未检查的警告都可能在运行时触发 'ClassCastException'。 示例： 'List items = Arrays.asList(\"string\", \"string\");\n  List<Integer> numbers = Collections.unmodifiableList(items); // 未检查的赋值'",
                  "markdown": "报告 javac 编译器发出未检查的警告的代码。 每个未检查的警告都可能在运行时触发 `ClassCastException`。\n\n示例：\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // 未检查的赋值\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unchecked",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/编译器问题",
                      "index": 88,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLengthCheck",
                "shortDescription": {
                  "text": "冗余的数组长度检查"
                },
                "fullDescription": {
                  "text": "报告数组迭代后不必要的数组长度检查。 当数组长度为零时，迭代将被跳过，因此没有必要显式地检查长度。 示例： 'void f(String[] array) {\n    if (array.length != 0) { // 不必要的检查\n      for (String str : array) {\n        System.out.println(str);\n      }\n    }\n  }' 建议使用快速修复来解包或移除长度检查： 'void f(String[] array) {\n    for (String str : array) {\n      System.out.println(str);\n    }\n  }' 2022.3 最新变化",
                  "markdown": "报告数组迭代后不必要的数组长度检查。 当数组长度为零时，迭代将被跳过，因此没有必要显式地检查长度。\n\n示例：\n\n\n      void f(String[] array) {\n        if (array.length != 0) { // 不必要的检查\n          for (String str : array) {\n            System.out.println(str);\n          }\n        }\n      }\n\n建议使用快速修复来解包或移除长度检查：\n\n\n      void f(String[] array) {\n        for (String str : array) {\n          System.out.println(str);\n        }\n      }\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantLengthCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DataFlowIssue",
                "shortDescription": {
                  "text": "为 null 性和数据流问题"
                },
                "fullDescription": {
                  "text": "根据数据流分析，报告始终违反为 null 性约定、可能抛出异常或只是冗余的代码结构。 示例： 'if (array.length < index) {\n  System.out.println(array[index]);\n} // 数组索引始终超出界限\n\nif (str == null) System.out.println(\"str is null\");\nSystem.out.println(str.trim());\n// 最后一个语句可能会抛出 NPE\n\n@NotNull\nInteger square(@Nullable Integer input) {\n    // 违反方法约定\n    return input == null ? null : input * input;\n}' 检查行为可能由许多注解控制，例如为 null 性注解、'@Contract' 注解、'@Range' 注解等。 配置检查： 使用对可 null 值的方法/字段/形参建议使用 @Nullable 注解选项可以在以下情况下发出警告：null 值作为实参传递给具有非注解形参的方法时，存储到非注解字段时，或从非注解方法返回时。 在这种情况下，该检查将建议传播 '@Nullable' 注解。 您还可以使用配置注解按钮配置可 null 性注解。 使用将未注解的成员和形参视为 @Nullable 选项可假设非注解成员可以为 null，因此不得在非 null 上下文中使用。 使用报告使用 null 文字实参用法的非 null 必需形参>选项可以报告不能为 null（例如在方法体中立即取消引用），但存在传递 'null' 文字的调用点的方法形参。 使用报告始终返回非 null 值的可 null 方法选项，可报告注解为 '@Nullable' 但始终返回非 null 值的方法。 在这种情况下，建议您将注解更改为 '@NotNull'。 使用忽略 assert 语句选项可控制检查如何处理 'assert' 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。 使用报告仅在某些代码路径上发生的问题选项可控制是否报告仅在某些代码路径上发生的问题。 如果禁用此选项，则不会报告 exception is possible 等警告。 该检查只会报告类似 exception will definitely occur 的警告。 这种模式可以大大减少误报的数量，特别是如果代码没有一致地使用可 null 性和约定注解进行注解。 这就是为什么它对于查找传统代码库中最重要的问题很有用。 在 IntelliJ IDEA 2022.3 版本之前，此检查为“常量条件和异常”检查的一部分。 现在，它被拆分成两个检查：“常量值”和“为 null 性和数据流问题”。",
                  "markdown": "根据数据流分析，报告始终违反为 null 性约定、可能抛出异常或只是冗余的代码结构。\n\n示例：\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // 数组索引始终超出界限\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // 最后一个语句可能会抛出 NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // 违反方法约定\n        return input == null ? null : input * input;\n    }\n\n\n检查行为可能由许多注解控制，例如[为 null 性](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html)注解、[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) 注解、`@Range` 注解等。\n\n配置检查：\n\n* 使用**对可 null 值的方法/字段/形参建议使用 @Nullable 注解** 选项可以在以下情况下发出警告：null 值作为实参传递给具有非注解形参的方法时，存储到非注解字段时，或从非注解方法返回时。 在这种情况下，该检查将建议传播 `@Nullable` 注解。 您还可以使用**配置注解**按钮配置可 null 性注解。\n* 使用**将未注解的成员和形参视为 @Nullable** 选项可假设非注解成员可以为 null，因此不得在非 null 上下文中使用。\n* 使用**报告使用 null 文字实参用法的非 null 必需形参** \\>选项可以报告不能为 null（例如在方法体中立即取消引用），但存在传递 `null` 文字的调用点的方法形参。\n* 使用**报告始终返回非 null 值的可 null 方法** 选项，可报告注解为 `@Nullable` 但始终返回非 null 值的方法。 在这种情况下，建议您将注解更改为 `@NotNull`。\n* 使用**忽略 assert 语句** 选项可控制检查如何处理 `assert` 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。\n* 使用**报告仅在某些代码路径上发生的问题** 选项可控制是否报告仅在某些代码路径上发生的问题。 如果禁用此选项，则不会报告 *exception is possible* 等警告。 该检查只会报告类似 *exception will definitely occur* 的警告。 这种模式可以大大减少误报的数量，特别是如果代码没有一致地使用可 null 性和约定注解进行注解。 这就是为什么它对于查找传统代码库中最重要的问题很有用。\n\n\n在 IntelliJ IDEA 2022.3 版本之前，此检查为\"常量条件和异常\"检查的一部分。\n现在，它被拆分成两个检查：\"常量值\"和\"为 null 性和数据流问题\"。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DataFlowIssue",
                    "cweIds": [
                      129,
                      252,
                      253,
                      394,
                      395,
                      476,
                      570,
                      571,
                      690
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterCanBeLocal",
                "shortDescription": {
                  "text": "从不读取作为形参传递的值"
                },
                "fullDescription": {
                  "text": "报告可以用局部变量替换的冗余方法形参。 如果一个形参的所有局部用法都紧跟对该形参的赋值，则可以移除该形参，并且将其用法替换为局部变量。 拥有此类形参是没有意义的，因为传递给它的值会被重写。 此问题通常是重构的结果。 示例： 'void test(int p) {\n    p = 1;\n    System.out.print(p);\n  }' 在应用快速修复后： 'void test() {\n    int p = 1;\n    System.out.print(p);\n  }'",
                  "markdown": "报告可以用局部变量替换的冗余方法形参。\n\n如果一个形参的所有局部用法都紧跟对该形参的赋值，则可以移除该形参，并且将其用法替换为局部变量。\n拥有此类形参是没有意义的，因为传递给它的值会被重写。\n此问题通常是重构的结果。\n\n示例：\n\n\n      void test(int p) {\n        p = 1;\n        System.out.print(p);\n      }\n\n在应用快速修复后：\n\n\n      void test() {\n        int p = 1;\n        System.out.print(p);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterCanBeLocal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToSimpleGetterInClass",
                "shortDescription": {
                  "text": "从类内调用简单 getter"
                },
                "fullDescription": {
                  "text": "报告从属性的类内部对简单属性 getter 的调用。 简单的属性 getter 会被定义为只返回字段的值，而不进行其他计算。 可以使用该快速修复安全地内联此类简单的 getter 调用。 为了保持代码清晰，某些编码标准还建议不使用简单的 getter。 示例： 'public class Salient {\n    private String name;\n\n    public String getName() {\n      return name;\n    }\n\n    @Override\n    public String toString() {\n      return getName();\n    }\n  }' 在应用快速修复后： 'public class Salient {\n    private String name;\n\n    public String getName() {\n      return name;\n    }\n\n    @Override\n    public String toString() {\n      return name;\n    }\n  }' 使用以下选项配置检查： 是否仅报告 'this' 上的 getter 调用，而不报告作为形参传入的相同类型的对象。 是否忽略非 'private' getter。",
                  "markdown": "报告从属性的类内部对简单属性 getter 的调用。\n\n\n简单的属性 getter 会被定义为只返回字段的值，而不进行其他计算。 可以使用该快速修复安全地内联此类简单的 getter 调用。\n为了保持代码清晰，某些编码标准还建议不使用简单的 getter。\n\n**示例：**\n\n\n      public class Salient {\n        private String name;\n\n        public String getName() {\n          return name;\n        }\n\n        @Override\n        public String toString() {\n          return getName();\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Salient {\n        private String name;\n\n        public String getName() {\n          return name;\n        }\n\n        @Override\n        public String toString() {\n          return name;\n        }\n      }\n\n使用以下选项配置检查：\n\n* 是否仅报告 `this` 上的 getter 调用，而不报告作为形参传入的相同类型的对象。\n* 是否忽略非 `private` getter。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSimpleGetterFromWithinClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementDensity",
                "shortDescription": {
                  "text": "'switch' 语句的分支密度过低"
                },
                "fullDescription": {
                  "text": "报告 switch 标签与可执行语句的比率太低的 'switch' 语句或表达式。 此类 'switch' 语句可能令人困惑，或许应对其进行重构。 示例： 'switch (i) { // 1 个 case，5 个可执行语句 -> 20% 的密度\n        case 1:\n            System.out.println(\"1\");\n            System.out.println(\"2\");\n            System.out.println(\"3\");\n            System.out.println(\"4\");\n            System.out.println(\"5\");\n            break;\n    }' 使用分支的最小密度字段可以指定 switch 标签与可执行语句的允许比率。",
                  "markdown": "报告 switch 标签与可执行语句的比率太低的 `switch` 语句或表达式。\n\n此类 `switch` 语句可能令人困惑，或许应对其进行重构。\n\n示例：\n\n\n        switch (i) { // 1 个 case，5 个可执行语句 -> 20% 的密度\n            case 1:\n                System.out.println(\"1\");\n                System.out.println(\"2\");\n                System.out.println(\"3\");\n                System.out.println(\"4\");\n                System.out.println(\"5\");\n                break;\n        }\n\n\n使用**分支的最小密度**字段可以指定 switch 标签与可执行语句的允许比率。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatementDensity",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableFieldInSerializableClass",
                "shortDescription": {
                  "text": "'Serializable' 类中有不可序列化的字段"
                },
                "fullDescription": {
                  "text": "报告实现 'java.io.Serializable' 的类中的不可序列化字段。 如果对象被序列化，此类字段将导致运行时异常。 不报告被声明为 'transient' 或 'static' 的字段，也不报告定义了 'writeObject' 方法的类的字段。 此检查假定 'java.util.Collection' 和 'java.util.Map' 类型的字段为 'Serializable'，除非声明它们的类型为非 'Serializable'。 示例： 'class NonSerializableClass {}\n\n  public class SerializableClass implements Serializable {\n      NonSerializableClass clazz; // //警告：可序列化类中存在不可序列化字段 'clazz'\n      static NonSerializableClass staticClazz; // 无警告\n  }'\n 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 列出会使检查忽略注解字段的注解。 是否忽略使用匿名类初始化的字段。",
                  "markdown": "报告实现 `java.io.Serializable` 的类中的不可序列化字段。 如果对象被序列化，此类字段将导致运行时异常。\n\n\n不报告被声明为 `transient` 或 `static` 的字段，也不报告定义了 `writeObject` 方法的类的字段。\n\n\n此检查假定 `java.util.Collection` 和 `java.util.Map` 类型的字段为 `Serializable`，除非声明它们的类型为非 `Serializable`。\n\n**示例：**\n\n\n      class NonSerializableClass {}\n\n      public class SerializableClass implements Serializable {\n          NonSerializableClass clazz; // //警告：可序列化类中存在不可序列化字段 'clazz'\n          static NonSerializableClass staticClazz; // 无警告\n      }\n      \n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 列出会使检查忽略注解字段的注解。\n* 是否忽略使用匿名类初始化的字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableFieldInSerializableClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedJavadocCode",
                "shortDescription": {
                  "text": "Javadoc 和代码不匹配"
                },
                "fullDescription": {
                  "text": "报告用英语编写的与方法声明冲突的方法规范部分。 这包括： 方法被指定为返回 'true' 或 'false'，但其返回值类型不是布尔。 方法被指定为返回 'null'，但被注解为 '@NotNull' 或其返回值类型为基元。 方法被指定为返回列表，但其返回值类型为集合或数组。 以此类推。 示例： '/**\n   * @return true if user is found, false otherwise\n   */\n  User findUser(String name);' 请注意，误报是可能的，因为此检查会试图解释一种人类语言。 然而，如果检查不正确报告，描述仍然可能令人困惑，应该重写。 2022.3 最新变化",
                  "markdown": "报告用英语编写的与方法声明冲突的方法规范部分。 这包括：\n\n* 方法被指定为返回 `true` 或 `false`，但其返回值类型不是布尔。\n* 方法被指定为返回 `null`，但被注解为 `@NotNull` 或其返回值类型为基元。\n* 方法被指定为返回列表，但其返回值类型为集合或数组。\n* 以此类推。\n\n**示例：**\n\n\n      /**\n       * @return true if user is found, false otherwise\n       */\n      User findUser(String name);\n\n\n请注意，误报是可能的，因为此检查会试图解释一种人类语言。 然而，如果检查不正确报告，描述仍然可能令人困惑，应该重写。\n\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedJavadocCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnhancedSwitchMigration",
                "shortDescription": {
                  "text": "语句可被替换为增强的 'switch'"
                },
                "fullDescription": {
                  "text": "报告可以自动替换为增强型 'switch' 语句或表达式的 'switch' 语句。 示例： 'double getPrice(String fruit) {\n    // Switch 语句可以替换为增强型 'switch'\n    switch (fruit) {\n      case \"Apple\":\n        return 1.0;\n      case \"Orange\":\n        return 1.5;\n      case \"Mango\":\n        return 2.0;\n      default:\n        throw new IllegalArgumentException();\n    }\n  }' 在应用快速修复后： 'double getPrice(String fruit) {\n    return switch (fruit) {\n      case \"Apple\" -> 1.0;\n      case \"Orange\" -> 1.5;\n      case \"Mango\" -> 2.0;\n      default -> throw new IllegalArgumentException();\n    };\n  }' 使用仅在可以转换为表达式时显示警告选项，不对转换为 'switch' 语句发出警告。 使用一个分支中转换为 switch 表达式的最大语句数选项，仅在每个分支的语句数小于给定的语句数时才对转换为表达式发出警告。 2019.1 最新变化 此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。",
                  "markdown": "报告可以自动替换为增强型 `switch` 语句或表达式的 `switch` 语句。\n\n**示例：**\n\n\n      double getPrice(String fruit) {\n        // Switch 语句可以替换为增强型 'switch'\n        switch (fruit) {\n          case \"Apple\":\n            return 1.0;\n          case \"Orange\":\n            return 1.5;\n          case \"Mango\":\n            return 2.0;\n          default:\n            throw new IllegalArgumentException();\n        }\n      }\n\n在应用快速修复后：\n\n\n      double getPrice(String fruit) {\n        return switch (fruit) {\n          case \"Apple\" -> 1.0;\n          case \"Orange\" -> 1.5;\n          case \"Mango\" -> 2.0;\n          default -> throw new IllegalArgumentException();\n        };\n      }\n      \n\n* 使用**仅在可以转换为表达式时显示警告** 选项，不对转换为 `switch` 语句发出警告。\n* 使用**一个分支中转换为 switch 表达式的最大语句数**选项，仅在每个分支的语句数小于给定的语句数时才对转换为表达式发出警告。\n\n2019.1 最新变化\n\n此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnhancedSwitchMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 14",
                      "index": 102,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableAnnotation",
                "shortDescription": {
                  "text": "可简化注解"
                },
                "fullDescription": {
                  "text": "报告可以简化为单元素或标记速记形式的注解。 已报告的问题： 注解名称-值对中的冗余 'value=' 将仅包含单个值的数组值括起来的冗余大括号 @ 符号与注解名称之间的冗余空格 注解名称与形参列表之间的冗余空格 不带任何形参的注解中的冗余圆括号 示例： '@interface Foo { String[] value(); }\n\n  @ Foo({\"foo\"})\n  public String name;' 在应用快速修复后： '@interface Foo { String[] value(); }\n\n  @Foo(\"foo\")\n  public String name;'",
                  "markdown": "报告可以简化为单元素或标记速记形式的注解。\n\n\n已报告的问题：\n\n* 注解名称-值对中的冗余 `value=`\n* 将仅包含单个值的数组值括起来的冗余大括号\n* @ 符号与注解名称之间的冗余空格\n* 注解名称与形参列表之间的冗余空格\n* 不带任何形参的注解中的冗余圆括号\n\n**示例：**\n\n\n      @interface Foo { String[] value(); }\n\n      @ Foo({\"foo\"})\n      public String name;\n\n在应用快速修复后：\n\n\n      @interface Foo { String[] value(); }\n\n      @Foo(\"foo\")\n      public String name;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleLiteralMayBeFloatLiteral",
                "shortDescription": {
                  "text": "转换为 'float' 可以是 'float' 文字"
                },
                "fullDescription": {
                  "text": "报告被立即转换为 'float' 的 'double' 文字表达式。 此类文字表达式可以替换为等效的 'float' 文字。 示例： 'float f = (float)1.1;' 在应用快速修复后： 'float f = 1.1f;'",
                  "markdown": "报告被立即转换为 `float` 的 `double` 文字表达式。\n\n此类文字表达式可以替换为等效的 `float` 文字。\n\n**示例：**\n\n    float f = (float)1.1;\n\n在应用快速修复后：\n\n    float f = 1.1f;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoubleLiteralMayBeFloatLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Guava",
                "shortDescription": {
                  "text": "Guava 的函数基元可被替换为 Java"
                },
                "fullDescription": {
                  "text": "报告可以迁移到标准 Java API 调用的 Guava 函数基元的用法。 例如，该检查会报告类和接口（如 'FluentIterable'、'Optional'、'Function'、'Predicate' 或 'Supplier'）的用法。 示例： 'ImmutableList<String> results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();' 在应用快速修复后： 'List<String> results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());' 该快速修复可能会改变语义。 Guava 的一些惰性求值的可迭代对象可以转换为预求值的可迭代对象。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以迁移到标准 Java API 调用的 Guava 函数基元的用法。\n\n例如，该检查会报告类和接口（如 `FluentIterable`、`Optional`、`Function`、`Predicate` 或 `Supplier`）的用法。\n\n示例：\n\n\n      ImmutableList<String> results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();\n\n在应用快速修复后：\n\n\n      List<String> results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());\n\n\n该快速修复可能会改变语义。 Guava 的一些惰性求值的可迭代对象可以转换为预求值的可迭代对象。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Guava",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoopMethodInAbstractClass",
                "shortDescription": {
                  "text": "'abstract' 类中的无运算方法"
                },
                "fullDescription": {
                  "text": "报告 'abstract' 类中的 no-op（表示“无运算”）方法。 更好的设计通常是将此类方法设为 'abstract'，以便继承这些方法的类提供实现。 示例： 'abstract class Test {\n    protected void doTest() {\n    }\n  }'",
                  "markdown": "报告 `abstract` 类中的 no-op（表示\"无运算\"）方法。\n\n更好的设计通常是将此类方法设为 `abstract`，以便继承这些方法的类提供实现。\n\n**示例：**\n\n\n      abstract class Test {\n        protected void doTest() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NoopMethodInAbstractClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverloadedMethodsWithSameNumberOfParameters",
                "shortDescription": {
                  "text": "具有相同形参数量的重载方法"
                },
                "fullDescription": {
                  "text": "报告在同一类中声明、具有相同名称和相同数量形参的方法。 此类重载可能非常令人困惑，因为可能不清楚调用的是哪个重载。 示例： 'class Main {\n    public static void execute(Runnable r) {}\n    public static <T> void execute(RunnableFuture<T> c) {}\n  }' 使用该选项可以忽略形参类型绝对不兼容的重载方法。",
                  "markdown": "报告在同一类中声明、具有相同名称和相同数量形参的方法。 此类重载可能非常令人困惑，因为可能不清楚调用的是哪个重载。\n\n**示例：**\n\n\n      class Main {\n        public static void execute(Runnable r) {}\n        public static <T> void execute(RunnableFuture<T> c) {}\n      }\n\n\n使用该选项可以忽略形参类型绝对不兼容的重载方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverloadedMethodsWithSameNumberOfParameters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverridableMethodCallDuringObjectConstruction",
                "shortDescription": {
                  "text": "对象构造期间调用的可重写方法"
                },
                "fullDescription": {
                  "text": "报告在对象构造期间对当前类的可重写方法的调用。 如果方法位于以下位置，则会在对象构造期间调用： 构造函数 非 static 实例初始值设定项 非 static 字段初始值设定项 'clone()' 方法 'readObject()' 方法 'readObjectNoData()' 方法 如果方法未被声明为 'final'、'static' 或 'private'，则该方法可重写。 即使可重写，package-local 方法也被认为是安全的。 此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。 示例： 'class Parent {\n    void someMethod() { }\n  }\n\n  class Child extends Parent {\n    Child() {\n      someMethod();\n    }\n  }' 此检查与以下检查共享功能： 对象构造期间调用的 abstract 方法 在对象构造期间调用的重写的方法 一次只能启用一个检查，以防止警告重复。",
                  "markdown": "报告在对象构造期间对当前类的可重写方法的调用。\n\n如果方法位于以下位置，则会在对象构造期间调用：\n\n* 构造函数\n* 非 static 实例初始值设定项\n* 非 static 字段初始值设定项\n* `clone()` 方法\n* `readObject()` 方法\n* `readObjectNoData()` 方法\n* 如果方法未被声明为 `final`、`static` 或 `private`，则该方法可重写。 即使可重写，package-local 方法也被认为是安全的。 此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。\n* **示例：**\n\n\n      class Parent {\n        void someMethod() { }\n      }\n\n      class Child extends Parent {\n        Child() {\n          someMethod();\n        }\n      }\n\n* 此检查与以下检查共享功能：\n  * 对象构造期间调用的 abstract 方法\n  * 在对象构造期间调用的重写的方法\n* 一次只能启用一个检查，以防止警告重复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverridableMethodCallDuringObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyLongLambda",
                "shortDescription": {
                  "text": "过长的 lambda 表达式"
                },
                "fullDescription": {
                  "text": "报告语句数超过指定最大值的 lambda 表达式。 过长的 lambda 表达式可能令人困惑，将语句提取到单独的方法中通常会更好。 以下语句不计算在内： 空语句（分号） 块语句 'for' 循环初始化语句，即 'for(int i = ...;...)' 语句内的 'int i = ...' 'for' 循环 update 语句，即 'for(int i = ...;...; i += 2)' 语句内的 'i += 2' 使用非注释源语句限制字段可指定 lambda 表达式中允许的最大语句数。",
                  "markdown": "报告语句数超过指定最大值的 lambda 表达式。\n\n过长的 lambda 表达式可能令人困惑，将语句提取到单独的方法中通常会更好。\n\n\n以下语句不计算在内：\n\n* 空语句（分号）\n* 块语句\n* `for` 循环初始化语句，即 `for(int i = ...;...)` 语句内的 `int i = ...`\n* `for` 循环 update 语句，即 `for(int i = ...;...; i += 2)` 语句内的 `i += 2`\n\n使用**非注释源语句限制**字段可指定 lambda 表达式中允许的最大语句数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyLongLambda",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParametersPerMethod",
                "shortDescription": {
                  "text": "形参过多的方法"
                },
                "fullDescription": {
                  "text": "报告形参数量超过指定最大值的方法。 方法的形参过多可能表明有必要重构。 不报告具有 super 方法的方法。 使用形参限制字段可以指定方法允许的最大形参数量。",
                  "markdown": "报告形参数量超过指定最大值的方法。 方法的形参过多可能表明有必要重构。\n\n不报告具有 super 方法的方法。\n\n使用**形参限制**字段可以指定方法允许的最大形参数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithTooManyParameters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingDeprecatedAnnotation",
                "shortDescription": {
                  "text": "缺少 '@Deprecated' 注解"
                },
                "fullDescription": {
                  "text": "报告具有 '@deprecated' Javadoc 标记但没有 '@java.lang.Deprecated' 注解的模块声明、类、字段或方法。 示例： '/**\n   * @deprecated use {@code example()} instead\n   */\n  void sample(){ }' 在应用快速修复后： '/**\n   * @deprecated use {@code example()} instead\n   */\n  @Deprecated\n  void sample(){ }' 使用下面的复选框，报告使用 '@Deprecated' 注解但在 Javadoc '@deprecated' 标记中没有解释的成员。 此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。",
                  "markdown": "报告具有 `@deprecated` Javadoc 标记但没有 `@java.lang.Deprecated` 注解的模块声明、类、字段或方法。\n\n**示例：**\n\n\n      /**\n       * @deprecated use {@code example()} instead\n       */\n      void sample(){ }\n\n在应用快速修复后：\n\n\n      /**\n       * @deprecated use {@code example()} instead\n       */\n      @Deprecated\n      void sample(){ }\n\n\n使用下面的复选框，报告使用 `@Deprecated` 注解但在 Javadoc `@deprecated` 标记中没有解释的成员。\n\n此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingDeprecatedAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitCallToSuper",
                "shortDescription": {
                  "text": "隐式调用 'super()'"
                },
                "fullDescription": {
                  "text": "报告不以调用 \"super\" 构造函数或同一类的另一个构造函数开头的构造函数。 可以认为是此类构造函数隐式地从调用 'super()' 开始。 某些编码标准倾向于显式地调用 'super()'。 示例： 'class Foo {\n    Foo() {}\n  }' 在应用快速修复后： 'class Foo {\n    Foo() {\n      super();\n    }\n  }' 使用检查设置可以忽略直接从 'Object' 扩展的类。 例如： 'class Foo {\n    Foo() {} // 未报告\n  }\n\n  class Bar extends Foo {\n    Bar() {} // 对 'super()' 的隐式调用\n  }'",
                  "markdown": "报告不以调用 \"super\" 构造函数或同一类的另一个构造函数开头的构造函数。\n\n可以认为是此类构造函数隐式地从调用 `super()` 开始。 某些编码标准倾向于显式地调用 `super()`。\n\n**示例：**\n\n\n      class Foo {\n        Foo() {}\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        Foo() {\n          super();\n        }\n      }\n\n\n使用检查设置可以忽略直接从 `Object` 扩展的类。\n例如：\n\n\n      class Foo {\n        Foo() {} // 未报告\n      }\n\n      class Bar extends Foo {\n        Bar() {} // 对 'super()' 的隐式调用\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitCallToSuper",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTemplateMigration",
                "shortDescription": {
                  "text": "可以使用字符串模板"
                },
                "fullDescription": {
                  "text": "报告可以通过替换为字符串模板简化的 'String' 串联。 示例： 'String name = \"Bob\";\n  String greeting = \"Hello, \" + name + \". You are \" + 29 + \" years old.\";' 在应用快速修复后： 'String name = \"Bob\";\n  String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";' 2023.3 最新变化 此检查取决于 Java 功能 '字符串模板'，该功能自 Java 21-preview 起可用。",
                  "markdown": "报告可以通过替换为字符串模板简化的 `String` 串联。\n\n**示例：**\n\n\n      String name = \"Bob\";\n      String greeting = \"Hello, \" + name + \". You are \" + 29 + \" years old.\";\n\n在应用快速修复后：\n\n\n      String name = \"Bob\";\n      String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";\n\n2023.3 最新变化\n\n此检查取决于 Java 功能 '字符串模板'，该功能自 Java 21-preview 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringTemplateMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CachedNumberConstructorCall",
                "shortDescription": {
                  "text": "数字构造函数调用具有基元实参"
                },
                "fullDescription": {
                  "text": "报告具有基元 'long'、'integer'、'short' 或 'byte' 实参的新 'Long'、'Integer'、'Short' 或 'Byte' 对象的实例化。 建议使用 Java 5 中引入的 static 方法 'valueOf()' 默认情况下，此方法缓存值介于 -128 到 127（包含）之间的对象。 示例： 'Integer i = new Integer(1);\n  Long l = new Long(1L);' 应用快速修复后，代码变为： 'Integer i = Integer.valueOf(1);\n  Long l = Long.valueOf(1L);' 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。 使用忽略具有字符串实参的新数字表达式选项可以忽略对包含 'String' 实参的数字构造函数的调用。 使用仅在构造函数为 @Deprecated 时报告选项，仅报告对弃用的构造函数的调用。 'Long'、'Integer'、'Short' 和 'Byte' 构造函数自 JDK 9 起已被弃用。",
                  "markdown": "报告具有基元 `long`、`integer`、`short` 或 `byte` 实参的新 `Long`、`Integer`、`Short` 或 `Byte` 对象的实例化。\n\n建议使用 Java 5 中引入的 static 方法 `valueOf()` 默认情况下，此方法缓存值介于 -128 到 127（包含）之间的对象。\n\n**示例：**\n\n\n      Integer i = new Integer(1);\n      Long l = new Long(1L);\n\n应用快速修复后，代码变为：\n\n\n      Integer i = Integer.valueOf(1);\n      Long l = Long.valueOf(1L);\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。\n\n\n使用**忽略具有字符串实参的新数字表达式** 选项可以忽略对包含 `String` 实参的数字构造函数的调用。\n\n\n使用**仅在构造函数为 @Deprecated 时报告** 选项，仅报告对弃用的构造函数的调用。\n`Long`、`Integer`、`Short` 和 `Byte` 构造函数自 JDK 9 起已被弃用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CachedNumberConstructorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MustAlreadyBeRemovedApi",
                "shortDescription": {
                  "text": "API 必须已移除"
                },
                "fullDescription": {
                  "text": "报告使用应从当前版本的声明库中移除的 '@ApiStatus.ScheduledForRemoval' 标记的声明。 它会将计划移除的指定版本与可在下面设置的版本进行比较。 以点分隔字符串指定版本，可选择加上 'alpha'、'beta'、'snapshot' 或 'eap' 后缀。 有效版本示例：'1.0'、'2.3.1'、'2018.1'、'7.5-snapshot'、'3.0-eap'。 版本比较非常直观，例如：'1.0 < 2.0'、'1.0-eap < 1.0'、'2.3-snapshot < 2.3' 等。 有关详细比较逻辑，请参阅 VersionComparatorUtil 的实现。",
                  "markdown": "报告使用应从当前版本的声明库中移除的 `@ApiStatus.ScheduledForRemoval` 标记的声明。\n\n它会将计划移除的指定版本与可在下面设置的版本进行比较。\n\n\n以点分隔字符串指定版本，可选择加上\n`alpha`、`beta`、`snapshot` 或 `eap` 后缀。\n\n有效版本示例：`1.0`、`2.3.1`、`2018.1`、`7.5-snapshot`、`3.0-eap`。\n\n\n版本比较非常直观，例如：`1.0 < 2.0`、`1.0-eap < 1.0`、`2.3-snapshot < 2.3` 等。\n有关详细比较逻辑，请参阅 [VersionComparatorUtil](https://github.com/JetBrains/intellij-community/blob/master/platform/util-rt/src/com/intellij/util/text/VersionComparatorUtil.java) 的实现。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MustAlreadyBeRemovedApi",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneDeclaresCloneNotSupported",
                "shortDescription": {
                  "text": "'clone()' 未声明 'CloneNotSupportedException'"
                },
                "fullDescription": {
                  "text": "报告不声明 'throws CloneNotSupportedException' 的 'clone()' 方法。 如果没有声明 'throws CloneNotSupportedException'，该方法的子类将不能以标准方式禁止克隆。 此检查不会报告声明为 'final' 的 'clone()' 方法和 'final' 类内的 'clone()' 方法。 配置检查： 使用仅对 'protected' 克隆方法发出警告选项可以指示此检查仅对 'protected clone()' 方法发出警告。 Effective Java 一书（第二版和第三版）建议在 'public' 方法上省略 'CloneNotSupportedException' 声明，因为不抛出已检查的异常的方法更容易使用。 示例： 'public class Example implements Cloneable {\n    // 方法未声明 ’throws CloneNotSupportedException‘\n    protected Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n  }'",
                  "markdown": "报告不声明 `throws CloneNotSupportedException` 的 `clone()` 方法。\n\n如果没有声明 `throws CloneNotSupportedException`，该方法的子类将不能以标准方式禁止克隆。 此检查不会报告声明为 `final` 的 `clone()` 方法和 `final` 类内的 `clone()` 方法。\n\n配置检查：\n\n使用**仅对 'protected' 克隆方法发出警告** 选项可以指示此检查仅对 `protected clone()` 方法发出警告。\n*Effective Java* 一书（第二版和第三版）建议在 `public` 方法上省略 `CloneNotSupportedException` 声明，因为不抛出已检查的异常的方法更容易使用。\n\n示例：\n\n\n      public class Example implements Cloneable {\n        // 方法未声明 'throws CloneNotSupportedException'\n        protected Object clone() {\n            try {\n                return super.clone();\n            } catch (CloneNotSupportedException e) {\n                return null;\n            }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneDoesntDeclareCloneNotSupportedException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownDocumentationCommentsMigration",
                "shortDescription": {
                  "text": "Javadoc 注释可以是 Markdown 文档注释"
                },
                "fullDescription": {
                  "text": "报告可以转换为 Markdown 文档注释的 Javadoc 注释。 示例： '/**\n   * For blubbering of the florz.\n   *\n   * Similar to {@link com.deeps.Querp querping} class.\n   */\n  class FlorzBlubber {\n  }' 在应用快速修复后： '/// For blubbering of the florz.\n  /// Similar to [querping][com.deeps.Querp] class.\n  class FlorzBlubber {\n  }' 2024.2 最新变化",
                  "markdown": "报告可以转换为 Markdown 文档注释的 Javadoc 注释。\n\n**示例：**\n\n\n      /**\n       * For blubbering of the florz.\n       *\n       * Similar to {@link com.deeps.Querp querping} class.\n       */\n      class FlorzBlubber {\n      }\n\n在应用快速修复后：\n\n\n      /// For blubbering of the florz.\n      /// Similar to [querping][com.deeps.Querp] class.\n      class FlorzBlubber {\n      }\n\n2024.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MarkdownDocumentationCommentsMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 23",
                      "index": 105,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanExpressionMayBeConditional",
                "shortDescription": {
                  "text": "布尔表达式可被替换为条件表达式"
                },
                "fullDescription": {
                  "text": "报告任何能够以比使用条件表达式更紧凑、更清晰的方式来表述的 'boolean' 表达式。 使用该快速修复可以将 'boolean' 表达式替换为条件表达式。 示例： 'a && b || !a && c;' 在应用快速修复后： 'a ? b : c;'",
                  "markdown": "报告任何能够以比使用条件表达式更紧凑、更清晰的方式来表述的 `boolean` 表达式。\n\n使用该快速修复可以将 `boolean` 表达式替换为条件表达式。\n\n**示例：**\n\n\n      a && b || !a && c;\n\n在应用快速修复后：\n\n\n      a ? b : c;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "BooleanExpressionMayBeConditional",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldHidesSuperclassField",
                "shortDescription": {
                  "text": "子类字段隐藏超类字段"
                },
                "fullDescription": {
                  "text": "报告派生类中与超类的字段同名的字段。 Java 字段无法在派生类中重写，因此派生类中的字段将对超类隐藏该字段。 由于进行此类命名，在基类有意使用同名字段的情况下，您可能会误用派生类的字段。 建议通过快速修复重命名派生类中的字段。 示例： 'class Parent {\n  Parent parent;\n}\nclass Child extends Parent {\n  Child parent;\n}' 您可以为此检查配置以下选项： 忽略不可访问字段 - 指示此检查应报告所有名称冲突，还是只报告与子类可见的字段的冲突。 忽略隐藏 static 字段的 static 字段 - 忽略隐藏基类中的 'static' 字段的 'static' 字段。",
                  "markdown": "报告派生类中与超类的字段同名的字段。 Java 字段无法在派生类中重写，因此派生类中的字段将对超类隐藏该字段。\n\n\n由于进行此类命名，在基类有意使用同名字段的情况下，您可能会误用派生类的字段。\n\n建议通过快速修复重命名派生类中的字段。\n\n**示例：**\n\n    class Parent {\n      Parent parent;\n    }\n    class Child extends Parent {\n      Child parent;\n    }\n\n\n您可以为此检查配置以下选项：\n\n1. **忽略不可访问字段** - 指示此检查应报告所有名称冲突，还是只报告与子类可见的字段的冲突。\n2. **忽略隐藏 static 字段的 static 字段** - 忽略隐藏基类中的 `static` 字段的 `static` 字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldNameHidesFieldInSuperclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimpleDateFormatWithoutLocale",
                "shortDescription": {
                  "text": "无区域设置的 'SimpleDateFormat'"
                },
                "fullDescription": {
                  "text": "报告未指定 'java.util.Locale' 的 'java.util.SimpleDateFormat' 或 'java.time.format.DateTimeFormatter' 的实例化。 这些调用将使用平台默认区域设置，具体取决于操作系统设置。 当代码在不同的平台上运行或操作系统设置被更改时，这可能会导致意外行为。 '示例：' 'new SimpleDateFormat(\"yyyy\");\n  DateTimeFormatter.ofPattern(\"d/M/y\");'",
                  "markdown": "报告未指定 `java.util.Locale` 的 `java.util.SimpleDateFormat` 或 `java.time.format.DateTimeFormatter` 的实例化。 这些调用将使用平台默认区域设置，具体取决于操作系统设置。 当代码在不同的平台上运行或操作系统设置被更改时，这可能会导致意外行为。\n\n`示例：`\n\n\n      new SimpleDateFormat(\"yyyy\");\n      DateTimeFormatter.ofPattern(\"d/M/y\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimpleDateFormatWithoutLocale",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryExplicitNumericCast",
                "shortDescription": {
                  "text": "不必要的显式数字转换"
                },
                "fullDescription": {
                  "text": "报告将由编译器隐式插入的基元数字类型转换。 此外，报告编译器将移除的任何基元数值转换。 示例： 'int x = (short)5; // 该转换将被 javac 工具移除' 在应用快速修复后： 'int x = 5;'",
                  "markdown": "报告将由编译器隐式插入的基元数字类型转换。 此外，报告编译器将移除的任何基元数值转换。\n\n**示例：**\n\n    int x = (short)5; // 该转换将被 javac 工具移除\n\n在应用快速修复后：\n`int x = 5;`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryExplicitNumericCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnnotationClass",
                "shortDescription": {
                  "text": "注解接口"
                },
                "fullDescription": {
                  "text": "报告注解接口。 Java 1.4 和更早版本不支持此类接口。",
                  "markdown": "报告注解接口。 Java 1.4 和更早版本不支持此类接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnnotationClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TransientFieldNotInitialized",
                "shortDescription": {
                  "text": "transient 字段在反序列化时未初始化"
                },
                "fullDescription": {
                  "text": "报告在正常对象构造过程中初始化，但其类没有 'readObject' 方法的 'transient' 字段。 'transient' 字段未被序列化，因此在反序列化期间，需要在 'readObject()' 方法中单独初始化。 任何在正常对象构造过程中未被初始化的 'transient' 字段都被视为使用默认初始化，并且不会被此检查报告。 示例： 'class Person implements Serializable {\n    transient String name = \"Default\"; //警告，反序列化后实际上可能为 null\n    transient String surname; //null 被视为默认值，不予报告\n  }'",
                  "markdown": "报告在正常对象构造过程中初始化，但其类没有 `readObject` 方法的 `transient` 字段。\n\n\n`transient` 字段未被序列化，因此在反序列化期间，需要在 `readObject()` 方法中单独初始化。\n\n\n任何在正常对象构造过程中未被初始化的 `transient` 字段都被视为使用默认初始化，并且不会被此检查报告。\n\n**示例：**\n\n\n      class Person implements Serializable {\n        transient String name = \"Default\"; //警告，反序列化后实际上可能为 null\n        transient String surname; //null 被视为默认值，不予报告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TransientFieldNotInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PropertyValueSetToItself",
                "shortDescription": {
                  "text": "属性值设置为自身"
                },
                "fullDescription": {
                  "text": "报告以相同的对象 getter 作为值的 setter 方法的调用。 该代码通常不执行任何工作，并且可能不是有意为之。 示例： 'bean.setPayerId(bean.getPayerId());'",
                  "markdown": "报告以相同的对象 getter 作为值的 setter 方法的调用。 该代码通常不执行任何工作，并且可能不是有意为之。\n\n**示例：**\n\n    bean.setPayerId(bean.getPayerId());\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PropertyValueSetToItself",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Finalize",
                "shortDescription": {
                  "text": "'finalize()' 不应被重写"
                },
                "fullDescription": {
                  "text": "报告重写 'Object.finalize()' 方法。 根据 'Object.finalize()' 文档： 终结机制本身就有问题。 终结可能导致性能问题、死锁和挂起。 终结器中的错误可能导致资源泄漏；如果不再需要，那么无从取消终结；并且对不同对象的 'finalize' 方法的调用之间没有指定顺序。 此外，关于终结时机也没有任何保证。 'finalize' 方法只能在不确定的延迟之后才对可终结的对象调用（如果有）。 配置检查： 使用对普通 'finalize()' 实现忽略选项可以忽略具有空方法体或仅包含具有计算结果为 'false' 的条件并且是编译时常量的 'if' 语句的方法体的 'finalize()' 实现。 出于性能原因，在子类中使用空实现重写非普通 'finalize()' 可能会有好处。 空的 final 'finalize()' 实现也可以用来防止子类被重写。",
                  "markdown": "报告重写 `Object.finalize()` 方法。\n\n根据 `Object.finalize()` 文档：\n>\n> 终结机制本身就有问题。 终结可能导致性能问题、死锁和挂起。 终结器中的错误可能导致资源泄漏；如果不再需要，那么无从取消终结；并且对不同对象的 `finalize` 方法的调用之间没有指定顺序。 此外，关于终结时机也没有任何保证。 `finalize` 方法只能在不确定的延迟之后才对可终结的对象调用（如果有）。\n\n配置检查：\n\n* 使用**对普通 'finalize()' 实现忽略** 选项可以忽略具有空方法体或仅包含具有计算结果为 `false` 的条件并且是编译时常量的 `if` 语句的方法体的 `finalize()` 实现。 出于性能原因，在子类中使用空实现重写非普通 `finalize()` 可能会有好处。 空的 final `finalize()` 实现也可以用来防止子类被重写。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalizeDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/完成",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessArithmeticExpression",
                "shortDescription": {
                  "text": "无意义的算术表达式"
                },
                "fullDescription": {
                  "text": "报告无意义的算术表达式。 此类表达式包括加 0、减 0、乘以 0 或 1 以及除以 1。 此类表达式可能是自动重构所致，不太可能是开发者的本意。 该快速修复会简化此类表达式。 示例： 'void f(int a) {\n    int x = a - a;\n    int y = a + 0;\n    int res = x / x;\n  }' 在应用快速修复后： 'void f(int a) {\n    int x = 0;\n    int y = a;\n    int res = 1;\n  }' 请注意，在极少数情况下，建议的替换可能不完全等同于所有可能输入的原始代码。 例如，该检查会建议将 'x / x' 替换为 '1'。 但是，如果 'x' 为零，原始代码将抛出 'ArithmeticException' 或导致 'NaN'。 另外，如果 'x' 为 'NaN'，则结果也是 'NaN'。 此类行为不太可能出于本意。",
                  "markdown": "报告无意义的算术表达式。 此类表达式包括加 0、减 0、乘以 0 或 1 以及除以 1。\n\n此类表达式可能是自动重构所致，不太可能是开发者的本意。\n\n该快速修复会简化此类表达式。\n\n**示例：**\n\n\n      void f(int a) {\n        int x = a - a;\n        int y = a + 0;\n        int res = x / x;\n      }\n\n在应用快速修复后：\n\n\n      void f(int a) {\n        int x = 0;\n        int y = a;\n        int res = 1;\n      }\n\n\n请注意，在极少数情况下，建议的替换可能不完全等同于所有可能输入的原始代码。 例如，该检查会建议将 `x / x` 替换为 `1`。\n但是，如果 `x` 为零，原始代码将抛出 `ArithmeticException` 或导致 `NaN`。\n另外，如果 `x` 为 `NaN`，则结果也是 `NaN`。 此类行为不太可能出于本意。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessArithmeticExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyLargePrimitiveArrayInitializer",
                "shortDescription": {
                  "text": "原始类型数组的过大初始值设定项"
                },
                "fullDescription": {
                  "text": "报告包含过多元素的基元数组的数组初始值设定项表达式。 此类初始值设定项可能会导致过大的类文件，因为必须生成代码才能初始化每个数组元素。 在内存或带宽受限的环境中，从资源文件加载大型基元数组可能更高效。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 使用该选项可以指定基元数组初始值设定项中允许的最大元素数。",
                  "markdown": "报告包含过多元素的基元数组的数组初始值设定项表达式。 此类初始值设定项可能会导致过大的类文件，因为必须生成代码才能初始化每个数组元素。 在内存或带宽受限的环境中，从资源文件加载大型基元数组可能更高效。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n\n使用该选项可以指定基元数组初始值设定项中允许的最大元素数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyLargePrimitiveArrayInitializer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassInitializer",
                "shortDescription": {
                  "text": "非 'static' 初始值设定项"
                },
                "fullDescription": {
                  "text": "报告类中的非 'static' 初始值设定项。 某些编码标准禁止实例初始值设定项，建议使用构造函数或字段初始值设定项进行初始化。 此外，删除 'static' 关键字可能会导致意外创建非 'static' 初始值设定项，造成模糊不清的错误。 此检查不报告匿名类中的实例初始值设定项。 使用仅在类具有一个或多个构造函数时警告选项，可忽略没有任何构造函数的类中的实例初始值设定项。",
                  "markdown": "报告类中的非 `static` 初始值设定项。\n\n某些编码标准禁止实例初始值设定项，建议使用构造函数或字段初始值设定项进行初始化。\n此外，删除 `static` 关键字可能会导致意外创建非 `static` 初始值设定项，造成模糊不清的错误。\n\n此检查不报告匿名类中的实例初始值设定项。\n\n\n使用**仅在类具有一个或多个构造函数时警告**选项，可忽略没有任何构造函数的类中的实例初始值设定项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonStaticInitializer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectNotify",
                "shortDescription": {
                  "text": "调用 'notify()' 而不是 'notifyAll()'"
                },
                "fullDescription": {
                  "text": "报告对 'Object.notify()' 的调用。 虽然偶尔有用，但在几乎所有情况下，'Object.notifyAll()' 都是更好的选择，因为调用 'Object.notify()' 可能导致死锁。 有关讨论，请参阅 Doug Lea 的 Concurrent Programming in Java。",
                  "markdown": "报告对 `Object.notify()` 的调用。 虽然偶尔有用，但在几乎所有情况下，`Object.notifyAll()` 都是更好的选择，因为调用 `Object.notify()` 可能导致死锁。 有关讨论，请参阅 Doug Lea 的 *Concurrent Programming in Java*。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToNotifyInsteadOfNotifyAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueOrBreakFromFinallyBlock",
                "shortDescription": {
                  "text": "'continue' 或 'break' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'break' 或 'continue' 语句。 虽然偶尔是有意为之，但此类语句非常令人困惑，可能会掩盖抛出的异常，并导致调试复杂化。 示例： 'while (true) {\n        try {\n          throwingMethod();\n        } finally {\n            continue;\n        }\n    }'",
                  "markdown": "报告 `finally` 块中的 `break` 或 `continue` 语句。\n\n虽然偶尔是有意为之，但此类语句非常令人困惑，可能会掩盖抛出的异常，并导致调试复杂化。\n\n**示例：**\n\n\n        while (true) {\n            try {\n              throwingMethod();\n            } finally {\n                continue;\n            }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueOrBreakFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LengthOneStringsInConcatenation",
                "shortDescription": {
                  "text": "单字符字符串串联"
                },
                "fullDescription": {
                  "text": "报告与一个字符组成的字符串文字的串联。 这些文字可以替换为等效的字符文字，从而提升一定的性能。 示例： 'String hello = hell + \"o\";' 在应用快速修复后： 'String hello = hell + 'o';'",
                  "markdown": "报告与一个字符组成的字符串文字的串联。\n\n这些文字可以替换为等效的字符文字，从而提升一定的性能。\n\n**示例：**\n\n\n      String hello = hell + \"o\";\n\n在应用快速修复后：\n\n\n      String hello = hell + 'o';\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SingleCharacterStringConcatenation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyTransitiveDependencies",
                "shortDescription": {
                  "text": "可传递依赖项过多的类"
                },
                "fullDescription": {
                  "text": "报告直接或间接依赖于过多其他类的类。 对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。 仅报告顶级类。 使用最大传递依赖项数字段可指定类允许的最大直接或间接依赖项数。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告直接或间接依赖于过多其他类的类。\n\n对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。\n\n仅报告顶级类。\n\n使用**最大传递依赖项数**字段可指定类允许的最大直接或间接依赖项数。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyTransitiveDependencies",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceVariableUninitializedUse",
                "shortDescription": {
                  "text": "实例字段在初始化前使用"
                },
                "fullDescription": {
                  "text": "报告在初始化之前读取的实例变量。 该检查会忽略 'null' 的相等检查。 示例： 'class Foo {\n    int bar;\n\n    Foo() {\n      System.out.println(bar);\n    }\n  }' 请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。 使用有注解时忽略选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的字段。 使用忽略基元字段选项可以忽略未初始化的基元字段。",
                  "markdown": "报告在初始化之前读取的实例变量。\n\n该检查会忽略 `null` 的相等检查。\n\n**示例：**\n\n\n      class Foo {\n        int bar;\n\n        Foo() {\n          System.out.println(bar);\n        }\n      }\n\n请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。\n\n使用**有注解时忽略**选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的字段。\n\n使用**忽略基元字段**选项可以忽略未初始化的基元字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceVariableUsedBeforeInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryThis",
                "shortDescription": {
                  "text": "不必要的 'this' 限定符"
                },
                "fullDescription": {
                  "text": "报告不必要的 'this' 限定符。 使用 'this' 来消除代码引用的歧义在许多编码样式中都不受鼓励，并且很容易通过自动重构变得不必要。 示例： 'class Foo {\n    int x;\n    void foo() {\n      this.x = 2;\n    }\n  }' 在应用快速修复后： 'class Foo {\n    int x;\n    void foo() {\n      x = 2;\n    }\n  }' 使用检查设置可以忽略对字段的赋值。 例如，'this.x = 2;' 不会被报告，但 'int y = this.x;' 会被报告。",
                  "markdown": "报告不必要的 `this` 限定符。\n\n\n使用 ` this ` 来消除代码引用的歧义在许多编码样式中都不受鼓励，并且很容易通过自动重构变得不必要。\n\n**示例：**\n\n\n      class Foo {\n        int x;\n        void foo() {\n          this.x = 2;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        int x;\n        void foo() {\n          x = 2;\n        }\n      }\n\n\n使用检查设置可以忽略对字段的赋值。\n例如，`this.x = 2;` 不会被报告，但 `int y = this.x;` 会被报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopWithImplicitTerminationCondition",
                "shortDescription": {
                  "text": "具有隐式终止条件的循环"
                },
                "fullDescription": {
                  "text": "报告任何以 'true' 常量作为其唯一条件的 'while'、'do-while' 和 'for' 循环。 同时，此类循环仍然能够被可以跳出循环的包含 'if' 语句终止。 此类 'if' 语句必须是 'while' 或 'for' 循环中的第一个或唯一语句，也必须是 'do-while' 循环中的最后一个或唯一语句。 移除 'if' 语句并将其条件设为显式循环条件可简化循环。",
                  "markdown": "报告任何以 `true` 常量作为其唯一条件的 `while`、`do-while` 和 `for` 循环。 同时，此类循环仍然能够被可以跳出循环的包含 `if` 语句终止。\n\n此类 `if` 语句必须是 `while` 或 `for` 循环中的第一个或唯一语句，也必须是 `do-while` 循环中的最后一个或唯一语句。\n\n移除 `if` 语句并将其条件设为显式循环条件可简化循环。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopWithImplicitTerminationCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitArrayFilling",
                "shortDescription": {
                  "text": "显式数组填充"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'Arrays.setAll()' 或 'Arrays.fill()' 调用的循环。 如果项目或模块的语言级别为 8 或更高，则此检查建议将循环替换为 'Arrays.setAll()'。 您可以在任何语言级别将循环替换为 'Arrays.fill()'。 示例： 'for (int i=0; i<array.length; i++) {\n     array[i] = calc(i);\n  }' 在应用快速修复后： 'Arrays.setAll(array, this::calc);' 2017.1 最新变化",
                  "markdown": "报告可以替换为 `Arrays.setAll()` 或 `Arrays.fill()` 调用的循环。\n\n如果项目或模块的语言级别为 8 或更高，则此检查建议将循环替换为 `Arrays.setAll()`。\n您可以在任何语言级别将循环替换为 `Arrays.fill()`。\n\n示例：\n\n\n      for (int i=0; i<array.length; i++) {\n         array[i] = calc(i);\n      }\n\n在应用快速修复后：\n\n\n      Arrays.setAll(array, this::calc);\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExplicitArrayFilling",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExceptionDeclared",
                "shortDescription": {
                  "text": "已声明禁止异常"
                },
                "fullDescription": {
                  "text": "报告在其 'throws' 子句中声明不适当异常的方法。 例如，异常可能因为过于通用而不适当，例如 'java.lang.Exception' 或 'java.lang.Throwable'。 示例： 'void describeModule(String module) throws Exception {} // 警告：声明了禁止的异常 'Exception'' 配置检查： 使用被禁止的异常列表可指定应报告哪些异常。 使用忽略在重写库方法的方法上声明的异常选项可忽略在重写库方法的方法上声明的异常。",
                  "markdown": "报告在其 `throws` 子句中声明不适当异常的方法。 例如，异常可能因为过于通用而不适当，例如 `java.lang.Exception` 或 `java.lang.Throwable`。\n\n**示例：**\n\n\n      void describeModule(String module) throws Exception {} // 警告：声明了禁止的异常 'Exception'\n\n配置检查：\n\n* 使用**被禁止的异常**列表可指定应报告哪些异常。\n* 使用**忽略在重写库方法的方法上声明的异常**选项可忽略在重写库方法的方法上声明的异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProhibitedExceptionDeclared",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntegerMultiplicationImplicitCastToLong",
                "shortDescription": {
                  "text": "整数乘法或移位隐式转换为 'long'"
                },
                "fullDescription": {
                  "text": "报告隐式转换为 long 的整数乘法和左移。 示例： 'void f(int i) {\n    long val = 65536 * i;\n  }' 应用快速修复后，代码变为： 'void x(int i) {\n    long val = 65536L * i;\n  }' 示例： 'void f(int i) {\n    long value = i << 24;\n  }' 应用快速修复后，代码变为： 'void f(int i) {\n    long value = (long) i << 24;\n  }' 此类乘法通常表明有错误，因为可能会意外发生溢出截断。 将 'int' 文字转换为 'long' 文字 ('65536L') 可以修正该问题。",
                  "markdown": "报告隐式转换为 long 的整数乘法和左移。\n\n**示例：**\n\n\n      void f(int i) {\n        long val = 65536 * i;\n      }\n\n应用快速修复后，代码变为：\n\n\n      void x(int i) {\n        long val = 65536L * i;\n      }\n\n**示例：**\n\n\n      void f(int i) {\n        long value = i << 24;\n      }\n\n应用快速修复后，代码变为：\n\n\n      void f(int i) {\n        long value = (long) i << 24;\n      }\n\n\n此类乘法通常表明有错误，因为可能会意外发生溢出截断。\n将 `int` 文字转换为 `long` 文字 (`65536`**L**) 可以修正该问题。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IntegerMultiplicationImplicitCastToLong",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExpressionMayBeFactorized",
                "shortDescription": {
                  "text": "表达式可以因式分解"
                },
                "fullDescription": {
                  "text": "报告可以分解（即重组以提取公因数）的表达式。 这减少了冗余，可以提高代码的可读性。 示例： 'a && b || a && c' 在应用快速修复后： 'a && (b || c)' 2021.3 最新变化",
                  "markdown": "报告可以分解（即重组以提取公因数）的表达式。 这减少了冗余，可以提高代码的可读性。\n\n**示例：**\n\n\n      a && b || a && c\n\n在应用快速修复后：\n\n\n      a && (b || c)\n\n2021.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ExpressionMayBeFactorized",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ListRemoveInLoop",
                "shortDescription": {
                  "text": "在循环中调用了 'List.remove()'"
                },
                "fullDescription": {
                  "text": "报告在循环中调用的可以替换为 'List.subList().clear()' 的 'List.remove(index)'。 在删除多个元素的情况下，此替换对于大多数 'List' 实现更有效。 示例： 'void removeRange(List<String> list, int from, int to) {\n    for (int i = from; i < to; i++) {\n        list.remove(from);\n    }\n  }' 在应用快速修复后： 'void removeRange(List<String> list, int from, int to) {\n    if (to > from) {\n      list.subList(from, to).clear();\n    }\n  }' 该快速修复会自动添加范围检查，以防止在最小值大于最大值时可能出现的 'IndexOutOfBoundsException'。 如果代码中不可能出现这种情况，则可将其移除。 2018.2 最新变化",
                  "markdown": "报告在循环中调用的可以替换为 `List.subList().clear()` 的 `List.remove(index)`。\n\n在删除多个元素的情况下，此替换对于大多数 `List` 实现更有效。\n\n示例：\n\n\n      void removeRange(List<String> list, int from, int to) {\n        for (int i = from; i < to; i++) {\n            list.remove(from);\n        }\n      }\n\n在应用快速修复后：\n\n\n      void removeRange(List<String> list, int from, int to) {\n        if (to > from) {\n          list.subList(from, to).clear();\n        }\n      }\n\n\n该快速修复会自动添加范围检查，以防止在最小值大于最大值时可能出现的 `IndexOutOfBoundsException`。 如果代码中不可能出现这种情况，则可将其移除。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ListRemoveInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAssignmentWithOperatorAssignment",
                "shortDescription": {
                  "text": "赋值可被替换为运算符赋值"
                },
                "fullDescription": {
                  "text": "报告可以替换为运算符赋值的赋值运算。 使用运算符赋值的代码更短，可能更清晰。 示例： 'x = x + 3;\n  x = x / 3;' 在应用快速修复后： 'x += 3;\n  x /= 3;' 使用忽略条件运算符选项可忽略 '&&' 和 '||'。 将条件运算符替换为运算符赋值将使惰性求值变为及早求值，从而可能改变表达式的语义。 使用忽略模糊运算符选项可忽略不太为人所知的 '^' 和 '%'。",
                  "markdown": "报告可以替换为运算符赋值的赋值运算。\n\n使用运算符赋值的代码更短，可能更清晰。\n\n**示例：**\n\n      x = x + 3;\n      x = x / 3;\n\n在应用快速修复后：\n\n      x += 3;\n      x /= 3;\n\n\n使用**忽略条件运算符** 选项可忽略 `&&` 和 `||`。 将条件运算符替换为运算符赋值将使惰性求值变为及早求值，从而可能改变表达式的语义。\n\n\n使用**忽略模糊运算符** 选项可忽略不太为人所知的 `^` 和 `%`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AssignmentReplaceableWithOperatorAssignment",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnFromFinallyBlock",
                "shortDescription": {
                  "text": "'return' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'return' 语句。 虽然偶尔是有意为之，但此类 'return' 语句可能会掩盖抛出的异常，并导致调试复杂化。 示例： 'try {\n    foo();\n  } finally {\n    if (bar()) return;\n  }'",
                  "markdown": "报告 `finally` 块中的 `return` 语句。\n\n虽然偶尔是有意为之，但此类 `return` 语句可能会掩盖抛出的异常，并导致调试复杂化。\n\n**示例：**\n\n\n      try {\n        foo();\n      } finally {\n        if (bar()) return;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnInsideFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingOverrideAnnotation",
                "shortDescription": {
                  "text": "缺少 '@Override' 注解"
                },
                "fullDescription": {
                  "text": "报告重写超类方法但未使用 '@java.lang.Override' 注解的方法。 由于表明了意图，使用 '@java.lang.Override' 注解方法提高了代码可读性。 此外，在被重写的方法的签名与超类方法不匹配时，编译器会报错。 示例： 'class X {\n      public String toString() {\n        return \"hello world\";\n      }\n    }' 在应用快速修复后： 'class X {\n      @Override\n      public String toString() {\n        return \"hello world\";\n      }\n    }' 配置检查： 使用忽略 'equals()'、'hashCode()' 和 'toString()' 选项可以忽略这些 'java.lang.Object' 方法：'equals()'、'hashCode()' 和 'toString()'。 由于 '@Override' 注解而使得这些方法消失且代码不再编译的风险相对较小。 使用忽略匿名类中的方法选项可以忽略匿名类中的方法。 禁用当方法的重写方法并非全部具有 '@Override' 注解时，高亮显示该方法选项，可以仅就缺少 '@Override' 注解的方法发出警告，而不就其一个或多个后代缺少 '@Override' 注解的被重写方法发出警告。 此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。",
                  "markdown": "报告重写超类方法但未使用 `@java.lang.Override` 注解的方法。\n\n\n由于表明了意图，使用 `@java.lang.Override` 注解方法提高了代码可读性。\n此外，在被重写的方法的签名与超类方法不匹配时，编译器会报错。\n\n**示例：**\n\n\n        class X {\n          public String toString() {\n            return \"hello world\";\n          }\n        }\n      \n在应用快速修复后：\n\n\n        class X {\n          @Override\n          public String toString() {\n            return \"hello world\";\n          }\n        }\n      \n配置检查：\n\n* 使用**忽略 'equals()'、'hashCode()' 和 'toString()'** 选项可以忽略这些 `java.lang.Object` 方法：`equals()`、`hashCode()` 和 `toString()`。 由于 `@Override` 注解而使得这些方法消失且代码不再编译的风险相对较小。\n* 使用**忽略匿名类中的方法**选项可以忽略匿名类中的方法。\n* 禁用**当方法的重写方法并非全部具有 '@Override' 注解时，高亮显示该方法** 选项，可以仅就缺少 `@Override` 注解的方法发出警告，而不就其一个或多个后代缺少 `@Override` 注解的被重写方法发出警告。\n\n此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "override",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitClose",
                "shortDescription": {
                  "text": "冗余 'close()'"
                },
                "fullDescription": {
                  "text": "报告在 try-with-resources 块的末尾对 'close()' 的不必要调用，并建议移除它们。 示例： 'try(MyAutoCloseable ac = new MyAutoCloseable()) {\n    foo();\n    ac.close();\n  }' 在应用快速修复后： 'try(MyAutoCloseable ac = new MyAutoCloseable()) {\n    foo();\n  }' 2018.1 最新变化",
                  "markdown": "报告在 try-with-resources 块的末尾对 `close()` 的不必要调用，并建议移除它们。\n\n**示例**：\n\n\n      try(MyAutoCloseable ac = new MyAutoCloseable()) {\n        foo();\n        ac.close();\n      }\n\n在应用快速修复后：\n\n\n      try(MyAutoCloseable ac = new MyAutoCloseable()) {\n        foo();\n      }\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitClose",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertStatement",
                "shortDescription": {
                  "text": "'assert' 语句"
                },
                "fullDescription": {
                  "text": "报告 'assert' 语句。 默认情况下，在生产环境中执行期间禁用 'assert' 语句。 可以考虑改用记录器或异常。 Java 1.3 和更早版本的 JVM 不支持 'assert' 语句。 此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。",
                  "markdown": "报告 `assert` 语句。 默认情况下，在生产环境中执行期间禁用 `assert` 语句。 可以考虑改用记录器或异常。\n\nJava 1.3 和更早版本的 JVM 不支持 `assert` 语句。\n\n\n此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CharUsedInArithmeticContext",
                "shortDescription": {
                  "text": "在算术上下文中使用 'char' 表达式"
                },
                "fullDescription": {
                  "text": "报告用于加法或减法表达式的 'char' 类型的表达式。 此类代码不一定是问题，但可能会导致错误（例如，如果需要字符串）。 示例：'int a = 'a' + 42;' 应用该快速修复后：'int a = (int) 'a' + 42;' 对于 'String' 上下文： 'int i1 = 1;\nint i2 = 2;\nSystem.out.println(i2 + '-' + i1 + \" = \" + (i2 - i1));' 在应用快速修复后： 'System.out.println(i2 + \"-\" + i1 + \" = \" + (i2 - i1));'",
                  "markdown": "报告用于加法或减法表达式的 `char` 类型的表达式。\n\n此类代码不一定是问题，但可能会导致错误（例如，如果需要字符串）。\n\n**示例** ：`int a = 'a' + 42;`\n\n应用该快速修复后：`int a = (int) 'a' + 42;`\n\n对于 `String` 上下文：\n\n    int i1 = 1;\n    int i2 = 2;\n    System.out.println(i2 + '-' + i1 + \" = \" + (i2 - i1));\n\n在应用快速修复后：\n`System.out.println(i2 + \"-\" + i1 + \" = \" + (i2 - i1));`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CharUsedInArithmeticContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringEqualsCharSequence",
                "shortDescription": {
                  "text": "使用 'CharSequence' 实参调用了 'String.equals()'"
                },
                "fullDescription": {
                  "text": "报告对 'CharSequence' 作为实参的 'String.equals()' 的调用。 对于 'String' 实参，'String.equals()' 只能返回 'true'。 要比较包含非 'String' 'CharSequence' 实参的 'String' 的内容，请使用 'contentEquals()' 方法。 示例： 'boolean equals(String s, CharSequence ch) {\n    return s.equals(ch);\n  }' 在应用快速修复后： 'boolean equals(String s, CharSequence ch) {\n    return s.contentEquals(ch);\n  }' 2017.3 最新变化",
                  "markdown": "报告对 `CharSequence` 作为实参的 `String.equals()` 的调用。\n\n\n对于 `String` 实参，`String.equals()` 只能返回 `true`。\n要比较包含非 `String` `CharSequence` 实参的 `String` 的内容，请使用 `contentEquals()` 方法。\n\n**示例：**\n\n\n      boolean equals(String s, CharSequence ch) {\n        return s.equals(ch);\n      }\n\n在应用快速修复后：\n\n\n      boolean equals(String s, CharSequence ch) {\n        return s.contentEquals(ch);\n      }\n\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringEqualsCharSequence",
                    "cweIds": [
                      597
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarySemicolon",
                "shortDescription": {
                  "text": "不必要的分号"
                },
                "fullDescription": {
                  "text": "报告任何不必要的分号，包括在类成员之间、块语句内部或类定义之后使用的分号。 尽管这些分号在 Java 中有效，但它们是冗余的，可以被删除。 示例： 'class C {\n    ;\n    void m() throws Exception {\n        try (AutoCloseable r1 = createAutoCloseable();) {\n          ;\n        }\n    }\n    ;\n  }' 在应用快速修复后： 'class C {\n    void m() throws Exception {\n      try (AutoCloseable r1 = createAutoCloseable()) {\n      }\n    }\n  }'",
                  "markdown": "报告任何不必要的分号，包括在类成员之间、块语句内部或类定义之后使用的分号。\n\n尽管这些分号在 Java 中有效，但它们是冗余的，可以被删除。\n\n示例：\n\n\n      class C {\n        ;\n        void m() throws Exception {\n            try (AutoCloseable r1 = createAutoCloseable();) {\n              ;\n            }\n        }\n        ;\n      }\n\n在应用快速修复后：\n\n\n      class C {\n        void m() throws Exception {\n          try (AutoCloseable r1 = createAutoCloseable()) {\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarySemicolon",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestFailedLine",
                "shortDescription": {
                  "text": "测试中失败的行"
                },
                "fullDescription": {
                  "text": "报告测试中失败的方法调用或断言。 它有助于更快地检测代码中失败的行，并立即开始调试。 示例： '@Test\n  fun foo() {\n    assertEquals(1, 0) // 高亮显示\n  }'",
                  "markdown": "报告测试中失败的方法调用或断言。 它有助于更快地检测代码中失败的行，并立即开始调试。\n\n**示例：**\n\n\n      @Test\n      fun foo() {\n        assertEquals(1, 0) // 高亮显示\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestFailedLine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicStaticCollectionField",
                "shortDescription": {
                  "text": "'public static' 集合字段"
                },
                "fullDescription": {
                  "text": "报告可修改的 'public' 'static' 集合字段。 尽管这些字段经常用于存储常量值集合，但它们仍然代表着安全隐患，因为即使字段被声明为 'final'，它们的内容仍可能被修改。 示例： 'public static final List<String> EVENTS = new ArrayList<>();'\n 使用选项部分中的表可指定返回不可修改集合的方法。 将不会报告使用这些方法初始化的 'public' 'static' 集合字段。",
                  "markdown": "报告可修改的 `public` `static` 集合字段。\n\n尽管这些字段经常用于存储常量值集合，但它们仍然代表着安全隐患，因为即使字段被声明为 `final`，它们的内容仍可能被修改。\n\n**示例：**\n\n\n      public static final List<String> EVENTS = new ArrayList<>();\n      \n\n使用**选项** 部分中的表可指定返回不可修改集合的方法。\n将不会报告使用这些方法初始化的 `public` `static` 集合字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicStaticCollectionField",
                    "cweIds": [
                      732
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsConcreteCollection",
                "shortDescription": {
                  "text": "类显式扩展 'Collection' 类"
                },
                "fullDescription": {
                  "text": "报告扩展 'java.util.Collection' 或 'java.util.Map' 类的具体子类的类。 一种常见但欠佳的做法是对具体集合类型进行子类化。 它比委托集合调用要脆弱得多。",
                  "markdown": "报告扩展 `java.util.Collection` 或 `java.util.Map` 类的具体子类的类。\n\n\n一种常见但欠佳的做法是对具体集合类型进行子类化。 它比委托集合调用要脆弱得多。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExtendsConcreteCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocBlankLines",
                "shortDescription": {
                  "text": "空行应替换为 <p> 以换行"
                },
                "fullDescription": {
                  "text": "报告 Javadoc 注释中的空行。 Javadoc 中的空行可能表示将文本拆分为不同段落的意图。 但是，Javadoc 工具和 IntelliJ IDEA 在呈现文档注释时会忽略它们。 该快速修复会建议将空行替换为段落标记 (<p>)。 示例： 'class Main {\n    /**\n     * 不起作用。\n     *\n     * 完全不起作用\n     */\n    void foo() {}\n  }' 在应用快速修复后： 'class Main {\n    /**\n     * 不起作用。\n     * <p>\n     * 完全不起作用\n     */\n    void foo() {}\n  }' 2022.1 最新变化",
                  "markdown": "报告 Javadoc 注释中的空行。\n\n\nJavadoc 中的空行可能表示将文本拆分为不同段落的意图。 但是，Javadoc 工具和 IntelliJ IDEA 在呈现文档注释时会忽略它们。\n\n\n该快速修复会建议将空行替换为段落标记 (\\<p\\>)。\n\n**示例：**\n\n\n      class Main {\n        /**\n         * 不起作用。\n         *\n         * 完全不起作用\n         */\n        void foo() {}\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        /**\n         * 不起作用。\n         * <p>\n         * 完全不起作用\n         */\n        void foo() {}\n      }\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocBlankLines",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectInstantiationInEqualsHashCode",
                "shortDescription": {
                  "text": "'equals()' 或 'hashCode()' 内部的对象实例化"
                },
                "fullDescription": {
                  "text": "报告 'equals()'、'hashCode()'、'compareTo()' 和 'Comparator.compare()' 方法内（临时）新对象的构造。 除了构造函数调用之外，还可以通过在 'foreach' 语句中自动装箱或迭代器创建来创建新对象。 这可能会导致性能问题，例如，将对象添加到 'Set' 或 'Map' 时，这些方法将在这些地方被经常调用。 当在 'throw' 或 'assert' 语句中创建对象时，该检查将不会报告。 示例： 'class Person {\n    private String name;\n    private int age;\n\n    public boolean equals(Object o) {\n      return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});\n    }\n\n    public int hashCode() {\n      return (name + age).hashCode();\n    }\n  }' 在此示例中，在 'equals()' 内部创建了两个额外的数组，'age' 字段的用法需要装箱，而 'name + age' 隐式地创建了一个新字符串。",
                  "markdown": "报告 `equals()`、`hashCode()`、`compareTo()` 和 `Comparator.compare()` 方法内（临时）新对象的构造。\n\n\n除了构造函数调用之外，还可以通过在 `foreach` 语句中自动装箱或迭代器创建来创建新对象。\n这可能会导致性能问题，例如，将对象添加到 `Set` 或 `Map` 时，这些方法将在这些地方被经常调用。\n\n\n当在 `throw` 或 `assert` 语句中创建对象时，该检查将不会报告。\n\n**示例：**\n\n\n      class Person {\n        private String name;\n        private int age;\n\n        public boolean equals(Object o) {\n          return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});\n        }\n\n        public int hashCode() {\n          return (name + age).hashCode();\n        }\n      }\n\n\n在此示例中，在 `equals()` 内部创建了两个额外的数组，`age` 字段的用法需要装箱，而 `name + age` 隐式地创建了一个新字符串。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectInstantiationInEqualsHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClassWithPublicConstructor",
                "shortDescription": {
                  "text": "实用程序类具有 'public' 构造函数"
                },
                "fullDescription": {
                  "text": "报告包含 'public' 构造函数的实用程序类。 实用程序类将所有字段和方法声明为 'static'。 在这种类中创建 'public' 构造函数令人困惑，并且可能导致类意外实例化。 示例： 'public final class UtilityClass {\n    public UtilityClass(){\n    }\n    public static void foo() {}\n  }' 在应用快速修复后： 'public final class UtilityClass {\n    private UtilityClass(){\n    }\n    public static void foo() {}\n  }'",
                  "markdown": "报告包含 `public` 构造函数的实用程序类。\n\n实用程序类将所有字段和方法声明为 `static`。 在这种类中创建 `public` 构造函数令人困惑，并且可能导致类意外实例化。\n\n**示例：**\n\n\n      public final class UtilityClass {\n        public UtilityClass(){\n        }\n        public static void foo() {}\n      }\n\n在应用快速修复后：\n\n\n      public final class UtilityClass {\n        private UtilityClass(){\n        }\n        public static void foo() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClassWithPublicConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeParameterExtendsFinalClass",
                "shortDescription": {
                  "text": "类型形参扩展 'final' 类"
                },
                "fullDescription": {
                  "text": "报告为扩展 'final' 类而声明的类型形参。 由于无法扩展 'final' 类，建议将类型形参替换为指定的 'final' 类的类型。 示例： 'void foo() {\n    List<? extends Integer> list; // 警告：Integer 类为 final 类\n  }' 在应用快速修复后： 'void foo() {\n    List<Integer> list;\n  }' 此检查取决于 Java 功能 '泛型'，该功能自 Java 5 起可用。",
                  "markdown": "报告为扩展 `final` 类而声明的类型形参。\n\n由于无法扩展 `final` 类，建议将类型形参替换为指定的 `final` 类的类型。\n\n**示例：**\n\n\n      void foo() {\n        List<? extends Integer> list; // 警告：Integer 类为 final 类\n      }\n\n在应用快速修复后：\n\n\n      void foo() {\n        List<Integer> list;\n      }\n\n此检查取决于 Java 功能 '泛型'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeParameterExtendsFinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialIf",
                "shortDescription": {
                  "text": "冗余的 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告可以简化为单个赋值、'return' 或 'assert' 语句的 'if' 语句。 示例： 'if (foo()) {\n    return true;\n  } else {\n    return false;\n  }' 在应用快速修复后： 'return foo();' 配置检查： 如果要隐藏链式 'if' 语句的警告，请使用忽略链式 'if' 语句选项。 例如，在以下代码中，警告将被隐藏，但快速修复仍然可用： 'if (condition1) return true;\n  if (condition2) return false;\n  return true;' 请注意，如果条件有副作用，将 'if (isTrue()) assert false;' 替换为 'assert isTrue();' 可能会改变禁用 assert 时的程序语义。 如果要隐藏 'if' 语句在其主体中仅包含 'assert' 语句的警告，请使用忽略带有普通 'assert' 的 'if' 语句选项。",
                  "markdown": "报告可以简化为单个赋值、`return` 或 `assert` 语句的 `if` 语句。\n\n示例：\n\n\n      if (foo()) {\n        return true;\n      } else {\n        return false;\n      }\n\n在应用快速修复后：\n\n\n      return foo();\n\n配置检查：\n\n如果要隐藏链式 `if` 语句的警告，请使用**忽略链式 'if' 语句**选项。\n\n例如，在以下代码中，警告将被隐藏，但快速修复仍然可用：\n\n\n      if (condition1) return true;\n      if (condition2) return false;\n      return true;\n\n请注意，如果条件有副作用，将 `if (isTrue()) assert false;` 替换为 `assert isTrue();` 可能会改变禁用 assert 时的程序语义。\n如果要隐藏 `if` 语句在其主体中仅包含 `assert` 语句的警告，请使用**忽略带有普通 'assert' 的 'if' 语句**选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantIfStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnconditionalWait",
                "shortDescription": {
                  "text": "无条件的 'wait()' 调用"
                },
                "fullDescription": {
                  "text": "报告在同步上下文中无条件调用的 'wait()'。 'wait()' 通常用于在某个条件为 true 前阻塞线程。 如果是无条件调用 'wait()'，它通常表示在获取锁定之前检查了条件。 在这种情况下可能会发生数据竞争，条件在得到检查和获取锁定之间变为 true。 虽然此检查发现的结构未必不正确，但肯定值得检查。 示例： 'class Bar {\n      void foo() throws InterruptedException {\n          synchronized (this) {\n              wait(); // 警告\n          }\n      }\n  }'",
                  "markdown": "报告在同步上下文中无条件调用的 `wait()`。\n\n\n`wait()` 通常用于在某个条件为 true 前阻塞线程。 如果是无条件调用 `wait()`，它通常表示在获取锁定之前检查了条件。 在这种情况下可能会发生数据竞争，条件在得到检查和获取锁定之间变为 true。\n\n\n虽然此检查发现的结构未必不正确，但肯定值得检查。\n\n**示例：**\n\n\n      class Bar {\n          void foo() throws InterruptedException {\n              synchronized (this) {\n                  wait(); // 警告\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnconditionalWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanMethodIsAlwaysInverted",
                "shortDescription": {
                  "text": "布尔方法总是反向的"
                },
                "fullDescription": {
                  "text": "报告返回值类型为 'boolean' 且在调用时始终求反的方法。 提供了一种快速修复方法来反转并可选择地重命名该方法。 由于性能原因，并不是所有有问题的方法都会在编辑器中高亮显示。 示例： 'class C {\n    boolean alwaysTrue() {\n      return true;\n    }\n\n    void f() {\n      if (!alwaysTrue()) {\n        return;\n      }\n    }\n    boolean member = !alwaysTrue();\n  }' 在应用快速修复后： 'class C {\n    boolean alwaysFalse() {\n      return false;\n    }\n\n    void f() {\n      if (alwaysFalse()) {\n        return;\n      }\n    }\n    boolean member = alwaysFalse();\n  }'",
                  "markdown": "报告返回值类型为 `boolean` 且在调用时始终求反的方法。\n\n提供了一种快速修复方法来反转并可选择地重命名该方法。\n由于性能原因，并不是所有有问题的方法都会在编辑器中高亮显示。\n\n示例：\n\n\n      class C {\n        boolean alwaysTrue() {\n          return true;\n        }\n\n        void f() {\n          if (!alwaysTrue()) {\n            return;\n          }\n        }\n        boolean member = !alwaysTrue();\n      }\n\n在应用快速修复后：\n\n\n      class C {\n        boolean alwaysFalse() {\n          return false;\n        }\n\n        void f() {\n          if (alwaysFalse()) {\n            return;\n          }\n        }\n        boolean member = alwaysFalse();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanMethodIsAlwaysInverted",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceGuardedByStatic",
                "shortDescription": {
                  "text": "由 static 字段保护的实例成员"
                },
                "fullDescription": {
                  "text": "报告保护符是 'static' 字段的实例字段或方法上的 '@GuardedBy' 注解。 用 static 来保护非 static 可能会导致过度的锁争用，因为访问任何对象实例中的每个锁定字段均将阻止同时访问每个对象实例中的字段。 示例： 'private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static 保护字段\n    private Object state;\n\n    @GuardedBy(\"lock\")\n    public void bar() {\n        state = new Object();\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告保护符是 `static` 字段的实例字段或方法上的 `@GuardedBy` 注解。 用 static 来保护非 static 可能会导致过度的锁争用，因为访问任何对象实例中的每个锁定字段均将阻止同时访问每个对象实例中的字段。\n\n示例：\n\n\n        private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static 保护字段\n        private Object state;\n\n        @GuardedBy(\"lock\")\n        public void bar() {\n            state = new Object();\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceGuardedByStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOverridesInaccessibleMethodOfSuper",
                "shortDescription": {
                  "text": "方法重写了超类不可访问的方法"
                },
                "fullDescription": {
                  "text": "报告与超类的不可访问方法包含相同签名的方法， 例如，另一个软件包中的超类的 private 方法或 package-private 方法。 此类方法名称可能令人困惑，因为子类中的方法看似重写，实则隐藏了超类不可访问的方法。 此外，如果此方法在超类中的可见性日后发生变化，可能会静默地更改子类的语义，否则会导致编译错误。 建议通过快速修复重命名该方法。 示例： 'public class Super {\n    private void test() {\n    }\n  }\n\n  public class Sub extends Super {\n    void test() { // 将 'Super.test()' 设为 public 将导致编译错误\n                  // 将 'Super.test()' 设为 package-private 会使 'Sub.test()' 变成重写\n    }\n  }'",
                  "markdown": "报告与超类的不可访问方法包含相同签名的方法， 例如，另一个软件包中的超类的 private 方法或 package-private 方法。\n\n\n此类方法名称可能令人困惑，因为子类中的方法看似重写，实则隐藏了超类不可访问的方法。\n此外，如果此方法在超类中的可见性日后发生变化，可能会静默地更改子类的语义，否则会导致编译错误。\n\n建议通过快速修复重命名该方法。\n\n**示例：**\n\n\n      public class Super {\n        private void test() {\n        }\n      }\n\n      public class Sub extends Super {\n        void test() { // 将 'Super.test()' 设为 public 将导致编译错误\n                      // 将 'Super.test()' 设为 package-private 会使 'Sub.test()' 变成重写\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOverridesInaccessibleMethodOfSuper",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AutoCloseableResource",
                "shortDescription": {
                  "text": "在没有 'try-with-resources' 的情况下使用 AutoCloseable"
                },
                "fullDescription": {
                  "text": "报告未在 try-with-resources 语句中使用的 'AutoCloseable' 实例，也称 自动资源管理。 这意味着还报告在 try-with-resources 可用前使用的“在 'try' 前面/中打开资源，在 'finally' 中关闭资源”的样式。 在 Java 7 及更高版本中开发时，此检查意在取代所有已打开但未安全关闭的检查。 示例： 'private static void foo() throws IOException {\n    InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"/someFile\");\n    System.out.println(profile.read());\n  }' 使用以下选项配置检查： 列出不需关闭并且此检查应当忽略的 'AutoCloseable' 的子类。 注意：即便列出将忽略 'java.util.stream.Stream'，该检查仍将报告从 'java.nio.file.Files' 方法 'lines()'、'walk()'、'list()' 以及 'find()' 返回的流。 这些流包含需要关闭的关联 I/O 资源。 列出在调用时应被忽略的返回 'AutoCloseable' 的方法。 如果为方法调用的结果时是否忽略 'AutoCloseable'。 启用此选项时，工厂方法的结果也将被忽略。 当 'AutoCloseable' 实例作为方法调用实参传递时，该检查是否应报告。 如果启用此选项，该检查将假定所调用方法中的资源已关闭。 不会忽略名称中含有 'close' 的 'finally' 块和 'AutoCloseable' 实参中的方法调用。 是否忽略对资源类构造函数的方法引用。 是否忽略返回资源且名称以 'get' 开头的方法。 这可能会减少误报，因为大多数 getter 不转移资源的所有权，并且其调用点不负责关闭资源。 此检查取决于 Java 功能 'Try-with-resources'，该功能自 Java 7 起可用。",
                  "markdown": "报告未在 try-with-resources 语句中使用的 `AutoCloseable` 实例，也称 *自动资源管理* 。\n\n\n这意味着还报告在 try-with-resources 可用前使用的\"在 `try` 前面/中打开资源，在 `finally` 中关闭资源\"的样式。\n在 Java 7 及更高版本中开发时，此检查意在取代所有*已打开但未安全关闭*的检查。\n\n**示例：**\n\n\n      private static void foo() throws IOException {\n        InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"/someFile\");\n        System.out.println(profile.read());\n      }\n\n\n使用以下选项配置检查：\n\n* 列出不需关闭并且此检查应当忽略的 `AutoCloseable` 的子类。   \n  **注意** ：即便列出将忽略 `java.util.stream.Stream`，该检查仍将报告从 `java.nio.file.Files` 方法 `lines()`、`walk()`、`list()` 以及 `find()` 返回的流。 这些流包含需要关闭的关联 I/O 资源。\n* 列出在调用时应被忽略的返回 `AutoCloseable` 的方法。\n* 如果为方法调用的结果时是否忽略 `AutoCloseable`。 启用此选项时，工厂方法的结果也将被忽略。\n* 当 `AutoCloseable` 实例作为方法调用实参传递时，该检查是否应报告。 如果启用此选项，该检查将假定所调用方法中的资源已关闭。 不会忽略名称中含有 'close' 的 `finally` 块和 `AutoCloseable` 实参中的方法调用。\n* 是否忽略对资源类构造函数的方法引用。\n* 是否忽略返回资源且名称以 'get' 开头的方法。 这可能会减少误报，因为大多数 getter 不转移资源的所有权，并且其调用点不负责关闭资源。\n\n此检查取决于 Java 功能 'Try-with-resources'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "resource",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntLiteralMayBeLongLiteral",
                "shortDescription": {
                  "text": "转换为 'long' 可以是 'long' 文字"
                },
                "fullDescription": {
                  "text": "报告立即转换为 'long' 的 'int' 文字表达式。 此类文字表达式可以替换为等效的 'long' 文字。 示例： 'Long l = (long)42;' 在应用快速修复后： 'Long l = 42L;'",
                  "markdown": "报告立即转换为 `long` 的 `int` 文字表达式。\n\n此类文字表达式可以替换为等效的 `long` 文字。\n\n**示例：**\n\n    Long l = (long)42;\n\n在应用快速修复后：\n\n    Long l = 42L;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IntLiteralMayBeLongLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleStatementInBlock",
                "shortDescription": {
                  "text": "代码块包含单条语句"
                },
                "fullDescription": {
                  "text": "报告代码块中仅有一条语句的控制流语句，并建议移除控制流语句体中的大括号。 示例： 'if (x > 0) {\n    System.out.println(\"x is positive\");\n  }' 在应用快速修复后： 'if (x > 0) System.out.println(\"x is positive\");'",
                  "markdown": "报告代码块中仅有一条语句的控制流语句，并建议移除控制流语句体中的大括号。\n\n示例：\n\n\n      if (x > 0) {\n        System.out.println(\"x is positive\");\n      }\n\n在应用快速修复后：\n\n\n      if (x > 0) System.out.println(\"x is positive\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SingleStatementInBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestCaseWithConstructor",
                "shortDescription": {
                  "text": "具有非普通构造函数的 TestCase"
                },
                "fullDescription": {
                  "text": "报告在其构造函数中具有初始化逻辑的测试用例。 如果构造函数失败，将不会调用 '@After' 注解方法或 'tearDown()' 方法。 这可能导致测试环境部分初始化，因而对其他测试产生不利影响。 相反，测试用例初始化应在 'setUp()' 或 '@Before' 注解方法中完成。 不良示例： 'public class ImportantTest {\n    private File file;\n\n    public ImportantTest() throws IOException {\n      file = File.createTempFile(\"xyz\", \".tmp\");\n    }\n\n    // ... tests go here\n  }'",
                  "markdown": "报告在其构造函数中具有初始化逻辑的测试用例。 如果构造函数失败，将不会调用 `@After` 注解方法或 `tearDown()` 方法。 这可能导致测试环境部分初始化，因而对其他测试产生不利影响。 相反，测试用例初始化应在 `setUp()` 或 `@Before` 注解方法中完成。\n\n不良示例：\n\n\n      public class ImportantTest {\n        private File file;\n\n        public ImportantTest() throws IOException {\n          file = File.createTempFile(\"xyz\", \".tmp\");\n        }\n\n        // ... tests go here\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitTestCaseWithNonTrivialConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleCharacterStartsWith",
                "shortDescription": {
                  "text": "单个字符 'startsWith()' 或 'endsWith()'"
                },
                "fullDescription": {
                  "text": "报告对 'String.startsWith()' 和 'String.endsWith()' 的调用，其中单字符字符串文字会作为实参传递。 建议通过快速修复，使用更高效实现的 'String.charAt()' 替换此类调用。 然而，由于额外的非零长度检查，此类更改的性能增益很小并且会降低代码的可读性，建议仅在紧密循环内应用该快速修复。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 示例： 'boolean startsWithX(String s) {\n    return s.startsWith(\"x\");\n  }' 在应用快速修复后： 'boolean startsWithX(String s) {\n    return !s.isEmpty() && s.charAt(0) == 'x';\n  }'",
                  "markdown": "报告对 `String.startsWith()` 和 `String.endsWith()` 的调用，其中单字符字符串文字会作为实参传递。\n\n\n建议通过快速修复，使用更高效实现的 `String.charAt()` 替换此类调用。\n\n\n然而，由于额外的非零长度检查，此类更改的性能增益很小并且会降低代码的可读性，建议仅在紧密循环内应用该快速修复。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n**示例：**\n\n\n      boolean startsWithX(String s) {\n        return s.startsWith(\"x\");\n      }\n\n在应用快速修复后：\n\n\n      boolean startsWithX(String s) {\n        return !s.isEmpty() && s.charAt(0) == 'x';\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SingleCharacterStartsWith",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClassCanBeEnum",
                "shortDescription": {
                  "text": "实用程序类可以是 'enum'"
                },
                "fullDescription": {
                  "text": "报告可转换为枚举的实用程序类。 某些编码样式准则要求将实用程序类作为枚举实现，以避免 'private' 构造函数中的代码覆盖率问题。 示例： 'class StringUtils {\n    public static final String EMPTY = \"\";\n  }' 在应用快速修复后： 'enum StringUtils {\n    ;\n    public static final String EMPTY = \"\";\n  }' 此检查取决于 Java 功能 '枚举'，该功能自 Java 5 起可用。",
                  "markdown": "报告可转换为枚举的实用程序类。\n\n某些编码样式准则要求将实用程序类作为枚举实现，以避免 `private` 构造函数中的代码覆盖率问题。\n\n**示例：**\n\n\n      class StringUtils {\n        public static final String EMPTY = \"\";\n      }\n\n在应用快速修复后：\n\n\n      enum StringUtils {\n        ;\n        public static final String EMPTY = \"\";\n      }\n\n此检查取决于 Java 功能 '枚举'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClassCanBeEnum",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadObjectAndWriteObjectPrivate",
                "shortDescription": {
                  "text": "'readObject()' 或 'writeObject()' 未被声明为 'private'"
                },
                "fullDescription": {
                  "text": "报告 'readObject' 或 'writeObject' 方法未被声明为 private 的 'Serializable' 类。 这些方法的可见性没有理由比 'private' 更高。 建议通过快速修复将相应的方法设为 'private'。 示例： 'public class Test implements Serializable {\n    public void readObject(ObjectInputStream stream) {\n      /* ... */\n    }\n  }' 在应用快速修复后： 'public class Test implements Serializable {\n    private void readObject(ObjectInputStream stream) {\n      /* ... */\n    }\n  }'",
                  "markdown": "报告 `readObject` 或 `writeObject` 方法未被声明为 private 的 `Serializable` 类。 这些方法的可见性没有理由比 `private` 更高。\n\n\n建议通过快速修复将相应的方法设为 `private`。\n\n**示例：**\n\n\n      public class Test implements Serializable {\n        public void readObject(ObjectInputStream stream) {\n          /* ... */\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Test implements Serializable {\n        private void readObject(ObjectInputStream stream) {\n          /* ... */\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonPrivateSerializationMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsObject",
                "shortDescription": {
                  "text": "类显式扩展 'Object'"
                },
                "fullDescription": {
                  "text": "报告一个明确声明要扩展'java.lang.Object' 的类。 这种声明是冗余的，可以安全地删除。 示例： 'class MyClass extends Object {\n  }' 快速修复删除了冗余的 'extends Object' 子句： 'class MyClass {\n  }'",
                  "markdown": "报告一个明确声明要扩展` java.lang.Object` 的类。\n\n这种声明是冗余的，可以安全地删除。\n\n示例：\n\n\n      class MyClass extends Object {\n      }\n\n快速修复删除了冗余的 `extends Object` 子句：\n\n\n      class MyClass {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExplicitlyExtendsObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantFileCreation",
                "shortDescription": {
                  "text": "创建冗余 'File' 实例"
                },
                "fullDescription": {
                  "text": "在只能使用 'String' 路径的情况下，报告在下面的一种构造函数中创建的冗余 'File'：'FileInputStream'、'FileOutputStream'、'FileReader'、'FileWriter'、'PrintStream'、'PrintWriter'、'Formatter'。 示例： 'InputStream is = new FileInputStream(new File(\"in.txt\"));' 在应用快速修复后： 'InputStream is = new FileInputStream(\"in.txt\");' 2020.3 最新变化",
                  "markdown": "在只能使用 `String` 路径的情况下，报告在下面的一种构造函数中创建的冗余 `File`：`FileInputStream`、`FileOutputStream`、`FileReader`、`FileWriter`、`PrintStream`、`PrintWriter`、`Formatter`。\n\n示例：\n\n\n    InputStream is = new FileInputStream(new File(\"in.txt\"));\n\n在应用快速修复后：\n\n\n    InputStream is = new FileInputStream(\"in.txt\");\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantFileCreation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessBooleanExpression",
                "shortDescription": {
                  "text": "无意义的布尔表达式"
                },
                "fullDescription": {
                  "text": "报告不必要的或过于复杂的布尔表达式。 此类表达式包括： '&&' 和 'true' 的组合、 '||' 和 'false' 的组合、布尔文字的相等比较或布尔文字求反。 此类表达可以简化。 示例： 'boolean a = !(x && false);\n  boolean b = false || x;\n  boolean c = x != true;' 在应用快速修复后： 'boolean a = true;\n  boolean b = x;\n  boolean c = !x;' 配置检查： 使用 在确定无意义表达式时忽略命名常量 选项可在确定表达式是否无意义时忽略命名常量。",
                  "markdown": "报告不必要的或过于复杂的布尔表达式。\n\n此类表达式包括： `&&` 和 `true` 的组合、\n`||` 和 `false` 的组合、布尔文字的相等比较或布尔文字求反。 此类表达可以简化。\n\n示例：\n\n\n      boolean a = !(x && false);\n      boolean b = false || x;\n      boolean c = x != true;\n\n在应用快速修复后：\n\n\n      boolean a = true;\n      boolean b = x;\n      boolean c = !x;\n\n\n配置检查：\n使用 **在确定无意义表达式时忽略命名常量** 选项可在确定表达式是否无意义时忽略命名常量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ListenerMayUseAdapter",
                "shortDescription": {
                  "text": "类可以扩展适配器而不是实现侦听器"
                },
                "fullDescription": {
                  "text": "报告实现侦听器而不是扩展相应适配器的类。 在将侦听器实现替换为适配器扩展后，可以通过快速修复来移除任何冗余的空方法。 使用仅在找到空实现方法时发出警告选项可将检查配置为即便未发现空方法也发出警告。",
                  "markdown": "报告实现侦听器而不是扩展相应适配器的类。\n\n在将侦听器实现替换为适配器扩展后，可以通过快速修复来移除任何冗余的空方法。\n\n\n使用**仅在找到空实现方法时发出警告**选项可将检查配置为即便未发现空方法也发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ListenerMayUseAdapter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReassignedVariable",
                "shortDescription": {
                  "text": "重新分配的变量"
                },
                "fullDescription": {
                  "text": "报告会使阅读和理解代码变得复杂的重新赋值的变量。 示例： 'int value = 2 * (height + width);\n  System.out.println(\"perimeter: \" + value);\n\n  value = height * width;\n  System.out.println(\"area: \" + value);'",
                  "markdown": "报告会使阅读和理解代码变得复杂的重新赋值的变量。\n\n示例：\n\n\n      int value = 2 * (height + width);\n      System.out.println(\"perimeter: \" + value);\n\n      value = height * width;\n      System.out.println(\"area: \" + value);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReassignedVariable",
                    "ideaSeverity": "TEXT ATTRIBUTES",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodNameSameAsClassName",
                "shortDescription": {
                  "text": "方法名称与类名相同"
                },
                "fullDescription": {
                  "text": "报告与其类同名的方法。 虽然 Java 语言允许此类命名，但按照约定，它被保留用于定义构造函数。 将它用于方法可能是一种错误或不好的做法。 示例： 'class MyClass {\n    int val;\n\n    // 方法 MyClass 的名称与其包含类相同。\n    // 可能是错误添加了 'void'。\n    void MyClass(int val) {\n      this.val = val;\n    }\n  }' 在适当的情况下，可以通过快速修复将方法转换为构造函数： 'class MyClass {\n    int val;\n\n    MyClass(int val) {\n      this.val = val;\n    }\n  }' 可以通过另一种快速修复重命名该方法。",
                  "markdown": "报告与其类同名的方法。 虽然 Java 语言允许此类命名，但按照约定，它被保留用于定义构造函数。 将它用于方法可能是一种错误或不好的做法。\n\n**示例：**\n\n\n      class MyClass {\n        int val;\n\n        // 方法 MyClass 的名称与其包含类相同。\n        // 可能是错误添加了 'void'。\n        void MyClass(int val) {\n          this.val = val;\n        }\n      }\n\n在适当的情况下，可以通过快速修复将方法转换为构造函数：\n\n\n      class MyClass {\n        int val;\n\n        MyClass(int val) {\n          this.val = val;\n        }\n      }\n\n可以通过另一种快速修复重命名该方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodNameSameAsClassName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExpressionComparedToItself",
                "shortDescription": {
                  "text": "表达式与自身进行比较"
                },
                "fullDescription": {
                  "text": "报告左操作数和右操作数表示相同表达式的比较。 虽然有时可能会有意将表达式与其自身进行比较，但通常是疏忽大意所致。 示例： '// 可能 left.getLength() == right.getLength() 是有意为之\n  boolean result = left.getLength() == left.getLength();' 要忽略可能产生副作用的比较，请使用忽略有副作用的条件 选项。 禁用此选项可能会导致误报，例如，当同一方法在后续调用中返回不同的值时。 示例： 'native int unknownMethod();\n  \n  ...\n  \n  if (unknownMethod() > unknownMethod()) {\n    System.out.println(\"Got it\");\n  }' 由于 'unknownMethod()' 可能存在副作用（在示例中），只有在禁用 忽略有副作用的条件 选项时才会触发警告。 2024.2 最新变化",
                  "markdown": "报告左操作数和右操作数表示相同表达式的比较。 虽然有时可能会有意将表达式与其自身进行比较，但通常是疏忽大意所致。\n\n示例：\n\n\n      // 可能 left.getLength() == right.getLength() 是有意为之\n      boolean result = left.getLength() == left.getLength();\n\n\n要忽略可能产生副作用的比较，请使用**忽略有副作用的条件** 选项。\n禁用此选项可能会导致误报，例如，当同一方法在后续调用中返回不同的值时。\n\n示例：\n\n\n      native int unknownMethod();\n      \n      ...\n      \n      if (unknownMethod() > unknownMethod()) {\n        System.out.println(\"Got it\");\n      }\n\n由于 `unknownMethod()` 可能存在副作用（在示例中），只有在禁用 **忽略有副作用的条件** 选项时才会触发警告。\n\n2024.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExpressionComparedToItself",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalVariableNamingConvention",
                "shortDescription": {
                  "text": "局部变量命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的局部变量。 示例：如果在默认设置下启用该检查，其中变量名称应以小写字母开头，则报告 'int X = 42;'。 配置检查： 使用选项部分中的字段可指定局部变量名称的最小长度、最大长度以及预期的正则表达式。 指定 0 以便不检查名称的长度。 正则表达式应以标准 java.util.regex 格式指定。 使用复选框来忽略 'for' 循环和 'catch' 部分的形参。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的局部变量。\n\n**示例** ：如果在默认设置下启用该检查，其中变量名称应以小写字母开头，则报告 `int X = 42;`。\n\n配置检查：\n\n\n使用**选项** 部分中的字段可指定局部变量名称的最小长度、最大长度以及预期的正则表达式。\n指定 **0** 以便不检查名称的长度。 正则表达式应以标准 **java.util.regex** 格式指定。\n\n使用复选框来忽略 `for` 循环和 `catch` 部分的形参。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryJavaDocLink",
                "shortDescription": {
                  "text": "不必要的 Javadoc 链接"
                },
                "fullDescription": {
                  "text": "报告引用拥有注释的方法、拥有注释的方法的 super 方法或包含注释的类的 Javadoc '@see'、'{@link}' 和 '{@linkplain}' 标记。 此类链接不必要，可以通过此检查的快速修复安全移除。 如果标记是唯一内容，快速修复将移除整个 Javadoc 注释。 示例： 'class Example {\n    /**\n     * @see Example#method\n     */\n    public void method() { }\n  }' 在应用快速修复后： 'class Example {\n  public void method() { }\n}' 使用下面的复选框可以忽略指向 super 方法的内联链接（'{@link}' 和 '{@linkplain}'）。 尽管 Javadoc 工具会自动添加指向所有 super 方法的链接，但有时在 Javadoc 注释的文本中可能需要指向 super 方法的内联链接。",
                  "markdown": "报告引用拥有注释的方法、拥有注释的方法的 super 方法或包含注释的类的 Javadoc `@see`、`{@link}` 和 `{@linkplain}` 标记。\n\n此类链接不必要，可以通过此检查的快速修复安全移除。 如果标记是唯一内容，快速修复将移除整个 Javadoc 注释。\n\n**示例：**\n\n\n      class Example {\n        /**\n         * @see Example#method\n         */\n        public void method() { }\n      }\n\n在应用快速修复后：\n\n\n    class Example {\n      public void method() { }\n    }\n\n\n使用下面的复选框可以忽略指向 super 方法的内联链接（`{@link}` 和 `{@linkplain}`）。 尽管 Javadoc 工具会自动添加指向所有 super 方法的链接，但有时在 Javadoc 注释的文本中可能需要指向 super 方法的内联链接。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryJavaDocLink",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyTryBlock",
                "shortDescription": {
                  "text": "空 'try' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'try' 块，包括 try-with-resources 语句。 包含注释的 'try' 块视为空块。 此检查不报告在 JSP 文件中发现的空 'try' 块。",
                  "markdown": "报告空的 `try` 块，包括 try-with-resources 语句。\n\n包含注释的 `try` 块视为空块。\n\n\n此检查不报告在 JSP 文件中发现的空 `try` 块。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyTryBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedSwitchStatement",
                "shortDescription": {
                  "text": "嵌套 'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告嵌套的 'switch' 语句或表达式。 嵌套的 'switch' 语句可能导致代码格外令人困惑。 这些语句可以提取到一个单独的方法中。 示例： 'int res = switch (i) {\n            case 0 -> 0;\n            default -> switch (i) {\n                case 100 -> 0;\n                default -> i;\n            };\n        };'",
                  "markdown": "报告嵌套的 `switch` 语句或表达式。\n\n嵌套的 `switch` 语句可能导致代码格外令人困惑。 这些语句可以提取到一个单独的方法中。\n\n示例：\n\n\n      int res = switch (i) {\n                case 0 -> 0;\n                default -> switch (i) {\n                    case 100 -> 0;\n                    default -> i;\n                };\n            };\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedSwitchStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionsFieldAccessReplaceableByMethodCall",
                "shortDescription": {
                  "text": "对空集合字段的引用可被替换为方法调用"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Collections' 字段的用法：'EMPTY_LIST'、'EMPTY_MAP' 或 'EMPTY_SET'。 这些字段用法可以替换为以下方法调用：'emptyList()'、'emptyMap()' 或 'emptySet()'。 此类方法调用会防止编译器发出未检查的警告，因为可以推断出类型形参。 示例： 'List<Integer> emptyList = Collections.EMPTY_LIST;' 在应用快速修复后： 'List<Integer> emptyList = Collections.emptyList();' 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告 `java.util.Collections` 字段的用法：`EMPTY_LIST`、`EMPTY_MAP` 或 `EMPTY_SET`。 这些字段用法可以替换为以下方法调用：`emptyList()`、`emptyMap()` 或 `emptySet()`。 此类方法调用会防止编译器发出未检查的警告，因为可以推断出类型形参。\n\n**示例：**\n\n\n      List<Integer> emptyList = Collections.EMPTY_LIST;\n\n在应用快速修复后：\n\n\n      List<Integer> emptyList = Collections.emptyList();\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionsFieldAccessReplaceableByMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertWithSideEffects",
                "shortDescription": {
                  "text": "具有副作用的 'assert' 语句"
                },
                "fullDescription": {
                  "text": "报告导致副作用的 'assert' 语句。 由于断言可能关闭，无法保证这些副作用，这可能导致难以捉摸的错误。 此检查检测到的不受欢迎的常见副作用是变量和字段修改。 涉及到方法调用时，将对它们进行一级深入分析。 示例： 'assert i++ < 10;' 此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。",
                  "markdown": "报告导致副作用的 `assert` 语句。\n\n\n由于断言可能关闭，无法保证这些副作用，这可能导致难以捉摸的错误。 此检查检测到的不受欢迎的常见副作用是变量和字段修改。 涉及到方法调用时，将对它们进行一级深入分析。\n\n**示例：**\n\n\n      assert i++ < 10;\n\n此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertWithSideEffects",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitOrAwaitWithoutTimeout",
                "shortDescription": {
                  "text": "无超时的 'wait()' 或 'await()'"
                },
                "fullDescription": {
                  "text": "报告对未指定超时的 'Object.wait()' 或 'Condition.await()' 的调用。 在高可用性程序中，此类调用可能很危险，因为如果从未调用 'notify()'/'notifyAll()' 或 'signal()'/'signalAll()'，那么一个组件中的故障可能会导致等待的组件发生阻塞。 示例： 'void foo(Object bar) throws InterruptedException {\n    bar.wait();\n  }'",
                  "markdown": "报告对未指定超时的 `Object.wait()` 或 `Condition.await()` 的调用。\n\n\n在高可用性程序中，此类调用可能很危险，因为如果从未调用 `notify()`/`notifyAll()` 或 `signal()`/`signalAll()`，那么一个组件中的故障可能会导致等待的组件发生阻塞。\n\n**示例：**\n\n\n      void foo(Object bar) throws InterruptedException {\n        bar.wait();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitOrAwaitWithoutTimeout",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RefusedBequest",
                "shortDescription": {
                  "text": "方法不调用 super 方法"
                },
                "fullDescription": {
                  "text": "报告重写而不调用 super 方法的方法。 这也称作被拒绝的遗赠。 此类方法可能表明抽象失败，导致出现难以跟踪的 bug。 检查不报告从 'java.lang.Object'重写的方法（'clone()' 除外）。 按照惯例，'clone()' 应该调用其 super 方法，该方法将返回正确类型的对象。 示例 1： 'class A {\n    @Override\n    public Object clone() {\n      // 不调用 'super.clone()'\n      return new A();\n    }\n  }' 示例 2： 'interface I {\n    default void foo() {}\n  }\n\n  class A implements I {\n    // 禁用“忽略 'default' super 方法”时\n    //  对方法发出警告\n    @Override\n    public void foo(){}\n  }' 配置检查： 使用仅在通过以下方式注解 super 方法时报告选项，可以忽略使用所提供列表中的注解标记的 super 方法。 您可以手动将注解添加到此列表中。 使用忽略空 super 方法选项，可以忽略仅抛出异常或空的 super 方法。 使用忽略 'default' super 方法选项，可以忽略接口中的 'default' super 方法。",
                  "markdown": "报告重写而不调用 super 方法的方法。 这也称作*被拒绝的遗赠* 。 此类方法可能表明抽象失败，导致出现难以跟踪的 bug。\n\n\n检查不报告从 `java.lang.Object`重写的方法（`clone()` 除外）。\n按照惯例，`clone()` 应该调用其 super 方法，该方法将返回正确类型的对象。\n\n**示例 1：**\n\n\n      class A {\n        @Override\n        public Object clone() {\n          // 不调用 'super.clone()'\n          return new A();\n        }\n      }\n\n**示例 2：**\n\n\n      interface I {\n        default void foo() {}\n      }\n\n      class A implements I {\n        // 禁用\"忽略 'default' super 方法\"时\n        //  对方法发出警告\n        @Override\n        public void foo(){}\n      }\n\n配置检查：\n\n* 使用**仅在通过以下方式注解 super 方法时报告**选项，可以忽略使用所提供列表中的注解标记的 super 方法。 您可以手动将注解添加到此列表中。\n* 使用**忽略空 super 方法**选项，可以忽略仅抛出异常或空的 super 方法。\n* 使用**忽略 'default' super 方法** 选项，可以忽略接口中的 `default` super 方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodDoesntCallSuperMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalClass",
                "shortDescription": {
                  "text": "类禁止继承"
                },
                "fullDescription": {
                  "text": "报告被声明为 'final' 的类。 不报告扩展 'sealed' 类或接口的 final 类。 这种类不能被继承，并且可能表明缺乏面向对象的设计。 某些编码标准不鼓励 'final' 类。 示例： 'public final class Main {\n  }' 在应用快速修复后： 'public class Main {\n  }'",
                  "markdown": "报告被声明为 `final` 的类。 不报告扩展 `sealed` 类或接口的 final 类。 这种类不能被继承，并且可能表明缺乏面向对象的设计。 某些编码标准不鼓励 `final` 类。\n\n**示例：**\n\n\n      public final class Main {\n      }\n\n在应用快速修复后：\n\n\n      public class Main {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryEmptyArrayUsage",
                "shortDescription": {
                  "text": "不必要的零长度数组用法"
                },
                "fullDescription": {
                  "text": "报告数组元素类型的类中有常量时已知长度为零的数组分配。 由于零长度数组不可变，您可以重用相同的数组实例来节省内存。 示例： 'class Item {\n    // 可重用的 public 零长度数组常量 \n    public static final Item[] EMPTY_ARRAY = new Item[0];\n  }\n  class EmptyNode {\n    Item[] getChildren() {\n      // 不必要的零长度数组创建\n      return new Item[0];\n    }\n  }' 在应用快速修复后： 'class EmptyNode {\n    Item[] getChildren() {\n      return Item.EMPTY_ARRAY;\n    }\n  }'",
                  "markdown": "报告数组元素类型的类中有常量时已知长度为零的数组分配。 由于零长度数组不可变，您可以重用相同的数组实例来节省内存。\n\n**示例：**\n\n\n      class Item {\n        // 可重用的 public 零长度数组常量 \n        public static final Item[] EMPTY_ARRAY = new Item[0];\n      }\n      class EmptyNode {\n        Item[] getChildren() {\n          // 不必要的零长度数组创建\n          return new Item[0];\n        }\n      }\n\n在应用快速修复后：\n\n\n      class EmptyNode {\n        Item[] getChildren() {\n          return Item.EMPTY_ARRAY;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantForZeroLengthArrayAllocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LiteralAsArgToStringEquals",
                "shortDescription": {
                  "text": "字符串文字可以为 'equals()' 限定符"
                },
                "fullDescription": {
                  "text": "报告包含字符串文字实参的 'String.equals()' 或 'String.equalsIgnoreCase()' 调用。 某些编码标准指定字符串文字应当为 'equals()' 的限定符而不是实参，从而最大限度减少 'NullPointerException'。 可以通过快速修复交换文字和表达式。 示例： 'boolean isFoo(String value) {\n    return value.equals(\"foo\");\n  }' 在应用快速修复后： 'boolean isFoo(String value) {\n    return \"foo\".equals(value);\n  }'",
                  "markdown": "报告包含字符串文字实参的 `String.equals()` 或 `String.equalsIgnoreCase()` 调用。\n\n某些编码标准指定字符串文字应当为 `equals()` 的限定符而不是实参，从而最大限度减少 `NullPointerException`。\n\n可以通过快速修复交换文字和表达式。\n\n**示例：**\n\n\n      boolean isFoo(String value) {\n        return value.equals(\"foo\");\n      }\n\n在应用快速修复后：\n\n\n      boolean isFoo(String value) {\n        return \"foo\".equals(value);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LiteralAsArgToStringEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateExpressions",
                "shortDescription": {
                  "text": "同一表达式存在多个匹配项"
                },
                "fullDescription": {
                  "text": "如果表达式的结果可以重用，则报告同一表达式在方法（或构造函数，或类初始值设定项）中的多次等效匹配项。 如果表达式没有副作用并且其结果始终相同（就 'Object.equals()' 而言），则会报告该表达式。 此类表达式的示例是 'a + b'、'Math.max(a, b)'、'a.equals(b)'、's.substring(a,b)'。 为确保结果始终相同，已验证表达式中使用的变量在表达式匹配项之间不会更改其值。 此类表达式可能包含不可变的类（如 'String'、'BigDecimal' 等）和实用程序类（如 'Objects'、'Math'，'random()' 除外）的方法。 'Object.equals()'、'Object.hashCode()'、'Object.toString()'、 'Comparable.compareTo()' 和 'Comparator.compare()' 等常用方法也可以使用，因为没有任何可见的副作用。 使用表达式复杂性阈值选项可指定最小表达复杂性阈值。 指定更大的数字将移除关于短表达式的报告。 如果 'Path.of' 和 'Paths.get' 调用具有相同的实参，则被视为等效调用。 无论其实参有多复杂，这些调用始终会被报告。 使用不同的复杂性阈值可以调整这种行为。 2018.3 最新变化",
                  "markdown": "如果表达式的结果可以重用，则报告同一表达式在方法（或构造函数，或类初始值设定项）中的多次等效匹配项。\n\n\n如果表达式没有副作用并且其结果始终相同（就 `Object.equals()` 而言），则会报告该表达式。\n此类表达式的示例是 `a + b`、`Math.max(a, b)`、`a.equals(b)`、` s.substring(a,b)`。 为确保结果始终相同，已验证表达式中使用的变量在表达式匹配项之间不会更改其值。\n\n\n此类表达式可能包含不可变的类（如 `String`、`BigDecimal` 等）和实用程序类（如 `Objects`、`Math`，`random()` 除外）的方法。\n`Object.equals() `、` Object.hashCode() `、` Object.toString() `、\n`Comparable.compareTo()` 和 `Comparator.compare()` 等常用方法也可以使用，因为没有任何可见的副作用。\n\n\n使用**表达式复杂性阈值**选项可指定最小表达复杂性阈值。 指定更大的数字将移除关于短表达式的报告。\n\n\n如果 `Path.of` 和 `Paths.get` 调用具有相同的实参，则被视为等效调用。 无论其实参有多复杂，这些调用始终会被报告。 使用不同的复杂性阈值可以调整这种行为。\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DuplicateExpressions",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryReturn",
                "shortDescription": {
                  "text": "不必要的 'return' 语句"
                },
                "fullDescription": {
                  "text": "报告返回 'void' 的构造函数和方法结尾的 'return' 语句。 这些语句冗余，可以安全移除。 此检查不会在 JSP 文件中报告。 示例： 'void message() {\n    System.out.println(\"Hello World\");\n    return;\n  }' 在应用快速修复后： 'void message() {\n    System.out.println(\"Hello World\");\n  }' 使用在具有 'else' 分支的 'if' 语句的 then 分支中忽略选项可以忽略也有 'else' 分支的 'if' 语句的 then 分支中的 'return' 语句。",
                  "markdown": "报告返回 `void` 的构造函数和方法结尾的 `return` 语句。 这些语句冗余，可以安全移除。\n\n此检查不会在 JSP 文件中报告。\n\n示例：\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n        return;\n      }\n\n在应用快速修复后：\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n      }\n\n\n使用**在具有 'else' 分支的 'if' 语句的 then 分支中忽略** 选项可以忽略也有 `else` 分支的 `if` 语句的 then 分支中的 `return` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryReturnStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicInnerClass",
                "shortDescription": {
                  "text": "'public' 嵌套类"
                },
                "fullDescription": {
                  "text": "报告 'public' 嵌套类。 示例： 'public class Outer {\n    public static class Nested {} // 警告\n    public class Inner {}         // 警告\n    public enum Mode {}           // 警告取决于设置\n    public interface I {}         // 警告取决于设置\n  }' 配置检查： 使用忽略 'public' 内部枚举选项可忽略 'public' 内部枚举。 使用忽略 'public' 内部接口选项可忽略 'public' 内部接口。",
                  "markdown": "报告 `public` 嵌套类。\n\n**示例：**\n\n\n      public class Outer {\n        public static class Nested {} // 警告\n        public class Inner {}         // 警告\n        public enum Mode {}           // 警告取决于设置\n        public interface I {}         // 警告取决于设置\n      }\n\n配置检查：\n\n* 使用**忽略 'public' 内部枚举** 选项可忽略 `public` 内部枚举。\n* 使用**忽略 'public' 内部接口** 选项可忽略 `public` 内部接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanConstructor",
                "shortDescription": {
                  "text": "布尔构造函数调用"
                },
                "fullDescription": {
                  "text": "报告 'Boolean' 对象的创建情况。 基本不必要创建新的 'Boolean' 对象，如果经常这样做，可能会导致性能问题。 此外，'Boolean' 构造函数自 Java 9 起已弃用，在未来的 Java 版本中可能会被移除或变得无法访问。 示例： 'Boolean b1 = new Boolean(true);\n  Boolean b2 = new Boolean(str);' 在应用快速修复后： 'Boolean b1 = Boolean.TRUE;\n  Boolean b2 = Boolean.valueOf(str);'",
                  "markdown": "报告 `Boolean` 对象的创建情况。\n\n\n基本不必要创建新的 `Boolean` 对象，如果经常这样做，可能会导致性能问题。 此外，`Boolean` 构造函数自 Java 9 起已弃用，在未来的 Java 版本中可能会被移除或变得无法访问。\n\n**示例：**\n\n\n      Boolean b1 = new Boolean(true);\n      Boolean b2 = new Boolean(str);\n\n在应用快速修复后：\n\n\n      Boolean b1 = Boolean.TRUE;\n      Boolean b2 = Boolean.valueOf(str);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanConstructorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalGuard",
                "shortDescription": {
                  "text": "非 final '@GuardedBy' 字段"
                },
                "fullDescription": {
                  "text": "报告其中的保护字段不是 'final' 的 '@GuardedBy' 注解。 在非 final 字段上进行保护可能会导致意外的竞争条件，因为该字段的值会被锁定（可能会变化），而不是锁定字段本身。 示例： 'private ReadWriteLock lock = new ReentrantReadWriteLock(); //非 final 保护字段\n    private Object state;\n\n    @GuardedBy(\"lock\")\n    public void bar() {\n        state = new Object();\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告其中的保护字段不是 `final` 的 `@GuardedBy` 注解。\n\n在非 final 字段上进行保护可能会导致意外的竞争条件，因为该字段的值会被锁定（可能会变化），而不是锁定字段本身。\n\n示例：\n\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock(); //非 final 保护字段\n        private Object state;\n\n        @GuardedBy(\"lock\")\n        public void bar() {\n            state = new Object();\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalGuard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TooBroadScope",
                "shortDescription": {
                  "text": "变量作用域过宽"
                },
                "fullDescription": {
                  "text": "报告任何可以移动到更小范围的变量声明。 这种检查对于方法开头的 Pascal 样式声明特别有用。 此外，范围太广的变量在重构后也通常会被留下。 示例： 'StringBuilder sb = new StringBuilder();\n  System.out.println();\n  sb.append(1);' 在应用快速修复后： 'System.out.println();\n  StringBuilder sb = new StringBuilder();\n  sb.append(1);' 配置检查： 使用仅报告可移入内部块的变量选项可只报告那些可以移动到更深代码块中的变量。 例如，启用该选项时，将不建议对上面的 'sb' 变量进行移动。 但是，建议将其用于以下代码： 'StringBuilder sb = new StringBuilder(a);\n  if (flag) {\n    sb.append(1);\n  }' 使用报告使用新表达式作为初始值设定项的变量(可能不安全) 选项可以报告使用新表达式初始化的变量。 这使得当构造函数具有非本地副作用时，检查可能会不安全。 例如，启用该选项时，将建议对 'foo' 变量进行移动： 'class Foo {\n    static List<Foo> fooList = new ArrayList<>();\n    String bar;\n\n    Foo(String bar) {\n        this.bar = bar;\n        fooList.add(this);\n    }\n\n    public static void main(String[] args) {\n      // 虽不安全，但也可以移动\n      Foo foo = new Foo(\"bar\");\n      System.out.println(fooList.size());\n      System.out.println(foo.bar);\n    }\n  }'",
                  "markdown": "报告任何可以移动到更小范围的变量声明。\n\n这种检查对于方法开头的 *Pascal 样式*声明特别有用。 此外，范围太广的变量在重构后也通常会被留下。\n\n**示例：**\n\n\n      StringBuilder sb = new StringBuilder();\n      System.out.println();\n      sb.append(1);\n\n在应用快速修复后：\n\n\n      System.out.println();\n      StringBuilder sb = new StringBuilder();\n      sb.append(1);\n\n配置检查：\n\n* 使用**仅报告可移入内部块的变量** 选项可只报告那些可以移动到更深代码块中的变量。 例如，启用该选项时，将不建议对上面的 `sb` 变量进行移动。 但是，建议将其用于以下代码：\n\n\n        StringBuilder sb = new StringBuilder(a);\n        if (flag) {\n          sb.append(1);\n        }\n\n* 使用**报告使用新表达式作为初始值设定项的变量(可能不安全)** 选项可以报告使用新表达式初始化的变量。 这使得当构造函数具有非本地副作用时，检查可能会不安全。 例如，启用该选项时，将建议对 `foo` 变量进行移动：\n\n\n        class Foo {\n          static List<Foo> fooList = new ArrayList<>();\n          String bar;\n\n          Foo(String bar) {\n              this.bar = bar;\n              fooList.add(this);\n          }\n\n          public static void main(String[] args) {\n            // 虽不安全，但也可以移动\n            Foo foo = new Foo(\"bar\");\n            System.out.println(fooList.size());\n            System.out.println(foo.bar);\n          }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TooBroadScope",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionAddedToSelf",
                "shortDescription": {
                  "text": "集合已添加到自身"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Collection' 或 'java.util.Map' 的方法调用的实参是集合或映射本身的情况。 由于复制粘贴，原始类型的代码中可能会出现此类情况。 示例： 'ArrayList list = new ArrayList<>();\n  list.add(list); // 此处为警告\n  return list.hashCode(); // 抛出 StackOverflowError'",
                  "markdown": "报告对 `java.util.Collection` 或 `java.util.Map` 的方法调用的实参是集合或映射本身的情况。 由于复制粘贴，原始类型的代码中可能会出现此类情况。\n\n**示例：**\n\n\n      ArrayList list = new ArrayList<>();\n      list.add(list); // 此处为警告\n      return list.hashCode(); // 抛出 StackOverflowError\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionAddedToSelf",
                    "cweIds": [
                      664,
                      688
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowableSupplierOnlyThrowException",
                "shortDescription": {
                  "text": "Throwable 供应商从不返回值"
                },
                "fullDescription": {
                  "text": "报告抛出异常而不是返回异常的 'Optional.orElseThrow()'调用中的 'Supplier' lambda。 示例： 'optional.orElseThrow(() -> {\n    throw new RuntimeException();\n});' 在应用快速修复后： 'optional.orElseThrow(() -> new RuntimeException());' 2023.1 最新变化",
                  "markdown": "报告抛出异常而不是返回异常的 `Optional.orElseThrow()`调用中的 `Supplier` lambda。\n\n**示例：**\n\n\n    optional.orElseThrow(() -> {\n        throw new RuntimeException();\n    });\n\n在应用快速修复后：\n\n\n    optional.orElseThrow(() -> new RuntimeException());\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowableSupplierOnlyThrowException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementMissingBreakInLoop",
                "shortDescription": {
                  "text": "在 'if' 条件下提前退出循环"
                },
                "fullDescription": {
                  "text": "报告包含 'if' 语句并且以 'break' 结尾但又不改变语义的循环。 这可以防止冗余的循环迭代。 示例： 'boolean found = false;\n  for (int i = 0; i < arr.length; i++) {\n    if (Objects.equals(value, arr[i])) {\n      found = true;\n    }\n  }' 在应用快速修复后： 'boolean found = false;\n  for (int i = 0; i < arr.length; i++) {\n    if (Objects.equals(value, arr[i])) {\n      found = true;\n      break;\n    }\n  }' 2019.2 最新变化",
                  "markdown": "报告包含 `if` 语句并且以 `break` 结尾但又不改变语义的循环。 这可以防止冗余的循环迭代。\n\n**示例：**\n\n\n      boolean found = false;\n      for (int i = 0; i < arr.length; i++) {\n        if (Objects.equals(value, arr[i])) {\n          found = true;\n        }\n      }\n\n在应用快速修复后：\n\n\n      boolean found = false;\n      for (int i = 0; i < arr.length; i++) {\n        if (Objects.equals(value, arr[i])) {\n          found = true;\n          break;\n        }\n      }\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementMissingBreakInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantStreamOptionalCall",
                "shortDescription": {
                  "text": "'Stream' 或 'Optional' 调用链中存在冗余步骤"
                },
                "fullDescription": {
                  "text": "报告冗余的 'Stream' 或 'Optional' 调用（例如 'map(x -> x)'、'filter(x -> true)'）或冗余的 'sorted()' 或 'distinct()' 调用。 请注意，代码中 'streamOfIntegers.map(Integer::valueOf)' 之类的映射操作效果与 'requireNonNull()' 检查相同：如果该流包含 'null'，它将抛出 'NullPointerException'，因此并非绝对冗余。 如果不希望报告此类情况，请禁用报告 Stream.map() 中的冗余装箱选项。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告冗余的 `Stream` 或 `Optional` 调用（例如 `map(x -> x)`、`filter(x -> true)`）或冗余的 `sorted()` 或 `distinct()` 调用。\n\n请注意，代码中 `streamOfIntegers.map(Integer::valueOf)` 之类的映射操作效果与 `requireNonNull()` 检查相同：如果该流包含 `null`，它将抛出 `NullPointerException`，因此并非绝对冗余。\n如果不希望报告此类情况，请禁用**报告 Stream.map() 中的冗余装箱**选项。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantStreamOptionalCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarySuperQualifier",
                "shortDescription": {
                  "text": "不必要的 'super' 限定符"
                },
                "fullDescription": {
                  "text": "报告方法调用和字段引用中不必要的 'super' 限定符。 当超类的字段或方法在调用类中未被隐藏/重写时，不需要 'super' 限定符。 示例： 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      super.foo();\n    }\n  }' 在应用快速修复后： 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      foo();\n    }\n  }' 使用检查设置可以忽略有助于区分超类成员访问与外部类的同名成员的限定符。 另请参阅以下检查： Java | 可见性 | 继承字段的访问类似于访问周围代码中的元素 Java | 可见性 | 对继承方法的调用类似于对局部方法的调用",
                  "markdown": "报告方法调用和字段引用中不必要的 `super` 限定符。\n\n\n当超类的字段或方法在调用类中未被隐藏/重写时，不需要 `super` 限定符。\n\n**示例：**\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          super.foo();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          foo();\n        }\n      }\n\n\n使用检查设置可以忽略有助于区分超类成员访问与外部类的同名成员的限定符。\n\n\n另请参阅以下检查：\n\n* *Java \\| 可见性 \\| 继承字段的访问类似于访问周围代码中的元素*\n* *Java \\| 可见性 \\| 对继承方法的调用类似于对局部方法的调用*"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarySuperQualifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadPriority",
                "shortDescription": {
                  "text": "调用 'Thread.setPriority()'"
                },
                "fullDescription": {
                  "text": "报告对 'Thread.setPriority()' 的调用。 修改线程的优先级本质上是不可移植的操作，因为 Java 规范中没有保证如何在调度线程中使用优先级，甚至没有保证是否使用优先级。",
                  "markdown": "报告对 `Thread.setPriority()` 的调用。 修改线程的优先级本质上是不可移植的操作，因为 Java 规范中没有保证如何在调度线程中使用优先级，甚至没有保证是否使用优先级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadSetPriority",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsOnSuspiciousObject",
                "shortDescription": {
                  "text": "在不对其进行重写的类上调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告对 'StringBuilder'、'StringBuffer' 和 'java.util.concurrent.atomic' 软件包的实例的 'equals()' 调用。 'equals()' 方法在这些类中没有被重写，因此即使两个对象的内容相同，它也可能返回 'false'。 如果您打算使用引用相等，我们建议您使用 '==' 以避免混淆。 'StringBuilder'、'StringBuffer'、'AtomicBoolean'、'AtomicInteger'、'AtomicBoolean' 和 'AtomicLong' 的快速修复可用来转换为内容的比较。 当其中一个实例为 null 时，快速修复可能会改变语义。 示例： 'public void test(StringBuilder sb1, StringBuilder sb2) {\n    boolean result = sb1.equals(sb2); // 可疑\n  }' 在应用快速修复后： 'public void test(StringBuilder sb1, StringBuilder sb2) {\n      boolean result = sb1.toString().equals(sb2.toString());\n  }' 2017.2 最新变化",
                  "markdown": "报告对 `StringBuilder`、`StringBuffer` 和 `java.util.concurrent.atomic` 软件包的实例的 `equals()` 调用。\n\n`equals()` 方法在这些类中没有被重写，因此即使两个对象的内容相同，它也可能返回 `false`。\n如果您打算使用引用相等，我们建议您使用 `==` 以避免混淆。\n`StringBuilder`、`StringBuffer`、`AtomicBoolean`、`AtomicInteger`、`AtomicBoolean` 和 `AtomicLong` 的快速修复可用来转换为内容的比较。 当其中一个实例为 null 时，快速修复可能会改变语义。\n\n示例：\n\n\n      public void test(StringBuilder sb1, StringBuilder sb2) {\n        boolean result = sb1.equals(sb2); // 可疑\n      }\n\n在应用快速修复后：\n\n\n      public void test(StringBuilder sb1, StringBuilder sb2) {\n          boolean result = sb1.toString().equals(sb2.toString());\n      }\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsOnSuspiciousObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfPropertiesAsHashtable",
                "shortDescription": {
                  "text": "将 'Properties' 对象用作 'Hashtable'"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Properties' 对象上的以下方法的调用： 'put()' 'putIfAbsent()' 'putAll()' 'get()' 由于历史原因，'java.util.Properties' 继承自 'java.util.Hashtable'，但为防止污染 'String' 以外类型的属性值，不建议使用这些方法。 当映射中的键和值形参都为 'String' 类型时，不会报告对 'java.util.Properties.putAll()' 的调用。 此类调用是安全的，且没有更好的选择。 示例： 'Object f(Properties props) {\n    props.put(\"hello\", \"world\");\n    props.putIfAbsent(\"hello\", \"world\");\n    props.putAll(new HashMap<>());\n    return props.get(\"Hello\");\n  }' 在应用快速修复后： 'Object f(Properties props) {\n    props.setProperty(\"hello\", \"world\");\n    props.putIfAbsent(\"hello\", \"world\");\n    props.putAll(new HashMap<>());\n    return props.getProperty(\"hello\");\n  }'",
                  "markdown": "报告对 `java.util.Properties` 对象上的以下方法的调用：\n\n* `put()`\n* `putIfAbsent()`\n* `putAll()`\n* `get()`\n\n\n由于历史原因，`java.util.Properties` 继承自 `java.util.Hashtable`，但为防止污染 `String` 以外类型的属性值，不建议使用这些方法。\n\n\n当映射中的键和值形参都为 `String` 类型时，不会报告对 `java.util.Properties.putAll()` 的调用。\n此类调用是安全的，且没有更好的选择。\n\n**示例：**\n\n\n      Object f(Properties props) {\n        props.put(\"hello\", \"world\");\n        props.putIfAbsent(\"hello\", \"world\");\n        props.putAll(new HashMap<>());\n        return props.get(\"Hello\");\n      }\n\n在应用快速修复后：\n\n\n      Object f(Properties props) {\n        props.setProperty(\"hello\", \"world\");\n        props.putIfAbsent(\"hello\", \"world\");\n        props.putAll(new HashMap<>());\n        return props.getProperty(\"hello\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfPropertiesAsHashtable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCoupling",
                "shortDescription": {
                  "text": "过度耦合的方法"
                },
                "fullDescription": {
                  "text": "报告引用过多其他类的方法。 耦合度过高的方法可能非常脆弱，应该被拆分为较小的方法。 无论被引用多少次，每个被引用的类都只被计算一次。 配置检查： 使用方法耦合限制字段可指定方法允许的最大耦合度。 使用包括与 Java 系统类的耦合选项可计算对 'java' 或 'javax' 软件包中的类的引用。 使用包括与库类的耦合选项可计算对第三方库类的引用。",
                  "markdown": "报告引用过多其他类的方法。 耦合度过高的方法可能非常脆弱，应该被拆分为较小的方法。\n\n无论被引用多少次，每个被引用的类都只被计算一次。\n\n配置检查：\n\n* 使用**方法耦合限制**字段可指定方法允许的最大耦合度。\n* 使用**包括与 Java 系统类的耦合** 选项可计算对 `java` 或 `javax` 软件包中的类的引用。\n* 使用**包括与库类的耦合**选项可计算对第三方库类的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyCoupledMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantStringFormatCall",
                "shortDescription": {
                  "text": "冗余调用 'String.format()'"
                },
                "fullDescription": {
                  "text": "报告对 'format()' 和 'printf()' 等可以安全移除或简化的方法的调用。 示例： 'System.out.println(String.format(\"Total count: %d\", 42));' 在应用快速修复后： 'System.out.printf(\"Total count: %d%n\", 42);'",
                  "markdown": "报告对 `format()` 和 `printf()` 等可以安全移除或简化的方法的调用。\n\n**示例：**\n\n\n      System.out.println(String.format(\"Total count: %d\", 42));\n\n在应用快速修复后：\n\n\n      System.out.printf(\"Total count: %d%n\", 42);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantStringFormatCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalFieldOfException",
                "shortDescription": {
                  "text": "'Exception' 类的非 final 字段"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.Exception' 的子类中未被声明为 'final' 的字段。 不应修改异常对象上的数据，因为这可能会导致丢失可供以后调试和记录的错误上下文。 示例： 'public class EditorException extends Exception {\n    private String message; // 警告：异常类的非 final 字段 'message'\n  }'",
                  "markdown": "报告 `java.lang.Exception` 的子类中未被声明为 `final` 的字段。\n\n不应修改异常对象上的数据，因为这可能会导致丢失可供以后调试和记录的错误上下文。\n\n**示例：**\n\n\n      public class EditorException extends Exception {\n        private String message; // 警告：异常类的非 final 字段 'message'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldOfException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessNullCheck",
                "shortDescription": {
                  "text": "方法调用前出现不必要的 'null' 检查"
                },
                "fullDescription": {
                  "text": "报告后接传递 'null' 时必定返回 'false' 的方法调用的 'null' 检查（例如，'Class.isInstance'）。 在这种情况下，方法调用总是返回 'false'，此类检查似乎有些多余。 示例： 'if (x != null && myClass.isInstance(x)) { ... }' 在应用快速修复后： 'if (myClass.isInstance(x)) { ... }'",
                  "markdown": "报告后接传递 `null` 时必定返回 `false` 的方法调用的 `null` 检查（例如，`Class.isInstance`）。\n\n在这种情况下，方法调用总是返回 `false`，此类检查似乎有些多余。\n\n**示例：**\n\n\n      if (x != null && myClass.isInstance(x)) { ... }\n\n在应用快速修复后：\n\n\n      if (myClass.isInstance(x)) { ... }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessNullCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AccessToStaticFieldLockedOnInstance",
                "shortDescription": {
                  "text": "访问实例数据上锁定的 'static' 字段"
                },
                "fullDescription": {
                  "text": "报告对在 'this' 或 'this' 的实例字段上锁定的非常量 static 字段的访问。 在实例数据上锁定 static 字段并不能防止其他实例修改该字段，因此可能会导致意外的竞争条件。 示例： 'static String test;\n  public void foo() {\n      synchronized (this) {\n          System.out.println(test); // 警告\n      }\n  }' 通过快速修复可以忽略特定类型的 static 字段。 可以在检查选项中管理被忽略的类型。 使用检查选项可以指定应忽略哪些用于 static 字段的类。",
                  "markdown": "报告对在 `this` 或 `this` 的实例字段上锁定的非常量 static 字段的访问。\n\n\n在实例数据上锁定 static 字段并不能防止其他实例修改该字段，因此可能会导致意外的竞争条件。\n\n**示例：**\n\n\n      static String test;\n      public void foo() {\n          synchronized (this) {\n              System.out.println(test); // 警告\n          }\n      }\n\n\n通过快速修复可以忽略特定类型的 static 字段。\n可以在检查选项中管理被忽略的类型。\n\n\n使用检查选项可以指定应忽略哪些用于 static 字段的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessToStaticFieldLockedOnInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOverridesStaticMethod",
                "shortDescription": {
                  "text": "方法尝试重写超类的 'static' 方法"
                },
                "fullDescription": {
                  "text": "报告签名与超类的 'static' 方法相同的 'static' 方法。 此类方法可能看似重写，但实则它对超类隐藏了该方法，因为 Java 中的 'static' 方法不能被重写。 示例： 'class Parent {\n    static void method(){}\n  }\n\n  class Example extends Parent {\n    static void method(){} //警告\n  }'",
                  "markdown": "报告签名与超类的 `static` 方法相同的 `static` 方法。 此类方法可能看似重写，但实则它对超类隐藏了该方法，因为 Java 中的 `static` 方法不能被重写。\n\n**示例：**\n\n\n      class Parent {\n        static void method(){}\n      }\n\n      class Example extends Parent {\n        static void method(){} //警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOverridesStaticMethodOfSuperclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCompareToJavaTime",
                "shortDescription": {
                  "text": "带有 'java.time' 'compareTo()' 调用的表达式可以简化"
                },
                "fullDescription": {
                  "text": "报告 'java.time' 与 'compareTo()' 调用（可被替换为 'isAfter()'、'isBefore()' 或 'isEqual()' 调用）的比较。 示例： 'LocalDate date1 = LocalDate.now();\n  LocalDate date2 = LocalDate.now();\n  boolean t = date1.compareTo(date2) > 0;' 在应用快速修复后： 'LocalDate date1 = LocalDate.now();\n  LocalDate date2 = LocalDate.now();\n  boolean t = date1.isAfter(date2);' 2022.3 最新变化",
                  "markdown": "报告 `java.time` 与 `compareTo()` 调用（可被替换为 `isAfter()`、`isBefore()` 或 `isEqual()` 调用）的比较。\n\n示例：\n\n\n      LocalDate date1 = LocalDate.now();\n      LocalDate date2 = LocalDate.now();\n      boolean t = date1.compareTo(date2) > 0;\n\n在应用快速修复后：\n\n\n      LocalDate date1 = LocalDate.now();\n      LocalDate date2 = LocalDate.now();\n      boolean t = date1.isAfter(date2);\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCompareToJavaTime",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnclearBinaryExpression",
                "shortDescription": {
                  "text": "具有不同优先级的多个运算符"
                },
                "fullDescription": {
                  "text": "报告由不带圆括号的不同运算符组成的二元、条件或 'instanceof' 表达式。 由于运算符的优先级规则不同，此类表达式的可读性可能较低。 示例： 'int n = 3 + 9 * 8 + 1;' 在应用快速修复后： 'int n = 3 + (9 * 8) + 1;'",
                  "markdown": "报告由不带圆括号的不同运算符组成的二元、条件或 `instanceof` 表达式。 由于运算符的优先级规则不同，此类表达式的可读性可能较低。\n\n示例：\n\n\n      int n = 3 + 9 * 8 + 1;\n\n在应用快速修复后：\n\n\n      int n = 3 + (9 * 8) + 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnclearExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChainedMethodCall",
                "shortDescription": {
                  "text": "链式方法调用"
                },
                "fullDescription": {
                  "text": "报告目标是另一个方法调用的方法调用。 该快速修复会建议引入局部变量。 示例： 'class X {\n    int foo(File f) {\n      return f.getName().length();\n    }\n  }' 在应用快速修复后： 'class X {\n    int foo(File f) {\n      final String name = f.getName();\n      return name.length();\n    }\n  }' 使用检查选项来切换以下各项的警告： 字段初始值设定项中的链式方法调用，例如 'private final int i = new Random().nextInt();' 在相同的类型上运算的链式方法调用，例如，'new StringBuilder().append(\"x: \").append(new X()).append(\"y: \").append(new Y()).toString();'。",
                  "markdown": "报告目标是另一个方法调用的方法调用。 该快速修复会建议引入局部变量。\n\n**示例：**\n\n\n      class X {\n        int foo(File f) {\n          return f.getName().length();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class X {\n        int foo(File f) {\n          final String name = f.getName();\n          return name.length();\n        }\n      }\n\n使用检查选项来切换以下各项的警告：\n\n*\n  字段初始值设定项中的链式方法调用，例如 `private final int i = new Random().nextInt();`\n\n*\n  在相同的类型上运算的链式方法调用，例如，`new StringBuilder().append(\"x: \").append(new X()).append(\"y: \").append(new Y()).toString();`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainedMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VariableTypeCanBeExplicit",
                "shortDescription": {
                  "text": "变量类型可以是显式的"
                },
                "fullDescription": {
                  "text": "报告可以替换为显式类型的 'var' 类型的局部变量。 示例： 'var str = \"Hello\";' 在应用快速修复后： 'String str = \"Hello\";' 此检查取决于 Java 功能 '局部变量类型推断'，该功能自 Java 10 起可用。",
                  "markdown": "报告可以替换为显式类型的 `var` 类型的局部变量。\n\n**示例：**\n\n\n      var str = \"Hello\";\n\n在应用快速修复后：\n\n\n      String str = \"Hello\";\n\n此检查取决于 Java 功能 '局部变量类型推断'，该功能自 Java 10 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "VariableTypeCanBeExplicit",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 10",
                      "index": 112,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsUtilityClass",
                "shortDescription": {
                  "text": "类扩展实用程序类"
                },
                "fullDescription": {
                  "text": "报告扩展实用类的类。 实用类是非空类，其中所有字段和方法都为 static。 扩展实用类还允许无意中对实用类进行对象实例化，因为不能为了允许扩展而将构造函数设置为 private。 配置检查： 使用如果重写类为实用程序类，则忽略选项可以忽略任何重写实用程序类但本身也是实用程序类的类。",
                  "markdown": "报告扩展实用类的类。\n\n\n实用类是非空类，其中所有字段和方法都为 static。\n扩展实用类还允许无意中对实用类进行对象实例化，因为不能为了允许扩展而将构造函数设置为 private。\n\n\n配置检查：\n\n* 使用**如果重写类为实用程序类，则忽略**选项可以忽略任何重写实用程序类但本身也是实用程序类的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExtendsUtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClassWithoutPrivateConstructor",
                "shortDescription": {
                  "text": "实用程序类没有 'private' 构造函数"
                },
                "fullDescription": {
                  "text": "报告不包含 'private' 构造函数的实用程序类。 实用程序类将所有字段和方法声明为 'static'。 在实用程序类中创建 'private' 构造函数可防止它们被意外实例化。 使用有注解时忽略选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行标记的类。 使用忽略仅具有主方法的类选项，可以忽略除主方法外再无其他方法的类。",
                  "markdown": "报告不包含 `private` 构造函数的实用程序类。\n\n实用程序类将所有字段和方法声明为 `static`。 在实用程序类中创建 `private` 构造函数可防止它们被意外实例化。\n\n\n使用**有注解时忽略**选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行标记的类。\n\n\n使用**忽略仅具有主方法的类**选项，可以忽略除主方法外再无其他方法的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClassWithoutPrivateConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8ListSort",
                "shortDescription": {
                  "text": "'Collections.sort()' 可被替换为 'List.sort()'"
                },
                "fullDescription": {
                  "text": "报告 'Collections.sort(list,comparator)' 的调用，可以替换为 'list.sort(comparator)'。 'Collections.sort' 只是一个包装器，所以最好直接使用实例方法。 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告 `Collections.sort(list,comparator)` 的调用，可以替换为 `list.sort(comparator)`。\n\n`Collections.sort` 只是一个包装器，所以最好直接使用实例方法。\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8ListSort",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertMessageNotString",
                "shortDescription": {
                  "text": "'assert' 消息不是字符串"
                },
                "fullDescription": {
                  "text": "报告非 'java.lang.String' 类型的 'assert' 消息。 使用字符串可以提供更多信息，有助于诊断失败或断言原因。 示例： 'void foo(List<Integer> myList) {\n    assert myList.isEmpty() : false;\n  }' 使用仅当 'assert' 消息为 'boolean' 或 'java.lang.Boolean' 时发出警告选项可以仅在 'assert' 消息类型为 'boolean' 或 'java.lang.Boolean' 时发出警告。 'boolean' 详细消息不太可能提供有关断言失败的其他信息，可能是由于错误输入 ':' 而不是 '&' 所致。 此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。",
                  "markdown": "报告非 `java.lang.String` 类型的 `assert` 消息。\n\n使用字符串可以提供更多信息，有助于诊断失败或断言原因。\n\n**示例：**\n\n\n      void foo(List<Integer> myList) {\n        assert myList.isEmpty() : false;\n      }\n\n\n使用**仅当 `assert` 消息为 'boolean' 或 'java.lang.Boolean' 时发出警告** 选项可以仅在 `assert` 消息类型为 `boolean` 或 `java.lang.Boolean` 时发出警告。\n`boolean` 详细消息不太可能提供有关断言失败的其他信息，可能是由于错误输入 `:` 而不是 `&` 所致。\n\n此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertMessageNotString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorCombinators",
                "shortDescription": {
                  "text": "可以使用 'Comparator' 连结符"
                },
                "fullDescription": {
                  "text": "报告定义为可以使用 'Comparator.comparing()' 调用表示的 lambda 表达式的 'Comparator' 实例。 还会报告可以替换为 'Comparator.thenComparing()' 表达式的链式比较。 示例： 'myList.sort((person1, person2) -> person1.getName().compareTo(person2.getName()));\n\n  myList2.sort((person1, person2) -> {\n      int res = person1.first().compareTo(person2.first());\n      if(res == 0) res = person1.second().compareTo(person2.second());\n      if(res == 0) res = person1.third() - person2.third();\n      return res;\n  });' 在应用快速修复后： 'myList.sort(Comparator.comparing(Person::getName));\n\n  myList2.sort(Comparator.comparing(Person::first)\n                         .thenComparing(Person::second)\n                         .thenComparingInt(Person::third));' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告定义为可以使用 `Comparator.comparing()` 调用表示的 lambda 表达式的 `Comparator` 实例。 还会报告可以替换为 `Comparator.thenComparing()` 表达式的链式比较。\n\n示例：\n\n\n      myList.sort((person1, person2) -> person1.getName().compareTo(person2.getName()));\n\n      myList2.sort((person1, person2) -> {\n          int res = person1.first().compareTo(person2.first());\n          if(res == 0) res = person1.second().compareTo(person2.second());\n          if(res == 0) res = person1.third() - person2.third();\n          return res;\n      });\n\n在应用快速修复后：\n\n\n      myList.sort(Comparator.comparing(Person::getName));\n\n      myList2.sort(Comparator.comparing(Person::first)\n                             .thenComparing(Person::second)\n                             .thenComparingInt(Person::third));\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorCombinators",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternVariableCanBeUsed",
                "shortDescription": {
                  "text": "可以使用模式变量"
                },
                "fullDescription": {
                  "text": "报告可以替换为模式变量的局部变量声明，模式变量通常更紧凑。 示例： 'if (obj instanceof String) {\n    String str = (String) obj;\n    System.out.println(str);\n  }' 可以替换为： 'if (obj instanceof String str) {\n    System.out.println(str);\n  }' 2020.1 最新变化 此检查取决于 Java 功能 ''instanceof' 中的模式'，该功能自 Java 16 起可用。",
                  "markdown": "报告可以替换为模式变量的局部变量声明，模式变量通常更紧凑。\n\n**示例：**\n\n\n      if (obj instanceof String) {\n        String str = (String) obj;\n        System.out.println(str);\n      }\n\n可以替换为：\n\n\n      if (obj instanceof String str) {\n        System.out.println(str);\n      }\n\n2020.1 最新变化\n\n此检查取决于 Java 功能 ''instanceof' 中的模式'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternVariableCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 16",
                      "index": 113,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsReplaceableByObjectsCall",
                "shortDescription": {
                  "text": "'equals()' 表达式可被替换为 'Objects.equals()' 表达式"
                },
                "fullDescription": {
                  "text": "报告可以替换为对 'java.util.Objects#equals' 的调用的表达式。 示例： 'void f(Object a, Object b) {\n    boolean result = a != null && a.equals(b);\n  }' 在应用快速修复后： 'void f(Object a, Object b) {\n    boolean result = Objects.equals(a, b);\n  }' 将 'a != null && a.equals(b)' 之类的表达式替换为 'Objects.equals(a, b)' 会略微改变语义。 使用高亮显示与 'a != null && a.equals(b)' 类似的表达式选项，可启用或禁用此行为。 此检查取决于 Java 功能 'java.util.Objects API'，该功能自 Java 7 起可用。",
                  "markdown": "报告可以替换为对 `java.util.Objects#equals` 的调用的表达式。\n\n**示例：**\n\n\n      void f(Object a, Object b) {\n        boolean result = a != null && a.equals(b);\n      }\n\n在应用快速修复后：\n\n\n      void f(Object a, Object b) {\n        boolean result = Objects.equals(a, b);\n      }\n\n\n将 `a != null && a.equals(b)` 之类的表达式替换为 `Objects.equals(a, b)` 会略微改变语义。 使用**高亮显示与 'a != null \\&\\& a.equals(b)' 类似的表达式**选项，可启用或禁用此行为。\n\n此检查取决于 Java 功能 'java.util.Objects API'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EqualsReplaceableByObjectsCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitToExplicitClassBackwardMigration",
                "shortDescription": {
                  "text": "隐式声明的类可被替换为普通类"
                },
                "fullDescription": {
                  "text": "报告隐式声明的类，并建议用常规类替换它们。 示例（在文件 Sample.java 中）： 'public static void main() {\n      System.out.println(\"Hello, world!\");\n  }' 在应用快速修复后： 'public class Sample {\n    public static void main() {\n        System.out.println(\"Hello, world!\");\n    }\n}' 此检查有助于为向后兼容早期 Java 版本而降级。 2024.1 最新变化 此检查取决于 Java 功能 '隐式声明的类'，该功能自 Java 21-preview 起可用。",
                  "markdown": "报告隐式声明的类，并建议用常规类替换它们。\n\n**示例（在文件 Sample.java 中）：**\n\n\n      public static void main() {\n          System.out.println(\"Hello, world!\");\n      }\n\n在应用快速修复后：\n\n\n    public class Sample {\n        public static void main() {\n            System.out.println(\"Hello, world!\");\n        }\n    }\n\n\n此检查有助于为向后兼容早期 Java 版本而降级。\n\n2024.1 最新变化\n\n此检查取决于 Java 功能 '隐式声明的类'，该功能自 Java 21-preview 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ImplicitToExplicitClassBackwardMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodCallInConstructor",
                "shortDescription": {
                  "text": "对象构造期间调用的 abstract 方法"
                },
                "fullDescription": {
                  "text": "报告在对象构造期间对当前类的 'abstract' 方法的调用。 如果方法位于以下位置，则会在对象构造期间调用： 构造函数 非 static 实例初始值设定项 非 static 字段初始值设定项 'clone()' 方法 'readObject()' 方法 'readObjectNoData()' 方法 此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。 示例： 'abstract class Parent {\n    abstract void abstractMethod();\n  }\n\n  class Child extends Parent {\n    Child() {\n      abstractMethod();\n    }\n  }' 此检查与以下检查共享功能： 在对象构造期间调用的可重写方法 在对象构造期间调用的重写的方法 一次只能启用一个检查，以防止警告重复。",
                  "markdown": "报告在对象构造期间对当前类的 `abstract` 方法的调用。\n\n如果方法位于以下位置，则会在对象构造期间调用：\n\n* 构造函数\n* 非 static 实例初始值设定项\n* 非 static 字段初始值设定项\n* `clone()` 方法\n* `readObject()` 方法\n* `readObjectNoData()` 方法\n\n此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。\n\n**示例：**\n\n\n      abstract class Parent {\n        abstract void abstractMethod();\n      }\n\n      class Child extends Parent {\n        Child() {\n          abstractMethod();\n        }\n      }\n\n此检查与以下检查共享功能：\n\n* 在对象构造期间调用的可重写方法\n* 在对象构造期间调用的重写的方法\n\n一次只能启用一个检查，以防止警告重复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodCallInConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousClassVariableHidesContainingMethodVariable",
                "shortDescription": {
                  "text": "匿名类变量隐藏包含方法中的变量"
                },
                "fullDescription": {
                  "text": "报告匿名类中名称与包含方法或 lambda 表达式的局部变量或形参相同的字段。 由于进行此类命名，在包含方法中有意使用同名变量或形参的情况下，您可能会误用匿名类字段。 建议通过快速修复重命名该字段。 示例： 'class Test {\n    public Test(String value) {\n      Object foo = new Object() {\n        private String value = \"TEST\";\n        public void foo() {\n          System.out.println(value); //访问的是字段，而不是形参\n        }\n      };\n    }\n  }'",
                  "markdown": "报告匿名类中名称与包含方法或 lambda 表达式的局部变量或形参相同的字段。\n\n\n由于进行此类命名，在包含方法中有意使用同名变量或形参的情况下，您可能会误用匿名类字段。\n\n建议通过快速修复重命名该字段。\n\n**示例：**\n\n\n      class Test {\n        public Test(String value) {\n          Object foo = new Object() {\n            private String value = \"TEST\";\n            public void foo() {\n              System.out.println(value); //访问的是字段，而不是形参\n            }\n          };\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousClassVariableHidesContainingMethodVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TailRecursion",
                "shortDescription": {
                  "text": "尾递归"
                },
                "fullDescription": {
                  "text": "报告尾递归，即方法在返回前调用自身作为其最后一项操作。 尾递归总是可以替换为循环，循环的速度快得多。 有些 JVM 执行尾调用优化，而其他一些 JVM 则不执行。 因此，尾递归解决方案在不同的虚拟机上可能有截然不同的性能特征。 示例： 'int factorial(int val, int runningVal) {\n    if (val == 1) {\n      return runningVal;\n    } else {\n      return factorial(val - 1, runningVal * val);\n    }\n  }' 在应用快速修复后： 'int factorial(int val, int runningVal) {\n    while (true) {\n      if (val == 1) {\n        return runningVal;\n      } else {\n        runningVal = runningVal * val;\n        val = val - 1;\n      }\n    }\n  }'",
                  "markdown": "报告尾递归，即方法在返回前调用自身作为其最后一项操作。\n\n\n尾递归总是可以替换为循环，循环的速度快得多。\n有些 JVM 执行尾调用优化，而其他一些 JVM 则不执行。 因此，尾递归解决方案在不同的虚拟机上可能有截然不同的性能特征。\n\n示例：\n\n\n      int factorial(int val, int runningVal) {\n        if (val == 1) {\n          return runningVal;\n        } else {\n          return factorial(val - 1, runningVal * val);\n        }\n      }\n\n在应用快速修复后：\n\n\n      int factorial(int val, int runningVal) {\n        while (true) {\n          if (val == 1) {\n            return runningVal;\n          } else {\n            runningVal = runningVal * val;\n            val = val - 1;\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TailRecursion",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodRefCanBeReplacedWithLambda",
                "shortDescription": {
                  "text": "方法引用可被替换为 lambda"
                },
                "fullDescription": {
                  "text": "报告方法引用，例如 'MyClass::myMethod' 和 'myObject::myMethod'，并建议将它们替换为等效的 lambda 表达式。 Lambda 表达式比方法引用更容易修改。 示例： 'System.out::println' 在应用快速修复后： 's -> System.out.println(s)' 默认情况下，此检查不会高亮显示编辑器中的代码，而仅提供快速修复。 此检查依赖于以下 Java 功能: Lambda 表达式 方法引用 这些功能自 Java 8 起可用。",
                  "markdown": "报告方法引用，例如 `MyClass::myMethod` 和 `myObject::myMethod`，并建议将它们替换为等效的 lambda 表达式。\n\nLambda 表达式比方法引用更容易修改。\n\n示例：\n\n\n      System.out::println\n\n在应用快速修复后：\n\n\n      s -> System.out.println(s)\n\n默认情况下，此检查不会高亮显示编辑器中的代码，而仅提供快速修复。\n\n此检查依赖于以下 Java 功能:\n\n* Lambda 表达式\n* 方法引用\n\n这些功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MethodRefCanBeReplacedWithLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedSynchronizedStatement",
                "shortDescription": {
                  "text": "嵌套 'synchronized' 语句"
                },
                "fullDescription": {
                  "text": "报告嵌套的 'synchronized' 语句。 建议尽量避免嵌套同步，因为在某些情况下，嵌套同步可能会导致死锁。 示例： 'synchronized (lockA){\n    //线程 1 在等待 lockB\n    synchronized (lockB){ //警告\n    }\n  }\n  ...\n  synchronized (lockB) {\n    //线程 2 在等待 lockA\n    synchronized (lockA) { //警告\n    }\n  }'",
                  "markdown": "报告嵌套的 `synchronized` 语句。 建议尽量避免嵌套同步，因为在某些情况下，嵌套同步可能会导致死锁。\n\n**示例：**\n\n\n      synchronized (lockA){\n        //线程 1 在等待 lockB\n        synchronized (lockB){ //警告\n        }\n      }\n      ...\n      synchronized (lockB) {\n        //线程 2 在等待 lockA\n        synchronized (lockA) { //警告\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedSynchronizedStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringEqualsEmptyString",
                "shortDescription": {
                  "text": "'String.equals()' 可被替换为 'String.isEmpty()'"
                },
                "fullDescription": {
                  "text": "报告 'equals()' 被调用以将 'String' 与空字符串进行比较的情况。 在这种情况下，使用 '.isEmpty()' 更好，因为它可以准确显示您正在检查的内容。 示例： 'void checkString(String s){\n    if (\"\".equals(s)) throw new IllegalArgumentException();\n  }' 在应用快速修复后： 'void checkString(String s){\n    if (s != null && s.isEmpty()) throw new IllegalArgumentException();\n  }' '\"\".equals(str)' 在 'str' 为空时返回 false。 为了安全起见，当 'equals()' 实参可以为空时，此检查的快速修复会插入一个显式 null 检查。 使用该选项可使检查忽略此类情况。",
                  "markdown": "报告 `equals()` 被调用以将 `String` 与空字符串进行比较的情况。 在这种情况下，使用 `.isEmpty()` 更好，因为它可以准确显示您正在检查的内容。\n\n**示例：**\n\n\n      void checkString(String s){\n        if (\"\".equals(s)) throw new IllegalArgumentException();\n      }\n\n在应用快速修复后：\n\n\n      void checkString(String s){\n        if (s != null && s.isEmpty()) throw new IllegalArgumentException();\n      }\n\n\n`\"\".equals(str)` 在 `str` 为空时返回 false。 为了安全起见，当 `equals()` 实参可以为空时，此检查的快速修复会插入一个显式 null 检查。 使用该选项可使检查忽略此类情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringEqualsEmptyString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectDateTimeFormat",
                "shortDescription": {
                  "text": "不正确的 'DateTimeFormat' 模式"
                },
                "fullDescription": {
                  "text": "报告错误的日期时间格式模式。 报告以下错误： 不支持的模式字母，如 \"TT\" 使用保留字符，如 \"#\" 不正确的填充用法 不平衡的中括号 连续模式字母的数量不正确 示例： 'DateTimeFormatter.ofPattern(\"[][]]\"); // 右 ']' 之前没有左 '['\n  DateTimeFormatter.ofPattern(\"TT\"); // 非法的模式字母 'T'\n  DateTimeFormatter.ofPattern(\"{\"); // 使用了保留字符 '{'\n  DateTimeFormatter.ofPattern(\"MMMMMM\"); // 过多的连续模式字母 'M'' 2022.3 最新变化",
                  "markdown": "报告错误的日期时间格式模式。\n\n报告以下错误：\n\n* 不支持的模式字母，如 \"TT\"\n* 使用保留字符，如 \"#\"\n* 不正确的填充用法\n* 不平衡的中括号\n* 连续模式字母的数量不正确\n\n示例：\n\n\n      DateTimeFormatter.ofPattern(\"[][]]\"); // 右 ']' 之前没有左 '['\n      DateTimeFormatter.ofPattern(\"TT\"); // 非法的模式字母 'T'\n      DateTimeFormatter.ofPattern(\"{\"); // 使用了保留字符 '{'\n      DateTimeFormatter.ofPattern(\"MMMMMM\"); // 过多的连续模式字母 'M'\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncorrectDateTimeFormat",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PreviewFeature",
                "shortDescription": {
                  "text": "预览功能警告"
                },
                "fullDescription": {
                  "text": "报告预览功能 API 的用法，即使用 '@PreviewFeature' 注解的 'java.*' 或 'javax.*' 命名空间中的模块、软件包、类、接口、方法、构造函数或枚举常量。 预览特性是 Java 语言、Java 虚拟机或 Java SE API 的一个新特性，它已完全指定、完全实现，但不是永久性的。 预览特性的概念在 JEP 12 中进行了定义。 如果某段代码依赖于预览 API，如果更改或移除该功能，该段代码可能会在未来的 JDK 版本中停止编译。 仅当项目或模块的语言级别为预览版时，此检查才会报告。 2021.1 最新变化",
                  "markdown": "报告预览功能 API 的用法，即使用 `@PreviewFeature` 注解的 `java.*` 或 `javax.*` 命名空间中的模块、软件包、类、接口、方法、构造函数或枚举常量。\n\n\n预览特性是 Java 语言、Java 虚拟机或 Java SE API 的一个新特性，它已完全指定、完全实现，但不是永久性的。 预览特性的概念在 [JEP 12](https://openjdk.org/jeps/12) 中进行了定义。\n\n\n如果某段代码依赖于预览 API，如果更改或移除该功能，该段代码可能会在未来的 JDK 版本中停止编译。\n\n仅当项目或模块的语言级别为**预览版**时，此检查才会报告。\n\n2021.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "preview",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/编译器问题",
                      "index": 88,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TooBroadThrows",
                "shortDescription": {
                  "text": "过宽的 'throws' 子句"
                },
                "fullDescription": {
                  "text": "报告异常比方法实际抛出的异常更通用的 'throws' 子句。 示例： 'public void createFile() throws Exception { // 警告：'throws Exception' 范围过广，屏蔽异常 'IOException'\n    File file = new File(\"pathToFile\");\n    file.createNewFile();\n  }' 在应用快速修复后： 'public void createFile() throws IOException {\n    File file = new File(\"pathToFile\");\n    file.createNewFile();\n  }' 配置检查： 使用要警告的隐藏异常的最大数量字段可以忽略隐藏了比指定数量更多的其他异常的异常。 使用仅对 RuntimeException、异常、错误或 Throwable 发出警告选项可以使此检查仅对最常见的异常发出警告。 使用忽略在重写库方法的方法上声明的异常选项可以忽略在重写库方法的方法中过于宽泛的 'throws' 子句。 使用忽略隐藏其他异常但自身被抛出的异常选项可以忽略任何隐藏其他异常，但仍可能从方法体抛出并因此在技术上不会过于宽泛的异常。",
                  "markdown": "报告异常比方法实际抛出的异常更通用的 `throws` 子句。\n\n**示例：**\n\n\n      public void createFile() throws Exception { // 警告：'throws Exception' 范围过广，屏蔽异常 'IOException'\n        File file = new File(\"pathToFile\");\n        file.createNewFile();\n      }\n\n在应用快速修复后：\n\n\n      public void createFile() throws IOException {\n        File file = new File(\"pathToFile\");\n        file.createNewFile();\n      }\n\n配置检查：\n\n* 使用**要警告的隐藏异常的最大数量**字段可以忽略隐藏了比指定数量更多的其他异常的异常。\n* 使用**仅对 RuntimeException、异常、错误或 Throwable 发出警告**选项可以使此检查仅对最常见的异常发出警告。\n* 使用**忽略在重写库方法的方法上声明的异常** 选项可以忽略在重写库方法的方法中过于宽泛的 `throws` 子句。\n* 使用**忽略隐藏其他异常但自身被抛出的异常**选项可以忽略任何隐藏其他异常，但仍可能从方法体抛出并因此在技术上不会过于宽泛的异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyBroadThrowsClause",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitSubclassInspection",
                "shortDescription": {
                  "text": "final 声明不能在运行时被重写"
                },
                "fullDescription": {
                  "text": "报告在运行时代码阻止某个框架（例如 Spring 或 Hibernate）对类进行子类化的情况。 必要但不可能进行子类化的典型示例： 使用特定于框架的注解（例如 Spring '@Configuration'）标记的 'final' 类 使用特定于框架的注解（例如 Spring '@Transactional'）标记的 'final'、'static' 或 'private' 方法 'final' 类中使用特定于框架的注解标记的方法 报告的情况清单取决于使用的框架。",
                  "markdown": "报告在运行时代码阻止某个框架（例如 Spring 或 Hibernate）对类进行子类化的情况。\n\n必要但不可能进行子类化的典型示例：\n\n* 使用特定于框架的注解（例如 Spring `@Configuration`）标记的 `final` 类\n* 使用特定于框架的注解（例如 Spring `@Transactional`）标记的 `final`、`static` 或 `private` 方法\n* `final` 类中使用特定于框架的注解标记的方法\n\n报告的情况清单取决于使用的框架。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ImplicitSubclassInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryFullyQualifiedName",
                "shortDescription": {
                  "text": "不必要的完全限定名称"
                },
                "fullDescription": {
                  "text": "报告可以缩短的完全限定类名。 快速修复会缩短完全限定名称并在必要时添加导入语句。 示例： 'class ListWrapper {\n    java.util.List<Integer> l;\n  }' 在应用快速修复后： 'import java.util.List;\n  class ListWrapper {\n    List<Integer> l;\n  }' 配置检查： 使用 在 Java 9 模块语句中忽略 选项忽略 Java 9 'provides' 和 'uses' 模块语句中的完全限定名称。 在设置| 编辑器 | 代码样式 | Java | 导入 中，请使用以下选项配置检查： 如果应使用外部类限定对内部类的引用，请使用 为内部类插入导入 选项。 使用在 JavaDoc 中使用完全限定类名 选项允许在 Javadoc 中使用完全限定名称。",
                  "markdown": "报告可以缩短的完全限定类名。\n\n快速修复会缩短完全限定名称并在必要时添加导入语句。\n\n示例：\n\n\n      class ListWrapper {\n        java.util.List<Integer> l;\n      }\n\n在应用快速修复后：\n\n\n      import java.util.List;\n      class ListWrapper {\n        List<Integer> l;\n      }\n\n配置检查：\n\n\n使用 **在 Java 9 模块语句中忽略** 选项忽略 Java 9 `provides` 和 `uses` 模块语句中的完全限定名称。\n\n\n在[设置\\| 编辑器 \\| 代码样式 \\| Java \\| 导入](settings://preferences.sourceCode.Java?JavaDoc%20Inner) 中，请使用以下选项配置检查：\n\n* 如果应使用外部类限定对内部类的引用，请使用 **为内部类插入导入** 选项。\n* 使用**在 JavaDoc 中使用完全限定类名** 选项允许在 Javadoc 中使用完全限定名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryFullyQualifiedName",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedConditional",
                "shortDescription": {
                  "text": "具有否定条件的条件表达式"
                },
                "fullDescription": {
                  "text": "报告条件被否定的条件表达式。 翻转条件表达式分支的顺序通常会增加此类语句的清晰度。 使用忽略 '!= null' 比较和忽略 '!= 0' 比较选项可以忽略 'obj != null' 或 'num != 0' 形式的比较。 由于 'obj != null' 实际上意味着 \"obj exists\"，整个表达式的含义不涉及任何否定，所以易于理解。 同样的推理也适用于 'num !=0' 表达式，在使用位掩码时更是如此。 这些形式还有另外的好处，即先提及有趣的情况。 在大多数情况下，'== null' 分支的值为 'null' 本身，如以下示例所示： 'static String getName(Person p) {\n        return p != null ? p.getName() : null;\n    }\n\n    static String getExecutableString(int fileMode) {\n        return (fileMode & 0b001001001) != 0 ? \"executable\" : \"non-executable\";\n    }'",
                  "markdown": "报告条件被否定的条件表达式。\n\n翻转条件表达式分支的顺序通常会增加此类语句的清晰度。\n\n\n使用**忽略 '!= null' 比较** 和**忽略 '!= 0' 比较** 选项可以忽略 `obj != null` 或 `num != 0` 形式的比较。\n由于 `obj != null` 实际上意味着 \"obj exists\"，整个表达式的含义不涉及任何否定，所以易于理解。\n\n\n同样的推理也适用于 `num !=0` 表达式，在使用位掩码时更是如此。\n\n\n这些形式还有另外的好处，即先提及有趣的情况。\n在大多数情况下，`== null` 分支的值为 `null` 本身，如以下示例所示：\n\n\n        static String getName(Person p) {\n            return p != null ? p.getName() : null;\n        }\n\n        static String getExecutableString(int fileMode) {\n            return (fileMode & 0b001001001) != 0 ? \"executable\" : \"non-executable\";\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalExpressionWithNegatedCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectEqualsCanBeEquality",
                "shortDescription": {
                  "text": "'equals()' 调用可被替换为 '=='"
                },
                "fullDescription": {
                  "text": "报告对可以替换为 '==' 或 '!=' 表达式而又不改变语义的 'equals()' 的调用。 当这些调用用于比较没有自身的 'equals()' 实现但使用默认 'Object.equals()' 的'final' 类时，可以替换这些调用。 此替换可能会提升性能。 对 'enum' 值上的 'equals()' 调用进行单独检查：对 Enum 值调用 'equals()'。",
                  "markdown": "报告对可以替换为 `==` 或 `!=` 表达式而又不改变语义的 `equals()` 的调用。\n\n当这些调用用于比较没有自身的 `equals()` 实现但使用默认 `Object.equals()` 的`final` 类时，可以替换这些调用。\n此替换可能会提升性能。\n\n对 `enum` 值上的 `equals()` 调用进行单独检查：对 Enum 值调用 'equals()'。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectEqualsCanBeEquality",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanParameter",
                "shortDescription": {
                  "text": "'public' 方法具有 'boolean' 形参"
                },
                "fullDescription": {
                  "text": "报告接受 'boolean' 形参的 public 方法。 如果某个 public 方法（API 的一部分）不是 setter，则向该方法添加 'boolean' 形参几乎始终是一种不好的做法。 使用此类方法读取代码时，如果不查看源代码或文档，会很难理解 'boolean' 的含义。 此问题也被称为布尔陷阱。 'boolean' 形参通常可以替换为 'enum'。 示例： '// 警告：在查看对此方法的\n  // 调用时，很难理解\n  // 布尔形参的含义\n  public boolean setPermission(File f,\n                               int access,\n                               boolean enable,\n                               boolean ownerOnly) {\n    // ...\n  }' 使用仅报告具有多个布尔形参的方法选项可以仅在一个方法包含多个布尔形参时发出警告。",
                  "markdown": "报告接受 `boolean` 形参的 public 方法。\n\n如果某个 public 方法（API 的一部分）不是 setter，则向该方法添加 `boolean` 形参几乎始终是一种不好的做法。\n使用此类方法读取代码时，如果不查看源代码或文档，会很难理解 `boolean` 的含义。\n\n此问题也被称为[布尔陷阱](https://ariya.io/2011/08/hall-of-api-shame-boolean-trap)。\n`boolean` 形参通常可以替换为 `enum`。\n\n示例：\n\n\n      // 警告：在查看对此方法的\n      // 调用时，很难理解\n      // 布尔形参的含义\n      public boolean setPermission(File f,\n                                   int access,\n                                   boolean enable,\n                                   boolean ownerOnly) {\n        // ...\n      }\n\n\n使用**仅报告具有多个布尔形参的方法**选项可以仅在一个方法包含多个布尔形参时发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JDBCPrepareStatementWithNonConstantString",
                "shortDescription": {
                  "text": "'Connection.prepare*()' 调用具有非常量字符串"
                },
                "fullDescription": {
                  "text": "报告对 'java.sql.Connection.prepareStatement()'、'java.sql.Connection.prepareCall()' 或其任何变体的调用，这些变体会将动态构造的字符串作为要准备的语句。 构造的 SQL 语句是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。 示例： 'String bar() { return \"bar\"; }\n\n  Connection connection = DriverManager.getConnection(\"\", \"\", \"\");\n  connection.(\"SELECT * FROM user WHERE name='\" + bar() + \"'\");' 使用检查设置可以将任何 'static' 'final' 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略： 'static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";'",
                  "markdown": "报告对 `java.sql.Connection.prepareStatement()`、`java.sql.Connection.prepareCall()` 或其任何变体的调用，这些变体会将动态构造的字符串作为要准备的语句。\n\n\n构造的 SQL 语句是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。\n\n**示例：**\n\n\n      String bar() { return \"bar\"; }\n\n      Connection connection = DriverManager.getConnection(\"\", \"\", \"\");\n      connection.(\"SELECT * FROM user WHERE name='\" + bar() + \"'\");\n\n使用检查设置可以将任何 `static` `final` 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略：\n\n\n      static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JDBCPrepareStatementWithNonConstantString",
                    "cweIds": [
                      89
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemProperties",
                "shortDescription": {
                  "text": "系统属性的访问"
                },
                "fullDescription": {
                  "text": "报告使用以下其中一种方法访问系统属性的代码： 'System.getProperties()'、'System.setProperty()'、'System.setProperties()'、'System.clearProperties()' 'Integer.getInteger()' 'Boolean.getBoolean()' 虽然访问系统属性本身并不是安全风险，但它经常出现在恶意代码中。 在任何安全审核中都应该仔细检查访问系统属性的代码。",
                  "markdown": "报告使用以下其中一种方法访问系统属性的代码：\n\n* `System.getProperties()`、`System.setProperty()`、`System.setProperties()`、`System.clearProperties()`\n* `Integer.getInteger()`\n* `Boolean.getBoolean()`\n\n\n虽然访问系统属性本身并不是安全风险，但它经常出现在恶意代码中。\n在任何安全审核中都应该仔细检查访问系统属性的代码。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessOfSystemProperties",
                    "cweIds": [
                      250,
                      668
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestInProductSource",
                "shortDescription": {
                  "text": "产品源中的测试"
                },
                "fullDescription": {
                  "text": "报告位于生产源树中的测试类和测试方法。 这很可能表示有错误，并且可能导致测试代码被投入生产。",
                  "markdown": "报告位于生产源树中的测试类和测试方法。 这很可能表示有错误，并且可能导致测试代码被投入生产。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestInProductSource",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CopyConstructorMissesField",
                "shortDescription": {
                  "text": "复制缺少字段的构造函数"
                },
                "fullDescription": {
                  "text": "报告不复制该类所有字段的复制构造函数。 带有初始值设定项的 'final' 字段和 'transient' 字段被视为不必复制。 示例： 'class Point {\n\n    private int x;\n    private int y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    Point(Point other) {\n      // 字段 x 和 y 未初始化\n    }\n  }' 2018.1 最新变化",
                  "markdown": "报告不复制该类所有字段的复制构造函数。\n\n\n带有初始值设定项的 `final` 字段和 `transient` 字段被视为不必复制。\n\n**示例：**\n\n\n      class Point {\n\n        private int x;\n        private int y;\n\n        Point(int x, int y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        Point(Point other) {\n          // 字段 x 和 y 未初始化\n        }\n      }\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CopyConstructorMissesField",
                    "cweIds": [
                      665
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InvalidComparatorMethodReference",
                "shortDescription": {
                  "text": "用于 'Comparator' 的无效方法引用"
                },
                "fullDescription": {
                  "text": "报告映射到 'Comparator' 接口的不履行其约定的方法引用。 某些方法引用，例如 'Integer::max'，可以映射到 'Comparator' 接口。 但是，将它们用作 'Comparator' 是没有意义的，结果可能是不可预测的。 示例： 'ArrayList<Integer> ints = foo();\n  ints.sort(Math::min);' 在应用快速修复后： 'ArrayList<Integer> ints = foo();\n  ints.sort(Comparator.reverseOrder());'",
                  "markdown": "报告映射到 `Comparator` 接口的不履行其约定的方法引用。\n\n\n某些方法引用，例如 `Integer::max`，可以映射到 `Comparator` 接口。\n但是，将它们用作 `Comparator` 是没有意义的，结果可能是不可预测的。\n\n示例：\n\n\n      ArrayList<Integer> ints = foo();\n      ints.sort(Math::min);\n\n在应用快速修复后：\n\n\n      ArrayList<Integer> ints = foo();\n      ints.sort(Comparator.reverseOrder());\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InvalidComparatorMethodReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastCanBeRemovedNarrowingVariableType",
                "shortDescription": {
                  "text": "太弱的变量类型导致不必要的转换"
                },
                "fullDescription": {
                  "text": "如果将变量类型范围缩小到转换类型，则报告可以移除的类型转换。 示例： 'Object x = \"  string  \";\n  System.out.println(((String)x).trim());' 在这里，将 'x' 的类型更改为 'String' 使转换变得冗余。 建议的快速修复会更新变量类型并移除该变量上的所有冗余转换： 'String x = \"  string  \";\n  System.out.println(x.trim());' 2018.2 最新变化",
                  "markdown": "如果将变量类型范围缩小到转换类型，则报告可以移除的类型转换。\n\n示例：\n\n\n      Object x = \"  string  \";\n      System.out.println(((String)x).trim());\n\n\n在这里，将 `x` 的类型更改为 `String` 使转换变得冗余。 建议的快速修复会更新变量类型并移除该变量上的所有冗余转换：\n\n\n      String x = \"  string  \";\n      System.out.println(x.trim());\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastCanBeRemovedNarrowingVariableType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9ModuleExportsPackageToItself",
                "shortDescription": {
                  "text": "模块将软件包导出/打开到本身"
                },
                "fullDescription": {
                  "text": "报告导出到定义它们的同一 Java 9 模块或在该模块中打开的软件包。 该快速修复会从 'module-info.java' 中移除此类指令。 示例： 'module com.mycomp {\n    exports com.mycomp.main to com.mycomp;\n  }' 在应用快速修复后： 'module main {\n  }' 此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。",
                  "markdown": "报告导出到定义它们的同一 Java 9 模块或在该模块中打开的软件包。 该快速修复会从 `module-info.java` 中移除此类指令。\n\n示例：\n\n\n      module com.mycomp {\n        exports com.mycomp.main to com.mycomp;\n      }\n\n在应用快速修复后：\n\n\n      module main {\n      }\n\n此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9ModuleExportsPackageToItself",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ToArrayCallWithZeroLengthArrayArgument",
                "shortDescription": {
                  "text": "'Collection.toArray()' 调用样式"
                },
                "fullDescription": {
                  "text": "报告非首选样式的 'Collection.toArray()' 调用，并建议应用首选样式。 将集合转换为数组有两种样式： 预先确定大小的数组，例如 'c.toArray(new String[c.size()])' 空数组，例如 'c.toArray(new String[0])' 在旧的 Java 版本中，建议使用预先确定大小的数组，因为创建适当大小的数组所需的反射调用非常慢。 不过，自 OpenJDK 6 的最新更新以来，此调用已被添加，使得空数组版本的性能与预先确定大小的版本相同，有时甚至更高一筹。 此外，传递预先确定大小的数组对于并发集合或同步集合很危险，因为 'size' 和 'toArray' 调用之间可能会发生数据竞争。 如果在运算过程中并发收缩该集合，可能导致数组末尾出现额外的 'null'。 使用检查选项可以选择首选样式。",
                  "markdown": "报告非首选样式的 `Collection.toArray()` 调用，并建议应用首选样式。\n\n将集合转换为数组有两种样式：\n\n* 预先确定大小的数组，例如 `c.toArray(new String[c.size()])`\n* 空数组，例如 `c.toArray(new String[0])`\n\n在旧的 Java 版本中，建议使用预先确定大小的数组，因为创建适当大小的数组所需的反射调用非常慢。\n\n不过，自 OpenJDK 6 的最新更新以来，此调用已被添加，使得空数组版本的性能与预先确定大小的版本相同，有时甚至更高一筹。 此外，传递预先确定大小的数组对于并发集合或同步集合很危险，因为 `size` 和 `toArray` 调用之间可能会发生数据竞争。 如果在运算过程中并发收缩该集合，可能导致数组末尾出现额外的 `null`。\n\n使用检查选项可以选择首选样式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ToArrayCallWithZeroLengthArrayArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggerInitializedWithForeignClass",
                "shortDescription": {
                  "text": "使用外类初始化记录器"
                },
                "fullDescription": {
                  "text": "报告用来初始化的 'class' 文字所属的类与 'Logger' 所属的类不同的 'Logger' 实例。 从另一个类复制粘贴某些代码时，很容易发生这种情况，并可能导致在意外类别下记录事件，并导致筛选器应用不正确。 提供了一个快速修复来用周围类中的文字替换外类文字。 示例： 'public class Paramount {\n    protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n    // …其他字段和方法\n  }' 在应用快速修复后： 'public class Paramount {\n    protected static final Logger LOG = Logger.getLogger(Paramount.class);\n\n    // …其他字段和方法\n  }' 配置检查： 使用该表可以指定此检查识别的记录器工厂类和记录器工厂方法。 使用忽略使用超类初始化的记录器选项可以忽略使用包含该记录器的类的超类初始化的记录器。 使用忽略非 public 类中的记录器，仅对 'public' 类中的记录器发出警告。",
                  "markdown": "报告用来初始化的 `class` 文字所属的类与 `Logger` 所属的类不同的 `Logger` 实例。 从另一个类复制粘贴某些代码时，很容易发生这种情况，并可能导致在意外类别下记录事件，并导致筛选器应用不正确。\n\n提供了一个快速修复来用周围类中的文字替换外类文字。\n\n**示例：**\n\n\n      public class Paramount {\n        protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n        // ...其他字段和方法\n      }\n\n在应用快速修复后：\n\n\n      public class Paramount {\n        protected static final Logger LOG = Logger.getLogger(Paramount.class);\n\n        // ...其他字段和方法\n      }\n\n\n配置检查：\n\n* 使用该表可以指定此检查识别的记录器工厂类和记录器工厂方法。\n* 使用**忽略使用超类初始化的记录器**选项可以忽略使用包含该记录器的类的超类初始化的记录器。\n* 使用**忽略非 public 类中的记录器** ，仅对 `public` 类中的记录器发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LoggerInitializedWithForeignClass",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkerInterface",
                "shortDescription": {
                  "text": "标记接口"
                },
                "fullDescription": {
                  "text": "报告不含任何方法或字段的标记接口。 此类接口可能令人困惑，通常表明设计失败。 该检查将忽略扩展两个或多个接口的接口以及指定其超接口泛型类型的接口。",
                  "markdown": "报告不含任何方法或字段的标记接口。\n\n此类接口可能令人困惑，通常表明设计失败。\n\n该检查将忽略扩展两个或多个接口的接口以及指定其超接口泛型类型的接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkerInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SortedCollectionWithNonComparableKeys",
                "shortDescription": {
                  "text": "包含不可比较元素的排序集合"
                },
                "fullDescription": {
                  "text": "报告排序集合的结构，例如 'TreeSet'，它依赖于自然排序，其元素类型不实现 'Comparable' 接口。 此类集合不太可能正常工作。 如果集合元素类型是不可比较的父类型，但集合只打算保存可比较的子类型，则可能出现误报。 即便这样，也最好缩小集合元素类型的范围或将父类型声明为 'Comparable' ，因为上述方法容易出错。 该检查还会报告集合元素是未声明为 'extends Comparable' 的类型形参的情况。 您可以使用所提供的选项禁止对类型形参发出警告（例如，为了保持 API 兼容性）。 2018.3 最新变化",
                  "markdown": "报告排序集合的结构，例如 `TreeSet`，它依赖于自然排序，其元素类型不实现 `Comparable` 接口。\n\n此类集合不太可能正常工作。\n\n\n如果集合元素类型是不可比较的父类型，但集合只打算保存可比较的子类型，则可能出现误报。 即便这样，也最好缩小集合元素类型的范围或将父类型声明为 `Comparable` ，因为上述方法容易出错。\n\n\n该检查还会报告集合元素是未声明为 `extends Comparable` 的类型形参的情况。\n您可以使用所提供的选项禁止对类型形参发出警告（例如，为了保持 API 兼容性）。\n\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SortedCollectionWithNonComparableKeys",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CommentedOutCode",
                "shortDescription": {
                  "text": "注释掉的代码"
                },
                "fullDescription": {
                  "text": "报告包含 Java 代码的注释。 通常，被注释掉的代码很快就会过时并且会引起误解。 由于大多数项目使用某种版本控制系统，因此最好完全删除注释掉的代码并改用 VCS 历史记录。 2020.3 最新变化",
                  "markdown": "报告包含 Java 代码的注释。\n\n通常，被注释掉的代码很快就会过时并且会引起误解。\n由于大多数项目使用某种版本控制系统，因此最好完全删除注释掉的代码并改用 VCS 历史记录。\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CommentedOutCode",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToStaticFieldFromInstanceMethod",
                "shortDescription": {
                  "text": "从实例上下文赋值给 static 字段"
                },
                "fullDescription": {
                  "text": "报告对实例方法中 'static' 字段的赋值或修改。 虽然合法，但此类赋值很难安全完成，并且通常是无意中将字段标记为 'static' 的结果。 示例： 'class Counter {\n    private static int count = 0;\n\n    void increment() {\n      // 警告：从实例方法\n      // 更新 static 字段\n      count++;\n    }\n  }'",
                  "markdown": "报告对实例方法中 `static` 字段的赋值或修改。\n\n虽然合法，但此类赋值很难安全完成，并且通常是无意中将字段标记为 `static` 的结果。\n\n**示例：**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // 警告：从实例方法\n          // 更新 static 字段\n          count++;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToStaticFieldFromInstanceMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithoutLogger",
                "shortDescription": {
                  "text": "不带记录器的类"
                },
                "fullDescription": {
                  "text": "报告没有声明记录器的类。 确保每个类都有一个专用的记录器是为应用程序提供统一的日志记录实现的重要步骤。 此检查不报告接口、枚举、注解、内部类和 abstract 类。 示例： 'public class NoLoggerDeclared {\n\n    int calculateNthDigitOfPi(int n) {\n      // todo\n      return 1;\n    }\n  }' 使用 Options 部分中的表可以指定记录器类名。 此检查将报告未声明具有指定类之一类型的字段的类。",
                  "markdown": "报告没有声明记录器的类。\n\n确保每个类都有一个专用的记录器是为应用程序提供统一的日志记录实现的重要步骤。 此检查不报告接口、枚举、注解、内部类和 abstract 类。\n\n示例：\n\n\n      public class NoLoggerDeclared {\n\n        int calculateNthDigitOfPi(int n) {\n          // todo\n          return 1;\n        }\n      }\n\n\n使用 **Options** 部分中的表可以指定记录器类名。\n此检查将报告未声明具有指定类之一类型的字段的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithoutLogger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnOfInnerClass",
                "shortDescription": {
                  "text": "返回匿名、局部或内部类的实例"
                },
                "fullDescription": {
                  "text": "报告返回匿名类、局部类或内部类实例的 'return' 语句。 此类实例会保持对外部实例的隐式引用，这可以防止外部实例被垃圾回收。 任何返回此类实例的方法的调用方都可能通过保留返回的实例而导致内存泄漏。 配置检查： 使用忽略非 public 方法的返回值选项可以忽略来自 'protected' 或 package-private 方法的返回值。 始终忽略来自 'private' 方法的返回。",
                  "markdown": "报告返回匿名类、局部类或内部类实例的 `return` 语句。 此类实例会保持对外部实例的隐式引用，这可以防止外部实例被垃圾回收。 任何返回此类实例的方法的调用方都可能通过保留返回的实例而导致内存泄漏。\n\n\n配置检查：\n\n* 使用**忽略非 public 方法的返回值** 选项可以忽略来自 `protected` 或 package-private 方法的返回值。 始终忽略来自 `private` 方法的返回。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnOfInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousClassComplexity",
                "shortDescription": {
                  "text": "过度复杂的匿名类"
                },
                "fullDescription": {
                  "text": "报告总复杂度超过指定最大值的匿名内部类。 类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。 匿名类应该具有非常低的复杂度，否则它们会难以理解并且应提升为命名的内部类。 使用循环复杂度限制字段可指定类允许的最大复杂度。",
                  "markdown": "报告总复杂度超过指定最大值的匿名内部类。\n\n类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。\n\n匿名类应该具有非常低的复杂度，否则它们会难以理解并且应提升为命名的内部类。\n\n使用**循环复杂度限制**字段可指定类允许的最大复杂度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexAnonymousInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassWithOnlyOneDirectInheritor",
                "shortDescription": {
                  "text": "只有一个直接继承者的抽象类"
                },
                "fullDescription": {
                  "text": "报告仅具有一个直接继承者的 abstract 类。 虽然这种类可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将抽象类与其继承者合并。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 示例： 'abstract class Base {} // 将被报告\n\n  class Inheritor extends Base {}'",
                  "markdown": "报告仅具有一个直接继承者的 abstract 类。 虽然这种类可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将抽象类与其继承者合并。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n**示例：**\n\n\n      abstract class Base {} // 将被报告\n\n      class Inheritor extends Base {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassWithOnlyOneDirectInheritor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitWithoutCorrespondingNotify",
                "shortDescription": {
                  "text": "没有相应 'notify()' 的 'wait()'"
                },
                "fullDescription": {
                  "text": "报告对无法为之找到相应 'Object.notify()' 或 'Object.notifyAll()' 调用的 'Object.wait()' 的调用。 此检查仅报告包含引用当前类字段的限定符的调用。 示例： 'public class Foo {\n    public Object foo = new Object();\n\n    void bar() throws InterruptedException {\n      this.foo.wait();\n    }\n  }'",
                  "markdown": "报告对无法为之找到相应 `Object.notify()` 或 `Object.notifyAll()` 调用的 `Object.wait()` 的调用。\n\n此检查仅报告包含引用当前类字段的限定符的调用。\n\n**示例：**\n\n\n      public class Foo {\n        public Object foo = new Object();\n\n        void bar() throws InterruptedException {\n          this.foo.wait();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitWithoutCorrespondingNotify",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsecureRandomNumberGeneration",
                "shortDescription": {
                  "text": "不安全的随机数生成"
                },
                "fullDescription": {
                  "text": "报告任何使用 'java.lang.Random' 或 'java.lang.Math.random()' 的情况。 在安全环境中，'java.secure.SecureRandom' 是更好的选择，因为它提供加密安全的随机数生成。 示例： 'long token = new Random().nextLong();'",
                  "markdown": "报告任何使用 `java.lang.Random` 或 `java.lang.Math.random()` 的情况。\n\n\n在安全环境中，`java.secure.SecureRandom` 是更好的选择，因为它提供加密安全的随机数生成。\n\n**示例：**\n\n\n      long token = new Random().nextLong();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsecureRandomNumberGeneration",
                    "cweIds": [
                      330
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullableProblems",
                "shortDescription": {
                  "text": "@NotNull/@Nullable 问题"
                },
                "fullDescription": {
                  "text": "报告与可 null 性注解相关的问题。 示例： 重写方法未注解： 'abstract class A {\n  @NotNull abstract String m();\n}\nclass B extends A {\n    String m() { return \"empty string\"; }\n}' 注解的基元类型：'@NotNull int myFoo;' '@Nullable' 和 '@NotNull' 位于同一成员上：'@Nullable @NotNull String myFooString;' 可 null 元素的集合被分配到非 null 元素的集合中： 'void testList(List<@Nullable String> nullableList) {\n   List<@NotNull String> list2 = nullableList;\n}' 使用配置注解按钮可指定可 null 性注解，使用复选框可细调该检查提供警告的位置。 仅当项目或模块的语言级别为 5 或更高，并且类路径上提供可 null 性注解时，此检查才会报告。",
                  "markdown": "报告与可 null 性注解相关的问题。\n\n**示例：**\n\n* 重写方法未注解：\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* 注解的基元类型：`@NotNull int myFoo;`\n* `@Nullable` 和 `@NotNull` 位于同一成员上：`@Nullable @NotNull String myFooString;`\n* 可 null 元素的集合被分配到非 null 元素的集合中：\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \n使用**配置注解**按钮可指定可 null 性注解，使用复选框可细调该检查提供警告的位置。\n\n仅当项目或模块的语言级别为 5 或更高，并且类路径上提供可 null 性注解时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NullableProblems",
                    "cweIds": [
                      476,
                      754
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug/为 null 性问题",
                      "index": 118,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfAWTPeerClass",
                "shortDescription": {
                  "text": "使用 AWT 对等类"
                },
                "fullDescription": {
                  "text": "报告使用 AWT 对等类的情况。 这些类代表原生窗口系统微件，并且不可在不同的窗口系统之间移植。 示例： 'import java.awt.peer.ButtonPeer;\n\n  abstract class Sample implements ButtonPeer {\n    public void foo() {\n        Sample sample;\n    }\n  }'",
                  "markdown": "报告使用 AWT 对等类的情况。 这些类代表原生窗口系统微件，并且不可在不同的窗口系统之间移植。\n\n**示例：**\n\n\n      import java.awt.peer.ButtonPeer;\n\n      abstract class Sample implements ButtonPeer {\n        public void foo() {\n            Sample sample;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfAWTPeerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "'equals()' 位于不可转换类型的对象之间"
                },
                "fullDescription": {
                  "text": "报告对目标和实参的类型不兼容的 'equals()' 的调用。 虽然此类调用理论上可能有用，但很可能是错误。 示例： 'new HashSet<String>().equals(new TreeSet<Integer>());'",
                  "markdown": "报告对目标和实参的类型不兼容的 `equals()` 的调用。\n\n虽然此类调用理论上可能有用，但很可能是错误。\n\n**示例：**\n\n\n      new HashSet<String>().equals(new TreeSet<Integer>());\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTemplateReverseMigration",
                "shortDescription": {
                  "text": "字符串模板可以是串联字符串"
                },
                "fullDescription": {
                  "text": "使用 'STR' 处理器报告字符串模板表达式，并提供快速修复以迁移回纯字符串串联。 示例： 'String name = \"Bob\";\n  String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";' 在应用快速修复后： 'String name = \"Bob\";\n  String greeting = \"Hello, \" + name + \". You are 29 years old.\";' 2024.2 最新变化",
                  "markdown": "使用 `STR` 处理器报告字符串模板表达式，并提供快速修复以迁移回纯字符串串联。\n\n**示例：**\n\n\n      String name = \"Bob\";\n      String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";\n\n在应用快速修复后：\n\n\n      String name = \"Bob\";\n      String greeting = \"Hello, \" + name + \". You are 29 years old.\";\n\n2024.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "StringTemplateReverseMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateCondition",
                "shortDescription": {
                  "text": "条件重复"
                },
                "fullDescription": {
                  "text": "报告 '&&' 和 '||' 表达式以及 'if' 语句分支中的重复条件。 这些重复的条件有时是有意为之，但通常是因为疏忽大意所致。 示例： 'boolean result = digit1 != digit2 || digit1 != digit2;' 要忽略可能产生副作用的条件，请使用忽略有副作用的条件 选项。 禁用此选项可能会导致误报，例如，当同一方法在后续调用中返回不同的值时。 示例： 'native boolean unknownMethod();\n  \n  ...\n  \n  if (unknownMethod() || unknownMethod()) {\n    System.out.println(\"Got it\");\n  }' 由于 'unknownMethod()' 可能存在副作用（在示例中），只有在禁用 忽略有副作用的条件 选项时才会触发警告。",
                  "markdown": "报告 `&&` 和 `||` 表达式以及 `if` 语句分支中的重复条件。 这些重复的条件有时是有意为之，但通常是因为疏忽大意所致。\n\n示例：\n\n\n      boolean result = digit1 != digit2 || digit1 != digit2;\n\n\n要忽略可能产生副作用的条件，请使用**忽略有副作用的条件** 选项。\n禁用此选项可能会导致误报，例如，当同一方法在后续调用中返回不同的值时。\n\n示例：\n\n\n      native boolean unknownMethod();\n      \n      ...\n      \n      if (unknownMethod() || unknownMethod()) {\n        System.out.println(\"Got it\");\n      }\n\n由于 `unknownMethod()` 可能存在副作用（在示例中），只有在禁用 **忽略有副作用的条件** 选项时才会触发警告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizationOnGetClass",
                "shortDescription": {
                  "text": "在 'getClass()' 上同步"
                },
                "fullDescription": {
                  "text": "报告对 'getClass()' 的调用上的同步。 如果包含同步的类被子类化，子类将在不同的类对象上同步。 对 'getClass()' 的调用通常可以替换为类的文字表达式，例如 'String.class'。 一种更好的解决办法是在 'private static final' 锁对象上同步，从而完全控制对该对象的访问。 示例： 'synchronized(getClass()) {}'",
                  "markdown": "报告对 `getClass()` 的调用上的同步。\n\n\n如果包含同步的类被子类化，子类将在不同的类对象上同步。 对 `getClass()` 的调用通常可以替换为类的文字表达式，例如 `String.class`。 一种更好的解决办法是在 `private static final` 锁对象上同步，从而完全控制对该对象的访问。\n\n**示例：**\n\n     synchronized(getClass()) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizationOnGetClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitVariableType",
                "shortDescription": {
                  "text": "可以省略局部变量类型"
                },
                "fullDescription": {
                  "text": "报告冗余局部变量类型。 这些类型可以从上下文中推断出来，因此替换为 'var'。 示例： 'void test(InputStream s) {\n    try (InputStream in = s) {}\n  }' 应用修正后： 'void test(InputStream s) {\n    try (var in = s) {}\n  }' 此检查取决于 Java 功能 '局部变量类型推断'，该功能自 Java 10 起可用。",
                  "markdown": "报告冗余局部变量类型。\n\n这些类型可以从上下文中推断出来，因此替换为 `var`。\n\n**示例：**\n\n\n      void test(InputStream s) {\n        try (InputStream in = s) {}\n      }\n\n应用修正后：\n\n\n      void test(InputStream s) {\n        try (var in = s) {}\n      }\n\n\n此检查取决于 Java 功能 '局部变量类型推断'，该功能自 Java 10 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitVariableType",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 10",
                      "index": 112,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrownExceptionsPerMethod",
                "shortDescription": {
                  "text": "方法声明的异常过多"
                },
                "fullDescription": {
                  "text": "报告在 'throws' 列表中具有过多异常类型的方法。 声明了太多异常的方法是错误处理代码变得过于复杂的标志。 使用异常抛出限制字段可指定方法在其 'throws' 列表中允许的最大异常类型数。",
                  "markdown": "报告在 `throws` 列表中具有过多异常类型的方法。\n\n声明了太多异常的方法是错误处理代码变得过于复杂的标志。\n\n使用**异常抛出限制** 字段可指定方法在其 `throws` 列表中允许的最大异常类型数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithTooExceptionsDeclared",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantThrows",
                "shortDescription": {
                  "text": "冗余 'throws' 子句"
                },
                "fullDescription": {
                  "text": "报告在方法签名中声明但方法本身或其实现和重写方法从未抛出的异常。 该检查会忽略与序列化相关的方法，例如方法 'readObject()' 和 'writeObject()'。 示例： 'void method() throws InterruptedException {\n    System.out.println();\n  }' 该快速修复会移除声明中不必要的异常，并规范化冗余的 'try'-'catch' 语句： 'void method() {\n    System.out.println();\n  }' 注意：由于性能原因，在编辑器中高亮显示时可能不会报告某些异常。 要查看所有结果，请从主菜单中选择代码 | 检查代码或代码 | 分析代码 | 按名称运行检查来运行检查。 使用忽略由入口点方法抛出的异常选项可以不报告由 'main()' 等方法抛出的异常。 可以在 Java | 声明冗余 | 未使用的声明检查的设置中配置入口点方法。",
                  "markdown": "报告在方法签名中声明但方法本身或其实现和重写方法从未抛出的异常。\n\n该检查会忽略与序列化相关的方法，例如方法 `readObject()` 和 `writeObject()`。\n\n**示例：**\n\n\n      void method() throws InterruptedException {\n        System.out.println();\n      }\n\n该快速修复会移除声明中不必要的异常，并规范化冗余的 `try`-`catch` 语句：\n\n\n      void method() {\n        System.out.println();\n      }\n\n\n**注意** ：由于性能原因，在编辑器中高亮显示时可能不会报告某些异常。\n要查看所有结果，请从主菜单中选择**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 按名称运行检查**来运行检查。\n\n使用**忽略由入口点方法抛出的异常** 选项可以不报告由 `main()` 等方法抛出的异常。\n可以在 [Java \\| 声明冗余 \\| 未使用的声明](settings://Errors?Unused%20Declaration%20entry%20point)检查的设置中配置入口点方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantThrows",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableWithUnconstructableAncestor",
                "shortDescription": {
                  "text": "具有不可构造上级的可序列化类"
                },
                "fullDescription": {
                  "text": "报告最近的不可序列化祖先没有无实参构造函数的 'Serializable' 类。 这种类无法反序列化，将失败并抛出 'InvalidClassException'。 示例： 'class Ancestor {\n    private String name;\n    Ancestor(String name) {\n      this.name = name;\n    }\n  }\n\n  //对此类发出警告，因为超类并非\n//可序列化，并且其构造函数接受实参\n  class Descendant extends Ancestor implements Serializable {\n    Descendant() {\n      super(\"Bob\");\n    }\n  }'",
                  "markdown": "报告最近的不可序列化祖先没有无实参构造函数的 `Serializable` 类。 这种类无法反序列化，将失败并抛出 `InvalidClassException`。\n\n**示例：**\n\n\n      class Ancestor {\n        private String name;\n        Ancestor(String name) {\n          this.name = name;\n        }\n      }\n\n      //对此类发出警告，因为超类并非\n    //可序列化，并且其构造函数接受实参\n      class Descendant extends Ancestor implements Serializable {\n        Descendant() {\n          super(\"Bob\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableClassWithUnconstructableAncestor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExcessiveLambdaUsage",
                "shortDescription": {
                  "text": "过度使用 lambda"
                },
                "fullDescription": {
                  "text": "报告一个普通的 lambda 表达式被用在另一种方法中的情况，这种方法以相同方式运行，但只接受一个具体的值而不是 lambda。 此检查有助于简化代码。 示例： 'Optional.orElseGet(() -> null)' 在应用快速修复后： 'Optional.orElse(null)' 2017.1 最新变化 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告一个普通的 lambda 表达式被用在另一种方法中的情况，这种方法以相同方式运行，但只接受一个具体的值而不是 lambda。\n\n此检查有助于简化代码。\n\n示例：\n\n\n      Optional.orElseGet(() -> null)\n\n在应用快速修复后：\n\n\n      Optional.orElse(null)\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExcessiveLambdaUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterHidingMemberVariable",
                "shortDescription": {
                  "text": "形参隐藏字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的方法形参。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该形参。 建议通过快速修复重命名该形参。 示例： 'class Main {\n    private String value;\n\n    public Main(String value) {\n      value = value.toUpperCase();\n    }\n  }' 您可以为此检查配置以下选项： 对属性 setter 忽略 - 忽略简单 setter 的形参。 忽略从子类不可见的超类字段 - 忽略超类中对此方法不可见的 'private' 字段。 对构造函数忽略 - 忽略构造函数的形参。 对 abstract 方法忽略 - 忽略 abstract 方法的形参。 对隐藏实例字段的 static 方法形参忽略 - 忽略隐藏实例字段的 'static' 方法的形参，并忽略隐藏外部类实例字段的 static 内部类中实例方法的形参。 虽然不是严格意义上的隐藏，但此类形参仍然令人困惑。",
                  "markdown": "报告与周围类的字段同名的方法形参。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该形参。\n\n建议通过快速修复重命名该形参。\n\n**示例：**\n\n\n      class Main {\n        private String value;\n\n        public Main(String value) {\n          value = value.toUpperCase();\n        }\n      }\n      \n\n您可以为此检查配置以下选项：\n\n1. **对属性 setter 忽略** - 忽略简单 setter 的形参。\n2. **忽略从子类不可见的超类字段** - 忽略超类中对此方法不可见的 `private` 字段。\n3. **对构造函数忽略** - 忽略构造函数的形参。\n4. **对 abstract 方法忽略** - 忽略 abstract 方法的形参。\n5. **对隐藏实例字段的 static 方法形参忽略** - 忽略隐藏实例字段的 `static` 方法的形参，并忽略隐藏外部类实例字段的 static 内部类中实例方法的形参。 虽然不是严格意义上的隐藏，但此类形参仍然令人困惑。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterHidesMemberVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaBodyCanBeCodeBlock",
                "shortDescription": {
                  "text": "lambda 体可以是代码块"
                },
                "fullDescription": {
                  "text": "报告主体为表达式的 lambda，并建议将表达式主体转换为代码块。 示例： 'n -> n + 1' 在应用快速修复后： 'n -> {\n  return n + 1;\n}' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告主体为表达式的 lambda，并建议将表达式主体转换为代码块。\n\n示例：\n\n\n      n -> n + 1\n\n在应用快速修复后：\n\n    n -> {\n      return n + 1;\n    }\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaBodyCanBeCodeBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfAnotherObjectsPrivateField",
                "shortDescription": {
                  "text": "访问另一个对象的非 public 字段"
                },
                "fullDescription": {
                  "text": "报告对另一个对象的 'private' 或 'protected' 字段的访问。 Java 允许访问与当前对象属于同一类的对象的此类字段，但某些编码样式不鼓励这种用法。 此外，这种对 'private' 字段的直接访问在面向组件的架构（例如 Spring 或 Hibernate）中可能会失败，它们期望对其他对象的所有访问都通过方法调用进行，以便框架可以使用代理调解访问。 示例： 'public class Base {\n    protected int bar;\n\n    void increment(Base base) {\n      bar++;\n      base.bar++; // warning: direct access to another object's non-public field\n    }\n  }' 可以通过快速修复封装该字段。 配置检查： 使用忽略来自同一类的访问选项可忽略来自同一类的访问，只报告来自内部或外部类的访问。 要忽略来自内部类的访问，请使用嵌套的忽略来自内部类的访问。 使用忽略来自 'equals()' 方法的访问可忽略来自 'equals()' 方法的访问。",
                  "markdown": "报告对另一个对象的 `private` 或 `protected` 字段的访问。 Java 允许访问与当前对象属于同一类的对象的此类字段，但某些编码样式不鼓励这种用法。 此外，这种对 `private` 字段的直接访问在面向组件的架构（例如 Spring 或 Hibernate）中可能会失败，它们期望对其他对象的所有访问都通过方法调用进行，以便框架可以使用代理调解访问。\n\n**示例：**\n\n\n      public class Base {\n        protected int bar;\n\n        void increment(Base base) {\n          bar++;\n          base.bar++; // warning: direct access to another object's non-public field\n        }\n      }\n\n可以通过快速修复封装该字段。\n\n配置检查：\n\n* 使用**忽略来自同一类的访问** 选项可忽略来自同一类的访问，只报告来自内部或外部类的访问。\n\n  要忽略来自内部类的访问，请使用嵌套的**忽略来自内部类的访问**。\n* 使用**忽略来自 'equals()' 方法的访问** 可忽略来自 `equals()` 方法的访问。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessingNonPublicFieldOfAnotherObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessBitwiseExpression",
                "shortDescription": {
                  "text": "无意义的按位表达式"
                },
                "fullDescription": {
                  "text": "报告无意义的按位表达式。 此类表达式包括对给定类型的最大值应用 '&' 运算符，对零以及移零应用 'or' 运算符。 出现此类表达式，可能是因为自动重构没有一直持续到完成，而且不太可能是出于原本的意图。 示例： '// 警告：运算毫无意义，可以替换为 `flags`\n  // 0xFFFF_FFFF 是一个整数的最大值，并且这两个文字都被视为\n  // 32 位整数文字。\n  int bits = flags & 0xFFFF_FFFF;\n\n  // 警告：运算毫无意义，可以替换为 `bits`\n  // 包含 0 的 OR 运算始终输出另一个操作数。\n  int or = bits | 0x0;\n\n  // 警告：运算毫无意义，结果始终为 0\n  int xor = or ^ or;'",
                  "markdown": "报告无意义的按位表达式。\n\n\n此类表达式包括对给定类型的最大值应用 `&` 运算符，对零以及移零应用 `or` 运算符。 出现此类表达式，可能是因为自动重构没有一直持续到完成，而且不太可能是出于原本的意图。\n\n**示例：**\n\n\n      // 警告：运算毫无意义，可以替换为 `flags`\n      // 0xFFFF_FFFF 是一个整数的最大值，并且这两个文字都被视为\n      // 32 位整数文字。\n      int bits = flags & 0xFFFF_FFFF;\n\n      // 警告：运算毫无意义，可以替换为 `bits`\n      // 包含 0 的 OR 运算始终输出另一个操作数。\n      int or = bits | 0x0;\n\n      // 警告：运算毫无意义，结果始终为 0\n      int xor = or ^ or;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessBitwiseExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/按位运算问题",
                      "index": 98,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CustomSecurityManager",
                "shortDescription": {
                  "text": "自定义 'SecurityManager'"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.SecurityManager' 的用户定义子类。 虽然不一定代表安全漏洞，但应彻底和专业地检查这种类是否存在可能的安全问题。 示例： 'class CustomSecurityManager extends SecurityManager {\n  }'",
                  "markdown": "报告 `java.lang.SecurityManager` 的用户定义子类。\n\n\n虽然不一定代表安全漏洞，但应彻底和专业地检查这种类是否存在可能的安全问题。\n\n**示例：**\n\n\n      class CustomSecurityManager extends SecurityManager {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CustomSecurityManager",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectEquality",
                "shortDescription": {
                  "text": "使用 '==' 而不是 'equals()' 进行对象比较"
                },
                "fullDescription": {
                  "text": "报告使用 '==' 或 '!=' 而不是 'equals()' 测试对象相等性的代码。 使用 '==' 或 '!=' 比较对象通常是 bug，因为它不是通过相等性而是通过同一性来比较对象。 不报告与 'null' 的比较。 数组、'String' 和 'Number' 比较由单独的检查报告。 示例： 'if (list1 == list2) {\n    return;\n  }' 在应用快速修复后： 'if (Objects.equals(list1, list2)) {\n    return;\n  }' 使用检查设置为此检查配置异常。",
                  "markdown": "报告使用 `==` 或 `!=` 而不是 `equals()` 测试对象相等性的代码。\n\n\n使用 `==` 或 `!=` 比较对象通常是 bug，因为它不是通过相等性而是通过同一性来比较对象。\n不报告与 `null` 的比较。\n\n\n数组、`String` 和 `Number` 比较由单独的检查报告。\n\n**示例：**\n\n      if (list1 == list2) {\n        return;\n      }\n\n在应用快速修复后：\n\n      if (Objects.equals(list1, list2)) {\n        return;\n      }\n\n使用检查设置为此检查配置异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectEquality",
                    "cweIds": [
                      480
                    ],
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TimeToString",
                "shortDescription": {
                  "text": "调用 'Time.toString()'"
                },
                "fullDescription": {
                  "text": "报告 'java.sql.Time' 对象上的 'toString()' 调用。 在国际化环境中，此类调用通常是不正确的。",
                  "markdown": "报告 `java.sql.Time` 对象上的 `toString()` 调用。 在国际化环境中，此类调用通常是不正确的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToTimeToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateThrows",
                "shortDescription": {
                  "text": "重复抛出"
                },
                "fullDescription": {
                  "text": "报告方法 'throws' 列表中的重复异常。 示例： 'void f() throws Exception, Exception {}' 在应用快速修复后： 'void f() throws Exception {}' 使用忽略子类化其他异常的异常选项可以忽略子类化其他异常的异常。",
                  "markdown": "报告方法 `throws` 列表中的重复异常。\n\n示例：\n\n\n      void f() throws Exception, Exception {}\n\n在应用快速修复后：\n\n\n      void f() throws Exception {}\n\n\n使用**忽略子类化其他异常的异常**选项可以忽略子类化其他异常的异常。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateThrows",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnstableTypeUsedInSignature",
                "shortDescription": {
                  "text": "签名中使用了不稳定的类型"
                },
                "fullDescription": {
                  "text": "报告在签名中引用不稳定 API 类型，但没有使用相同的不稳定注解进行标记的类、方法和字段的声明。 此检查可以确保公共 API 的签名不会公开任何不稳定（内部、实验性）类型。 例如，如果方法返回实验性类，则会将该方法视为实验性方法， 因为对类型的不兼容更改（删除或移到另一个软件包）会导致不兼容的方法签名更改。 使用下面的列表可以指定标记不稳定 API 的注解。",
                  "markdown": "报告在签名中引用不稳定 API 类型，但没有使用相同的不稳定注解进行标记的类、方法和字段的声明。\n\n\n此检查可以确保公共 API 的签名不会公开任何*不稳定* （内部、实验性）类型。\n例如，如果方法返回*实验性* 类，则会将该方法视为*实验性*方法，\n因为对类型的不兼容更改（删除或移到另一个软件包）会导致不兼容的方法签名更改。\n\n使用下面的列表可以指定标记不稳定 API 的注解。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnstableTypeUsedInSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PrivateMemberAccessBetweenOuterAndInnerClass",
                "shortDescription": {
                  "text": "合成访问器调用"
                },
                "fullDescription": {
                  "text": "报告从嵌套类到外部类的非常量 'private' 成员的引用。 对于此类引用，javac 将生成 package-private 合成访问器方法，这可能会危及安全性，因为看似为 private 的成员实际上可以从整个软件包中访问。 嵌套类及其外部类会被编译为单独的类文件。 Java 虚拟机通常会禁止从一个类访问另一个类的 private 字段和方法。 为了实现从嵌套类访问外部类的 private 成员，javac 创建了一个 package-private 合成访问器方法。 通过将 'private' 成员设为 package-private，实际的可访问性变成了显式。 这也会节省少量内存，可能会在资源受限的环境中提高性能。 仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。 在 Java 11 和更高版本中，由于基于嵌套的访问控制 (JEP 181)，不再生成访问器方法。 示例： 'class Outer {\n    private void x() {}\n\n    class Inner {\n      void y() {\n        x();\n      }\n    }\n  }' 在应用快速修复后： 'class Outer {\n    void x() {}\n\n    class Inner {\n      void y() {\n        x();\n      }\n    }\n  }'",
                  "markdown": "报告从嵌套类到外部类的非常量 `private` 成员的引用。 对于此类引用，javac 将生成 package-private 合成访问器方法，这可能会危及安全性，因为看似为 private 的成员实际上可以从整个软件包中访问。\n\n\n嵌套类及其外部类会被编译为单独的类文件。 Java 虚拟机通常会禁止从一个类访问另一个类的 private 字段和方法。 为了实现从嵌套类访问外部类的 private 成员，javac 创建了一个 package-private 合成访问器方法。\n\n\n通过将 `private` 成员设为 package-private，实际的可访问性变成了显式。\n这也会节省少量内存，可能会在资源受限的环境中提高性能。\n\n\n仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。\n在 Java 11 和更高版本中，由于基于嵌套的访问控制 ([JEP 181](https://openjdk.org/jeps/181))，不再生成访问器方法。\n\n**示例：**\n\n\n      class Outer {\n        private void x() {}\n\n        class Inner {\n          void y() {\n            x();\n          }\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Outer {\n        void x() {}\n\n        class Inner {\n          void y() {\n            x();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SyntheticAccessorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemRunFinalizersOnExit",
                "shortDescription": {
                  "text": "调用 'System.runFinalizersOnExit()'"
                },
                "fullDescription": {
                  "text": "报告对 'System.runFinalizersOnExit()' 的调用。 此调用是 Java 语言中最危险的调用之一。 它本质上为非线程安全，可能导致数据损坏、死锁，并可能影响远离调用点的程序部分。 在 JDK 11 中已被弃用并移除，强烈建议不要使用。 仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。",
                  "markdown": "报告对 `System.runFinalizersOnExit()` 的调用。\n\n\n此调用是 Java 语言中最危险的调用之一。 它本质上为非线程安全，可能导致数据损坏、死锁，并可能影响远离调用点的程序部分。\n在 JDK 11 中已被弃用并移除，强烈建议不要使用。\n\n仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemRunFinalizersOnExit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassIndependentOfModule",
                "shortDescription": {
                  "text": "独立于其模块的类"
                },
                "fullDescription": {
                  "text": "报告符合以下情况的类： 不依赖于其模块中的任何其他类 不是其模块中任何其他类的依赖项 这种类表示临时或不连贯的模块化策略，并且通常可以有利地移动。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告符合以下情况的类：\n\n* 不依赖于其模块中的任何其他类\n* 不是其模块中任何其他类的依赖项\n\n这种类表示临时或不连贯的模块化策略，并且通常可以有利地移动。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassIndependentOfModule",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternVariablesCanBeReplacedWithCast",
                "shortDescription": {
                  "text": "将 'instanceof' 与模式一起使用"
                },
                "fullDescription": {
                  "text": "报告带模式的 'instanceof'，并建议将其转换为带转换的普通 'instanceof'。 通过应用快速修复，此检查可以将带模式的 'instanceof' 移到使用早期 Java 版本的代码库。 请注意，在 'instanceof' 前面使用复杂表达式时，结果不能完全等同于带模式的原始 'instanceof'。 在这种情况下，将对该表达式重新求值。 示例： 'if (object instanceof String txt && txt.length() == 1) {\n      System.out.println(txt);\n  } else {\n      return;\n  }\n  System.out.println(txt);' 在应用快速修复后： 'if (object instanceof String && ((String) object).length() ==1) {\n      String txt = (String) object;\n      System.out.println(txt);\n  } else {\n      return;\n  }\n  String txt = (String) object;\n  System.out.println(txt);' 2023.1 最新变化",
                  "markdown": "报告带模式的 `instanceof`，并建议将其转换为带转换的普通 `instanceof`。\n\n通过应用快速修复，此检查可以将带模式的 `instanceof` 移到使用早期 Java 版本的代码库。\n\n\n请注意，在 `instanceof` 前面使用复杂表达式时，结果不能完全等同于带模式的原始 `instanceof`。 在这种情况下，将对该表达式重新求值。\n\n示例：\n\n\n      if (object instanceof String txt && txt.length() == 1) {\n          System.out.println(txt);\n      } else {\n          return;\n      }\n      System.out.println(txt);\n\n在应用快速修复后：\n\n\n      if (object instanceof String && ((String) object).length() ==1) {\n          String txt = (String) object;\n          System.out.println(txt);\n      } else {\n          return;\n      }\n      String txt = (String) object;\n      System.out.println(txt);\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PatternVariablesCanBeReplacedWithCast",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceInefficientStreamCount",
                "shortDescription": {
                  "text": "以 count() 结尾的低效 Stream API 调用链"
                },
                "fullDescription": {
                  "text": "报告可以优化并且以 'count()' 运算结束的 Stream API 调用链。 以下调用链可以替换为此检查： 'Collection.stream().count()' → 'Collection.size()'. 在 Java 8 中，'Collection.stream().count()' 实际上是通过迭代集合元素来进行计数，而 'Collection.size()' 对于大多数集合来说速度要快得多。 'Stream.flatMap(Collection::stream).count()' → 'Stream.mapToLong(Collection::size).sum()'. 同样，不需要遍历所有嵌套集合。 相反，它们的大小可以相加。 'Stream.filter(o -> ...).count() > 0' → 'Stream.anyMatch(o -> ...)'. 与初始调用不同，一旦找到匹配元素后 'anyMatch()' 就可以立即停止计算。 'Stream.filter(o -> ...).count() == 0' → 'Stream.noneMatch(o -> ...)'. 与以上相似。 请注意，如果替换涉及 'anyMatch()' 等短路操作，那么中间流操作产生副作用时，可能会出现明显的行为变化。 在 Stream API 调用中通常应避免副作用。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以优化并且以 `count()` 运算结束的 Stream API 调用链。\n\n\n以下调用链可以替换为此检查：\n\n* `Collection.stream().count()` → `Collection.size()`. 在 Java 8 中，`Collection.stream().count()` 实际上是通过迭代集合元素来进行计数，而 `Collection.size()` 对于大多数集合来说速度要快得多。\n* `Stream.flatMap(Collection::stream).count()` → `Stream.mapToLong(Collection::size).sum()`. 同样，不需要遍历所有嵌套集合。 相反，它们的大小可以相加。\n* `Stream.filter(o -> ...).count() > 0` → `Stream.anyMatch(o -> ...)`. 与初始调用不同，一旦找到匹配元素后 `anyMatch()` 就可以立即停止计算。\n* `Stream.filter(o -> ...).count() == 0` → `Stream.noneMatch(o -> ...)`. 与以上相似。\n\n\n请注意，如果替换涉及 `anyMatch()` 等短路操作，那么中间流操作产生副作用时，可能会出现明显的行为变化。 在 Stream API 调用中通常应避免副作用。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceInefficientStreamCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterTypePreventsOverriding",
                "shortDescription": {
                  "text": "形参类型阻止重写"
                },
                "fullDescription": {
                  "text": "报告与相应 super 方法的形参类型同名但属于不同软件包的子类方法的形参类型。 在这些情况下，子类方法不能重写 super 方法。 示例： 'public class A {\n public void method(Object o) {}\n}\n\npublic class B extends A {\n public void method(Object o) {} // 对形参类型发出警告\n class Object {}\n}' 在应用快速修复后： 'public class A {\n public void method(Object o) {}\n}\n\npublic class B extends A {\n public void method(java.lang.Object o) {} // 新形参类型\n class Object {}\n}'",
                  "markdown": "报告与相应 super 方法的形参类型同名但属于不同软件包的子类方法的形参类型。 在这些情况下，子类方法不能重写 super 方法。\n\n**示例：**\n\n\n    public class A {\n     public void method(Object o) {}\n    }\n\n    public class B extends A {\n     public void method(Object o) {} // 对形参类型发出警告\n     class Object {}\n    }\n\n在应用快速修复后：\n\n\n    public class A {\n     public void method(Object o) {}\n    }\n\n    public class B extends A {\n     public void method(java.lang.Object o) {} // 新形参类型\n     class Object {}\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterTypePreventsOverriding",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ManualArrayToCollectionCopy",
                "shortDescription": {
                  "text": "手动数组到集合复制"
                },
                "fullDescription": {
                  "text": "报告使用循环将数组内容复制到集合中的代码。 一种更短并且有可能更快（取决于集合实现）的方法是使用 'Collection.addAll(Arrays.asList())' 或 'Collections.addAll()'。 仅报告内部没有附加语句的循环。 示例： 'void addAll(List<String> list, String[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n      String s = arr[i];\n      list.add(s);\n    }\n  }' 在应用快速修复后： 'void addAll(List<String> list, String[] arr) {\n    Collections.addAll(list, arr);\n  }'",
                  "markdown": "报告使用循环将数组内容复制到集合中的代码。\n\n\n一种更短并且有可能更快（取决于集合实现）的方法是使用 `Collection.addAll(Arrays.asList())` 或 `Collections.addAll()`。\n\n\n仅报告内部没有附加语句的循环。\n\n**示例：**\n\n\n      void addAll(List<String> list, String[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n          String s = arr[i];\n          list.add(s);\n        }\n      }\n\n在应用快速修复后：\n\n\n      void addAll(List<String> list, String[] arr) {\n        Collections.addAll(list, arr);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ManualArrayToCollectionCopy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchLabeledRuleCanBeCodeBlock",
                "shortDescription": {
                  "text": "标记的 switch 规则可以具有代码块"
                },
                "fullDescription": {
                  "text": "报告 'switch' 表达式或带有表达式体的增强 'switch' 语句的规则。 这些可以转换为代码块。 示例： 'String message = switch (errorCode) {\n    case 404 -> \"Not found!\";\n    ...\n  };' 在应用快速修复后： 'String message = switch (errorCode) {\n    case 404 -> {\n                yield \"Not found!\";\n            }\n    ...\n  };' 2019.1 最新变化 此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。",
                  "markdown": "报告 `switch` 表达式或带有表达式体的增强 `switch` 语句的规则。 这些可以转换为代码块。\n\n示例：\n\n\n      String message = switch (errorCode) {\n        case 404 -> \"Not found!\";\n        ...\n      };\n\n在应用快速修复后：\n\n\n      String message = switch (errorCode) {\n        case 404 -> {\n                    yield \"Not found!\";\n                }\n        ...\n      };\n\n2019.1 最新变化\n\n此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SwitchLabeledRuleCanBeCodeBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtractMethodRecommender",
                "shortDescription": {
                  "text": "方法可以提取"
                },
                "fullDescription": {
                  "text": "建议将代码段提取到单独的方法中，以使代码更加清晰。 此检查有许多启发来选择好的提取候选项，包括以下几个。 提取的片段没有非本地控制流 提取的片段有且只有一个输出变量 在提取的片段内部和外部没有使用类似的输出变量 提取的片段只有很少的输入形参（默认情况下不超过三个；通过检查选项配置） 提取的片段不小于配置的长度（默认为 500 个字符），但不大于所包含方法体的 60%",
                  "markdown": "建议将代码段提取到单独的方法中，以使代码更加清晰。 此检查有许多启发来选择好的提取候选项，包括以下几个。\n\n* 提取的片段没有非本地控制流\n* 提取的片段有且只有一个输出变量\n* 在提取的片段内部和外部没有使用类似的输出变量\n* 提取的片段只有很少的输入形参（默认情况下不超过三个；通过检查选项配置）\n* 提取的片段不小于配置的长度（默认为 500 个字符），但不大于所包含方法体的 60%"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExtractMethodRecommender",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringOperationCanBeSimplified",
                "shortDescription": {
                  "text": "冗余的 'String' 操作"
                },
                "fullDescription": {
                  "text": "报告对 'toString()' 或 'substring()' 等可被替换为更简单表达式的 'String' 构造函数和方法的冗余调用。 例如，在 '\"string\".substring(0)'、'\"string\".toString()' 或 'new StringBuilder().toString().substring(1,3)' 等代码中，可以安全移除对这些方法的调用。 示例： 'System.out.println(new String(\"message\"));' 在应用快速修复后： 'System.out.println(\"message\");' 请注意，该快速修复会移除冗余的构造函数调用，这可能会影响 'String' 引用相等。 即使被认为是一种不好的做法，如果您仍需要保留，请禁止警告或使用检查设置来忽略冗余的 'String' 构造函数调用。 使用下方的不报告 String 构造函数调用选项可以不报告如上例所示的代码。 这将避免在使用 'new String()' 调用保证不同对象相等性的代码中应用快速修复后改变与 '==' 或 '!=' 进行字符串比较的结果。 使用下方的不报告单实参 substring() 调用选项可以不报告如下所示的代码。 'stringBuilder.append(string.substring(5));' 可以替换为以下内容。 'stringBuilder.append(string, 5, string.length());' 2018.1 最新变化",
                  "markdown": "报告对 `toString()` 或 `substring()` 等可被替换为更简单表达式的 `String` 构造函数和方法的冗余调用。\n\n例如，在 `\"string\".substring(0)`、`\"string\".toString()` 或\n`new StringBuilder().toString().substring(1,3)` 等代码中，可以安全移除对这些方法的调用。\n\n示例：\n\n\n      System.out.println(new String(\"message\"));\n\n在应用快速修复后：\n\n\n      System.out.println(\"message\");\n\n\n请注意，该快速修复会移除冗余的构造函数调用，这可能会影响 `String` 引用相等。\n即使被认为是一种不好的做法，如果您仍需要保留，请禁止警告或使用检查设置来忽略冗余的 `String` 构造函数调用。\n\n\n使用下方的**不报告 String 构造函数调用** 选项可以不报告如上例所示的代码。\n这将避免在使用 `new String()` 调用保证不同对象相等性的代码中应用快速修复后改变与 `==` 或 `!=` 进行字符串比较的结果。\n\n\n使用下方的**不报告单实参 substring() 调用**选项可以不报告如下所示的代码。\n\n\n      stringBuilder.append(string.substring(5));\n\n可以替换为以下内容。\n\n\n      stringBuilder.append(string, 5, string.length());\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringOperationCanBeSimplified",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassReferencesSubclass",
                "shortDescription": {
                  "text": "类引用其子类之一"
                },
                "fullDescription": {
                  "text": "报告包含对其中一个子类进行了引用的类。 此类引用可能令人困惑，并违反面向对象设计的多条规则。 示例： 'class Entity {\n    // 警告：该类引用了其子类\n    void compare(SimpleEntity entity) {\n      ...\n    }\n  }\n  class SimpleEntity extends Entity {\n    ...\n  }'",
                  "markdown": "报告包含对其中一个子类进行了引用的类。 此类引用可能令人困惑，并违反面向对象设计的多条规则。\n\n示例：\n\n\n      class Entity {\n        // 警告：该类引用了其子类\n        void compare(SimpleEntity entity) {\n          ...\n        }\n      }\n      class SimpleEntity extends Entity {\n        ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassReferencesSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaReflectionMemberAccess",
                "shortDescription": {
                  "text": "对不存在或不可见的类成员的反射访问"
                },
                "fullDescription": {
                  "text": "报告对不存在或不可见的字段和方法的反射访问。 示例： 'Field stringHashField() throws NoSuchFieldException {\n    return String.class.getField(\"hash\");\n  }' 在应用快速修复后： 'Field stringHashField() throws NoSuchFieldException {\n    return String.class.getDeclaredField(\"hash\");\n  }' 对于 'final' 类，很清楚该类中是否存在具有指定名称的字段或方法。 对于非 'final' 类，子类中可能有使用该名称的字段或方法，因此可能会出现误报。 使用该项检查的设置，可消除任何位置或特定类的此类误报。 2017.2 最新变化",
                  "markdown": "报告对不存在或不可见的字段和方法的反射访问。\n\n示例：\n\n\n      Field stringHashField() throws NoSuchFieldException {\n        return String.class.getField(\"hash\");\n      }\n\n在应用快速修复后：\n\n\n      Field stringHashField() throws NoSuchFieldException {\n        return String.class.getDeclaredField(\"hash\");\n      }\n\n\n对于 `final` 类，很清楚该类中是否存在具有指定名称的字段或方法。\n\n\n对于非 `final` 类，子类中可能有使用该名称的字段或方法，因此可能会出现误报。\n使用该项检查的设置，可消除任何位置或特定类的此类误报。\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaReflectionMemberAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/反射访问",
                      "index": 99,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObviousNullCheck",
                "shortDescription": {
                  "text": "使用明显非 null 实参调用 null 检查方法"
                },
                "fullDescription": {
                  "text": "报告是否在明显为非 null 的值（例如，新创建的对象）上调用 null 检查方法（例如，'Objects.requireNonNull' 或 'Assert.assertNotNull'）。 这种检查是冗余的，可能表明存在编程错误。 示例： 'final String greeting = Objects.requireNonNull(\"Hi!\");' 在应用快速修复后： 'final String greeting = \"Hi!\";' 2017.2 最新变化",
                  "markdown": "报告是否在明显为非 null 的值（例如，新创建的对象）上调用 null 检查方法（例如，`Objects.requireNonNull` 或 `Assert.assertNotNull`）。 这种检查是冗余的，可能表明存在编程错误。\n\n**示例：**\n\n\n      final String greeting = Objects.requireNonNull(\"Hi!\");\n\n在应用快速修复后：\n\n\n      final String greeting = \"Hi!\";\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObviousNullCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerialVersionUIDNotStaticFinal",
                "shortDescription": {
                  "text": "'serialVersionUID' 字段未被声明为 'private static final long'"
                },
                "fullDescription": {
                  "text": "报告 'serialVersionUID' 字段未被声明为 'private static final long' 的 'Serializable' 类。 示例： 'class SampleClass implements Serializable {\n    private long serialVersionUID = 1; // Serializable 类的字段未声明为 'private static final long'\n\n    public SampleClass() {\n        System.out.println(serialVersionUID);\n    }\n  }'",
                  "markdown": "报告 `serialVersionUID` 字段未被声明为 `private static final long` 的 `Serializable` 类。\n\n**示例：**\n\n\n      class SampleClass implements Serializable {\n        private long serialVersionUID = 1; // Serializable 类的字段未声明为 'private static final long'\n\n        public SampleClass() {\n            System.out.println(serialVersionUID);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerialVersionUIDWithWrongSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassOnInterface",
                "shortDescription": {
                  "text": "接口的内部类"
                },
                "fullDescription": {
                  "text": "报告 'interface' 类中的内部类。 有些编码标准不建议使用这种类。 该检查不报告枚举类和注解接口。 使用忽略接口的内部接口选项，可以忽略内部接口。 示例： 'interface I {\n    interface Inner {\n    }\n  }'",
                  "markdown": "报告 `interface` 类中的内部类。\n\n有些编码标准不建议使用这种类。 该检查不报告枚举类和注解接口。\n\n\n使用**忽略接口的内部接口**选项，可以忽略内部接口。 示例：\n\n\n      interface I {\n        interface Inner {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassOfInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DateToString",
                "shortDescription": {
                  "text": "调用 'Date.toString()'"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Date' 对象上的 'toString()' 调用。 在国际化环境中，此类调用通常是不正确的。",
                  "markdown": "报告 `java.util.Date` 对象上的 `toString()` 调用。 在国际化环境中，此类调用通常是不正确的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToDateToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IterableUsedAsVararg",
                "shortDescription": {
                  "text": "可迭代对象用作 vararg"
                },
                "fullDescription": {
                  "text": "报告 vararg 方法调用中 'Collection' 或 'Iterable' 的可疑用法。 例如，在以下方法中： '<T> boolean contains(T needle, T... haystack) {...}' 像下面这样的调用 'if(contains(\"item\", listOfStrings)) {...}' 看起来很可疑，因为列表将被包装成一个元素数组。 此类代码可以被成功编译并且很可能会无异常地运行，但它可能被错误地使用。 2019.2 最新变化 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告 vararg 方法调用中 `Collection` 或 `Iterable` 的可疑用法。\n\n例如，在以下方法中：\n\n\n      <T> boolean contains(T needle, T... haystack) {...}\n\n像下面这样的调用\n\n\n      if(contains(\"item\", listOfStrings)) {...}\n\n看起来很可疑，因为列表将被包装成一个元素数组。\n此类代码可以被成功编译并且很可能会无异常地运行，但它可能被错误地使用。\n\n2019.2 最新变化\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IterableUsedAsVararg",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodNameSameAsParentName",
                "shortDescription": {
                  "text": "方法名称与父类名相同"
                },
                "fullDescription": {
                  "text": "报告与此方法的类的超类同名的方法，因为此类方法名称可能令人困惑。 此检查不会检查层次结构深处的接口或超类。 示例： 'class Parent {}\n  class Child extends Parent {\n     public Parent Parent() {\n       return null;\n     }\n  }' 只能在编辑器中使用重命名此类方法的快速修复。",
                  "markdown": "报告与此方法的类的超类同名的方法，因为此类方法名称可能令人困惑。\n\n此检查不会检查层次结构深处的接口或超类。\n\n**示例：**\n\n\n      class Parent {}\n      class Child extends Parent {\n         public Parent Parent() {\n           return null;\n         }\n      }\n\n只能在编辑器中使用重命名此类方法的快速修复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodNameSameAsParentName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedLabel",
                "shortDescription": {
                  "text": "未使用的标签"
                },
                "fullDescription": {
                  "text": "报告不是任何 'break' 或 'continue' 语句目标的标签。 示例： 'label: for (int i = 0; i < 10; i++) {\n    if (i == 3) {\n      break;\n    }\n  }' 应用快速修复后，该标签将被移除： 'for (int i = 0; i < 10; i++) {\n    if (i == 3) {\n      break;\n    }\n  }'",
                  "markdown": "报告不是任何 `break` 或 `continue` 语句目标的标签。\n\n**示例：**\n\n\n      label: for (int i = 0; i < 10; i++) {\n        if (i == 3) {\n          break;\n        }\n      }\n\n应用快速修复后，该标签将被移除：\n\n\n      for (int i = 0; i < 10; i++) {\n        if (i == 3) {\n          break;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicFieldAccessedInSynchronizedContext",
                "shortDescription": {
                  "text": "在 'synchronized' 上下文中访问d了非 private 字段"
                },
                "fullDescription": {
                  "text": "报告在同步上下文中访问的非 'final'、非 'private' 字段。 不能保证始终以同步方式访问非 'private' 字段，此类“部分同步的”访问可能意外导致不一致的数据结构。 示例： 'class Bar {\n    public String field1;\n  }\n  public Bar myBar;\n\n  synchronized public void sample() {\n   myBar.field1 = \"bar\";\n  }'",
                  "markdown": "报告在同步上下文中访问的非 `final`、非 `private` 字段。\n\n\n不能保证始终以同步方式访问非 `private` 字段，此类\"部分同步的\"访问可能意外导致不一致的数据结构。\n\n**示例：**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonPrivateFieldAccessedInSynchronizedContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForeachStatement",
                "shortDescription": {
                  "text": "增强的 'for' 语句"
                },
                "fullDescription": {
                  "text": "报告增强型 'for' 语句。 示例： 'for (int x: Arrays.asList(1, 2, 3)) {\n    System.out.println(x);\n  }' 在应用快速修复后： 'for (Iterator<Integer> iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {\n    final int x = iterator.next();\n    System.out.println(x);\n  }' 增强型 'for' 语句在 Java 5 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告增强型 `for` 语句。\n\n示例：\n\n\n      for (int x: Arrays.asList(1, 2, 3)) {\n        System.out.println(x);\n      }\n\n在应用快速修复后：\n\n\n      for (Iterator<Integer> iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {\n        final int x = iterator.next();\n        System.out.println(x);\n      }\n\n\n*增强型* `for` *语句*在 Java 5 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForeachStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaParameterNamingConvention",
                "shortDescription": {
                  "text": "lambda 形参命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的 lambda 形参。 示例：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告 'Function<String, String> id = X -> X;'。 配置检查： 使用选项部分中的字段可指定 lambda 形参名称的最小长度、最大长度以及预期的正则表达式。 指定 0 以便不检查名称的长度。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的 lambda 形参。\n\n**示例** ：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告 `Function<String, String> id = X -> X;`。\n\n配置检查：\n\n\n使用**选项** 部分中的字段可指定 lambda 形参名称的最小长度、最大长度以及预期的正则表达式。\n指定 **0** 以便不检查名称的长度。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LambdaParameterNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LawOfDemeter",
                "shortDescription": {
                  "text": "迪米特法则"
                },
                "fullDescription": {
                  "text": "报告违反迪米特法则的情况。 迪米特法则并非真正的法则，但它指定了一种样式准则：绝不调用从另一个调用中获取的对象的方法。 遵循此准则的代码更容易维护、调整和重构，方法之间的耦合更少，重复更少，信息隐藏得更好。 另一方面，您可能需要编写许多包装器方法才能满足这一准则。 示例： 'boolean pay(Customer c, Invoice invoice) {\n    int dollars = c.getWallet().contents; // 违规\n    if (dollars >= invoice.getAmount()) {\n      Wallet w = c.getWallet();\n      w.subtract(invoice.getAmount()); // 违规\n      return true;\n    }\n    return false;\n  }' 上面的示例可以更好地实现为 'Customer' 中的 'payInvoice(Invoice invoice)' 方法。 使用忽略对库方法的调用和对库字段的访问选项可以忽略不更改库就无法修正的违反迪米特法则的情况。",
                  "markdown": "报告违反[迪米特法则](https://en.wikipedia.org/wiki/Law_of_Demeter)的情况。\n\n\n迪米特法则并非真正的法则，但它指定了一种样式准则：绝不调用从另一个调用中获取的对象的方法。\n遵循此准则的代码更容易维护、调整和重构，方法之间的耦合更少，重复更少，信息隐藏得更好。 另一方面，您可能需要编写许多包装器方法才能满足这一准则。\n\n**示例：**\n\n\n      boolean pay(Customer c, Invoice invoice) {\n        int dollars = c.getWallet().contents; // 违规\n        if (dollars >= invoice.getAmount()) {\n          Wallet w = c.getWallet();\n          w.subtract(invoice.getAmount()); // 违规\n          return true;\n        }\n        return false;\n      }\n\n上面的示例可以更好地实现为 `Customer` 中的 `payInvoice(Invoice invoice)` 方法。\n\n\n使用**忽略对库方法的调用和对库字段的访问**选项可以忽略不更改库就无法修正的违反迪米特法则的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LawOfDemeter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalUsedAsFieldOrParameterType",
                "shortDescription": {
                  "text": "用作字段或形参类型的 'Optional'"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Optional<T>'、'java.util.OptionalDouble'、'java.util.OptionalInt'、'java.util.OptionalLong' 或 'com.google.common.base.Optional' 用为字段或形参的类型的任何情况。 'Optional' 设计为在需要一个明确的方式来表示 \"没有结果\"的情况下，为库方法的返回类型提供有限的机制。 如果类需要 'Serializable'，则使用 'java.util.Optional' 类型的字段也有问题，因为 'java.util.Optional' 不可序列化。 示例： 'class MyClass {\n    Optional<String> name; // Optional 字段\n\n    // Optional 形参\n    void setName(Optional<String> name) {\n      this.name = name;\n    }\n  }'",
                  "markdown": "报告 `java.util.Optional<T>`、`java.util.OptionalDouble`、`java.util.OptionalInt`、`java.util.OptionalLong` 或 `com.google.common.base.Optional` 用为字段或形参的类型的任何情况。\n\n`Optional` 设计为在需要一个明确的方式来表示 \"没有结果\"的情况下，为库方法的返回类型提供有限的机制。\n\n如果类需要 `Serializable`，则使用 `java.util.Optional` 类型的字段也有问题，因为 `java.util.Optional` 不可序列化。\n\n示例：\n\n\n      class MyClass {\n        Optional<String> name; // Optional 字段\n\n        // Optional 形参\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalUsedAsFieldOrParameterType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAllDot",
                "shortDescription": {
                  "text": "可疑的正则表达式实参"
                },
                "fullDescription": {
                  "text": "报告对其中第一个实参为单一正则表达式元字符实参的 'String.replaceAll()' 或 'String.split()' 的调用。 正则表达式元字符为 '.$|()[{^?*+\\' 之一。 它们在正则表达式中有特殊的含义。 例如，调用 '\"ab.cd\".replaceAll(\".\", \"-\")' 将生成 '\"-----\"'，因为点匹配任意字符。 很可能本意是转义变体 '\"\\\\.\"'。 还报告了将 'File.separator' 用作正则表达式的情况。 'File.separator' 具有平台特定的值。 它在 Linux 和 Mac 上等于 '/'，而在 Windows 上等于 '\\'，这不是一个有效的正则表达式，因此这样的代码无法移植。 示例： 's.replaceAll(\".\", \"-\");' 在应用快速修复后： 's.replaceAll(\"\\\\.\", \"-\");'",
                  "markdown": "报告对其中第一个实参为单一正则表达式元字符实参的 `String.replaceAll()` 或 `String.split()` 的调用。\n\n\n正则表达式元字符为 `.$|()[{^?*+\\` 之一。 它们在正则表达式中有特殊的含义。\n例如，调用 `\"ab.cd\".replaceAll(\".\", \"-\")` 将生成 `\"-----\"`，因为点匹配任意字符。\n很可能本意是转义变体 `\"\\\\.\"`。\n\n\n还报告了将 `File.separator` 用作正则表达式的情况。 `File.separator` 具有平台特定的值。 它在 Linux 和 Mac 上等于 `/`，而在 Windows 上等于 `\\`，这不是一个有效的正则表达式，因此这样的代码无法移植。\n\n**示例：**\n\n\n      s.replaceAll(\".\", \"-\");\n\n在应用快速修复后：\n\n\n      s.replaceAll(\"\\\\.\", \"-\");\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousRegexArgument",
                    "cweIds": [
                      20,
                      185,
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForCanBeForeach",
                "shortDescription": {
                  "text": "'for' 循环可被替换为增强的 for 循环"
                },
                "fullDescription": {
                  "text": "报告迭代集合或数组并且可以自动替换为增强型 'for' 循环（foreach 迭代语法）的 'for' 循环。 示例： 'for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {\n    String item = iterator.next();\n    System.out.println(item);\n  }' 在应用快速修复后： 'for (String item : list) {\n    System.out.println(item);\n  }' 使用报告索引的 'java.util.List' 循环选项可查找涉及 'list.get(index)' 调用的循环。 这些循环通常可以替换为增强型 'for' 循环，除非它们修改了进程中的基础列表，例如通过调用 'list.remove(index)' 进行修改。 如果是后面这种情况，增强型 'for' 循环可能抛出 'ConcurrentModificationException'。 在某些情况下，'list.get(index)' 循环的操作速度也可能更快一些。 使用不报告无类型集合上的迭代选项可忽略没有类型形参的集合。 这将防止创建 'java.lang.Object' 类型的增强型 'for' 循环变量以及在使用循环变量的位置插入转换。 此检查取决于 Java 功能 'For-each 循环'，该功能自 Java 5 起可用。",
                  "markdown": "报告迭代集合或数组并且可以自动替换为增强型 `for` 循环（foreach 迭代语法）的 `for` 循环。\n\n**示例：**\n\n\n      for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {\n        String item = iterator.next();\n        System.out.println(item);\n      }\n\n在应用快速修复后：\n\n\n      for (String item : list) {\n        System.out.println(item);\n      }\n\n\n使用**报告索引的 'java.util.List' 循环** 选项可查找涉及 `list.get(index)` 调用的循环。\n这些循环通常可以替换为增强型 `for` 循环，除非它们修改了进程中的基础列表，例如通过调用 `list.remove(index)` 进行修改。\n如果是后面这种情况，增强型 `for` 循环可能抛出 `ConcurrentModificationException`。\n在某些情况下，`list.get(index)` 循环的操作速度也可能更快一些。\n\n\n使用**不报告无类型集合上的迭代** 选项可忽略没有类型形参的集合。\n这将防止创建 `java.lang.Object` 类型的增强型 `for` 循环变量以及在使用循环变量的位置插入转换。\n\n此检查取决于 Java 功能 'For-each 循环'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopReplaceableByForEach",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousFieldAccess",
                "shortDescription": {
                  "text": "对继承字段的访问类似于对周围代码中元素的访问"
                },
                "fullDescription": {
                  "text": "如果在类周围的代码中存在同名的局部变量、形参或字段，则报告从匿名类、内部类或局部类对超类字段的访问。 在这种情况下，看似访问了来自周围代码的元素，而实际上访问的是来自超类的字段。 为阐明代码的意图，建议对字段访问添加显式 'super' 限定符。 示例： 'class First {\n      protected String ambiguous;\n    }\n    class Second {\n      void foo(String ambiguous) {\n        new First() {\n          {\n            System.out.println(ambiguous); // 访问的是字段，而不是形参\n          }\n        };\n      }\n    }' 在应用快速修复后： 'class First {\n      protected String ambiguous;\n    }\n    class Second {\n      void foo(String ambiguous) {\n        new First() {\n          {\n            System.out.println(super.ambiguous);\n          }\n        };\n      }\n    }'",
                  "markdown": "如果在类周围的代码中存在同名的局部变量、形参或字段，则报告从匿名类、内部类或局部类对超类字段的访问。 在这种情况下，看似访问了来自周围代码的元素，而实际上访问的是来自超类的字段。\n\n\n为阐明代码的意图，建议对字段访问添加显式 `super` 限定符。\n\n**示例：**\n\n\n        class First {\n          protected String ambiguous;\n        }\n        class Second {\n          void foo(String ambiguous) {\n            new First() {\n              {\n                System.out.println(ambiguous); // 访问的是字段，而不是形参\n              }\n            };\n          }\n        }\n\n在应用快速修复后：\n\n\n        class First {\n          protected String ambiguous;\n        }\n        class Second {\n          void foo(String ambiguous) {\n            new First() {\n              {\n                System.out.println(super.ambiguous);\n              }\n            };\n          }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AmbiguousFieldAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonProtectedConstructorInAbstractClass",
                "shortDescription": {
                  "text": "抽象类中的 public 构造函数"
                },
                "fullDescription": {
                  "text": "报告 'abstract' 类的 'public' 构造函数。 'abstract' 类的构造函数只能从其子类的构造函数进行调用，将其声明为 'public' 可能令人困惑。 该快速修复会将此类构造函数设为 protected。 示例： 'public abstract class Foo {\n    public Foo () { // 警告：有 'public' 修饰符\n        /* ... */\n    }\n  }' 在应用快速修复后： 'public abstract class Foo {\n    protected Foo () {\n        /* ... */\n    }\n  }' 配置检查： 使用下面的忽略非 public 类选项可以忽略非 public 类中的 'public' 构造函数。",
                  "markdown": "报告 `abstract` 类的 `public` 构造函数。\n\n\n`abstract` 类的构造函数只能从其子类的构造函数进行调用，将其声明为 `public` 可能令人困惑。\n\n该快速修复会将此类构造函数设为 protected。\n\n**示例：**\n\n\n      public abstract class Foo {\n        public Foo () { // 警告：有 'public' 修饰符\n            /* ... */\n        }\n      }\n\n在应用快速修复后：\n\n\n      public abstract class Foo {\n        protected Foo () {\n            /* ... */\n        }\n      }\n\n配置检查：\n\n使用下面的**忽略非 public 类** 选项可以忽略非 public 类中的 `public` 构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstructorNotProtectedInAbstractClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparableImplementedButEqualsNotOverridden",
                "shortDescription": {
                  "text": "已实现 'Comparable'，但 'equals()' 未被重写"
                },
                "fullDescription": {
                  "text": "报告实现 'java.lang.Comparable' 但不重写 'equals()' 的类。 如果未重写 'equals()'，'equals()' 实现与 'compareTo()' 实现将不一致。 如果将这种类的对象添加到 'java.util.SortedSet' 等集合，该集合将违反根据 'equals()' 定义的 'java.util.Set' 的约定。 示例： 'class Length implements Comparable<Length> {\n    private int cm = 0;\n\n    @Override\n    public int compareTo(@NotNull Length o) {\n      if (cm == o.cm) return 0;\n      return cm < o.cm ? -1 : 1;\n    }\n  }' 在应用快速修复后： 'class Length implements Comparable<Length> {\n    private int cm = 0;\n\n    @Override\n    public int compareTo(@NotNull Length o) {\n      if (cm == o.cm) return 0;\n      return cm < o.cm ? -1 : 1;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      return o instanceof Length && compareTo((Length) o) == 0;\n    }\n  }'",
                  "markdown": "报告实现 `java.lang.Comparable` 但不重写 `equals()` 的类。\n\n\n如果未重写 `equals()`，`equals()` 实现与 `compareTo()` 实现将不一致。 如果将这种类的对象添加到 `java.util.SortedSet` 等集合，该集合将违反根据 `equals()` 定义的 `java.util.Set` 的约定。\n\n**示例：**\n\n\n      class Length implements Comparable<Length> {\n        private int cm = 0;\n\n        @Override\n        public int compareTo(@NotNull Length o) {\n          if (cm == o.cm) return 0;\n          return cm < o.cm ? -1 : 1;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Length implements Comparable<Length> {\n        private int cm = 0;\n\n        @Override\n        public int compareTo(@NotNull Length o) {\n          if (cm == o.cm) return 0;\n          return cm < o.cm ? -1 : 1;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n          return o instanceof Length && compareTo((Length) o) == 0;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparableImplementedButEqualsNotOverridden",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageVisibleField",
                "shortDescription": {
                  "text": "软件包可见字段"
                },
                "fullDescription": {
                  "text": "报告在没有任何访问修饰符（也称为 package-private）的情况下声明的字段。 不报告常量（即标记为 'static' 和 'final' 的字段）。 示例： 'public class A {\n    Object object;             // 警告\n    final static int MODE = 0; // 常量，无警告\n  }'",
                  "markdown": "报告在没有任何访问修饰符（也称为 package-private）的情况下声明的字段。\n\n不报告常量（即标记为 `static` 和 `final` 的字段）。\n\n**示例：**\n\n\n      public class A {\n        Object object;             // 警告\n        final static int MODE = 0; // 常量，无警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageVisibleField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstantiationOfUtilityClass",
                "shortDescription": {
                  "text": "实用程序类的实例化"
                },
                "fullDescription": {
                  "text": "报告使用 'new' 关键字的实用程序类的实例化。 在实用程序类中，所有字段和方法均为 'static'。 这种类的实例化很可能不必要，并且表明存在错误。 示例： 'class MyUtils {\n    public static double cube(double x) {\n      return x * x * x;\n    }\n  }\n  class Main {\n    public static void main(String[] args) {\n      // 实用类的实例化\n      MyUtils utils = new MyUtils();\n    }\n  }' 为防止实用程序类被实例化，建议使用 'private' 构造函数。",
                  "markdown": "报告使用 `new` 关键字的实用程序类的实例化。\n\n\n在实用程序类中，所有字段和方法均为 `static`。\n这种类的实例化很可能不必要，并且表明存在错误。\n\n**示例：**\n\n\n      class MyUtils {\n        public static double cube(double x) {\n          return x * x * x;\n        }\n      }\n      class Main {\n        public static void main(String[] args) {\n          // 实用类的实例化\n          MyUtils utils = new MyUtils();\n        }\n      }\n\n\n为防止实用程序类被实例化，建议使用 `private` 构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstantiationOfUtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MapReplaceableByEnumMap",
                "shortDescription": {
                  "text": "'Map' 可被替换为 'EnumMap'"
                },
                "fullDescription": {
                  "text": "报告键类型为枚举类的 'java.util.Map' 对象的实例化。 此类 'java.util.Map' 对象可以替换为 'java.util.EnumMap' 对象。 'java.util.EnumMap' 实现可以更加高效，因为底层数据结构是简单的数组。 示例： 'Map<MyEnum, String> myEnums = new HashMap<>();' 在应用快速修复后： 'Map<MyEnum, String> myEnums = new EnumMap<>(MyEnum.class);'",
                  "markdown": "报告键类型为枚举类的 `java.util.Map` 对象的实例化。 此类 `java.util.Map` 对象可以替换为 `java.util.EnumMap` 对象。\n\n\n`java.util.EnumMap` 实现可以更加高效，因为底层数据结构是简单的数组。\n\n**示例：**\n\n\n      Map<MyEnum, String> myEnums = new HashMap<>();\n\n在应用快速修复后：\n\n\n      Map<MyEnum, String> myEnums = new EnumMap<>(MyEnum.class);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MapReplaceableByEnumMap",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrailingWhitespacesInTextBlock",
                "shortDescription": {
                  "text": "文本块中的尾随空格"
                },
                "fullDescription": {
                  "text": "报告带有尾随空格字符的文本块。 尾随空格被视为是附带的，将被 Java 编译器去除。 2021.1 最新变化 此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。",
                  "markdown": "报告带有尾随空格字符的文本块。 尾随空格被视为是附带的，将被 Java 编译器去除。\n\n2021.1 最新变化\n\n此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TrailingWhitespacesInTextBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnNull",
                "shortDescription": {
                  "text": "返回 'null'"
                },
                "fullDescription": {
                  "text": "报告返回值为 'null' 的 'return' 语句。 虽然偶尔有用，但此结构可能导致代码因更容易出现 'NullPointerException' 而失败。 如果方法设计为返回 'null'，建议使用 '@Nullable' 注解来标记 - 此类方法将被此检查忽略。 示例： 'class Person {\n    public String getName () {\n      return null;\n    }\n  }' 在应用快速修复后： 'class Person {\n    public @Nullable String getName () {\n      return null;\n    }\n  }' 如果返回类型为 'java.util.Optional'，建议使用另一个快速修复将 'null' 转换为 'Optional.empty()'。 使用以下选项配置检查： 是否忽略 'private' 方法。 这也将忽略从匿名类和 lambda 返回的 'null'。 应报告数组返回的 'null' 值、集合对象返回的值、普通对象返回的值还是三者的组合。 总是报告返回类型为 'java.util.Optional' 的方法中返回的 'null'。 点击配置注解以指定哪些注解应视为 'nullable'。",
                  "markdown": "报告返回值为 `null` 的 `return` 语句。 虽然偶尔有用，但此结构可能导致代码因更容易出现 `NullPointerException` 而失败。\n\n\n如果方法设计为返回 `null`，建议使用 `@Nullable` 注解来标记 - 此类方法将被此检查忽略。\n\n**示例：**\n\n\n      class Person {\n        public String getName () {\n          return null;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Person {\n        public @Nullable String getName () {\n          return null;\n        }\n      }\n\n\n如果返回类型为 `java.util.Optional`，建议使用另一个快速修复将 `null` 转换为 `Optional.empty()`。\n\n\n使用以下选项配置检查：\n\n* 是否忽略 `private` 方法。 这也将忽略从匿名类和 lambda 返回的 `null`。\n* 应报告数组返回的 `null` 值、集合对象返回的值、普通对象返回的值还是三者的组合。 总是报告返回类型为 `java.util.Optional` 的方法中返回的 `null`。\n* 点击**配置注解**以指定哪些注解应视为 'nullable'。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnOfNull",
                    "cweIds": [
                      252,
                      476
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug/为 null 性问题",
                      "index": 118,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewClassNamingConvention",
                "shortDescription": {
                  "text": "类命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的类。 示例：如果为测试启用了检查，并且指定的最小类名称长度为 8（默认值），因以下测试类的名称长度为 6，即小于 8，因此将生成警告：'public class MyTest{}'。 只能在编辑器中采用快速修复来重命名这种类。 配置检查： 使用选项部分中的列表来指定应检查哪些类。 取消选中要为之跳过检查的类对应的复选框。 对于类的每种类型，请使用所提供的输入字段指定类名应有的最小长度、最大长度和正则表达式。 在长度字段中指定 0 可跳过相应检查。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的类。\n\n**示例** ：如果为测试启用了检查，并且指定的最小类名称长度为 8（默认值），因以下测试类的名称长度为 6，即小于 8，因此将生成警告：`public class MyTest{}`。\n\n只能在编辑器中采用快速修复来重命名这种类。\n\n配置检查：\n\n\n使用**选项**部分中的列表来指定应检查哪些类。 取消选中要为之跳过检查的类对应的复选框。\n\n对于类的每种类型，请使用所提供的输入字段指定类名应有的最小长度、最大长度和正则表达式。 在长度字段中指定 **0** 可跳过相应检查。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewClassNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingStringTemplateAsArgument",
                "shortDescription": {
                  "text": "字符串模板作为日志记录调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作 SLF4J 和 Log4j 2 日志记录方法的实参的字符串模板。 方法 'org.apache.logging.log4j.Logger.log()' 及其重载仅支持所有日志级别选项。 即使在没有记录日志消息的情况下，也会在运行时评估字符串模板；这可能会对性能产生负面影响。 建议改用形参化日志消息，禁用日志记录时不会对其进行评估。 示例（针对 Kotlin）： 'val variable1 = getVariable()\n      logger.info(\"variable1: $variable1\")' 在应用快速修复之后（针对 Kotlin）： 'val variable1 = getVariable()\n      logger.info(\"variable1: {}\", variable1)' 请注意，建议的替换可能不等同于原始代码，例如，当字符串模板包含方法调用或赋值表达式时。 使用警告对象列表可以忽略某些更高的日志记录级别。 可以始终启用更高的日志记录级别，并且将始终对实参求值。 使用当仅包含具有基元类型的表达式、其包装器或字符串时不发出警告选项可以忽略仅包含具有基元类型、其包装器或字符串的表达式的字符串模板。 例如，它可能有助于防止加载延迟集合。 请注意，在运行时即使只使用具有基元类型、其包装器或字符串的表达式创建字符串，也会对性能产生负面影响。 使用当调用仅在消息实参之后以异常作为实参时不发出警告选项可以忽略仅在消息实参之后包含异常作为实参的调用。 例如，其在使用自定义代码样式调整检查的行为时可能很有用。 2023.1 最新变化",
                  "markdown": "报告用作 **SLF4J** 和 **Log4j 2** 日志记录方法的实参的字符串模板。 方法 `org.apache.logging.log4j.Logger.log()` 及其重载仅支持**所有日志级别** 选项。 即使在没有记录日志消息的情况下，也会在运行时评估字符串模板；这可能会对性能产生负面影响。 建议改用形参化日志消息，禁用日志记录时不会对其进行评估。\n\n**示例（针对 Kotlin）：**\n\n\n          val variable1 = getVariable()\n          logger.info(\"variable1: $variable1\")\n\n**在应用快速修复之后（针对 Kotlin）：**\n\n\n          val variable1 = getVariable()\n          logger.info(\"variable1: {}\", variable1)\n\n\n请注意，建议的替换可能不等同于原始代码，例如，当字符串模板包含方法调用或赋值表达式时。\n\n* 使用**警告对象**列表可以忽略某些更高的日志记录级别。 可以始终启用更高的日志记录级别，并且将始终对实参求值。\n* 使用**当仅包含具有基元类型的表达式、其包装器或字符串时不发出警告**选项可以忽略仅包含具有基元类型、其包装器或字符串的表达式的字符串模板。 例如，它可能有助于防止加载延迟集合。 请注意，在运行时即使只使用具有基元类型、其包装器或字符串的表达式创建字符串，也会对性能产生负面影响。\n* 使用**当调用仅在消息实参之后以异常作为实参时不发出警告**选项可以忽略仅在消息实参之后包含异常作为实参的调用。 例如，其在使用自定义代码样式调整检查的行为时可能很有用。\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggingStringTemplateAsArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnpredictableBigDecimalConstructorCall",
                "shortDescription": {
                  "text": "不可预知的 'BigDecimal' 构造函数调用"
                },
                "fullDescription": {
                  "text": "报告对接受 'double' 值的 'BigDecimal' 构造函数的调用。 这些构造函数生成正好等于提供的 'double' 值的 'BigDecimal'。 但是，由于 double 是以 IEEE 754 64 位双精度二进制浮点格式进行编码，确切值可能出乎意料。 例如，'new BigDecimal(0.1)' 会生成一个 'BigDecimal' 对象。 它的值为 '0.1000000000000000055511151231257827021181583404541015625'，这是最接近 0.1 的数字，可以表示为 double。 要获取存储的值与源代码中编写的值相同的 'BigDecimal'，请使用 'new BigDecimal(\"0.1\")' 或 'BigDecimal.valueOf(0.1)'。 示例： 'class Constructor {\n    void foo() {\n      new BigDecimal(0.1);\n    }\n  }' 在应用快速修复后： 'class Constructor {\n    void foo() {\n      new BigDecimal(\"0.1\");\n    }\n  }'",
                  "markdown": "报告对接受 `double` 值的 `BigDecimal` 构造函数的调用。 这些构造函数生成正好等于提供的 `double` 值的 `BigDecimal`。 但是，由于 double 是以 IEEE 754 64 位双精度二进制浮点格式进行编码，确切值可能出乎意料。\n\n例如，`new BigDecimal(0.1)` 会生成一个 `BigDecimal` 对象。 它的值为 `0.1000000000000000055511151231257827021181583404541015625`，这是最接近 0.1 的数字，可以表示为 double。\n要获取存储的值与源代码中编写的值相同的 `BigDecimal`，请使用 `new BigDecimal(\"0.1\")` 或 `BigDecimal.valueOf(0.1)`。\n\n**示例：**\n\n\n      class Constructor {\n        void foo() {\n          new BigDecimal(0.1);\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Constructor {\n        void foo() {\n          new BigDecimal(\"0.1\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnpredictableBigDecimalConstructorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseCompareMethod",
                "shortDescription": {
                  "text": "可以使用 'compare()' 方法比较数值"
                },
                "fullDescription": {
                  "text": "报告可被替换为对 'Integer.compare()' 方法或来自 'Long'、'Short'、'Byte'、'Double' 或 'Float' 类的类似方法（而非更冗长或更低效构造）的调用的表达式。 如果 'x' 和 'y' 是已装箱整数，则建议使用 'x.compareTo(y)'；如果它们是基元，则建议使用 'Integer.compare(x, y)'。 示例： 'public int compare(int x, int y) {\n    return x > y ? 1 : x < y ? -1 : 0;\n  }' 在应用快速修复后： 'public int compare(int x, int y) {\n    return Integer.compare(x, y);\n  }' 请注意，'Double.compare' 和 'Float.compare' 会略微更改代码语义。 特别是，它们会使 '-0.0' 和 '0.0' 可以区分（'Double.compare(-0.0, 0.0)' 生成 -1）。 此外，它们会一致地处理 'NaN' 值。 在大多数情况下，这种语义更改实际上会改进代码。 如果您的情况无法接受语义更改，请使用复选框禁用此项对浮点数的检查。 2017.2 最新变化",
                  "markdown": "报告可被替换为对 `Integer.compare()` 方法或来自 `Long`、`Short`、`Byte`、`Double` 或 `Float` 类的类似方法（而非更冗长或更低效构造）的调用的表达式。\n\n如果 `x` 和 `y` 是已装箱整数，则建议使用 `x.compareTo(y)`；如果它们是基元，则建议使用 `Integer.compare(x, y)`。\n\n**示例：**\n\n\n      public int compare(int x, int y) {\n        return x > y ? 1 : x < y ? -1 : 0;\n      }\n\n在应用快速修复后：\n\n\n      public int compare(int x, int y) {\n        return Integer.compare(x, y);\n      }\n\n\n请注意，`Double.compare` 和 `Float.compare` 会略微更改代码语义。 特别是，它们会使 `-0.0` 和 `0.0` 可以区分（`Double.compare(-0.0, 0.0)` 生成 -1）。\n此外，它们会一致地处理 `NaN` 值。 在大多数情况下，这种语义更改实际上会改进代码。 如果您的情况无法接受语义更改，请使用复选框禁用此项对浮点数的检查。\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseCompareMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级迁移帮助",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntegerDivisionInFloatingPointContext",
                "shortDescription": {
                  "text": "浮点上下文中的整数除法"
                },
                "fullDescription": {
                  "text": "报告结果用作浮点数时的整数除法。 此类除法通常表明有错误，并且由于在整数除法中出现截断，可能会产生意想不到的结果。 示例： 'float x = 3.0F + 3 * 2 / 5;' 在应用快速修复后： 'float x = 3.0F + ((float) (3 * 2)) /5;'",
                  "markdown": "报告结果用作浮点数时的整数除法。 此类除法通常表明有错误，并且由于在整数除法中出现截断，可能会产生意想不到的结果。\n\n**示例：**\n\n\n      float x = 3.0F + 3 * 2 / 5;\n\n在应用快速修复后：\n\n\n      float x = 3.0F + ((float) (3 * 2)) /5;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IntegerDivisionInFloatingPointContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertWithoutMessage",
                "shortDescription": {
                  "text": "断言上缺少消息"
                },
                "fullDescription": {
                  "text": "报告对没有错误消息字符串实参的 'assertXXX()' 或 'fail()' 的调用。 有关断言失败的错误消息可能有助于澄清测试用例的意图。 示例： 'assertTrue(checkValid());' 在应用快速修复后： 'assertTrue(checkValid(), \"|\");' 消息实参根据所使用的断言框架添加到现有实参前面或后面。",
                  "markdown": "报告对没有错误消息字符串实参的 `assertXXX()` 或 `fail()` 的调用。 有关断言失败的错误消息可能有助于澄清测试用例的意图。\n\n**示例：**\n\n\n      assertTrue(checkValid());\n\n在应用快速修复后：\n\n    assertTrue(checkValid(), \"|\");\n\n\n消息实参根据所使用的断言框架添加到现有实参前面或后面。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertWithoutMessage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 97,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MoveFieldAssignmentToInitializer",
                "shortDescription": {
                  "text": "字段赋值可以移至初始值设定项中"
                },
                "fullDescription": {
                  "text": "建议将使用赋值的字段的初始化替换为字段声明中的初始化。 仅当字段赋值位于实例或 static 初始值设定项中时报告，并且将其与字段声明联接可能比较安全。 在其他情况下（比如构造函数中的赋值），提供的快速修复不会高亮显示，因为修正可能会更改语义。 示例： 'class MyClass {\n    static final int intConstant;\n    \n    static {\n      intConstant = 10;\n    }\n  }' 该快速修复会将赋予的值移至字段初始值设定项，并移除类初始值设定项（如果可能）： 'class MyClass {\n    static final int intConstant = 10;\n  }' 自从 2017.2",
                  "markdown": "建议将使用赋值的字段的初始化替换为字段声明中的初始化。\n\n仅当字段赋值位于实例或 static 初始值设定项中时报告，并且将其与字段声明联接可能比较安全。\n在其他情况下（比如构造函数中的赋值），提供的快速修复不会高亮显示，因为修正可能会更改语义。\n\n示例：\n\n\n      class MyClass {\n        static final int intConstant;\n        \n        static {\n          intConstant = 10;\n        }\n      }\n\n该快速修复会将赋予的值移至字段初始值设定项，并移除类初始值设定项（如果可能）：\n\n\n      class MyClass {\n        static final int intConstant = 10;\n      }\n\n自从 2017.2"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MoveFieldAssignmentToInitializer",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInFormatCall",
                "shortDescription": {
                  "text": "字符串串联作为 'format()' 调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作格式字符串实参的非常量字符串串联。 虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中使用的变量包含 '%' 等特殊字符时，甚至可能导致安全问题。 此外，有时这可能是在本应键入 ',' 时键入了 '+' 而错误串联字符串格式实参所致。 示例： 'static String formatGreeting(String userName) {\n    return String.format(\"Hello, \" + userName);\n  }' 这里的 'userName' 将解释为格式字符串的一部分，从而可能导致 'IllegalFormatException'（例如，如果 'userName' 为 '\"%\"'）或使用大量内存（例如，如果 'userName' 为 '\"%2000000000%\"'）。 该调用可能应替换为 'String.format(\"Hello, %s\", userName);'。 此检查将检查对 'java.util.Formatter'、'java.lang.String'、'java.io.PrintWriter' 或 'java.io.PrintStream' 的格式化方法的调用。",
                  "markdown": "报告用作格式字符串实参的非常量字符串串联。\n\n\n虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中使用的变量包含 `%` 等特殊字符时，甚至可能导致安全问题。\n\n\n此外，有时这可能是在本应键入 `,` 时键入了 `+` 而错误串联字符串格式实参所致。\n\n**示例：**\n\n\n      static String formatGreeting(String userName) {\n        return String.format(\"Hello, \" + userName);\n      }\n\n\n这里的 `userName` 将解释为格式字符串的一部分，从而可能导致 `IllegalFormatException`（例如，如果 `userName` 为 `\"%\"`）或使用大量内存（例如，如果 `userName` 为 `\"%2000000000%\"`）。\n该调用可能应替换为 `String.format(\"Hello, %s\", userName);`。\n\n\n此检查将检查对 `java.util.Formatter`、`java.lang.String`、`java.io.PrintWriter` 或 `java.io.PrintStream` 的格式化方法的调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInFormatCall",
                    "cweIds": [
                      116,
                      134
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalBreakInInfiniteLoop",
                "shortDescription": {
                  "text": "循环内条件中断"
                },
                "fullDescription": {
                  "text": "报告在循环开始或结束处的条件中断，并建议改为添加循环条件来缩短代码。 示例： 'while (true) {\n    if (i  == 23) break;\n    i++;\n  }' 在应用快速修复后： 'while (i != 23) {\n    i++;\n  }'",
                  "markdown": "报告在循环开始或结束处的条件中断，并建议改为添加循环条件来缩短代码。\n\n示例：\n\n\n      while (true) {\n        if (i  == 23) break;\n        i++;\n      }\n\n在应用快速修复后：\n\n\n      while (i != 23) {\n        i++;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalBreakInInfiniteLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedInnerClassAccess",
                "shortDescription": {
                  "text": "非限定内部类访问"
                },
                "fullDescription": {
                  "text": "报告对未使用封闭类名称限定的内部类的引用。 示例： 'import foo.Foo.Bar;\n\n  class Foo {\n    class Bar {}\n  }\n\n  class Baz {\n    void f(Bar bar) {}\n  }' 在应用快速修复后： 'class Foo {\n    class Bar {}\n  }\n\n  class Baz {\n    void f(Foo.Bar bar) {}\n  }' 使用检查设置可以忽略对同一类中的内部类的引用，因此这些类不需要导入。",
                  "markdown": "报告对未使用封闭类名称限定的内部类的引用。\n\n**示例：**\n\n\n      import foo.Foo.Bar;\n\n      class Foo {\n        class Bar {}\n      }\n\n      class Baz {\n        void f(Bar bar) {}\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        class Bar {}\n      }\n\n      class Baz {\n        void f(Foo.Bar bar) {}\n      }\n\n\n使用检查设置可以忽略对同一类中的内部类的引用，因此这些类不需要导入。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedInnerClassAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitWhileHoldingTwoLocks",
                "shortDescription": {
                  "text": "保持两个锁时 'wait()'"
                },
                "fullDescription": {
                  "text": "报告在当前线程持有两个锁定时可能发生的对 'wait()' 方法的调用。 调用 'wait()' 只会释放目标上的一个锁定，因此持有两个锁定时的等待很容易导致死锁。 示例： 'synchronized (lockA) {\n    synchronized (lockB) {\n      lockB.wait(); //警告\n      //线程 A 卡在这里，持有 lockA\n    }\n  }\n\n  synchronized (lockA) { //线程 B 无法进入此块和释放线程 A\n    lockB.notify();\n  }'",
                  "markdown": "报告在当前线程持有两个锁定时可能发生的对 `wait()` 方法的调用。\n\n\n调用 `wait()` 只会释放目标上的一个锁定，因此持有两个锁定时的等待很容易导致死锁。\n\n**示例：**\n\n\n      synchronized (lockA) {\n        synchronized (lockB) {\n          lockB.wait(); //警告\n          //线程 A 卡在这里，持有 lockA\n        }\n      }\n\n      synchronized (lockA) { //线程 B 无法进入此块和释放线程 A\n        lockB.notify();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitWhileHoldingTwoLocks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantClassCall",
                "shortDescription": {
                  "text": "冗余的 'isInstance()' 或 'cast()' 调用"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.Class' 方法的冗余调用。 例如，'Xyz.class.isInstance(object)' 可以替换为 'object instanceof Xyz'。 首选 instanceof 检查：尽管性能与这些方法可能并无本质区别，但它们更好地指示了静态检查。 2018.2 最新变化",
                  "markdown": "报告 `java.lang.Class` 方法的冗余调用。\n\n例如，`Xyz.class.isInstance(object)` 可以替换为 `object instanceof Xyz`。\n首选 instanceof 检查：尽管性能与这些方法可能并无本质区别，但它们更好地指示了静态检查。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantClassCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryStringEscape",
                "shortDescription": {
                  "text": "不必要的转义字符"
                },
                "fullDescription": {
                  "text": "报告 'String' 和 'char' 文字（可选）中不必要的转义字符。 不会报告转义的制表符字符 '\\t'，因为制表符字符不可见。 示例： 'String s = \"\\'Scare\\' quotes\";\n  String t = \"\"\"\n    All you need is\\n\\tLove\\n\"\"\";' 在应用快速修复后： 'String s = \"'Scare' quotes\";\n  String t = \"\"\"\n    All you need is\n    \\tLove\n  \"\"\";' 2019.3 最新变化",
                  "markdown": "报告 `String` 和 `char` 文字（可选）中不必要的转义字符。\n\n不会报告转义的制表符字符 `\\t`，因为制表符字符不可见。\n\n示例：\n\n\n      String s = \"\\'Scare\\' quotes\";\n      String t = \"\"\"\n        All you need is\\n\\tLove\\n\"\"\";\n\n在应用快速修复后：\n\n\n      String s = \"'Scare' quotes\";\n      String t = \"\"\"\n        All you need is\n        \\tLove\n      \"\"\";\n\n2019.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryStringEscape",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableInnerClassWithNonSerializableOuterClass",
                "shortDescription": {
                  "text": "可序列化非 'static' 内部类具有不可序列化外部类"
                },
                "fullDescription": {
                  "text": "报告实现 'Serializable' 并在未实现 'Serializable' 的类中声明的非 static 内部类。 由于对外部类的隐式引用，这种类不太可能正确序列化。 示例： 'class A {\n      class Main implements Serializable {\n    }\n  }' 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 是否忽略 'Serializable' 匿名类。",
                  "markdown": "报告实现 `Serializable` 并在未实现 `Serializable` 的类中声明的非 static 内部类。\n\n\n由于对外部类的隐式引用，这种类不太可能正确序列化。\n\n**示例：**\n\n\n      class A {\n          class Main implements Serializable {\n        }\n      }\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 是否忽略 `Serializable` 匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableInnerClassWithNonSerializableOuterClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousListRemoveInLoop",
                "shortDescription": {
                  "text": "循环中的 'List.remove()' 可疑"
                },
                "fullDescription": {
                  "text": "报告升序计数循环中的 'list.remove(index)' 调用。 这很可疑，因为移除后列表变短，下一个元素被跳过。 简单的修正方法是在移除后减小索引变量，但更稳健的做法可能是通过迭代器或使用 'removeIf()' 方法（Java 8 及更高版本）移除。 如果您不希望 'remove()' 在循环中被多次调用，不妨在它后面添加 'break'。 示例： 'public static void main(String[] args) {\n    process(new ArrayList<>(\n      Arrays.asList(\"1\", \"2\", \"|\", \"3\", \"4\")));\n  }\n\n  static void process(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n      if (list.get(i).equals(\"|\")) {\n        list.remove(i);\n        continue;\n      }\n      System.out.println(list.get(i));\n    }\n  }' 代码看起来像是会打印 '1 2 3 4'，但实则在输出中将跳过 '3'。 2018.2 最新变化",
                  "markdown": "报告升序计数循环中的 `list.remove(index)` 调用。\n\n\n这很可疑，因为移除后列表变短，下一个元素被跳过。 简单的修正方法是在移除后减小索引变量，但更稳健的做法可能是通过迭代器或使用 `removeIf()` 方法（Java 8 及更高版本）移除。\n如果您不希望 `remove()` 在循环中被多次调用，不妨在它后面添加 `break`。\n\n**示例：**\n\n      public static void main(String[] args) {\n        process(new ArrayList<>(\n          Arrays.asList(\"1\", \"2\", \"|\", \"3\", \"4\")));\n      }\n\n      static void process(List<String> list) {\n        for (int i = 0; i < list.size(); i++) {\n          if (list.get(i).equals(\"|\")) {\n            list.remove(i);\n            continue;\n          }\n          System.out.println(list.get(i));\n        }\n      }\n\n代码看起来像是会打印 `1 2 3 4`，但实则在输出中将跳过 `3`。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousListRemoveInLoop",
                    "cweIds": [
                      129
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegativeIntConstantInLongContext",
                "shortDescription": {
                  "text": "长整型上下文中的负整型十六进制常量"
                },
                "fullDescription": {
                  "text": "报告 long 上下文中的负 int 十六进制常量。 此类常量会被隐式加宽为 long，意味着它们的高位将为 1，而不是 0（例如，0xFFFF_FFFF 将变成 0xFFFF_FFFF_FFFF_FFFFL）。 这不太可能是有意为之，即使是有意为之，使用显式 long 常量也不会那么容易造成困惑。 示例： '// 警告：这是 int 常量 -1，它被加宽为 long\n  // 成为 0xFFFF_FFFF_FFFF_FFFFL.\n  long mask = 0xFFFF_FFFF;' 2022.3 最新变化",
                  "markdown": "报告 long 上下文中的负 int 十六进制常量。 此类常量会被隐式加宽为 long，意味着它们的高位将为 1，而不是 0（例如，0xFFFF_FFFF 将变成 0xFFFF_FFFF_FFFF_FFFFL）。 这不太可能是有意为之，即使是有意为之，使用显式 long 常量也不会那么容易造成困惑。\n\n**示例：**\n\n\n      // 警告：这是 int 常量 -1，它被加宽为 long\n      // 成为 0xFFFF_FFFF_FFFF_FFFFL.\n      long mask = 0xFFFF_FFFF;\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegativeIntConstantInLongContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldCanBeLocal",
                "shortDescription": {
                  "text": "可以为本地字段"
                },
                "fullDescription": {
                  "text": "报告可以用局部变量替换的冗余类字段。 如果一个字段的所有局部用法都紧跟对该字段的赋值，则可以删除该字段，并且可以将其用法替换为局部变量。",
                  "markdown": "报告可以用局部变量替换的冗余类字段。\n\n如果一个字段的所有局部用法都紧跟对该字段的赋值，则可以删除该字段，并且可以将其用法替换为局部变量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldCanBeLocal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UrlHashCode",
                "shortDescription": {
                  "text": "在 'URL' 对象上调用 'equals()' 或 'hashCode()'"
                },
                "fullDescription": {
                  "text": "报告在 'java.net.URL' 对象上的 'hashCode()' 和 'equals()' 调用，以及将 'URL' 对象添加到映射和集合的调用。 'URL' 的 'equals()' 和 'hashCode()' 方法可以执行 DNS 查找来解析主机名。 这可能会导致重大延迟，具体取决于网络和 DNS 服务器的可用性和速度。 使用 'java.net.URI' 代替 'java.net.URL' 将避免 DNS 查找。 示例： 'boolean urlEquals(URL url1, URL url2) {\n      return url1.equals(url2);\n  }'",
                  "markdown": "报告在 `java.net.URL` 对象上的 `hashCode()` 和 `equals()` 调用，以及将 `URL` 对象添加到映射和集合的调用。\n\n\n`URL` 的 `equals()` 和 `hashCode()` 方法可以执行 DNS 查找来解析主机名。\n这可能会导致重大延迟，具体取决于网络和 DNS 服务器的可用性和速度。\n使用 `java.net.URI` 代替 `java.net.URL` 将避免 DNS 查找。\n\n**示例：**\n\n\n      boolean urlEquals(URL url1, URL url2) {\n          return url1.equals(url2);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UrlHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhileLoopSpinsOnField",
                "shortDescription": {
                  "text": "'while' 循环在字段上自旋"
                },
                "fullDescription": {
                  "text": "报告在非 'volatile' 字段值上自旋，等待它被另一个线程更改的 'while' 循环。 除了在循环内完成少量工作时可能会非常耗费 CPU 之外，此类循环很可能具有与预期不同的语义。 即便另一个线程更改了该字段的值，Java 内存模型也允许此类循环永不完成。 此外，自 Java 9 起，建议在 'volatile' 字段上的自旋循环中调用 'Thread.onSpinWait()'，这可能会显著提高某些硬件上的性能。 示例： 'class SpinsOnField {\n    boolean ready = false;\n\n    void run() {\n      while (!ready) {\n      }\n      // 执行某些工作\n    }\n\n    void markAsReady() {\n      ready = true;\n    }\n  }' 在应用快速修复后： 'class SpinsOnField {\n    volatile boolean ready = false;\n\n    void run() {\n      while (!ready) {\n        Thread.onSpinWait();\n      }\n      // 执行某些工作\n    }\n\n    void markAsReady() {\n      ready = true;\n    }\n  }' 使用检查选项可仅报告空的 'while' 循环。",
                  "markdown": "报告在非 `volatile` 字段值上自旋，等待它被另一个线程更改的 `while` 循环。\n\n\n除了在循环内完成少量工作时可能会非常耗费 CPU 之外，此类循环很可能具有与预期不同的语义。\n即便另一个线程更改了该字段的值，Java 内存模型也允许此类循环永不完成。\n\n\n此外，自 Java 9 起，建议在 `volatile` 字段上的自旋循环中调用 `Thread.onSpinWait()`，这可能会显著提高某些硬件上的性能。\n\n**示例：**\n\n\n      class SpinsOnField {\n        boolean ready = false;\n\n        void run() {\n          while (!ready) {\n          }\n          // 执行某些工作\n        }\n\n        void markAsReady() {\n          ready = true;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class SpinsOnField {\n        volatile boolean ready = false;\n\n        void run() {\n          while (!ready) {\n            Thread.onSpinWait();\n          }\n          // 执行某些工作\n        }\n\n        void markAsReady() {\n          ready = true;\n        }\n      }\n\n\n使用检查选项可仅报告空的 `while` 循环。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WhileLoopSpinsOnField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DefaultAnnotationParam",
                "shortDescription": {
                  "text": "默认注解形参值"
                },
                "fullDescription": {
                  "text": "报告被赋值给其 'default' 值的注解形参。 示例： '@interface Test {\n      Class<?> expected() default Throwable.class;\n  }\n\n  @Test(expected = Throwable.class)\n  void testSmth() {}' 在应用快速修复后： '@Test()\n  void testSmth() {}'",
                  "markdown": "报告被赋值给其 `default` 值的注解形参。\n\n示例：\n\n\n      @interface Test {\n          Class<?> expected() default Throwable.class;\n      }\n\n      @Test(expected = Throwable.class)\n      void testSmth() {}\n\n在应用快速修复后：\n\n\n      @Test()\n      void testSmth() {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DefaultAnnotationParam",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementWithIdenticalBranches",
                "shortDescription": {
                  "text": "具有相同分支或通用部分的 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告可以从分支中提取通用部分的 'if' 语句。 这些通用部分独立于条件并使 'if' 语句更难理解。 示例： 'if (x > 12) {\n    doSomethingBefore();\n    doSomethingDifferent1();\n    doSomethingAfter();\n  } else {\n    doSomethingBefore();\n    doSomethingDifferent2();\n    doSomethingAfter();\n  }' 在应用快速修复后： 'doSomethingBefore();\n  if (x > 12) {\n    doSomethingDifferent1();\n  } else {\n    doSomethingDifferent2();\n  }\n  doSomethingAfter();' 这是 2018.1 更新的功能",
                  "markdown": "报告可以从分支中提取通用部分的 `if` 语句。\n\n这些通用部分独立于条件并使 `if` 语句更难理解。\n\n示例：\n\n\n      if (x > 12) {\n        doSomethingBefore();\n        doSomethingDifferent1();\n        doSomethingAfter();\n      } else {\n        doSomethingBefore();\n        doSomethingDifferent2();\n        doSomethingAfter();\n      }\n\n在应用快速修复后：\n\n\n      doSomethingBefore();\n      if (x > 12) {\n        doSomethingDifferent1();\n      } else {\n        doSomethingDifferent2();\n      }\n      doSomethingAfter();\n\n这是 2018.1 更新的功能"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfStatementWithIdenticalBranches",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceWithOnlyOneDirectInheritor",
                "shortDescription": {
                  "text": "只有一个直接继承者的接口"
                },
                "fullDescription": {
                  "text": "报告仅具有一个直接继承者的接口。 虽然此类接口可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将接口与其继承者合并。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。",
                  "markdown": "报告仅具有一个直接继承者的接口。 虽然此类接口可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将接口与其继承者合并。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceWithOnlyOneDirectInheritor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofChain",
                "shortDescription": {
                  "text": "'instanceof' 检查链"
                },
                "fullDescription": {
                  "text": "报告所有语句条件均为 'instanceof' 表达式或类等式表达式（例如与 'String.class' 比较）的 'if'-'else' 语句的任何链。 此类结构通常表明面向对象的设计失败，面向对象的设计要求此类基于类型的调度应通过多态方法调用而不是类型测试的显式链来完成。 示例： 'double getArea(Shape shape) {\n    // 警告：抽象失败。\n    // 最好在 shape 接口中\n    // 声明 getArea() 抽象方法，\n    // 并在每个继承者中实现。\n    if (shape instanceof Point) {\n      return 0;\n    }\n    if (shape instanceof Circle) {\n      return Math.PI *\n        Math.pow(((Circle) shape).radius(), 2);\n    }\n    if (shape instanceof Rectangle) {\n      return ((Rectangle) shape).width() *\n        ((Rectangle) shape).height();\n    }\n    throw new IllegalArgumentException();\n  }' 使用下面的复选框可忽略库类中的 'instanceof' 表达式。",
                  "markdown": "报告所有语句条件均为 `instanceof` 表达式或类等式表达式（例如与 `String.class` 比较）的 `if`-`else` 语句的任何链。 此类结构通常表明面向对象的设计失败，面向对象的设计要求此类基于类型的调度应通过多态方法调用而不是类型测试的显式链来完成。\n\n示例：\n\n\n      double getArea(Shape shape) {\n        // 警告：抽象失败。\n        // 最好在 shape 接口中\n        // 声明 getArea() 抽象方法，\n        // 并在每个继承者中实现。\n        if (shape instanceof Point) {\n          return 0;\n        }\n        if (shape instanceof Circle) {\n          return Math.PI *\n            Math.pow(((Circle) shape).radius(), 2);\n        }\n        if (shape instanceof Rectangle) {\n          return ((Rectangle) shape).width() *\n            ((Rectangle) shape).height();\n        }\n        throw new IllegalArgumentException();\n      }\n\n\n使用下面的复选框可忽略库类中的 `instanceof` 表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainOfInstanceofChecks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BlockMarkerComments",
                "shortDescription": {
                  "text": "块标记注释"
                },
                "fullDescription": {
                  "text": "报告用作代码块标记的注释。 该快速修复会移除此类注释。 示例： 'while (i < 10) {\n    i++;\n  } // end while' 在应用快速修复后： 'while (i < 10) {\n    i++;\n  }'",
                  "markdown": "报告用作代码块标记的注释。 该快速修复会移除此类注释。\n\n示例：\n\n\n      while (i < 10) {\n        i++;\n      } // end while\n\n在应用快速修复后：\n\n\n      while (i < 10) {\n        i++;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BlockMarkerComments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableHasSerializationMethods",
                "shortDescription": {
                  "text": "不带 'readObject()' 和 'writeObject()' 的可序列化类"
                },
                "fullDescription": {
                  "text": "报告不实现 'readObject()' 和 'writeObject()' 方法的 'Serializable' 类。 如果没有实现 'readObject()' 和 'writeObject()' 方法，将使用默认的序列化算法，在许多环境中，这对于性能和兼容性而言或许是次优选择。 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 是否忽略没有非 static 字段的 'Serializable' 类。 是否忽略 'Serializable' 匿名类。",
                  "markdown": "报告不实现 `readObject()` 和 `writeObject()` 方法的 `Serializable` 类。\n\n\n如果没有实现 `readObject()` 和 `writeObject()` 方法，将使用默认的序列化算法，在许多环境中，这对于性能和兼容性而言或许是次优选择。\n\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 是否忽略没有非 static 字段的 `Serializable` 类。\n* 是否忽略 `Serializable` 匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableHasSerializationMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnLock",
                "shortDescription": {
                  "text": "在 'Lock' 对象上同步"
                },
                "fullDescription": {
                  "text": "报告锁定 'java.util.concurrent.locks.Lock' 实例的 'synchronized' 块。 此类同步几乎肯定是无意为之，应当改用适当版本的 '.lock()' 和 '.unlock()'。 示例： 'final ReentrantLock lock = new ReentrantLock();\n\n  public void foo() {\n    synchronized (lock) {}\n  }'",
                  "markdown": "报告锁定 `java.util.concurrent.locks.Lock` 实例的 `synchronized` 块。 此类同步几乎肯定是无意为之，应当改用适当版本的 `.lock()` 和 `.unlock()`。\n\n**示例：**\n\n\n      final ReentrantLock lock = new ReentrantLock();\n\n      public void foo() {\n        synchronized (lock) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchroniziationOnLockObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IdempotentLoopBody",
                "shortDescription": {
                  "text": "幂等循环体"
                },
                "fullDescription": {
                  "text": "报告除了第一次迭代中产生的副作用外，在第二次和后续迭代中不产生其他副作用的循环，这可能表示编程错误。 此类循环可能只迭代零次、一次或无限次。 如果不存在无限循环的情况，则可以将其替换为 'if' 语句。 否则，程序可能会卡住。 示例： 'public void foo(String baseName, String names) {\n        int suffix = 1;\n        String name = baseName;\n        while (names.contains(name)) {\n            // 错误：suffix 未更新，导致循环体幂等\n            name = baseName + suffix;\n        }\n    }' 2018.1 最新变化",
                  "markdown": "报告除了第一次迭代中产生的副作用外，在第二次和后续迭代中不产生其他副作用的循环，这可能表示编程错误。\n\n此类循环可能只迭代零次、一次或无限次。\n如果不存在无限循环的情况，则可以将其替换为 ` if ` 语句。\n否则，程序可能会卡住。\n\n示例：\n\n\n        public void foo(String baseName, String names) {\n            int suffix = 1;\n            String name = baseName;\n            while (names.contains(name)) {\n                // 错误：suffix 未更新，导致循环体幂等\n                name = baseName + suffix;\n            }\n        }\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IdempotentLoopBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExceptionCaught",
                "shortDescription": {
                  "text": "已捕获禁止的 'Exception'"
                },
                "fullDescription": {
                  "text": "报告捕获不适当异常的 'catch' 子句。 一些异常（例如 'java.lang.NullPointerException' 或 'java.lang.IllegalMonitorStateException'）表示编程错误，因此几乎肯定不会在生产代码中被捕获。 示例： 'try {\n    return component.getMousePosition(true) != null;\n  } catch (NullPointerException e) { // warning: Prohibited exception 'NullPointerException' caught\n    return false;\n  }' 使用被禁止的异常列表可指定应报告哪些异常。",
                  "markdown": "报告捕获不适当异常的 `catch` 子句。\n\n一些异常（例如 `java.lang.NullPointerException` 或 `java.lang.IllegalMonitorStateException`）表示编程错误，因此几乎肯定不会在生产代码中被捕获。\n\n**示例：**\n\n\n      try {\n        return component.getMousePosition(true) != null;\n      } catch (NullPointerException e) { // warning: Prohibited exception 'NullPointerException' caught\n        return false;\n      }\n\n使用**被禁止的异常**列表可指定应报告哪些异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProhibitedExceptionCaught",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantImplements",
                "shortDescription": {
                  "text": "冗余接口声明"
                },
                "fullDescription": {
                  "text": "报告类的 'implements' 列表或接口的 'extends' 列表中已经由超类实现或由超接口扩展的接口。 此类声明不必要，并且可以安全移除。 示例： 'class X implements One, Two {\n  }\n  interface One {}\n  interface Two extends One {}' 在应用快速修复后： 'class X implements Two {\n  }\n  interface One {}\n  interface Two extends One {}' 使用该选项可以不报告 'extends' 或 'implements' 列表中的 'Serializable' 或 'Externalizable'。",
                  "markdown": "报告类的 `implements` 列表或接口的 `extends` 列表中已经由超类实现或由超接口扩展的接口。 此类声明不必要，并且可以安全移除。\n\n**示例：**\n\n\n      class X implements One, Two {\n      }\n      interface One {}\n      interface Two extends One {}\n\n在应用快速修复后：\n\n\n      class X implements Two {\n      }\n      interface One {}\n      interface Two extends One {}\n\n\n使用该选项可以不报告 `extends` 或 `implements` 列表中的 `Serializable` 或 `Externalizable`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantInterfaceDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofCatchParameter",
                "shortDescription": {
                  "text": "'catch' 形参上的 'instanceof'"
                },
                "fullDescription": {
                  "text": "报告使用 'instanceof' 表达式来测试 'catch' 块中形参类型的情况。 测试 'catch' 形参的类型通常最好使用单独的 'catch' 块，而不是使用 'instanceof'。 示例： 'void foo(Runnable runnable) {\n    try {\n        runnable.run();\n    } catch (Throwable throwable) {\n        if (throwable instanceof NoClassDefFoundError) { // 警告：'catch' 形参 'throwable' 上的 'instanceof'\n            System.out.println(\"Class not found!\");\n        }\n    }\n  }'",
                  "markdown": "报告使用 `instanceof` 表达式来测试 `catch` 块中形参类型的情况。\n\n测试 `catch` 形参的类型通常最好使用单独的 `catch` 块，而不是使用 `instanceof`。\n\n**示例：**\n\n\n      void foo(Runnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable throwable) {\n            if (throwable instanceof NoClassDefFoundError) { // 警告：'catch' 形参 'throwable' 上的 'instanceof'\n                System.out.println(\"Class not found!\");\n            }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceofCatchParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantScheduledForRemovalAnnotation",
                "shortDescription": {
                  "text": "冗余的 @ScheduledForRemoval 注解"
                },
                "fullDescription": {
                  "text": "报告无 'inVersion' 特性的 '@ApiStatus.ScheduledForRemoval' 注解在以 Java 9 或更高版本为目标的代码中的用法。 此类用法可以用 '@Deprecated' 注解中的 'forRemoval' 特性代替以简化代码。 2022.1 最新变化",
                  "markdown": "报告无 `inVersion` 特性的 `@ApiStatus.ScheduledForRemoval` 注解在以 Java 9 或更高版本为目标的代码中的用法。\n\n\n此类用法可以用 `@Deprecated` 注解中的 `forRemoval` 特性代替以简化代码。\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantScheduledForRemovalAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FrequentlyUsedInheritorInspection",
                "shortDescription": {
                  "text": "类可以扩展常用的基类"
                },
                "fullDescription": {
                  "text": "报告可以替换为更具体的常用类或接口的实现或扩展的类或接口。 为进行此检查，超类需位于项目源文件中，并且项目需要使用 IntelliJ IDEA 构建系统。 示例： 'class MyInheritor implements A {} // B 针对 A 引用提供建议\n\n  interface A {}\n\n  abstract class B implements A {}\n\n  abstract class C1 extends B {}\n  abstract class C2 extends B {}\n  abstract class C3 extends B {}\n  abstract class C4 extends B {}\n  abstract class C5 extends B {}' 默认情况下，此检查不会在编辑器中高亮显示问题，而是只提供快速修复。 2017.2 最新变化",
                  "markdown": "报告可以替换为更具体的常用类或接口的实现或扩展的类或接口。\n\n为进行此检查，超类需位于项目源文件中，并且项目需要使用 IntelliJ IDEA 构建系统。\n\n**示例：**\n\n\n      class MyInheritor implements A {} // B 针对 A 引用提供建议\n\n      interface A {}\n\n      abstract class B implements A {}\n\n      abstract class C1 extends B {}\n      abstract class C2 extends B {}\n      abstract class C3 extends B {}\n      abstract class C4 extends B {}\n      abstract class C5 extends B {}\n\n默认情况下，此检查不会在编辑器中高亮显示问题，而是只提供快速修复。\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FrequentlyUsedInheritorInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalGetWithoutIsPresent",
                "shortDescription": {
                  "text": "在不进行 isPresent() 检查的情况下调用 Optional.get()"
                },
                "fullDescription": {
                  "text": "报告对 'Optional' 上的 'get()' 的调用而不检查它是否有值。 在空 'Optional' 实例上调用 'Optional.get()' 将抛出异常。 示例： 'void x(List<Integer> list) {\n    final Optional<Integer> optional =\n      list.stream().filter(x -> x > 10).findFirst();\n    final Integer result = optional.get(); // 此处有问题\n  }' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告对 `Optional` 上的 `get()` 的调用而不检查它是否有值。\n\n在空 `Optional` 实例上调用 `Optional.get()` 将抛出异常。\n\n**示例：**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // 此处有问题\n      }\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalGetWithoutIsPresent",
                    "cweIds": [
                      252,
                      476
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OnDemandImport",
                "shortDescription": {
                  "text": "'*' 导入"
                },
                "fullDescription": {
                  "text": "报告任何涵盖整个软件包的 'import' 语句 ('* imports')。 某些编码标准禁止此类 'import' 语句。 您可以将 IntelliJ IDEA 配置为使用优化 import 命令检测和修正此类语句。 转到设置 | 编辑器 | 代码样式 | Java | 导入，确保启用使用单个类导入选项，并在将 import 与 '*' 搭配使用的类计数和将静态 import 与 '*' 搭配使用的名称计数字段中指定值。 因此，对于不打算更改的代码库的脱机报告，此检查非常有用。",
                  "markdown": "报告任何涵盖整个软件包的 `import` 语句 ('\\* imports')。\n\n某些编码标准禁止此类 `import` 语句。\n\n\n您可以将 IntelliJ IDEA 配置为使用**优化 import** 命令检测和修正此类语句。 转到[设置 \\| 编辑器 \\| 代码样式 \\| Java \\| 导入](settings://preferences.sourceCode.Java?Use%20single%20class%20import)，确保启用**使用单个类导入** 选项，并在**将 import 与 '\\*' 搭配使用的类计数** 和**将静态 import 与 '\\*' 搭配使用的名称计数**字段中指定值。\n因此，对于不打算更改的代码库的脱机报告，此检查非常有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OnDemandImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FallthruInSwitchStatement",
                "shortDescription": {
                  "text": "'switch' 语句中的直落"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句中的直落。 当 'case' 标签后面的一系列可执行语句不能保证在下一个 'case' 标签前转移控制权时，就会发生直落。 例如，如果分支缺少 'break' 语句，就可能发生这种情况。 在这种情况下，即便 'switch' 表达式不等于被直落标签的值，控制权也会直落到 'switch' 标签后面的语句。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。 此检查将忽略任何使用与正则表达式模式 '(?i)falls?\\s*thro?u' 相匹配的文本注释的直落。 可以通过修正向可能直落到下一个分支的分支添加 'break'。 示例： 'switch(x) {\n      case (4):\n          if (condition) {\n              System.out.println(\"3\");\n              // 此处无 break\n          } else {\n              break;\n          }\n      case (6):\n          System.out.println(\"4\");\n    }' 在应用快速修复后： 'switch(x) {\n        case (4):\n            if (condition) {\n                System.out.println(\"3\");\n            } else {\n                break;\n            }\n            break;\n        case (6):\n            System.out.println(\"4\");\n    }'",
                  "markdown": "报告 `switch` 语句中的直落。\n\n当 `case` 标签后面的一系列可执行语句不能保证在下一个 `case` 标签前转移控制权时，就会发生直落。 例如，如果分支缺少 `break` 语句，就可能发生这种情况。\n在这种情况下，即便 `switch` 表达式不等于被直落标签的值，控制权也会直落到 `switch` 标签后面的语句。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。\n\n\n此检查将忽略任何使用与正则表达式模式 `(?i)falls?\\s*thro?u` 相匹配的文本注释的直落。\n\n可以通过修正向可能直落到下一个分支的分支添加 `break`。\n\n示例：\n\n\n        switch(x) {\n          case (4):\n              if (condition) {\n                  System.out.println(\"3\");\n                  // 此处无 break\n              } else {\n                  break;\n              }\n          case (6):\n              System.out.println(\"4\");\n        }\n\n在应用快速修复后：\n\n\n        switch(x) {\n            case (4):\n                if (condition) {\n                    System.out.println(\"3\");\n                } else {\n                    break;\n                }\n                break;\n            case (6):\n                System.out.println(\"4\");\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "fallthrough",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantOperationOnEmptyContainer",
                "shortDescription": {
                  "text": "空容器上存在冗余操作"
                },
                "fullDescription": {
                  "text": "报告对空集合、映射或数组的冗余操作。 在空集合上迭代、移除元素、排序和某些其他操作没有任何效果，可以移除。 此外，它们可能表明存在错误。 示例： 'if (numbers.isEmpty()){\n    //由于缺少否定，因此出现错误\n    int max = numbers.stream().max(Comparator.naturalOrder()).get();\n    ...\n  }' 2019.1 最新变化",
                  "markdown": "报告对空集合、映射或数组的冗余操作。\n\n\n在空集合上迭代、移除元素、排序和某些其他操作没有任何效果，可以移除。 此外，它们可能表明存在错误。\n\n**示例：**\n\n\n      if (numbers.isEmpty()){\n        //由于缺少否定，因此出现错误\n        int max = numbers.stream().max(Comparator.naturalOrder()).get();\n        ...\n      }\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantOperationOnEmptyContainer",
                    "cweIds": [
                      561
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalIsPresent",
                "shortDescription": {
                  "text": "非函数样式 'Optional.isPresent()' 用法"
                },
                "fullDescription": {
                  "text": "报告可用函数样式重写的、用作 'if' 或条件表达式条件的 'Optional' 表达式。 结果往往更短，更易于阅读。 示例： 'if (str.isPresent()) str.get().trim();' 在应用快速修复后： 'str.ifPresent(String::trim);' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可用函数样式重写的、用作 `if` 或条件表达式条件的 `Optional` 表达式。 结果往往更短，更易于阅读。\n\n示例：\n\n\n      if (str.isPresent()) str.get().trim();\n\n在应用快速修复后：\n\n\n      str.ifPresent(String::trim);\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalIsPresent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AtomicFieldUpdaterNotStaticFinal",
                "shortDescription": {
                  "text": "'AtomicFieldUpdater' 字段未被声明为 'static final'"
                },
                "fullDescription": {
                  "text": "报告以下类型的字段： 'java.util.concurrent.atomic.AtomicLongFieldUpdater' 'java.util.concurrent.atomic.AtomicIntegerFieldUpdater' 'java.util.concurrent.atomic.AtomicReferenceFieldUpdater' 其类型为 'static final'。 因为在一个类的所有实例中，只需要一个原子字段更新程序来更新 'volatile' 字段，所以它几乎总是 'static'。 使更新程序为 'final'，JVM 就能优化访问以提高性能。 示例： 'class Main {\n    private volatile int id;\n    private AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n  }' 在应用快速修复后： 'class Main {\n    private volatile int id;\n    private static final AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n  }'",
                  "markdown": "报告以下类型的字段：\n\n* `java.util.concurrent.atomic.AtomicLongFieldUpdater`\n* `java.util.concurrent.atomic.AtomicIntegerFieldUpdater`\n* `java.util.concurrent.atomic.AtomicReferenceFieldUpdater`\n\n其类型为 `static final`。 因为在一个类的所有实例中，只需要一个原子字段更新程序来更新 `volatile` 字段，所以它几乎总是 `static`。\n\n使更新程序为 `final`，JVM 就能优化访问以提高性能。\n\n**示例：**\n\n\n      class Main {\n        private volatile int id;\n        private AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        private volatile int id;\n        private static final AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AtomicFieldUpdaterNotStaticFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldNamingConvention",
                "shortDescription": {
                  "text": "字段命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的字段。 示例：如果对常量启用了检查，并且字段名称的最小指定长度为 5（默认值），由于以下常量的名称长度为 3，即小于 5，因此将生成警告：'public static final int MAX = 42;'。 只能在编辑器中使用重命名此类字段的快速修复。 配置检查： 使用选项部分中的列表来指定应检查哪些字段。 取消选中要为之跳过检查的字段对应的复选框。 对于每种字段类型，请使用所提供的输入字段指定字段名称的最小长度、最大长度和正则表达式。 在长度字段中指定 0 可跳过相应检查。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的字段。\n\n**示例** ：如果对常量启用了检查，并且字段名称的最小指定长度为 5（默认值），由于以下常量的名称长度为 3，即小于 5，因此将生成警告：`public static final int MAX = 42;`。\n\n只能在编辑器中使用重命名此类字段的快速修复。\n\n配置检查：\n\n使用**选项**部分中的列表来指定应检查哪些字段。 取消选中要为之跳过检查的字段对应的复选框。\n\n对于每种字段类型，请使用所提供的输入字段指定字段名称的最小长度、最大长度和正则表达式。\n在长度字段中指定 **0** 可跳过相应检查。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8MapForEach",
                "shortDescription": {
                  "text": "可以使用 Map.forEach()"
                },
                "fullDescription": {
                  "text": "建议将 'for(Entry<?,?> entry : map.entrySet()) {...}' 或 'map.entrySet().forEach(entry -> ...)' 替换为 'map.forEach((key, value) -> ...)'。 示例 'void print(Map<String, Integer> map) {\n    map.entrySet().forEach(entry -> {\n      String str = entry.getKey();\n      System.out.println(str + \":\" + entry.getValue());\n    });\n  }' 在应用快速修复后： 'void print(Map<String, Integer> map) {\n    map.forEach((str, value) -> System.out.println(str + \":\" + value));\n  }' 启用 不要报告循环选项后，只会报告 'entrySet().forEach()' 情况。 但是，该快速修复操作也可用于 'for' 循环。 2017.1 最新变化 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "建议将 `for(Entry<?,?> entry : map.entrySet()) {...}` 或 `map.entrySet().forEach(entry -> ...)` 替换为 `map.forEach((key, value) -> ...)`。\n\n示例\n\n\n      void print(Map<String, Integer> map) {\n        map.entrySet().forEach(entry -> {\n          String str = entry.getKey();\n          System.out.println(str + \":\" + entry.getValue());\n        });\n      }\n\n在应用快速修复后：\n\n\n      void print(Map<String, Integer> map) {\n        map.forEach((str, value) -> System.out.println(str + \":\" + value));\n      }\n\n\n启用 **不要报告循环** 选项后，只会报告 `entrySet().forEach()` 情况。\n但是，该快速修复操作也可用于 `for` 循环。\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8MapForEach",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantConditionalExpression",
                "shortDescription": {
                  "text": "常量条件表达式"
                },
                "fullDescription": {
                  "text": "报告条件为 'true' 或 'false' 常量的条件表达式。 这些表达式有时是自动重构的结果，并且可以被简化。 示例： 'return true ? \"Yes\" : \"No\";' 在应用快速修复后： 'return \"Yes\";'",
                  "markdown": "报告条件为 `true` 或 `false` 常量的条件表达式。 这些表达式有时是自动重构的结果，并且可以被简化。\n\n示例：\n\n\n      return true ? \"Yes\" : \"No\";\n\n在应用快速修复后：\n\n\n      return \"Yes\";\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNamePrefixedWithPackageName",
                "shortDescription": {
                  "text": "使用软件包名称作为前缀的类名"
                },
                "fullDescription": {
                  "text": "报告名称前缀为其软件包名称并忽略大写差异的类。 虽然偶尔使用此类名称是合理的，但通常是由于欠佳的命名方案而使用，可能冗余并且令人生厌。 示例： 'package byteCode;\n  class ByteCodeAnalyzer {}' 只能在编辑器中采用快速修复来重命名这种类。",
                  "markdown": "报告名称前缀为其软件包名称并忽略大写差异的类。\n\n虽然偶尔使用此类名称是合理的，但通常是由于欠佳的命名方案而使用，可能冗余并且令人生厌。\n\n**示例：**\n\n\n      package byteCode;\n      class ByteCodeAnalyzer {}\n\n只能在编辑器中采用快速修复来重命名这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNamePrefixedWithPackageName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SameParameterValue",
                "shortDescription": {
                  "text": "方法形参始终具有相同的值"
                },
                "fullDescription": {
                  "text": "报告始终具有相同常量值的方法形参。 示例： 'static void printPoint(int x, int y) { // x 始终为 0\n    System.out.println(x + \", \" + y);\n  }\n\n  public static void main(String[] args) {\n    printPoint(0, 1);\n    printPoint(0, 2);\n  }' 该快速修复会内联常量值。 这可能会简化方法实现。 在以下情况下，使用当无法提供快速修复时忽略选项来禁止检查： 形参在方法内部被修改 传递的形参值是对不可访问字段的引用（仅限 Java） 形参为 vararg（仅限 Java） 使用最大方法可见性选项可以控制要报告的方法的最大可见性。 使用要报告形参的最小方法用法计数字段可以指定具有相同形参值的最小方法用法数。",
                  "markdown": "报告始终具有相同常量值的方法形参。\n\n示例：\n\n\n      static void printPoint(int x, int y) { // x 始终为 0\n        System.out.println(x + \", \" + y);\n      }\n\n      public static void main(String[] args) {\n        printPoint(0, 1);\n        printPoint(0, 2);\n      }\n\n该快速修复会内联常量值。 这可能会简化方法实现。\n\n\n在以下情况下，使用**当无法提供快速修复时忽略**选项来禁止检查：\n\n* 形参在方法内部被修改\n* 传递的形参值是对不可访问字段的引用（仅限 Java）\n* 形参为 vararg（仅限 Java）\n\n\n使用**最大方法可见性**选项可以控制要报告的方法的最大可见性。\n\n\n使用**要报告形参的最小方法用法计数**字段可以指定具有相同形参值的最小方法用法数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SameParameterValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CatchMayIgnoreException",
                "shortDescription": {
                  "text": "catch 块可能会忽略异常"
                },
                "fullDescription": {
                  "text": "报告空的或可能忽略异常的 'catch' 块。 虽然偶尔是有意为之，但空的 'catch' 块可能导致调试复杂化。 此外，忽略 'catch' 形参可能是错误的。 最后，静态代码分析器会报告是否检测到 'catch' 块可能无提示地忽略重要的 VM 异常，如 'NullPointerException'。 忽略此类异常（不记录或重新抛出）可能会隐藏错误。 该检查不会报告任何命名为 'ignore' 或 'ignored' 的 'catch' 形参。 相反，它将对真正在使用的命名为 'ignore' 或 'ignored' 的 'catch' 形参发出警告。 此外，该检查不会报告命名为 'expected' 或 'ok' 的测试源中的 'catch' 形参。 您可以使用快速修复将异常名称更改为 'ignored'。 对于空的 catch 块，建议使用其他快速修复来生成 catch 主体。 您可以在设置 | 编辑器 | 文件和代码模板中的“代码”标签页上修改 \"Catch Statement Body\" 模板。 示例： 'try {\n    throwingMethod();\n  } catch (IOException ex) {\n\n  }' 在应用快速修复后： 'try {\n    System.out.println(System.in.read());\n  } catch (IOException ignored) {\n\n  }' 配置检查： 使用当 'catch' 块包含注释时不发出警告选项可以忽略包含注释的 'catch' 块。 使用当 'catch' 块不为空时不发出警告选项可以忽略其中包含语句或注释但又不使用变量本身的 'catch' 块。 使用当名称为 'ignore(d)' 的异常实际上未被忽略时不发出警告选项可以忽略使用中名称为 'ignored' 的变量。 2018.1 最新变化",
                  "markdown": "报告空的或可能忽略异常的 `catch` 块。\n\n虽然偶尔是有意为之，但空的 `catch` 块可能导致调试复杂化。\n此外，忽略 `catch` 形参可能是错误的。\n最后，静态代码分析器会报告是否检测到 `catch` 块可能无提示地忽略重要的 VM 异常，如 `NullPointerException`。 忽略此类异常（不记录或重新抛出）可能会隐藏错误。\n\n\n该检查不会报告任何命名为 `ignore` 或 `ignored` 的 `catch` 形参。\n相反，它将对真正在使用的命名为 `ignore` 或 `ignored` 的 `catch` 形参发出警告。\n此外，该检查不会报告命名为 `expected` 或 `ok` 的测试源中的 `catch` 形参。\n\n\n您可以使用快速修复将异常名称更改为 `ignored`。\n对于空的 **catch** 块，建议使用其他快速修复来生成 **catch** 主体。\n您可以在[设置 \\| 编辑器 \\| 文件和代码模板](settings://fileTemplates)中的\"代码\"标签页上修改 \"Catch Statement Body\" 模板。\n\n**示例：**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\n在应用快速修复后：\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\n配置检查：\n\n* 使用**当 'catch' 块包含注释时不发出警告** 选项可以忽略包含注释的 `catch` 块。\n* 使用**当 'catch' 块不为空时不发出警告** 选项可以忽略其中包含语句或注释但又不使用变量本身的 `catch` 块。\n* 使用**当名称为 'ignore(d)' 的异常实际上未被忽略时不发出警告** 选项可以忽略使用中名称为 `ignored` 的变量。\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CatchMayIgnoreException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecordStoreResource",
                "shortDescription": {
                  "text": "打开了 'RecordStore'，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未在 'try' 块前打开并在相应的 'finally' 块中关闭的 Java ME 'javax.microedition.rms.RecordStore' 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 示例： 'void foo1() throws RecordStoreException {\n      RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 警告\n  }\n  void foo2() throws RecordStoreException {\n      RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 无警告\n      try {\n          /* ... */\n      } finally {\n          rs.closeRecordStore();\n      }\n  }'",
                  "markdown": "报告未在 `try` 块前打开并在相应的 `finally` 块中关闭的 Java ME `javax.microedition.rms.RecordStore` 资源。\n\n如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n**示例：**\n\n\n      void foo1() throws RecordStoreException {\n          RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 警告\n      }\n      void foo2() throws RecordStoreException {\n          RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 无警告\n          try {\n              /* ... */\n          } finally {\n              rs.closeRecordStore();\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RecordStoreOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyDependents",
                "shortDescription": {
                  "text": "依赖项过多的类"
                },
                "fullDescription": {
                  "text": "报告被过多其他类直接依赖的类。 对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。 仅报告顶级类。 使用下面的字段可指定类的最大允许依赖项数。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告被过多其他类直接依赖的类。\n\n对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。\n\n仅报告顶级类。\n\n使用下面的字段可指定类的最大允许依赖项数。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyDependents",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrongPackageStatement",
                "shortDescription": {
                  "text": "错误的 package 语句"
                },
                "fullDescription": {
                  "text": "检测与项目目录结构不对应的 'package' 语句。 此外，如果不包含 'package' 语句的类不是直接位于源根目录中，则报告这种类。 虽然 Java 语言没有严格规定，但最好将软件包 'com.example.myapp' 中的类直接保存在源根下的 'com/example/myapp' 目录中。 如果不这样做，可能会导致代码读取器混淆，某些工具也无法正确工作。",
                  "markdown": "检测与项目目录结构不对应的 `package` 语句。 此外，如果不包含 `package` 语句的类不是直接位于源根目录中，则报告这种类。\n\n虽然 Java 语言没有严格规定，但最好将软件包 `com.example.myapp` 中的类直接保存在源根下的 `com/example/myapp` 目录中。 如果不这样做，可能会导致代码读取器混淆，某些工具也无法正确工作。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "WrongPackageStatement",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectsEqualsCanBeSimplified",
                "shortDescription": {
                  "text": "'Objects.equals()' 可被替换为 'equals()'"
                },
                "fullDescription": {
                  "text": "报告对 'Objects.equals(a, b)' 的调用，其中第一个实参是静态已知为非 null。 如果两个实参都是基元，此类调用可以安全地替换为 'a.equals(b)' 或 'a == b'。 示例： 'String defaultName = \"default\";\n  boolean isDefault = Objects.equals(defaultName, name);' 在应用快速修复后： 'String defaultName = \"default\";\n  boolean isDefault = defaultName.equals(name);' 2018.3 最新变化 此检查取决于 Java 功能 'java.util.Objects API'，该功能自 Java 7 起可用。",
                  "markdown": "报告对 `Objects.equals(a, b)` 的调用，其中第一个实参是静态已知为非 null。\n\n如果两个实参都是基元，此类调用可以安全地替换为 `a.equals(b)` 或 `a == b`。\n\n示例：\n\n\n      String defaultName = \"default\";\n      boolean isDefault = Objects.equals(defaultName, name);\n\n在应用快速修复后：\n\n\n      String defaultName = \"default\";\n      boolean isDefault = defaultName.equals(name);\n\n2018.3 最新变化\n\n此检查取决于 Java 功能 'java.util.Objects API'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectsEqualsCanBeSimplified",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassLoaderInstantiation",
                "shortDescription": {
                  "text": "'ClassLoader' 实例化"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.ClassLoader' 类的实例化。 虽然通常是良性的，但在任何安全审核中都应该仔细检查 'ClassLoader' 的任何实例化。 示例： 'Class<?> loadExtraClass(String name) throws Exception {\n      try(URLClassLoader loader =\n          new URLClassLoader(new URL[]{new URL(\"extraClasses/\")})) {\n        return loader.loadClass(name);\n      }\n    }'",
                  "markdown": "报告 `java.lang.ClassLoader` 类的实例化。\n\n虽然通常是良性的，但在任何安全审核中都应该仔细检查 `ClassLoader` 的任何实例化。\n\n**示例：**\n\n        Class<?> loadExtraClass(String name) throws Exception {\n          try(URLClassLoader loader =\n              new URLClassLoader(new URL[]{new URL(\"extraClasses/\")})) {\n            return loader.loadClass(name);\n          }\n        }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassLoaderInstantiation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldNotUsedInToString",
                "shortDescription": {
                  "text": "字段未在 'toString()' 方法中使用"
                },
                "fullDescription": {
                  "text": "报告在类的 'toString()' 方法中未使用的字段。 帮助发现在 'toString()' 方法上次更新后添加的字段。 该快速修复会重新生成 'toString()' 方法。 在 生成 | toString() 对话框中，可以从此检查中排除字段。 如果在代码生成中启用 getter 选项，则此检查还将检查 getter 方法是否存在问题。 示例： 'public class Relevant {\n    private String name; // 未在 toString() 中使用\n    private int index;\n    private int length;\n\n    @Override\n    public String toString() {\n        return \"Relevant{\" + \"index=\" + index +\n          \", length=\" + length + '}';\n    }\n  }' 在应用快速修复后： 'public class Relevant {\n    private String name;\n    private int index;\n    private int length;\n\n    @Override\n    public String toString() {\n        return \"Relevant{\" + \"name='\" + name + '\\'' +\n          \", index=\" + index + \", length=\" + length + '}';\n    }\n  }'",
                  "markdown": "报告在类的 `toString()` 方法中未使用的字段。\n\n帮助发现在 `toString()` 方法上次更新后添加的字段。\n该快速修复会重新生成 `toString()` 方法。\n\n\n在 **生成 \\| toString()** 对话框中，可以从此检查中排除字段。\n如果*在代码生成中启用 getter* 选项，则此检查还将检查 getter 方法是否存在问题。\n\n示例：\n\n\n      public class Relevant {\n        private String name; // 未在 toString() 中使用\n        private int index;\n        private int length;\n\n        @Override\n        public String toString() {\n            return \"Relevant{\" + \"index=\" + index +\n              \", length=\" + length + '}';\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Relevant {\n        private String name;\n        private int index;\n        private int length;\n\n        @Override\n        public String toString() {\n            return \"Relevant{\" + \"name='\" + name + '\\'' +\n              \", index=\" + index + \", length=\" + length + '}';\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldNotUsedInToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/toString() 问题",
                      "index": 122,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CovariantEquals",
                "shortDescription": {
                  "text": "协变 'equals()'"
                },
                "fullDescription": {
                  "text": "如果包含类没有将 'java.lang.Object' 作为其实参类型的其他 'equals()' 重载，则报告采用 'java.lang.Object' 以外的实参类型的 'equals()' 方法。 'equals()' 的协变版本不会重写 'Object.equals(Object)' 方法。 它可能会在运行时导致意外行为。 例如，如果该类用于构造一个标准集合类，该集合类预期会重写 'Object.equals(Object)' 方法。 示例： 'class Foo {\n      public boolean equals(Foo foo) {  // 警告\n          return false;\n      }\n  }\n  class Bar {\n      public boolean equals(Bar bar) {  // 此处无警告\n          return false;\n      }\n      @Override\n      public boolean equals(Object obj) {\n          return false;\n      }\n  }'",
                  "markdown": "如果包含类没有将 `java.lang.Object` 作为其实参类型的其他 `equals()` 重载，则报告采用 `java.lang.Object` 以外的实参类型的 `equals()` 方法。\n\n\n`equals()` 的协变版本不会重写 `Object.equals(Object)` 方法。 它可能会在运行时导致意外行为。 例如，如果该类用于构造一个标准集合类，该集合类预期会重写 `Object.equals(Object)` 方法。\n\n**示例：**\n\n\n      class Foo {\n          public boolean equals(Foo foo) {  // 警告\n              return false;\n          }\n      }\n      class Bar {\n          public boolean equals(Bar bar) {  // 此处无警告\n              return false;\n          }\n          @Override\n          public boolean equals(Object obj) {\n              return false;\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CovariantEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2Lambda",
                "shortDescription": {
                  "text": "匿名类型可被替换为 lambda"
                },
                "fullDescription": {
                  "text": "报告可以替换为 lambda 表达式的匿名类。 示例： 'new Thread(new Runnable() {\n    @Override\n    public void run() {\n      // 运行线程\n    }\n  });' 在应用快速修复后： 'new Thread(() -> {\n    // 运行线程\n  });' 请注意，如果将匿名类转换为无状态 lambda，则 Java 运行时可以在后续调用期间重用相同的 lambda 对象。 另一方面，当使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 'HashMap' 键时。 使用在接口未使用 @FunctionalInterface 注解时报告选项可忽略匿名类实现没有 '@FunctionalInterface' 注解的接口的情况。 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为 lambda 表达式的匿名类。\n\n示例：\n\n\n      new Thread(new Runnable() {\n        @Override\n        public void run() {\n          // 运行线程\n        }\n      });\n\n在应用快速修复后：\n\n\n      new Thread(() -> {\n        // 运行线程\n      });\n\n\n请注意，如果将匿名类转换为无状态 lambda，则 Java 运行时可以在后续调用期间重用相同的 lambda 对象。 另一方面，当使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 `HashMap` 键时。\n\n\n使用**在接口未使用 @FunctionalInterface 注解时报告** 选项可忽略匿名类实现没有 `@FunctionalInterface` 注解的接口的情况。\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Convert2Lambda",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NativeMethods",
                "shortDescription": {
                  "text": "本地方法"
                },
                "fullDescription": {
                  "text": "报告被声明为 'native' 的方法。 原生方法本质上不可移植。",
                  "markdown": "报告被声明为 `native` 的方法。 原生方法本质上不可移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NativeMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableIfStatement",
                "shortDescription": {
                  "text": "'if' 语句可被替换为条件或布尔表达式"
                },
                "fullDescription": {
                  "text": "报告可以替换为使用 '&&'、'||'、'=='、'!=' 或 '?:' 运算符的条件的 'if' 语句 。 结果通常更短，但并不总是更清晰，因此不建议在每种情况下都应用此修复程序。 示例： 'if (condition) return true; else return foo;' 在应用快速修复后： 'return condition || foo;' 配置检查： 当建议使用 '?:' 运算符时，请使用 不建议使用 '?:' 运算符 选项禁用警告。 在这种情况下，只会突出显示 '&&'、'||'、'==' 和 '!=' 建议。 快速修复仍将在编辑器中可用。 使用 忽略链式 'if' 语句 选项禁用 'if-else' 链的警告 快速修复仍将在编辑器中可用。 2018.2 最新变化",
                  "markdown": "报告可以替换为使用 `&&`、`||`、`==`、`!=` 或 `?:` 运算符的条件的 `if` 语句 。\n\n结果通常更短，但并不总是更清晰，因此不建议在每种情况下都应用此修复程序。\n\n示例：\n\n\n      if (condition) return true; else return foo;\n\n在应用快速修复后：\n\n\n      return condition || foo;\n\n配置检查：\n\n* 当建议使用 `?:` 运算符时，请使用 **不建议使用 '?:' 运算符** 选项禁用警告。 在这种情况下，只会突出显示 `&&`、`||`、`==` 和 `!=` 建议。 快速修复仍将在编辑器中可用。\n* 使用 **忽略链式 'if' 语句** 选项禁用 `if-else` 链的警告 快速修复仍将在编辑器中可用。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifiableIfStatement",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsWithItself",
                "shortDescription": {
                  "text": "在自身上调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告对 'equals()'、'compareTo()' 或比较一个对象是否与自身相等的类似方法的调用。 这些方法的方法约定指定了此类调用将始终为 'equals()' 返回 'true' 或为 'compareTo()' 返回 '0'。 该检查还会检查对 'Objects.equals()'、'Objects.deepEquals()'、'Arrays.equals()'、'Comparator.compare()'、测试框架（JUnit、TestNG、AssertJ）的 'assertEquals()' 方法、'Integer.compare()'、'Integer.compareUnsigned()' 以及类似方法的调用。 示例： 'class Foo {\n    boolean foo(Object o) {\n        return o.equals(o); // 警告\n    }\n\n    boolean bar(String[] ss) {\n        return Arrays.equals(ss, ss); // 警告\n    }\n}' 使用该选项可以仅报告对不可扩展的库类（如 'String'）和基元类型的测试断言。 当测试 'equals' 方法时，此选项可能很有用。",
                  "markdown": "报告对 `equals()`、`compareTo()` 或比较一个对象是否与自身相等的类似方法的调用。 这些方法的方法约定指定了此类调用将始终为 `equals()` 返回 `true` 或为 `compareTo()` 返回 `0`。 该检查还会检查对 `Objects.equals()`、`Objects.deepEquals()`、`Arrays.equals()`、`Comparator.compare()`、测试框架（JUnit、TestNG、AssertJ）的 `assertEquals()` 方法、`Integer.compare()`、`Integer.compareUnsigned()` 以及类似方法的调用。\n\n**示例：**\n\n\n      class Foo {\n        boolean foo(Object o) {\n            return o.equals(o); // 警告\n        }\n\n        boolean bar(String[] ss) {\n            return Arrays.equals(ss, ss); // 警告\n        }\n    }\n\n\n使用该选项可以仅报告对不可扩展的库类（如 `String`）和基元类型的测试断言。\n当测试 `equals` 方法时，此选项可能很有用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsWithItself",
                    "cweIds": [
                      571
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassInheritanceDepth",
                "shortDescription": {
                  "text": "类在继承树中太深"
                },
                "fullDescription": {
                  "text": "报告继承层次结构过深的类。 继承太深的类可能令人困惑，并表明有必要重构。 库中的所有超类都被视为单个超类，库被认为不可修改。 使用继承深度限制字段可指定类的最大继承深度。",
                  "markdown": "报告继承层次结构过深的类。\n\n继承太深的类可能令人困惑，并表明有必要重构。\n\n库中的所有超类都被视为单个超类，库被认为不可修改。\n\n使用**继承深度限制**字段可指定类的最大继承深度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassTooDeepInInheritanceTree",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowCaughtLocally",
                "shortDescription": {
                  "text": "通过包含 'try' 语句捕获 'throw'"
                },
                "fullDescription": {
                  "text": "报告异常始终可以通过包含 'try' 语句捕获的 'throw' 语句。 使用 'throw' 语句作为 \"goto\" 来更改局部控制流会令人困惑并导致性能不佳。 示例： 'try {\n    if (!Files.isDirectory(PROJECTS)) {\n        throw new IllegalStateException(\"Directory not found.\"); // 警告：'throw' 被所包含的 'try' 语句捕获\n    }\n    ...\n  } catch (Exception e) {\n      LOG.error(\"run failed\");\n  }' 使用忽略重新抛出的异常选项可忽略重新抛出的异常。",
                  "markdown": "报告异常始终可以通过包含 `try` 语句捕获的 `throw` 语句。\n\n使用 `throw` 语句作为 \"goto\" 来更改局部控制流会令人困惑并导致性能不佳。\n\n**示例：**\n\n\n      try {\n        if (!Files.isDirectory(PROJECTS)) {\n            throw new IllegalStateException(\"Directory not found.\"); // 警告：'throw' 被所包含的 'try' 语句捕获\n        }\n        ...\n      } catch (Exception e) {\n          LOG.error(\"run failed\");\n      }\n\n使用**忽略重新抛出的异常**选项可忽略重新抛出的异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowCaughtLocally",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkedForRemoval",
                "shortDescription": {
                  "text": "使用API标记为删除"
                },
                "fullDescription": {
                  "text": "报告已用 '@Deprecated(forRemoval=true)' 标记为移除的已弃用的 API（类、字段和方法）的用法。 使用标记为移除的 API 的代码可能会导致未来版本的 API 出现运行时错误。 这就是为什么此检查的推荐严重性为 Error。 如果您想使用与普通弃用相同的代码高亮显示，您可以将严重性更改为 警告。 2017.3 最新变化",
                  "markdown": "报告已用 `@Deprecated(`**forRemoval**`=true)` 标记为移除的已弃用的 API（类、字段和方法）的用法。\n\n\n使用标记为移除的 API 的代码可能会导致未来版本的 API 出现运行时错误。 这就是为什么此检查的推荐严重性为 *Error*。\n\n\n如果您想使用与普通弃用相同的代码高亮显示，您可以将严重性更改为 *警告*。\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "removal",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableWithSerialVersionUIDField",
                "shortDescription": {
                  "text": "具有 'serialVersionUID' 的不可序列化类"
                },
                "fullDescription": {
                  "text": "报告定义 'serialVersionUID' 字段的非 'Serializable' 类。 该上下文中的 'serialVersionUID' 字段通常表明有错误，因为该字段将被忽略，且该类将不会被序列化。 示例： 'public class IWantToSerializeThis {\n    private static final long serialVersionUID = 2669293150219020249L;\n  }'",
                  "markdown": "报告定义 `serialVersionUID` 字段的非 `Serializable` 类。 该上下文中的 `serialVersionUID` 字段通常表明有错误，因为该字段将被忽略，且该类将不会被序列化。\n\n**示例：**\n\n\n      public class IWantToSerializeThis {\n        private static final long serialVersionUID = 2669293150219020249L;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableClassWithSerialVersionUID",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnValueBasedClass",
                "shortDescription": {
                  "text": "基于值的警告"
                },
                "fullDescription": {
                  "text": "报告尝试在基于值的类的实例上进行同步的情况，从 Java 16 开始，这些实例会生成编译时警告并引发运行时异常。 例如，'java.lang.Double' 用 'jdk.internal.ValueBased' 注解，因此以下代码会产生编译时警告： 'Double d = 20.0;\nsynchronized (d) { ... } // javac 警告' 2021.1 最新变化",
                  "markdown": "报告尝试在基于值的类的实例上进行同步的情况，从 Java 16 开始，这些实例会生成编译时警告并引发运行时异常。\n\n\n例如，`java.lang.Double` 用 `jdk.internal.ValueBased` 注解，因此以下代码会产生编译时警告：\n\n\n    Double d = 20.0;\n    synchronized (d) { ... } // javac 警告\n\n2021.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "synchronization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/编译器问题",
                      "index": 88,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedConditionalExpression",
                "shortDescription": {
                  "text": "嵌套条件表达式"
                },
                "fullDescription": {
                  "text": "报告嵌套的条件表达式，因为它们可能导致代码格外令人困惑。 示例： 'int y = a == 10 ? b == 20 ? 10 : a : b;'",
                  "markdown": "报告嵌套的条件表达式，因为它们可能导致代码格外令人困惑。\n\n示例：\n\n\n      int y = a == 10 ? b == 20 ? 10 : a : b;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhileCanBeForeach",
                "shortDescription": {
                  "text": "'while' 循环可被替换为增强的 'for' 循环"
                },
                "fullDescription": {
                  "text": "报告迭代集合并且可以替换为增强型 'for' 循环（foreach 迭代语法）的 'while' 循环。 示例： 'Iterator it = c.iterator();\n  while(it.hasNext()) {\n    Object obj = it.next();\n    System.out.println(obj);\n  }' 可以替换为： 'for (Object obj : c) {\n    System.out.println(obj);\n  }' 此检查取决于 Java 功能 'For-each 循环'，该功能自 Java 5 起可用。",
                  "markdown": "报告迭代集合并且可以替换为增强型 `for` 循环（foreach 迭代语法）的 `while` 循环。\n\n**示例：**\n\n\n      Iterator it = c.iterator();\n      while(it.hasNext()) {\n        Object obj = it.next();\n        System.out.println(obj);\n      }\n\n可以替换为：\n\n\n      for (Object obj : c) {\n        System.out.println(obj);\n      }\n\n此检查取决于 Java 功能 'For-each 循环'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WhileLoopReplaceableByForEach",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitNumericConversion",
                "shortDescription": {
                  "text": "隐式数字转换"
                },
                "fullDescription": {
                  "text": "报告数值类型之间的隐式转换。 隐式数字转换本身不是问题，但如果是意外，可能会在跟踪错误时造成困难。 示例： 'double m(int i) {\n    return i * 10;\n  }' 在应用快速修复后： 'double m(int i) {\n    return (double) (i * 10);\n  }' 配置检查： 使用忽略扩大转换选项可以忽略不会导致数据丢失的隐式转换（例如，'int'->'long'）。 使用忽略 'char' 与其他类型之间的转换选项可以忽略 'char' 与其他类型之间的转换。 该检查仍将报告浮点数与其他类型之间的转换。 使用忽略来自常量和文字的转换可使检查忽略来自文字和编译时常量的转换。",
                  "markdown": "报告数值类型之间的隐式转换。\n\n隐式数字转换本身不是问题，但如果是意外，可能会在跟踪错误时造成困难。\n\n**示例：**\n\n\n      double m(int i) {\n        return i * 10;\n      }\n\n在应用快速修复后：\n\n\n      double m(int i) {\n        return (double) (i * 10);\n      }\n\n配置检查：\n\n* 使用**忽略扩大转换** 选项可以忽略不会导致数据丢失的隐式转换（例如，`int`-\\>`long`）。\n* 使用**忽略 'char' 与其他类型之间的转换** 选项可以忽略 `char` 与其他类型之间的转换。 该检查仍将报告浮点数与其他类型之间的转换。\n* 使用**忽略来自常量和文字的转换**可使检查忽略来自文字和编译时常量的转换。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitNumericConversion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BulkFileAttributesRead",
                "shortDescription": {
                  "text": "可使用批量 'Files.readAttributes()' 调用"
                },
                "fullDescription": {
                  "text": "报告连续多个 'java.io.File' 特性检查，例如： 'isDirectory()' 'isFile()' 'lastModified()' 'length()' 此类调用可被替换为批量 'Files.readAttributes()' 调用。 这通常比多个单独的特性检查性能更好。 示例： 'boolean isNewFile(File file, long lastModified) throws IOException {\n    return file.isFile() && file.lastModified() > lastModified;\n  }' 在应用快速修复后： 'boolean isNewFile(File file, long lastModified) throws IOException {\n    var fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n    return fileAttributes.isRegularFile() && fileAttributes.lastModifiedTime().toMillis() > lastModified;\n  }' 如果 'IOException' 在当前上下文中未被处理，则此检查不会显示警告，但快速修复仍然可用。 请注意，替换通常不完全相同，应谨慎使用。 特别是，如果文件根本不存在，行为可能会有所不同。 仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。 2022.1 最新变化",
                  "markdown": "报告连续多个 `java.io.File` 特性检查，例如：\n\n* `isDirectory()`\n* `isFile()`\n* `lastModified()`\n* `length()`\n\n此类调用可被替换为批量 `Files.readAttributes()` 调用。 这通常比多个单独的特性检查性能更好。\n\n示例：\n\n\n      boolean isNewFile(File file, long lastModified) throws IOException {\n        return file.isFile() && file.lastModified() > lastModified;\n      }\n\n在应用快速修复后：\n\n\n      boolean isNewFile(File file, long lastModified) throws IOException {\n        var fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n        return fileAttributes.isRegularFile() && fileAttributes.lastModifiedTime().toMillis() > lastModified;\n      }\n\n如果 `IOException` 在当前上下文中未被处理，则此检查不会显示警告，但快速修复仍然可用。\n\n请注意，替换通常不完全相同，应谨慎使用。 特别是，如果文件根本不存在，行为可能会有所不同。\n\n仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BulkFileAttributesRead",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NotNullFieldNotInitialized",
                "shortDescription": {
                  "text": "@NotNull 字段未初始化"
                },
                "fullDescription": {
                  "text": "报告构造函数中未初始化的注解为非 null 的字段。 示例： 'public class MyClass {\n  private @NotNull String value;\n\n  public void setValue(@NotNull String value) {\n    this.value = value;\n  }\n\n  public @NotNull String getValue() {\n    return value;\n  }\n}' 此类字段可能违反非 null 约束。 在上例中，'setValue' 形参注解为非 null，但是如果没有调用 setter，'getValue' 可能返回 null。",
                  "markdown": "报告构造函数中未初始化的注解为非 null 的字段。\n\n示例：\n\n    public class MyClass {\n      private @NotNull String value;\n\n      public void setValue(@NotNull String value) {\n        this.value = value;\n      }\n\n      public @NotNull String getValue() {\n        return value;\n      }\n    }\n\n\n此类字段可能违反非 null 约束。 在上例中，`setValue` 形参注解为非 null，但是如果没有调用 setter，`getValue` 可能返回 null。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NotNullFieldNotInitialized",
                    "cweIds": [
                      476
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug/为 null 性问题",
                      "index": 118,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyComplexBooleanExpression",
                "shortDescription": {
                  "text": "过度复杂的布尔表达式"
                },
                "fullDescription": {
                  "text": "报告包含太多项的布尔表达式。 此类表达方式可能令人困惑，并且容易出错。 示例： 'cond(x1) && cond(x2) ^ cond(x3) && cond(x4);' 配置检查： 使用最大项数字段可以指定布尔表达式中允许的最大项数。 使用忽略纯合取和析取选项可以忽略重复使用单一布尔运算符的布尔表达式。",
                  "markdown": "报告包含太多项的布尔表达式。 此类表达方式可能令人困惑，并且容易出错。\n\n示例：\n\n\n      cond(x1) && cond(x2) ^ cond(x3) && cond(x4);\n\n配置检查：\n\n* 使用**最大项数**字段可以指定布尔表达式中允许的最大项数。\n* 使用**忽略纯合取和析取**选项可以忽略重复使用单一布尔运算符的布尔表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NotifyCalledOnCondition",
                "shortDescription": {
                  "text": "在 'java.util.concurrent.locks.Condition' 对象上调用了 'notify()' 或 'notifyAll()'"
                },
                "fullDescription": {
                  "text": "报告在 'java.util.concurrent.locks.Condition' 对象上对 'notify()' 或 'notifyAll()' 的调用。 这可能是编程错误，本应使用 'signal()' 或 'signalAll()' 方法的某些变体，否则可能出现 'IllegalMonitorStateException'。 示例： 'class C {\n    final Lock l = new ReentrantLock();\n    final Condition c = l.newCondition();\n\n    void release() {\n      l.lock();\n      try {\n        c.notifyAll(); // 此处可能本应使用 'signalAll()'\n      } finally {\n        l.unlock();\n      }\n    }\n  }'",
                  "markdown": "报告在 `java.util.concurrent.locks.Condition` 对象上对 `notify()` 或 `notifyAll()` 的调用。\n\n\n这可能是编程错误，本应使用 `signal()` 或 `signalAll()` 方法的某些变体，否则可能出现 `IllegalMonitorStateException`。\n\n**示例：**\n\n\n      class C {\n        final Lock l = new ReentrantLock();\n        final Condition c = l.newCondition();\n\n        void release() {\n          l.lock();\n          try {\n            c.notifyAll(); // 此处可能本应使用 'signalAll()'\n          } finally {\n            l.unlock();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NotifyCalledOnCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementsWithoutDefault",
                "shortDescription": {
                  "text": "不带 'default' 分支的 'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告不包含 'default' 标签的 'switch' 语句。 添加 'default' 标签可确保涵盖所有可能的场景，从而更容易对程序的当前状态作出假设。 请注意，默认情况下，如果用于枚举或 'sealed' 类的情况都被覆盖，则检查不会报告 'switch' 语句。 如果您想改变这种行为，请使用忽略详尽的 switch 语句选项。",
                  "markdown": "报告不包含 `default` 标签的 `switch` 语句。\n\n添加 `default` 标签可确保涵盖所有可能的场景，从而更容易对程序的当前状态作出假设。\n\n\n请注意，默认情况下，如果用于枚举或 `sealed` 类的情况都被覆盖，则检查不会报告 `switch` 语句。\n如果您想改变这种行为，请使用**忽略详尽的 switch 语句**选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SwitchStatementWithoutDefaultBranch",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncompatibleMask",
                "shortDescription": {
                  "text": "不兼容的按位掩码运算"
                },
                "fullDescription": {
                  "text": "报告确保评估为 'true' 或 'false' 的按位掩码表达式。 该检查将检查 '(var & constant1) == constant2' 或 '(var | constant1) == constant2' 形式的表达式，其中 'constant1' 和 'constant2' 是不兼容的位掩码常量。 示例： '// 不兼容的掩码：由于掩码以 00 结尾，\n  // 结果可能是 0x1200，但不是 0x1234\n  if ((mask & 0xFF00) == 0x1234) {...}'",
                  "markdown": "报告确保评估为 `true` 或 `false` 的按位掩码表达式。\n\n\n该检查将检查 `(var & constant1) == constant2` 或 `(var | constant1) == constant2` 形式的表达式，其中 `constant1` 和 `constant2` 是不兼容的位掩码常量。\n\n**示例：**\n\n      // 不兼容的掩码：由于掩码以 00 结尾，\n      // 结果可能是 0x1200，但不是 0x1234\n      if ((mask & 0xFF00) == 0x1234) {...}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncompatibleBitwiseMaskOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/按位运算问题",
                      "index": 98,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewMethodNamingConvention",
                "shortDescription": {
                  "text": "方法命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的方法。 此检查将忽略重写库方法和构造函数的实例方法。 示例：如果对 static 方法启用检查，并且指定的方法名称的最小长度为 4（默认值），则以下 static 方法会产生警告，因为其名称长度为 3，即小于 4：'public static int max(int a, int b)'。 只能在编辑器中使用重命名此类方法的快速修复。 配置检查： 使用选项部分中的列表可指定应检查哪些方法。 取消选中要跳过检查的方法类型的复选框。 在长度字段中指定 0 可跳过相应检查。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的方法。\n\n此检查将忽略重写库方法和构造函数的实例方法。\n\n**示例** ：如果对 static 方法启用检查，并且指定的方法名称的最小长度为 4（默认值），则以下 static 方法会产生警告，因为其名称长度为 3，即小于 4：`public static int max(int a, int b)`。\n\n只能在编辑器中使用重命名此类方法的快速修复。\n\n配置检查：\n\n使用**选项** 部分中的列表可指定应检查哪些方法。 取消选中要跳过检查的方法类型的复选框。 在长度字段中指定 **0** 可跳过相应检查。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewMethodNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitArgumentCanBeLambda",
                "shortDescription": {
                  "text": "显式实参可以是 lambda"
                },
                "fullDescription": {
                  "text": "报告接受非普通表达式的方法调用，这些方法调用可以替换为接受 lambda 的等效方法调用。 将表达式转换为 lambda 可确保不会评估方法中未使用的表达式。 例如，'optional.orElse(createDefaultValue())' 可以转换为 'optional.orElseGet(this::createDefaultValue)'。 2018.1 最新变化 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告接受非普通表达式的方法调用，这些方法调用可以替换为接受 lambda 的等效方法调用。\n\n\n将表达式转换为 lambda 可确保不会评估方法中未使用的表达式。 例如，`optional.orElse(createDefaultValue())` 可以转换为 `optional.orElseGet(this::createDefaultValue)`。\n\n2018.1 最新变化\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ExplicitArgumentCanBeLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsCalledOnEnumConstant",
                "shortDescription": {
                  "text": "对枚举值调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告枚举常量上的 'equals()' 调用。 此类调用可以替换为同一性比较 ('==')，因为只有两个枚举常量具备相同的同一性时，它们才相等。 可以通过快速修复将该调用更改为比较。 示例： 'boolean foo(MyEnum value) {\n    return value.equals(MyEnum.FOO);\n  }' 在应用快速修复后： 'boolean foo(MyEnum value) {\n    return value == MyEnum.FOO;\n  }'",
                  "markdown": "报告枚举常量上的 `equals()` 调用。\n\n此类调用可以替换为同一性比较 (`==`)，因为只有两个枚举常量具备相同的同一性时，它们才相等。\n\n可以通过快速修复将该调用更改为比较。\n\n**示例：**\n\n\n      boolean foo(MyEnum value) {\n        return value.equals(MyEnum.FOO);\n      }\n\n在应用快速修复后：\n\n\n      boolean foo(MyEnum value) {\n        return value == MyEnum.FOO;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsCalledOnEnumConstant",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyStrongTypeCast",
                "shortDescription": {
                  "text": "过强的类型转换"
                },
                "fullDescription": {
                  "text": "报告过强的类型转换。 例如，将对象转换为 'ArrayList'，将其转换为 'List' 也可以。 注意：与冗余类型转换检查非常相似，如果您有意使用过强的转换来生成 'ClassCastException'，则对此检查应用修正可能会改变程序的语义。 示例： 'interface Super {\n    void doSmth();\n  }\n  interface Sub extends Super { }\n\n  void use(Object obj) {\n    // 警告：可以使用 ((Super)obj).doSmth()\n    ((Sub)obj).doSmth();\n  }' 在代码中有匹配的 'instanceof' 检查时，使用下面的复选框可忽略转换。",
                  "markdown": "报告过强的类型转换。 例如，将对象转换为 `ArrayList`，将其转换为 `List` 也可以。\n\n\n**注意** ：与*冗余类型转换* 检查非常相似，如果您有意使用过强的转换来生成 `ClassCastException`，则对此检查应用修正可能会改变程序的语义。\n\n示例：\n\n\n      interface Super {\n        void doSmth();\n      }\n      interface Sub extends Super { }\n\n      void use(Object obj) {\n        // 警告：可以使用 ((Super)obj).doSmth()\n        ((Sub)obj).doSmth();\n      }\n\n\n在代码中有匹配的 `instanceof` 检查时，使用下面的复选框可忽略转换。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyStrongTypeCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaLangImport",
                "shortDescription": {
                  "text": "'java.lang' 软件包中有不必要的 import"
                },
                "fullDescription": {
                  "text": "报告引用 'java.lang' 软件包的 'import' 语句。 'java.lang' 类始终隐式导入，因此此类 import 语句冗余，也令人困惑。 IntelliJ IDEA 可以通过优化 import 命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。",
                  "markdown": "报告引用 `java.lang` 软件包的 `import` 语句。\n\n\n`java.lang` 类始终隐式导入，因此此类 import 语句冗余，也令人困惑。\n\n\nIntelliJ IDEA 可以通过**优化 import** 命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaLangImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClass",
                "shortDescription": {
                  "text": "实用程序类"
                },
                "fullDescription": {
                  "text": "报告实用程序类。 实用程序类将所有字段和方法声明为 'static'，存在这样的情况可能表明欠缺面向对象的设计。 使用有注解时忽略选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的类。",
                  "markdown": "报告实用程序类。\n\n实用程序类将所有字段和方法声明为 `static`，存在这样的情况可能表明欠缺面向对象的设计。\n\n\n使用**有注解时忽略**选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNameDiffersFromFileName",
                "shortDescription": {
                  "text": "类名与文件名不同"
                },
                "fullDescription": {
                  "text": "报告所属的文件名与其不匹配的顶层类名。 虽然 Java 规范允许以这种方式命名非 'public' 类，但名称不匹配的文件可能令人困惑，并降低各种软件工具的实用性。",
                  "markdown": "报告所属的文件名与其不匹配的顶层类名。\n\n虽然 Java 规范允许以这种方式命名非 `public` 类，但名称不匹配的文件可能令人困惑，并降低各种软件工具的实用性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNameDiffersFromFileName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HardcodedLineSeparators",
                "shortDescription": {
                  "text": "硬编码行分隔符"
                },
                "fullDescription": {
                  "text": "报告字符串文字、字符文字或文本块中使用的换行 ('\\n') 和回车 ('\\r') 字符转义序列。 这些字符通常用作行分隔符，如果它们被硬编码，可移植性可能会受到影响。 示例： 'String count = \"first\\nsecond\\rthird\";'",
                  "markdown": "报告字符串文字、字符文字或文本块中使用的换行 (`\\n`) 和回车 (`\\r`) 字符转义序列。 这些字符通常用作行分隔符，如果它们被硬编码，可移植性可能会受到影响。\n\n**示例：**\n\n\n      String count = \"first\\nsecond\\rthird\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HardcodedLineSeparator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryConstantArrayCreationExpression",
                "shortDescription": {
                  "text": "常量数组创建中的冗余 'new' 表达式"
                },
                "fullDescription": {
                  "text": "报告可以替换为数组初始值设定项的常量新数组表达式。 数组初始值设定项可以省略类型，因为它已在赋值的左侧指定。 示例： 'int[] foo = new int[] {42};' 在应用快速修复后： 'int[] foo = {42};'",
                  "markdown": "报告可以替换为数组初始值设定项的常量新数组表达式。 数组初始值设定项可以省略类型，因为它已在赋值的左侧指定。\n\n**示例：**\n\n\n      int[] foo = new int[] {42};\n\n在应用快速修复后：\n\n\n      int[] foo = {42};\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryConstantArrayCreationExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LabeledStatement",
                "shortDescription": {
                  "text": "标记语句"
                },
                "fullDescription": {
                  "text": "报告可能导致重构和方法控制流复杂化的语句。 示例： 'label:\n  while (true) {\n      // 代码\n  }'",
                  "markdown": "报告可能导致重构和方法控制流复杂化的语句。\n\n示例：\n\n\n      label:\n      while (true) {\n          // 代码\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LabeledStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IndexOfReplaceableByContains",
                "shortDescription": {
                  "text": "'String.indexOf()' 表达式可被替换为 'contains()'"
                },
                "fullDescription": {
                  "text": "报告与 'String.indexOf()' 调用（可以替换为对 'String.contains()' 方法的调用）的比较。 示例： 'boolean b = \"abcd\".indexOf('e') >= 0;' 在应用快速修复后： 'boolean b = \"abcd\".contains('e');' 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告与 `String.indexOf()` 调用（可以替换为对 `String.contains()` 方法的调用）的比较。\n\n**示例：**\n\n\n      boolean b = \"abcd\".indexOf('e') >= 0;\n\n在应用快速修复后：\n\n\n      boolean b = \"abcd\".contains('e');\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IndexOfReplaceableByContains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationArgumentToLogCall",
                "shortDescription": {
                  "text": "非常量字符串串联作为日志调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作 SLF4J 和 Log4j 2 日志记录方法实参的非常量字符串串联。 即使未记录日志消息，也会在运行时评估非常量串联；这会对性能产生负面影响。 建议改用形参化日志消息，禁用日志记录时不会对其进行评估。 示例： 'public class Vital {\n    private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n    public void saveTheWorld(int i, String s, boolean b) {\n      LOG.info(\"saveTheWorld(\" + i + \", \" + s + \", \"  + b + \")\");\n      // todo\n    }\n  }' 在应用快速修复后： 'public class Vital {\n    private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n    public void saveTheWorld(int i, String s, boolean b) {\n      LOG.info(\"saveTheWorld({}, {}, {})\", i, s, b);\n      // todo\n    }\n  }' 配置检查： 使用警告对象列表可以忽略某些更高的日志记录级别。 即使在生产中也可以启用更高的日志记录级别，并且始终会评估实参。",
                  "markdown": "报告用作 **SLF4J** 和 **Log4j 2** 日志记录方法实参的非常量字符串串联。 即使未记录日志消息，也会在运行时评估非常量串联；这会对性能产生负面影响。 建议改用形参化日志消息，禁用日志记录时不会对其进行评估。\n\n**示例：**\n\n\n      public class Vital {\n        private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n        public void saveTheWorld(int i, String s, boolean b) {\n          LOG.info(\"saveTheWorld(\" + i + \", \" + s + \", \"  + b + \")\");\n          // todo\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Vital {\n        private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n        public void saveTheWorld(int i, String s, boolean b) {\n          LOG.info(\"saveTheWorld({}, {}, {})\", i, s, b);\n          // todo\n        }\n      }\n\n\n配置检查：\n\n* 使用**警告对象**列表可以忽略某些更高的日志记录级别。 即使在生产中也可以启用更高的日志记录级别，并且始终会评估实参。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "StringConcatenationArgumentToLogCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousNameCombination",
                "shortDescription": {
                  "text": "可疑的变量/形参名称组合"
                },
                "fullDescription": {
                  "text": "报告目标变量或函数形参的名称与分配给它的值的名称不匹配的赋值和函数调用。 示例 1： 'int x = 0;\n  int y = x; // x 用作 y 坐标' 示例 2： 'int x = 0, y = 0;\n  // x 用作 y 坐标，y 用作 x 坐标\n  Rectangle rc = new Rectangle(y, x, 20, 20);' 配置检查： 使用名称组区域可以指定不应一起使用的名称：如果形参名称或赋值目标名称包含一个组中的字词，而赋值或传递的变量名称包含另一个组中的字词，就会报告错误。 使用忽略方法区域可以指定不应检查但名称可能存疑的方法。 例如，'Integer.compare()' 形参被命名为 'x' 和 'y'，但与坐标无关。",
                  "markdown": "报告目标变量或函数形参的名称与分配给它的值的名称不匹配的赋值和函数调用。\n\n示例 1：\n\n\n      int x = 0;\n      int y = x; // x 用作 y 坐标\n      \n示例 2：\n\n\n      int x = 0, y = 0;\n      // x 用作 y 坐标，y 用作 x 坐标\n      Rectangle rc = new Rectangle(y, x, 20, 20);\n\n配置检查：\n\n使用**名称组**区域可以指定不应一起使用的名称：如果形参名称或赋值目标名称包含一个组中的字词，而赋值或传递的变量名称包含另一个组中的字词，就会报告错误。\n\n使用**忽略方法** 区域可以指定不应检查但名称可能存疑的方法。\n例如，`Integer.compare()` 形参被命名为 `x` 和 `y`，但与坐标无关。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousNameCombination",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitDefaultCharsetUsage",
                "shortDescription": {
                  "text": "隐式平台默认字符集"
                },
                "fullDescription": {
                  "text": "报告隐式使用平台默认字符集的方法和构造函数调用。 此类调用可能会在使用不同默认字符集的系统上产生不同的结果，并可能导致意外行为。 示例： 'void foo(byte[] bytes) {\n  String s = new String(bytes);\n}'\n 如果相应的重载方法可用，则可以采用指定显式 UTF-8 字符集的快速修复。 在应用快速修复后： 'void foo(byte[] bytes) {\n  String s = new String(bytes, StandardCharsets.UTF_8);\n}'",
                  "markdown": "报告隐式使用平台默认字符集的方法和构造函数调用。 此类调用可能会在使用不同默认字符集的系统上产生不同的结果，并可能导致意外行为。\n\n**示例：**\n\n    void foo(byte[] bytes) {\n      String s = new String(bytes);\n    }\n\n如果相应的重载方法可用，则可以采用指定显式 UTF-8 字符集的快速修复。\n在应用快速修复后：\n\n    void foo(byte[] bytes) {\n      String s = new String(bytes, StandardCharsets.UTF_8);\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitDefaultCharsetUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DesignForExtension",
                "shortDescription": {
                  "text": "为扩展设计"
                },
                "fullDescription": {
                  "text": "报告非 'static'、'private'、'final' 或 'abstract'，且其语句体不为空的方法。 使用避免此类方法的样式进行编码可以保护类的约定不会被它们的子类破坏。 这种样式的好处是子类不会因为忘记调用 super 方法而破坏超类的状态。 代价是子类的灵活性受到限制，特别是它们不能阻止超类中代码的执行。 使用该快速修复可以添加缺失的修饰符。 示例： 'class Foo {\n    public boolean equals(Object o) { return true; }\n  }' 在应用快速修复后： 'class Foo {\n    public final boolean equals(Object o) { return true; }\n  }' 此检查适用于将在安全环境中使用的代码，可能不适合限制较少的环境。",
                  "markdown": "报告非 `static`、`private`、`final` 或 `abstract`，且其语句体不为空的方法。\n\n\n使用避免此类方法的样式进行编码可以保护类的约定不会被它们的子类破坏。 这种样式的好处是子类不会因为忘记调用 super 方法而破坏超类的状态。 代价是子类的灵活性受到限制，特别是它们不能阻止超类中代码的执行。 使用该快速修复可以添加缺失的修饰符。\n\n**示例：**\n\n\n      class Foo {\n        public boolean equals(Object o) { return true; }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        public final boolean equals(Object o) { return true; }\n      }\n\n此检查适用于将在安全环境中使用的代码，可能不适合限制较少的环境。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DesignForExtension",
                    "cweIds": [
                      668
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyStreamApiCallChains",
                "shortDescription": {
                  "text": "可以简化 Stream API 调用链"
                },
                "fullDescription": {
                  "text": "报告可以简化的流 API 调用链。 简化通常会在集合遍历期间避免一些临时对象创建操作。 该检查将替换以下调用链： 'collection.stream().forEach()' → 'collection.forEach()' 'collection.stream().collect(toList/toSet/toCollection())' → 'new CollectionType<>(collection)' 'collection.stream().toArray()' → 'collection.toArray()' 'Arrays.asList().stream()' → 'Arrays.stream()' or 'Stream.of()' 'IntStream.range(0, array.length).mapToObj(idx -> array[idx])' → 'Arrays.stream(array)' 'IntStream.range(0, list.size()).mapToObj(idx -> list.get(idx))' → 'list.stream()' 'Collections.singleton().stream()' → 'Stream.of()' 'Collections.emptyList().stream()' → 'Stream.empty()' 'stream.filter().findFirst().isPresent()' → 'stream.anyMatch()' 'stream.collect(counting())' → 'stream.count()' 'stream.collect(maxBy())' → 'stream.max()' 'stream.collect(mapping())' → 'stream.map().collect()' 'stream.collect(reducing())' → 'stream.reduce()' 'stream.collect(summingInt())' → 'stream.mapToInt().sum()' 'stream.mapToObj(x -> x)' → 'stream.boxed()' 'stream.map(x -> {...; return x;})' → 'stream.peek(x -> ...)' '!stream.anyMatch()' → 'stream.noneMatch()' '!stream.anyMatch(x -> !(...))' → 'stream.allMatch()' 'stream.map().anyMatch(Boolean::booleanValue)' → 'stream.anyMatch()' 'IntStream.range(expr1, expr2).mapToObj(x -> array[x])' → 'Arrays.stream(array, expr1, expr2)' 'Collection.nCopies(count, ...)' → 'Stream.generate().limit(count)' 'stream.sorted(comparator).findFirst()' → 'Stream.min(comparator)' 'optional.orElseGet(() -> { throw new ...; })' → 'optional.orElseThrow()' 请注意，在某些情况下，替换语义可能略有差异。 例如，'Collections.synchronizedList(...).stream().forEach()' 不同步，而 'Collections.synchronizedList(...).forEach()' 同步。 另外，如果得到的元素为 'null'，而 'Stream.max()' 在本例中抛出 'NullPointerException'，则 'collect(Collectors.maxBy())' 返回空的 'Optional'。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以简化的流 API 调用链。 简化通常会在集合遍历期间避免一些临时对象创建操作。\n\n\n该检查将替换以下调用链：\n\n* `collection.stream().forEach()` → `collection.forEach()`\n* `collection.stream().collect(toList/toSet/toCollection())` → `new CollectionType<>(collection)`\n* `collection.stream().toArray()` → `collection.toArray()`\n* `Arrays.asList().stream()` → `Arrays.stream()` or `Stream.of()`\n* `IntStream.range(0, array.length).mapToObj(idx -> array[idx])` → `Arrays.stream(array)`\n* `IntStream.range(0, list.size()).mapToObj(idx -> list.get(idx))` → `list.stream()`\n* `Collections.singleton().stream()` → `Stream.of()`\n* `Collections.emptyList().stream()` → `Stream.empty()`\n* `stream.filter().findFirst().isPresent()` → `stream.anyMatch()`\n* `stream.collect(counting())` → `stream.count()`\n* `stream.collect(maxBy())` → `stream.max()`\n* `stream.collect(mapping())` → `stream.map().collect()`\n* `stream.collect(reducing())` → `stream.reduce()`\n* `stream.collect(summingInt())` → `stream.mapToInt().sum()`\n* `stream.mapToObj(x -> x)` → `stream.boxed()`\n* `stream.map(x -> {...; return x;})` → `stream.peek(x -> ...)`\n* `!stream.anyMatch()` → `stream.noneMatch()`\n* `!stream.anyMatch(x -> !(...))` → `stream.allMatch()`\n* `stream.map().anyMatch(Boolean::booleanValue)` → `stream.anyMatch()`\n* `IntStream.range(expr1, expr2).mapToObj(x -> array[x])` → `Arrays.stream(array, expr1, expr2)`\n* `Collection.nCopies(count, ...)` → `Stream.generate().limit(count)`\n* `stream.sorted(comparator).findFirst()` → `Stream.min(comparator)`\n* `optional.orElseGet(() -> { throw new ...; })` → `optional.orElseThrow()`\n\n\n请注意，在某些情况下，替换语义可能略有差异。 例如，`Collections.synchronizedList(...).stream().forEach()` 不同步，而 `Collections.synchronizedList(...).forEach()` 同步。\n另外，如果得到的元素为 `null`，而 `Stream.max()` 在本例中抛出 `NullPointerException`，则 `collect(Collectors.maxBy())` 返回空的 `Optional`。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifyStreamApiCallChains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalContainsCollection",
                "shortDescription": {
                  "text": "'Optional' 包含数组或集合"
                },
                "fullDescription": {
                  "text": "报告包含数组或集合类型形参的 'java.util.Optional' 或 'com.google.common.base.Optional' 类型。 在此类情况下，使用空的数组或集合来表示无结果更为清晰。 示例： 'Optional<List<Integer>> foo() {\n    return Optional.empty();\n  }' 此代码可能如下所示： 'List<Integer> foo() {\n    return List.of();\n  }' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告包含数组或集合类型形参的 `java.util.Optional` 或 `com.google.common.base.Optional` 类型。\n\n在此类情况下，使用空的数组或集合来表示无结果更为清晰。\n\n**示例：**\n\n\n      Optional<List<Integer>> foo() {\n        return Optional.empty();\n      }\n\n此代码可能如下所示：\n\n\n      List<Integer> foo() {\n        return List.of();\n      }\n      \n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalContainsCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnknownGuard",
                "shortDescription": {
                  "text": "未知 '@GuardedBy' 字段"
                },
                "fullDescription": {
                  "text": "报告其中指定的保护字段未知的 '@GuardedBy' 注解。 示例： 'private Object state;\n\n    @GuardedBy(\"lock\") //未知的保护引用\n    public void bar() {\n        state = new Object();\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告其中指定的保护字段未知的 `@GuardedBy` 注解。\n\n示例：\n\n\n        private Object state;\n\n        @GuardedBy(\"lock\") //未知的保护引用\n        public void bar() {\n            state = new Object();\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnknownGuard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableAssertion",
                "shortDescription": {
                  "text": "可简化断言"
                },
                "fullDescription": {
                  "text": "报告任何可以替换为更简单的等效调用的 'assert' 调用。 示例 → 替换 'assertEquals(true, x());' 'assertTrue(x());' 'assertTrue(y() != null);' 'assertNotNull(y());' 'assertTrue(z == z());' 'assertSame(z, z());' 'assertTrue(a.equals(a()));' 'assertEquals(a, a());' 'assertTrue(false);' 'fail();'",
                  "markdown": "报告任何可以替换为更简单的等效调用的 `assert` 调用。\n\n|                示例                | → |           替换            |\n|----------------------------------|---|-------------------------|\n| `assertEquals(`**true**`, x());` |   | `assertTrue(x());`      |\n| `assertTrue(y() != null);`       |   | `assertNotNull(y());`   |\n| `assertTrue(z == z());`          |   | `assertSame(z, z());`   |\n| `assertTrue(a.equals(a()));`     |   | `assertEquals(a, a());` |\n| `assertTrue(`**false**`);`       |   | `fail();`               |"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableAssertion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 97,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoadLibraryWithNonConstantString",
                "shortDescription": {
                  "text": "'System.loadLibrary()' 调用具有非常量字符串"
                },
                "fullDescription": {
                  "text": "报告对'java.lang.System.loadLibrary()'、'java.lang.System.load()'、'java.lang.Runtime.loadLibrary()' 和 'java.lang.Runtime.load()' 的调用，它们会将动态构造的字符串作为库的名称。 构造的库名称字符串是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。 示例： 'void test(int i) {\n    System.loadLibrary(\"foo\" + i);\n  }' 使用检查设置可以将任何 'static final' 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略： 'private static final String LIBRARY = getUserInput();'",
                  "markdown": "报告对`java.lang.System.loadLibrary()`、`java.lang.System.load()`、`java.lang.Runtime.loadLibrary()` 和 `java.lang.Runtime.load()` 的调用，它们会将动态构造的字符串作为库的名称。\n\n\n构造的库名称字符串是安全漏洞的常见来源。\n默认情况下，此检查会忽略编译时常量。\n\n**示例：**\n\n\n      void test(int i) {\n        System.loadLibrary(\"foo\" + i);\n      }\n\n\n使用检查设置可以将任何 `static final` 字段视为常量。\n请小心，因为启用该选项时，像下面这样的字符串将被忽略：\n\n\n      private static final String LIBRARY = getUserInput();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoadLibraryWithNonConstantString",
                    "cweIds": [
                      114,
                      494,
                      676,
                      829
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceMethodClashesWithObject",
                "shortDescription": {
                  "text": "接口方法与 'Object' 中的方法冲突"
                },
                "fullDescription": {
                  "text": "报告与 'java.lang.Object' 类中的 protected 方法 'clone()' 和 'finalize()' 冲突的接口方法。 在接口中，可以使用与 'java.lang.Object' 方法不兼容的返回类型来声明这些方法。 实现此类接口的类不可编译。 当接口正常工作时，虽然仍可根据它创建 lambda，但不建议这样做。 示例： '// // 警告：此接口不能由任何类实现，\n  // 只能由 lambda 或方法引用实现\n  interface MyInterface {\n    double clone();\n  }'",
                  "markdown": "报告与 `java.lang.Object` 类中的 **protected** 方法 `clone()` 和 `finalize()` 冲突的接口方法。\n\n在接口中，可以使用与 `java.lang.Object` 方法不兼容的返回类型来声明这些方法。\n实现此类接口的类不可编译。\n当接口正常工作时，虽然仍可根据它创建 lambda，但不建议这样做。\n\n示例：\n\n\n      // // 警告：此接口不能由任何类实现，\n      // 只能由 lambda 或方法引用实现\n      interface MyInterface {\n        double clone();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceMethodClashesWithObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticMethodOnlyUsedInOneClass",
                "shortDescription": {
                  "text": "static 成员仅在其他一个类中使用"
                },
                "fullDescription": {
                  "text": "报告仅从包含类以外的类使用的 'static' 方法和字段。 此类成员可以移动到所使用的类。 此检查将忽略从成员的类内部的匿名类访问的工厂方法和成员。 调用同一个类中名称相同但形参较少的方法的方便重载也会被忽略。 仅在从测试类使用 static 成员时，可以使用第一个复选框来禁止此检查。 使用下面的第二个复选框可以忽略匿名类、本地类或非 static 内部类中的成员用法。 使用下面的第三个复选框，可以不对没有问题的情况下也无法移动的成员发出警告，例如，由于目标类中已存在签名相同的方法，或者由于移动此方法时将无法访问方法内部使用的字段或方法。 使用第四个复选框可以忽略位于实用程序类中的成员。",
                  "markdown": "报告仅从包含类以外的类使用的 `static` 方法和字段。 此类成员可以移动到所使用的类。 此检查将忽略从成员的类内部的匿名类访问的工厂方法和成员。 调用同一个类中名称相同但形参较少的方法的方便重载也会被忽略。\n\n\n仅在从测试类使用 static 成员时，可以使用第一个复选框来禁止此检查。\n\n\n使用下面的第二个复选框可以忽略匿名类、本地类或非 static 内部类中的成员用法。\n\n\n使用下面的第三个复选框，可以不对没有问题的情况下也无法移动的成员发出警告，例如，由于目标类中已存在签名相同的方法，或者由于移动此方法时将无法访问方法内部使用的字段或方法。\n\n\n使用第四个复选框可以忽略位于实用程序类中的成员。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticMethodOnlyUsedInOneClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassExtendsConcreteClass",
                "shortDescription": {
                  "text": "抽象类扩展具体类"
                },
                "fullDescription": {
                  "text": "报告扩展具体类的 'abstract' 类。",
                  "markdown": "报告扩展具体类的 `abstract` 类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassExtendsConcreteClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEscapeInRegexReplacement",
                "shortDescription": {
                  "text": "正则表达式替换字符串中的冗余转义"
                },
                "fullDescription": {
                  "text": "报告正则表达式方法的替换字符串中的冗余转义。 允许转义正则表达式替换字符串中的任何字符，但只有 '$' 和 '\\' 字符才需要转义。 示例： 'string.replaceAll(\"a\", \"\\\\b\");' 在应用快速修复后： 'string.replaceAll(\"a\", \"b\");' 2022.3 最新变化",
                  "markdown": "报告正则表达式方法的替换字符串中的冗余转义。 允许转义正则表达式替换字符串中的任何字符，但只有 `$` 和 `\\` 字符才需要转义。\n\n**示例：**\n\n\n      string.replaceAll(\"a\", \"\\\\b\");\n\n在应用快速修复后：\n\n\n      string.replaceAll(\"a\", \"b\");\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantEscapeInRegexReplacement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8CollectionRemoveIf",
                "shortDescription": {
                  "text": "循环可被替换为 'Collection.removeIf()'"
                },
                "fullDescription": {
                  "text": "报告可以折叠为单个 'Collection.removeIf()' 调用的循环。 示例： 'for (Iterator<String> it = collection.iterator(); it.hasNext(); ) {\n    String aValue = it.next();\n    if(shouldBeRemoved(aValue)) {\n      it.remove();\n    }\n  }' 在应用快速修复后： 'collection.removeIf(aValue -> shouldBeRemoved(aValue));' 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以折叠为单个 `Collection.removeIf()` 调用的循环。\n\n示例：\n\n\n      for (Iterator<String> it = collection.iterator(); it.hasNext(); ) {\n        String aValue = it.next();\n        if(shouldBeRemoved(aValue)) {\n          it.remove();\n        }\n      }\n\n在应用快速修复后：\n\n\n      collection.removeIf(aValue -> shouldBeRemoved(aValue));\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8CollectionRemoveIf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LogStatementNotGuardedByLogCondition",
                "shortDescription": {
                  "text": "日志调用不受日志条件保护"
                },
                "fullDescription": {
                  "text": "报告未被保护条件包围的日志记录调用。 对调用的实参进行评估可能开销巨大。 当日志记录语句使用的级别禁用日志记录时，使用临界子句包围日志记录调用可避免这种开销。 这对于最不严重的日志记录调用级别（跟踪、调试、最精细）特别有用，因为这些调用在生产环境中最常被禁用。 示例： 'public class TestObject {\n    void test(Object object) {\n      LOG.debug(\"some logging \" + expensiveCalculation(1));\n    }\n  }' 在应用快速修复后： 'public class TestObject {\n    void test(Object object) {\n      if(LOG.isDebugEnabled()){\n        LOG.debug(\"some logging \" + expensiveCalculation(1));\n      }\n    }\n  }' 此检查支持 Log4j2 和 SLF4J 日志记录框架（ 构建器除外）。 2024.2 最新变化",
                  "markdown": "报告未被保护条件包围的日志记录调用。 对调用的实参进行评估可能开销巨大。 当日志记录语句使用的级别禁用日志记录时，使用临界子句包围日志记录调用可避免这种开销。 这对于最不严重的日志记录调用级别（跟踪、调试、最精细）特别有用，因为这些调用在生产环境中最常被禁用。\n\n**示例：**\n\n\n      public class TestObject {\n        void test(Object object) {\n          LOG.debug(\"some logging \" + expensiveCalculation(1));\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class TestObject {\n        void test(Object object) {\n          if(LOG.isDebugEnabled()){\n            LOG.debug(\"some logging \" + expensiveCalculation(1));\n          }\n        }\n      }\n\n此检查支持 *Log4j2* 和 *SLF4J* 日志记录框架（ 构建器除外）。\n\n2024.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LogStatementNotGuardedByLogCondition",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizedOnLiteralObject",
                "shortDescription": {
                  "text": "在使用文字初始化的对象上同步"
                },
                "fullDescription": {
                  "text": "报告在用文字初始化的对象上锁定的 'synchronized' 块。 字符串文字是暂存的，'Character'、'Boolean' 和 'Number' 文字可以从缓存中分配。 正因为如此，可能系统的其他某些部分（使用通过相同文字初始化的对象）实际上会包含对完全相同的对象的引用。 如果锁定对象被认为是 private 对象，这可能会产生意外的死锁情况。 示例： 'class Main {\n    final String mutex = \"Mutex\";\n    void method() {\n      synchronized (mutex) {\n      }\n    }\n  }' 使用警告所有可能的文字选项可以报告 'String'、'Character'、'Boolean' 和 'Number' 对象的任何同步。",
                  "markdown": "报告在用文字初始化的对象上锁定的 `synchronized` 块。\n\n\n字符串文字是暂存的，`Character`、`Boolean` 和 `Number` 文字可以从缓存中分配。\n正因为如此，可能系统的其他某些部分（使用通过相同文字初始化的对象）实际上会包含对完全相同的对象的引用。 如果锁定对象被认为是 private 对象，这可能会产生意外的死锁情况。\n\n**示例：**\n\n\n      class Main {\n        final String mutex = \"Mutex\";\n        void method() {\n          synchronized (mutex) {\n          }\n        }\n      }\n\n\n使用**警告所有可能的文字** 选项可以报告 `String`、`Character`、`Boolean` 和 `Number` 对象的任何同步。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizedOnLiteralObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9ReflectionClassVisibility",
                "shortDescription": {
                  "text": "跨模块问题的反射访问"
                },
                "fullDescription": {
                  "text": "报告 'Class.forName()' 和 'ClassLoader.loadClass()' 调用，这些调用尝试访问由于 Java 9 模块可访问性规则而在当前范围内不可见的类。 此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。",
                  "markdown": "报告 `Class.forName()` 和 `ClassLoader.loadClass()` 调用，这些调用尝试访问由于 Java 9 模块可访问性规则而在当前范围内不可见的类。\n\n此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9ReflectionClassVisibility",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/反射访问",
                      "index": 99,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CharsetObjectCanBeUsed",
                "shortDescription": {
                  "text": "可以使用标准 'Charset' 对象"
                },
                "fullDescription": {
                  "text": "报告可以用预定义的 'StandardCharsets.UTF_8' 代码替换其中常量字符集 'String' 文字（例如，'\"UTF-8\"'）的方法和构造函数。 修复后可以加快代码的速度，因为字符集查找变得不必要。 此外，您可能也不需要捕捉 'UnsupportedEncodingException'。 在这种情况下，catch 块将被自动删除。 示例： 'try {\n    byte[] bytes = \"str\".getBytes(\"UTF-8\");\n  } catch (UnsupportedEncodingException e) {\n  }' 在应用快速修复后： 'byte[] bytes = \"str\".getBytes(StandardCharsets.UTF_8);' 该检查在 Java 7 及更高版本中可用。 2018.2 最新变化",
                  "markdown": "报告可以用预定义的 `StandardCharsets.UTF_8` 代码替换其中常量字符集 `String` 文字（例如，`\"UTF-8\"`）的方法和构造函数。\n\n修复后可以加快代码的速度，因为字符集查找变得不必要。\n此外，您可能也不需要捕捉 `UnsupportedEncodingException`。 在这种情况下，catch 块将被自动删除。\n\n示例：\n\n\n      try {\n        byte[] bytes = \"str\".getBytes(\"UTF-8\");\n      } catch (UnsupportedEncodingException e) {\n      }\n\n在应用快速修复后：\n\n\n      byte[] bytes = \"str\".getBytes(StandardCharsets.UTF_8);\n\n该检查在 Java 7 及更高版本中可用。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CharsetObjectCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SafeVarargsDetector",
                "shortDescription": {
                  "text": "形参化 vararg 类型可能导致堆污染"
                },
                "fullDescription": {
                  "text": "报告所有包含可变 arity 且可以注解为 '@SafeVarargs' 的方法。 '@SafeVarargs' 注解禁止有关在调用点创建形参化数组的未检查的警告。 示例： 'public class Foo<T> {\n    private List<T> list = new ArrayList<>();\n\n    public final void safeVarargs(T... elements) {\n      Collections.addAll(list, elements);\n    }\n  }' 在应用快速修复后： 'public class Foo<T> {\n    private List<T> list = new ArrayList<>();\n\n    @SafeVarargs\n    public final void safeVarargs(T... elements) {\n      Collections.addAll(list, elements);\n    }\n  }' Java 1.6 或更早版本的 JVM 不支持此注解。",
                  "markdown": "报告所有包含可变 arity 且可以注解为 `@SafeVarargs` 的方法。 `@SafeVarargs` 注解禁止有关在调用点创建形参化数组的未检查的警告。\n\n**示例：**\n\n\n      public class Foo<T> {\n        private List<T> list = new ArrayList<>();\n\n        public final void safeVarargs(T... elements) {\n          Collections.addAll(list, elements);\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Foo<T> {\n        private List<T> list = new ArrayList<>();\n\n        @SafeVarargs\n        public final void safeVarargs(T... elements) {\n          Collections.addAll(list, elements);\n        }\n      }\n\n\nJava 1.6 或更早版本的 JVM 不支持此注解。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unchecked",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfSunClasses",
                "shortDescription": {
                  "text": "使用 'sun.*' 类"
                },
                "fullDescription": {
                  "text": "报告使用 'sun.*' 层次结构中的类的情况。 这种类不可在不同的 JVM 之间移植。",
                  "markdown": "报告使用 `sun.*` 层次结构中的类的情况。 这种类不可在不同的 JVM 之间移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfSunClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorMethodParameterNotUsed",
                "shortDescription": {
                  "text": "可疑的 'Comparator.compare()' 实现"
                },
                "fullDescription": {
                  "text": "报告 'Comparator.compare()' 和 'Comparable.compareTo()' 实现中的问题。 将报告以下情况： 未使用形参。 很可能这是拼写错误，另一个形参与本身相比较，或者未正确实现方法。 显然，对于相同的元素，该方法不会返回 '0'。 这种比较方法违反了约定，当遇到相同的元素时，可能会产生不可预测的结果。 特别是，某些数据可能会出现异常而导致排序失败。 比较方法从不返回正值或负值。 为了履行约定，如果比较方法返回正值，那么如果以相反的顺序提供实参，它也应该返回负值。 比较方法返回 'Integer.MIN_VALUE'。 虽然约定允许，但它可能容易出错，因为一些调用站点可能会错误地使用一元减号来反转比较方法的返回值。 'Integer.MIN_VALUE' 的求反值为 'Integer.MIN_VALUE'。 示例： 'Comparator<String> lambda =\n    (a, b) -> a.length() > b.length()\n              ? 0\n              : Math.random() > 0.5 ? -1 : 1;'",
                  "markdown": "报告 `Comparator.compare()` 和 `Comparable.compareTo()` 实现中的问题。\n\n将报告以下情况：\n\n* 未使用形参。 很可能这是拼写错误，另一个形参与本身相比较，或者未正确实现方法。\n* 显然，对于相同的元素，该方法不会返回 `0`。 这种比较方法违反了约定，当遇到相同的元素时，可能会产生不可预测的结果。 特别是，某些数据可能会出现异常而导致排序失败。\n* 比较方法从不返回正值或负值。 为了履行约定，如果比较方法返回正值，那么如果以相反的顺序提供实参，它也应该返回负值。\n* 比较方法返回 `Integer.MIN_VALUE`。 虽然约定允许，但它可能容易出错，因为一些调用站点可能会错误地使用一元减号来反转比较方法的返回值。 `Integer.MIN_VALUE` 的求反值为 `Integer.MIN_VALUE`。\n\n**示例：**\n\n\n      Comparator<String> lambda =\n        (a, b) -> a.length() > b.length()\n                  ? 0\n                  : Math.random() > 0.5 ? -1 : 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorMethodParameterNotUsed",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCast",
                "shortDescription": {
                  "text": "冗余类型转换"
                },
                "fullDescription": {
                  "text": "报告不必要的转换表达式。 示例： 'static Object toObject(String s) {\n    return (Object) s;\n  }' 使用下面的复选框可以忽略澄清转换，例如应为 'Object' 的集合调用中的转换： 'static void removeFromList(List<String> l, Object o) {\n    l.remove((String)o);\n  }'",
                  "markdown": "报告不必要的转换表达式。\n\n示例：\n\n\n      static Object toObject(String s) {\n        return (Object) s;\n      }\n\n\n使用下面的复选框可以忽略澄清转换，例如应为 `Object` 的集合调用中的转换：\n\n\n      static void removeFromList(List<String> l, Object o) {\n        l.remove((String)o);\n      } \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousInnerClass",
                "shortDescription": {
                  "text": "匿名类可被替换为内部类"
                },
                "fullDescription": {
                  "text": "报告匿名类。 偶尔将匿名类替换为内部类可以提高代码的可读性和可维护性。 有些代码标准不建议使用匿名类。 示例： 'class Example {\n    public static void main(String[] args) {\n      new Thread() {\n        public void run() {\n          work()\n        }\n\n        private void work() {}\n      }.start();\n    }\n  }' 在应用快速修复后： 'class Example {\n    public static void main(String[] args) {\n      new MyThread().start();\n    }\n\n    private static class MyThread extends Thread {\n      public void run() {\n        work();\n      }\n\n      private void work() {}\n    }\n  }'",
                  "markdown": "报告匿名类。\n\n偶尔将匿名类替换为内部类可以提高代码的可读性和可维护性。\n有些代码标准不建议使用匿名类。\n\n**示例：**\n\n\n      class Example {\n        public static void main(String[] args) {\n          new Thread() {\n            public void run() {\n              work()\n            }\n\n            private void work() {}\n          }.start();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Example {\n        public static void main(String[] args) {\n          new MyThread().start();\n        }\n\n        private static class MyThread extends Thread {\n          public void run() {\n            work();\n          }\n\n          private void work() {}\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AnonymousInnerClass",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Annotation",
                "shortDescription": {
                  "text": "注解"
                },
                "fullDescription": {
                  "text": "报告注解。 Java 1.4 和更早版本的 JVM 不支持注解。",
                  "markdown": "报告注解。 Java 1.4 和更早版本的 JVM 不支持注解。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Annotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyCollector",
                "shortDescription": {
                  "text": "可简化的收集器"
                },
                "fullDescription": {
                  "text": "报告可以简化的收集器。 特别是，一些级联的 'groupingBy()' 收集器可以使用更简单的 'toMap()' 收集器来表示，这也可能会提高性能。 示例： 'Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));' 在应用快速修复后： 'Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));' 2017.1 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以简化的收集器。\n\n特别是，一些级联的 `groupingBy()` 收集器可以使用更简单的 `toMap()` 收集器来表示，这也可能会提高性能。\n\n示例：\n\n\n      Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));\n\n在应用快速修复后：\n\n\n      Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifyCollector",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleTopLevelClassesInFile",
                "shortDescription": {
                  "text": "单个文件中的多个顶级类"
                },
                "fullDescription": {
                  "text": "报告单个 Java 文件中的多个顶层类。 将多个顶层类放在一个文件中可能令人困惑，并且会降低各种软件工具的实用性。",
                  "markdown": "报告单个 Java 文件中的多个顶层类。\n\n将多个顶层类放在一个文件中可能令人困惑，并且会降低各种软件工具的实用性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultipleTopLevelClassesInFile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTokenizer",
                "shortDescription": {
                  "text": "使用 'StringTokenizer'"
                },
                "fullDescription": {
                  "text": "报告 'StringTokenizer' 类的用法。 在国际化环境中，过度使用 'StringTokenizer' 是不正确的。",
                  "markdown": "报告 `StringTokenizer` 类的用法。 在国际化环境中，过度使用 `StringTokenizer` 是不正确的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfStringTokenizer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryUnicodeEscape",
                "shortDescription": {
                  "text": "不必要的 Unicode 转义序列"
                },
                "fullDescription": {
                  "text": "报告不必要的 unicode 转义序列。 例如，当文件编码可以在不转义的情况下处理字符时。 此检查不报告 Unicode 控制字符（换行符和制表符除外）。 示例： 'String s = \"\\u0062\";'",
                  "markdown": "报告不必要的 unicode 转义序列。 例如，当文件编码可以在不转义的情况下处理字符时。 此检查不报告 Unicode 控制字符（换行符和制表符除外）。\n\n**示例：**\n\n    String s = \"\\u0062\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryUnicodeEscape",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PrimitiveArrayArgumentToVariableArgMethod",
                "shortDescription": {
                  "text": "引起混淆的 vararg 方法基元数组实参"
                },
                "fullDescription": {
                  "text": "报告对可变 arity 方法的任何调用，其中该调用在 arity 形参位置有基元数组（例如 'System.out.printf(\"%s\", new int[]{1, 2, 3})'）。 此类基元数组实参可能令人困惑，因为它将被包装为单一元素数组，而不是像预期的那样将每个单独的元素装箱。 示例： 'String.format(\"%s\", new int[]{1, 2, 3});' 在应用快速修复后： 'String.format(\"%s\", (Object) new int[]{1, 2, 3});' 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告对可变 arity 方法的任何调用，其中该调用在 arity 形参位置有基元数组（例如 `System.out.printf(\"%s\", new int[]{1, 2, 3})`）。 此类基元数组实参可能令人困惑，因为它将被包装为单一元素数组，而不是像预期的那样将每个单独的元素装箱。\n\n**示例：**\n\n\n      String.format(\"%s\", new int[]{1, 2, 3});\n\n在应用快速修复后：\n\n\n      String.format(\"%s\", (Object) new int[]{1, 2, 3});\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PrimitiveArrayArgumentToVarargsMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IteratorNextDoesNotThrowNoSuchElementException",
                "shortDescription": {
                  "text": "无法抛出 'NoSuchElementException' 的 'Iterator.next()'"
                },
                "fullDescription": {
                  "text": "报告不能抛出 'java.util.NoSuchElementException' 的 'Iterator.next()' 的实现。 此类实现违反了 'java.util.iterator' 的约定，如果以非标准方式使用迭代器，可能会导致难以捉摸的错误。 示例： 'class Numbers implements Iterator<Integer> {\n    @Override\n    public Integer next() { //warning\n        if (hasNext()) {\n            return generateNext();\n        } else {\n            return null; //而是抛出 NoSuchElementException\n        }\n    }\n\n    ...\n  }'",
                  "markdown": "报告不能抛出 `java.util.NoSuchElementException` 的 `Iterator.next()` 的实现。\n\n\n此类实现违反了 `java.util.iterator` 的约定，如果以非标准方式使用迭代器，可能会导致难以捉摸的错误。\n\n**示例：**\n\n\n      class Numbers implements Iterator<Integer> {\n        @Override\n        public Integer next() { //warning\n            if (hasNext()) {\n                return generateNext();\n            } else {\n                return null; //而是抛出 NoSuchElementException\n            }\n        }\n\n        ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IteratorNextCanNotThrowNoSuchElementException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectMessageFormat",
                "shortDescription": {
                  "text": "'MessageFormat' 模式不正确"
                },
                "fullDescription": {
                  "text": "报告不正确的消息格式模式或占位符的不正确索引 报告以下错误： 未解析的索引或负索引 未闭合的大括号 不成对的引号。 在这种情况下，模式的一部分可能不会被使用 可能引号的数量不正确 嵌套选择模式的下限不正确 占位符索引不正确。 在这种情况下，不能替换占位符或不能使用实参 示例： 'MessageFormat.format(\"{wrong}\", 1); // 不正确的索引\n  MessageFormat.format(\"{0\", 1); // 不匹配的大括号\n  MessageFormat.format(\"'{0}\", 1); // 不成对的引号\n  MessageFormat.format(\"It''''s {0}\", 1); // 将打印“It''s”而非“It's”\n  MessageFormat.format(\"{0}\", 1, 2); // 模式中未使用索引为 '1' 的实参' 2023.2 最新变化",
                  "markdown": "报告不正确的消息格式模式或占位符的不正确索引\n\n报告以下错误：\n\n* 未解析的索引或负索引\n* 未闭合的大括号\n* 不成对的引号。 在这种情况下，模式的一部分可能不会被使用\n* 可能引号的数量不正确\n* 嵌套选择模式的下限不正确\n* 占位符索引不正确。 在这种情况下，不能替换占位符或不能使用实参\n\n示例：\n\n\n      MessageFormat.format(\"{wrong}\", 1); // 不正确的索引\n      MessageFormat.format(\"{0\", 1); // 不匹配的大括号\n      MessageFormat.format(\"'{0}\", 1); // 不成对的引号\n      MessageFormat.format(\"It''''s {0}\", 1); // 将打印\"It''s\"而非\"It's\"\n      MessageFormat.format(\"{0}\", 1, 2); // 模式中未使用索引为 '1' 的实参\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncorrectMessageFormat",
                    "cweIds": [
                      628,
                      707
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousTernaryOperatorInVarargsCall",
                "shortDescription": {
                  "text": "vararg 方法调用中的可疑三元运算符"
                },
                "fullDescription": {
                  "text": "报告使用具有混合数组分支和非数组分支的三元运算符的 vararg 方法调用。 编译时，两个分支都被包装在数组中。 结果，数组分支变成了二维数组，这可能说明有问题。 该快速修复会将非数组分支包装在数组中以防止编译器执行转换。 示例： 'static void bar(boolean flag) {\n        Object[] a = {1, 2};\n        Object b = \"hello\";\n        foo(flag ? a : b);\n    }\n    static void foo(Object... obj) {\n    }' 应用该快速修复后： 'static void bar(boolean flag) {\n        Object[] a = {1, 2};\n        Object b = \"hello\";\n        foo(flag ? a : new Object[]{b});\n    }\n    static void foo(Object... obj) {\n    }' 2020.3 最新变化 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告使用具有混合数组分支和非数组分支的三元运算符的 vararg 方法调用。\n\n\n编译时，两个分支都被包装在数组中。 结果，数组分支变成了二维数组，这可能说明有问题。\n\n\n该快速修复会将非数组分支包装在数组中以防止编译器执行转换。\n\n**示例：**\n\n\n        static void bar(boolean flag) {\n            Object[] a = {1, 2};\n            Object b = \"hello\";\n            foo(flag ? a : b);\n        }\n        static void foo(Object... obj) {\n        }\n\n应用该快速修复后：\n\n\n        static void bar(boolean flag) {\n            Object[] a = {1, 2};\n            Object b = \"hello\";\n            foo(flag ? a : new Object[]{b});\n        }\n        static void foo(Object... obj) {\n        }\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousTernaryOperatorInVarargsCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseBulkOperation",
                "shortDescription": {
                  "text": "可以使用批量操作代替迭代"
                },
                "fullDescription": {
                  "text": "报告循环内部可以替换为批量方法的单一运算。 批量方法不仅更短，而且有时性能也更好。 示例： 'void test(Collection<Integer> numbers) {\n    List<Integer> result = new ArrayList<>();\n    for (Integer i : numbers) {\n      result.add(i);\n    }\n  }' 应用修正后： 'void test(Collection<Integer> numbers) {\n    List<Integer> result = new ArrayList<>();\n    result.addAll(numbers);\n  }' 即便批量方法需要集合，使用 Arrays.asList() 包装数组选项也使您能够报告数组。 在本例中，该快速修复会自动将数组包装在 'Arrays.asList()' 调用中。 2017.1 最新变化",
                  "markdown": "报告循环内部可以替换为批量方法的单一运算。\n\n\n批量方法不仅更短，而且有时性能也更好。\n\n**示例：**\n\n      void test(Collection<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        for (Integer i : numbers) {\n          result.add(i);\n        }\n      }\n\n应用修正后：\n\n\n      void test(Collection<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        result.addAll(numbers);\n      }\n\n\n即便批量方法需要集合，**使用 Arrays.asList() 包装数组** 选项也使您能够报告数组。\n在本例中，该快速修复会自动将数组包装在 `Arrays.asList()` 调用中。\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseBulkOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AccessToNonThreadSafeStaticFieldFromInstance",
                "shortDescription": {
                  "text": "非线程安全的 'static' 字段访问"
                },
                "fullDescription": {
                  "text": "报告对非线程安全类型的 'static' 字段的访问。 从实例方法或非同步块访问 'static' 字段时，多个线程都可以访问该字段。 这可能导致未指明的副作用，例如异常和不正确的结果。 示例： 'class Sample {\n    private static final SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n    String method() {\n      return df.format(\"\");\n    }\n  }' 您可以指定哪些类型应被视为非线程安全。 仅报告具有这些确切类型或使用这些确切类型进行初始化的字段，因为可能存在这些类型的线程安全子类。",
                  "markdown": "报告对非线程安全类型的 `static` 字段的访问。\n\n\n从实例方法或非同步块访问 `static` 字段时，多个线程都可以访问该字段。\n这可能导致未指明的副作用，例如异常和不正确的结果。\n\n**示例：**\n\n\n      class Sample {\n        private static final SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n        String method() {\n          return df.format(\"\");\n        }\n      }\n\n\n您可以指定哪些类型应被视为非线程安全。\n仅报告具有这些确切类型或使用这些确切类型进行初始化的字段，因为可能存在这些类型的线程安全子类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessToNonThreadSafeStaticField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BigDecimalEquals",
                "shortDescription": {
                  "text": "在 'BigDecimal' 上调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告比较两个 'java.math.BigDecimal' 数字的 'equals()' 调用。 这通常会是错误，因为两个 'java.math.BigDecimal' 数字只有在值和比例上都相等时才相等。 示例： 'if (new BigDecimal(\"2.0\").equals(\n    new BigDecimal(\"2.00\"))) {} // false' 在应用快速修复后： 'if (new BigDecimal(\"2.0\").compareTo(\n    new BigDecimal(\"2.00\")) == 0) {} // true'",
                  "markdown": "报告比较两个 `java.math.BigDecimal` 数字的 `equals()` 调用。 这通常会是错误，因为两个 `java.math.BigDecimal` 数字只有在值和比例上都相等时才相等。\n\n**示例：**\n\n\n      if (new BigDecimal(\"2.0\").equals(\n        new BigDecimal(\"2.00\"))) {} // false\n\n在应用快速修复后：\n\n\n      if (new BigDecimal(\"2.0\").compareTo(\n        new BigDecimal(\"2.00\")) == 0) {} // true\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BigDecimalEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToCatchBlockParameter",
                "shortDescription": {
                  "text": "赋值给 'catch' 块形参"
                },
                "fullDescription": {
                  "text": "报告对 'catch' 块形参的赋值。 更改 'catch' 块形参很容易令人困惑，不建议使用。 该快速修复会添加新变量的声明。 示例： 'void processFile(String fileName) throws Exception {\n    try {\n      doProcessFile(fileName);\n    } catch(Exception ex) {\n      if (ex instanceof UncheckedIOException) {\n        // Warning: catch block parameter reassigned\n        ex = ((UncheckedIOException) ex).getCause();\n      }\n      throw ex;\n    }\n  }' 在应用快速修复后： 'void processFile(String fileName) throws Exception {\n    try {\n      doProcessFile(fileName);\n    } catch(Exception ex) {\n      Exception unwrapped = ex;\n      if (unwrapped instanceof UncheckedIOException) {\n        unwrapped = ((UncheckedIOException)\n          unwrapped).getCause();\n      }\n      throw unwrapped;\n    }\n  }'",
                  "markdown": "报告对 `catch` 块形参的赋值。\n\n更改 `catch` 块形参很容易令人困惑，不建议使用。\n\n该快速修复会添加新变量的声明。\n\n**示例：**\n\n\n      void processFile(String fileName) throws Exception {\n        try {\n          doProcessFile(fileName);\n        } catch(Exception ex) {\n          if (ex instanceof UncheckedIOException) {\n            // Warning: catch block parameter reassigned\n            ex = ((UncheckedIOException) ex).getCause();\n          }\n          throw ex;\n        }\n      }\n\n在应用快速修复后：\n\n\n      void processFile(String fileName) throws Exception {\n        try {\n          doProcessFile(fileName);\n        } catch(Exception ex) {\n          Exception unwrapped = ex;\n          if (unwrapped instanceof UncheckedIOException) {\n            unwrapped = ((UncheckedIOException)\n              unwrapped).getCause();\n          }\n          throw unwrapped;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToCatchBlockParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodOverridesAbstractMethod",
                "shortDescription": {
                  "text": "abstract 方法重写 abstract 方法"
                },
                "fullDescription": {
                  "text": "报告重写 'abstract' 方法的 'abstract' 方法。 此类方法毫无意义，因为任何具体的子类都必须实现抽象方法。 此检查不会报告返回类型、异常声明、注解或修饰符与被重写方法不同的方法。 配置检查： 使用忽略 Javadoc 与其 super 方法不同的方法选项，以忽略 Javadoc 注释与其 super 方法不同的任何抽象方法。",
                  "markdown": "报告重写 `abstract` 方法的 `abstract` 方法。\n\n此类方法毫无意义，因为任何具体的子类都必须实现抽象方法。\n\n\n此检查不会报告返回类型、异常声明、注解或修饰符与被重写方法不同的方法。\n\n\n配置检查：\n\n* 使用**忽略 Javadoc 与其 super 方法不同的方法**选项，以忽略 Javadoc 注释与其 super 方法不同的任何抽象方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodOverridesAbstractMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableInnerClassHasSerialVersionUIDField",
                "shortDescription": {
                  "text": "没有 'serialVersionUID' 的可序列化非 static 内部类"
                },
                "fullDescription": {
                  "text": "报告实现 'java.io.Serializable' 但不定义 'serialVersionUID' 字段的非 static 内部类。 如果没有 'serialVersionUID' 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。 强烈建议 'Serializable' 非 static 内部类包含 'serialVersionUID' 字段，否则由于合成访问器方法的差异，默认序列化算法可能导致编译器之间的序列化版本不兼容。 建议通过快速修复添加缺失的 'serialVersionUID' 字段。 示例： 'class Outer {\n      class Inner implements Serializable {}\n  }' 在应用快速修复后： 'class Outer {\n      class Inner implements Serializable {\n          private static final long serialVersionUID = -7004458730436243902L;\n      }\n  }' 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 是否忽略 'Serializable' 匿名类。",
                  "markdown": "报告实现 `java.io.Serializable` 但不定义 `serialVersionUID` 字段的非 static 内部类。\n\n\n如果没有 `serialVersionUID` 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。 强烈建议 `Serializable` 非 static 内部类包含 `serialVersionUID` 字段，否则由于合成访问器方法的差异，默认序列化算法可能导致编译器之间的序列化版本不兼容。\n\n\n建议通过快速修复添加缺失的 `serialVersionUID` 字段。\n\n**示例：**\n\n\n      class Outer {\n          class Inner implements Serializable {}\n      }\n\n在应用快速修复后：\n\n\n      class Outer {\n          class Inner implements Serializable {\n              private static final long serialVersionUID = -7004458730436243902L;\n          }\n      }\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 是否忽略 `Serializable` 匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableNonStaticInnerClassWithoutSerialVersionUID",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopStatementsThatDontLoop",
                "shortDescription": {
                  "text": "不循环的循环语句"
                },
                "fullDescription": {
                  "text": "报告其语句体最多执行一次的 'for'、'while' 和 'do' 语句的任何实例。 通常，这表明存在错误。 使用忽略增强型 for 循环选项可忽略 foreach 循环。 它们有时用于以紧凑的方式仅对可迭代对象的第一个条目执行操作。 示例： 'for (String s : stringIterable) {\n    doSomethingOnFirstString(s);\n    break;\n  }'",
                  "markdown": "报告其语句体最多执行一次的 `for`、`while` 和 `do` 语句的任何实例。 通常，这表明存在错误。\n\n\n使用**忽略增强型 for 循环**选项可忽略 foreach 循环。\n它们有时用于以紧凑的方式仅对可迭代对象的第一个条目执行操作。\n\n示例：\n\n\n      for (String s : stringIterable) {\n        doSomethingOnFirstString(s);\n        break;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopStatementThatDoesntLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayCreationWithoutNewKeyword",
                "shortDescription": {
                  "text": "创建不带 'new' 表达式的数组"
                },
                "fullDescription": {
                  "text": "报告没有 'new' 数组表达式的数组初始化器并建议添加它们。 示例： 'int[] a = {42}' 在应用快速修复后： 'int[] a = new int[]{42}'",
                  "markdown": "报告没有 `new` 数组表达式的数组初始化器并建议添加它们。\n\n示例：\n\n\n      int[] a = {42}\n\n在应用快速修复后：\n\n\n      int[] a = new int[]{42}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ArrayCreationWithoutNewKeyword",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingOctalEscape",
                "shortDescription": {
                  "text": "引起混淆的八进制转义序列"
                },
                "fullDescription": {
                  "text": "报告包含紧跟数字的八进制转义序列的字符串文字。 此类字符串可能令人困惑，并且通常是转义码创建错误的结果。 示例： 'System.out.println(\"\\1234\"); // 紧跟数字的八进制转义序列 '\\123''",
                  "markdown": "报告包含紧跟数字的八进制转义序列的字符串文字。\n\n此类字符串可能令人困惑，并且通常是转义码创建错误的结果。\n\n**示例：**\n\n\n      System.out.println(\"\\1234\"); // 紧跟数字的八进制转义序列 '\\123'\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingOctalEscapeSequence",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterNameDiffersFromOverriddenParameter",
                "shortDescription": {
                  "text": "形参名称与重写或重载方法中的形参不同"
                },
                "fullDescription": {
                  "text": "报告名称与其重写或重载方法的相应形参不同的形参。 虽然在 Java 中是合法的，但这种不一致的名称可能令人困惑，并减少具有良好命名做法的文档优势。 示例： 'class Person {\n    Person(String fullName) {}\n  }\n  class Child extends Person {\n    Child(String name) { super(name); }\n  }' 在应用快速修复后： 'class Person {\n    Person(String fullName) {}\n  }\n  class Child extends Person {\n    Child(String fullName) { super(fullName); }\n  }' 使用选项可以指示是否忽略只有单个字符长度或来自库方法的重写的形参名称。 如果您不希望受到库中使用的可疑命名约定的约束，那么两者都会很有用。",
                  "markdown": "报告名称与其重写或重载方法的相应形参不同的形参。 虽然在 Java 中是合法的，但这种不一致的名称可能令人困惑，并减少具有良好命名做法的文档优势。\n\n**示例：**\n\n\n      class Person {\n        Person(String fullName) {}\n      }\n      class Child extends Person {\n        Child(String name) { super(name); }\n      }\n\n在应用快速修复后：\n\n\n      class Person {\n        Person(String fullName) {}\n      }\n      class Child extends Person {\n        Child(String fullName) { super(fullName); }\n      }\n\n\n使用选项可以指示是否忽略只有单个字符长度或来自库方法的重写的形参名称。 如果您不希望受到库中使用的可疑命名约定的约束，那么两者都会很有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterNameDiffersFromOverriddenParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OctalLiteral",
                "shortDescription": {
                  "text": "八进制整数"
                },
                "fullDescription": {
                  "text": "报告八进制整数文字。 某些编码标准禁止使用八进制文字，因为它们可能容易与十进制文字混淆。 示例： 'int i = 015;\n  int j = 0_777;' 此检查有两种不同的快速修复。 应用将八进制文字转换为十进制文字快速修复后，代码变为： 'int i = 13;\n  int j = 511;' 应用移除前导零以变为十进制快速修复后，代码变为： 'int i = 15;\n  int j = 777;'",
                  "markdown": "报告八进制整数文字。 某些编码标准禁止使用八进制文字，因为它们可能容易与十进制文字混淆。\n\n示例：\n\n\n      int i = 015;\n      int j = 0_777;\n\n此检查有两种不同的快速修复。\n应用**将八进制文字转换为十进制文字**快速修复后，代码变为：\n\n\n      int i = 13;\n      int j = 511;\n\n应用**移除前导零以变为十进制**快速修复后，代码变为：\n\n\n      int i = 15;\n      int j = 777;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OctalInteger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaParameterHidingMemberVariable",
                "shortDescription": {
                  "text": "lambda 形参隐藏字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的 lambda 形参。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用 lambda 形参。 建议通过快速修复重命名该 lambda 形参。 示例： 'public class MyClass {\n    public Object foo;\n\n    void sort(List<Integer> list) {\n      list.sort((foo, bar) -> foo - bar);\n    }\n  }' 使用此选项可选择是否忽略对 lambda 表达式不可见的字段。 例如，超类的 private 字段。 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告与周围类的字段同名的 lambda 形参。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用 lambda 形参。\n\n建议通过快速修复重命名该 lambda 形参。\n\n**示例：**\n\n\n      public class MyClass {\n        public Object foo;\n\n        void sort(List<Integer> list) {\n          list.sort((foo, bar) -> foo - bar);\n        }\n      }\n\n\n使用此选项可选择是否忽略对 lambda 表达式不可见的字段。\n例如，超类的 private 字段。\n\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LambdaParameterHidesMemberVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadWriteStringCanBeUsed",
                "shortDescription": {
                  "text": "可以使用 'Files.readString()' 或 'Files.writeString()'"
                },
                "fullDescription": {
                  "text": "报告使用 'java.nio.file.Files' 将 'String' 作为字节读取或写入的方法调用 此类调用可被替换为对 Java 11 中引入的 'Files.readString()' 或 'Files.writeString()' 方法的调用。 示例： 'String s = \"example\";\n  Files.write(Paths.get(\"out.txt\"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);\n  s = new String(Files.readAllBytes(Paths.get(\"in.txt\")), StandardCharsets.ISO_8859_1);' 在应用快速修复后： 'String s = \"example\";\n  Files.writeString(Paths.get(\"out.txt\"), s, StandardOpenOption.WRITE);\n  s = Files.readString(Paths.get(\"in.txt\"), StandardCharsets.ISO_8859_1);' 2018.3 最新变化",
                  "markdown": "报告使用 `java.nio.file.Files` 将 `String` 作为字节读取或写入的方法调用 此类调用可被替换为对 Java 11 中引入的 `Files.readString()` 或 `Files.writeString()` 方法的调用。\n\n**示例：**\n\n\n      String s = \"example\";\n      Files.write(Paths.get(\"out.txt\"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);\n      s = new String(Files.readAllBytes(Paths.get(\"in.txt\")), StandardCharsets.ISO_8859_1);\n\n在应用快速修复后：\n\n\n      String s = \"example\";\n      Files.writeString(Paths.get(\"out.txt\"), s, StandardOpenOption.WRITE);\n      s = Files.readString(Paths.get(\"in.txt\"), StandardCharsets.ISO_8859_1);\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReadWriteStringCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 11",
                      "index": 125,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantMathCall",
                "shortDescription": {
                  "text": "对 'Math' 的常量调用"
                },
                "fullDescription": {
                  "text": "报告对可被替换为简单的编译时常量的 'java.lang.Math' 或 'java.lang.StrictMath' 方法的调用。 示例： 'double v = Math.sin(0.0);' 在应用快速修复后： 'double v = 0.0;'",
                  "markdown": "报告对可被替换为简单的编译时常量的 `java.lang.Math` 或 `java.lang.StrictMath` 方法的调用。\n\n**示例：**\n\n    double v = Math.sin(0.0);\n\n在应用快速修复后：\n\n    double v = 0.0;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantMathCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissortedModifiers",
                "shortDescription": {
                  "text": "错位修饰符"
                },
                "fullDescription": {
                  "text": "报告修饰符不符合规范首选顺序（如 Java 语言规范中所述）的声明。 示例： 'class Foo {\n    native public final void foo();\n  }' 在应用快速修复后： 'class Foo {\n    public final native void foo();\n  }'",
                  "markdown": "报告修饰符不符合规范首选顺序（如 Java 语言规范中所述）的声明。\n\n**示例：**\n\n\n      class Foo {\n        native public final void foo();\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        public final native void foo();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MissortedModifiers",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TransientFieldInNonSerializableClass",
                "shortDescription": {
                  "text": "不可序列化类中存在 transient 字段"
                },
                "fullDescription": {
                  "text": "报告未实现 'java.io.Serializable' 的类中的 'transient' 字段。 示例： 'public class NonSerializableClass {\n    private transient String password;\n  }' 在应用快速修复后： 'public class NonSerializableClass {\n    private String password;\n  }'",
                  "markdown": "报告未实现 `java.io.Serializable` 的类中的 `transient` 字段。\n\n**示例：**\n\n\n      public class NonSerializableClass {\n        private transient String password;\n      }\n\n在应用快速修复后：\n\n\n      public class NonSerializableClass {\n        private String password;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TransientFieldInNonSerializableClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclomaticComplexity",
                "shortDescription": {
                  "text": "过度复杂的方法"
                },
                "fullDescription": {
                  "text": "报告分支点过多的方法。 分支点是以下选项之一： 循环语句 'if' 语句 三元表达式 'catch' 部分 包含一个或多个 '&&' 或 '||' 运算符的表达式 具有非默认分支的 'switch' 块 循环复杂度过高的方法可能令人困惑且难以测试。 使用方法复杂度限制字段可指定一个方法允许的最大循环复杂度。",
                  "markdown": "报告分支点过多的方法。\n\n分支点是以下选项之一：\n\n* 循环语句\n* `if` 语句\n* 三元表达式\n* `catch` 部分\n* 包含一个或多个 `&&` 或 `||` 运算符的表达式\n* 具有非默认分支的 `switch` 块\n\n循环复杂度过高的方法可能令人困惑且难以测试。\n\n使用**方法复杂度限制**字段可指定一个方法允许的最大循环复杂度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SlowListContainsAll",
                "shortDescription": {
                  "text": "对 'list.containsAll(collection)' 的调用可能具有较差性能"
                },
                "fullDescription": {
                  "text": "报告 'java.util.List' 上对 'containsAll()' 的调用。 此方法调用的时间复杂度为 O(n·m)，其中 n 是调用该方法的列表中的元素数，m 是作为形参传递至该方法的集合中的元素数。 当列表很大时，这可能是一项开销巨大的操作。 该快速修复会将列表包装在 'new java.util.HashSet<>()' 中，因为从 'java.util.List' 创建 'java.util.HashSet' 并在 'java.util.HashSet' 上执行 'containsAll()' 的所需时间为 O(n+m)。 示例： 'public boolean check(List<String> list, Collection<String> collection) {\n    // O(n·m) 复杂度\n    return list.containsAll(collection);\n  }' 在应用快速修复后： 'public boolean check(List<String> list, Collection<String> collection) {\n    // O(n+m) 复杂度\n    return new HashSet<>(list).containsAll(collection);\n  }' 2022.1 最新变化",
                  "markdown": "报告 `java.util.List` 上对 `containsAll()` 的调用。\n\n\n此方法调用的时间复杂度为 O(n·m)，其中 n 是调用该方法的列表中的元素数，m 是作为形参传递至该方法的集合中的元素数。\n当列表很大时，这可能是一项开销巨大的操作。\n\n\n该快速修复会将列表包装在 `new java.util.HashSet<>()` 中，因为从 `java.util.List` 创建\n`java.util.HashSet` 并在 `java.util.HashSet` 上执行 `containsAll()` 的所需时间为 O(n+m)。\n\n**示例：**\n\n      public boolean check(List<String> list, Collection<String> collection) {\n        // O(n·m) 复杂度\n        return list.containsAll(collection);\n      }\n\n在应用快速修复后：\n\n      public boolean check(List<String> list, Collection<String> collection) {\n        // O(n+m) 复杂度\n        return new HashSet<>(list).containsAll(collection);\n      }\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SlowListContainsAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AwaitNotInLoop",
                "shortDescription": {
                  "text": "未在循环中调用的 'await()'"
                },
                "fullDescription": {
                  "text": "报告没有在循环中调用的 'java.util.concurrent.locks.Condition.await()'。 'await()' 和相关方法通常用于挂起线程，直到某个条件变为 true 为止。 线程可能出于不同原因而被唤醒，因此应在 'await()' 调用返回后检查条件。 使用循环很容易做到这一点。 示例： 'void acquire(Condition released) throws InterruptedException {\n    released.await();\n  }' 优良的代码应类似于： 'void acquire(Condition released) throws InterruptedException {\n    while (acquired) {\n      released.await();\n    }\n  }'",
                  "markdown": "报告没有在循环中调用的 `java.util.concurrent.locks.Condition.await()`。\n\n\n`await()` 和相关方法通常用于挂起线程，直到某个条件变为 true 为止。\n线程可能出于不同原因而被唤醒，因此应在 `await()` 调用返回后检查条件。\n使用循环很容易做到这一点。\n\n**示例：**\n\n\n      void acquire(Condition released) throws InterruptedException {\n        released.await();\n      }\n\n优良的代码应类似于：\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.await();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AwaitNotInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticVariableUninitializedUse",
                "shortDescription": {
                  "text": "static 字段在初始化前使用"
                },
                "fullDescription": {
                  "text": "报告在初始化之前读取的 'static' 变量。 该检查会忽略 'null' 的相等检查。 示例： 'class Foo {\n    public static int bar;\n\n    public static void main(String[] args) {\n      System.out.println(bar);\n    }\n  }' 请注意，此检查使用非常保守的数据流算法，并且可能会将 'static' 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。 使用忽略基元字段选项可以忽略未初始化的基元字段。",
                  "markdown": "报告在初始化之前读取的 `static` 变量。\n\n该检查会忽略 `null` 的相等检查。\n\n**示例：**\n\n\n      class Foo {\n        public static int bar;\n\n        public static void main(String[] args) {\n          System.out.println(bar);\n        }\n      }\n\n请注意，此检查使用非常保守的数据流算法，并且可能会将 `static` 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。\n\n使用**忽略基元字段**选项可以忽略未初始化的基元字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticVariableUsedBeforeInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionPackage",
                "shortDescription": {
                  "text": "异常软件包"
                },
                "fullDescription": {
                  "text": "报告仅包含直接或间接扩展 'java.lang.Throwable' 的类的软件包。 尽管异常的实现通常不依赖于其他类，但它们通常不会单独使用。 更好的设计通常会将异常与使用它们的类放在同一个软件包中。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告仅包含直接或间接扩展 `java.lang.Throwable` 的类的软件包。\n\n尽管异常的实现通常不依赖于其他类，但它们通常不会单独使用。\n更好的设计通常会将异常与使用它们的类放在同一个软件包中。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExceptionPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclicClassDependency",
                "shortDescription": {
                  "text": "循环类依赖"
                },
                "fullDescription": {
                  "text": "报告相互依赖或循环依赖于其他类的类。 此类循环依赖项会使代码变得脆弱且难以维护。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告相互依赖或循环依赖于其他类的类。\n\n此类循环依赖项会使代码变得脆弱且难以维护。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CyclicClassDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferReplaceableByStringBuilder",
                "shortDescription": {
                  "text": "'StringBuffer' 可能是 'StringBuilder'"
                },
                "fullDescription": {
                  "text": "报告声明为 'StringBuffer' 的变量，并建议将它们替换为 'StringBuilder'。 'StringBuilder' 是 'StringBuffer' 的非线程安全替换。 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告声明为 `StringBuffer` 的变量，并建议将它们替换为 `StringBuilder`。 `StringBuilder` 是 `StringBuffer` 的非线程安全替换。\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferMayBeStringBuilder",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeParameterExtendsObject",
                "shortDescription": {
                  "text": "类型形参显式扩展 'Object'"
                },
                "fullDescription": {
                  "text": "报告显式声明为扩展 'java.lang.Object' 的类型形参和通配符类型实参。 此类 'extends' 子句是冗余的，因为 'java.lang.Object' 是所有类的父类型。 示例： 'class ClassA<T extends Object> {}' 如果由于注解而需保留 'extends Object' 子句，请禁用注解 java.lang.Object 时忽略选项。 这可能会有用，例如在您使用空值分析器并且 'extends Object' 子句包含 '@Nullable'/'@NotNull' 注解时。 示例： 'class MyClass<T extends @NotNull Object> {}'",
                  "markdown": "报告显式声明为扩展 `java.lang.Object` 的类型形参和通配符类型实参。\n\n此类 'extends' 子句是冗余的，因为 `java.lang.Object` 是所有类的父类型。\n\n**示例：**\n\n      class ClassA<T extends Object> {}\n\n\n如果由于注解而需保留 'extends Object' 子句，请禁用**注解 java.lang.Object 时忽略** 选项。\n这可能会有用，例如在您使用空值分析器并且 'extends Object' 子句包含 `@Nullable`/`@NotNull` 注解时。\n\n**示例：**\n\n      class MyClass<T extends @NotNull Object> {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeParameterExplicitlyExtendsObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizedMethod",
                "shortDescription": {
                  "text": "'synchronized' 方法"
                },
                "fullDescription": {
                  "text": "报告方法上的 'synchronized' 修饰符。 对方法使用 'synchronized' 修饰符可能并非好主意，原因有几点： 在锁定的情况下应尽可能少地执行工作。 因此，通常最好使用 'synchronized' 块，只保留共享状态的代码。 同步成为方法接口的一部分。 这导致难以转换到不同的锁定机制。 跟踪锁定特定对象的内容变得更加困难。 在继承方法的类时，无论是有意还是无意进行的 DoS（拒绝服务）攻击都变得可行。 替代做法是考虑在 'private final' 锁定对象上同步，可以完全控制对该对象的访问。 可以通过快速修复使用 'synchronized(this)' 包装方法体。 示例： 'class Main {\n    public synchronized void fooBar() {\n    }\n  }' 在应用快速修复后： 'class Main {\n    public void fooBar() {\n      synchronized (this) {\n      }\n    }\n  }' 您可以为此检查配置以下选项： 包括原生方法 - 将原生方法纳入检查范围。 忽略重写 synchronized 方法的方法 - 不报告重写 'synchronized' 方法的方法。",
                  "markdown": "报告方法上的 `synchronized` 修饰符。\n\n\n对方法使用 `synchronized` 修饰符可能并非好主意，原因有几点：\n\n1. 在锁定的情况下应尽可能少地执行工作。 因此，通常最好使用 `synchronized` 块，只保留共享状态的代码。\n2. 同步成为方法接口的一部分。 这导致难以转换到不同的锁定机制。\n3. 跟踪锁定特定对象的内容变得更加困难。\n4. 在继承方法的类时，无论是有意还是无意进行的 DoS（拒绝服务）攻击都变得可行。\n\n\n替代做法是考虑在 `private final` 锁定对象上同步，可以完全控制对该对象的访问。\n\n可以通过快速修复使用 `synchronized(this)` 包装方法体。\n\n**示例：**\n\n\n      class Main {\n        public synchronized void fooBar() {\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        public void fooBar() {\n          synchronized (this) {\n          }\n        }\n      }\n\n您可以为此检查配置以下选项：\n\n1. **包括原生方法** - 将原生方法纳入检查范围。\n2. **忽略重写 synchronized 方法的方法** - 不报告重写 `synchronized` 方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInsideStringBufferAppend",
                "shortDescription": {
                  "text": "字符串串联作为 'StringBuilder.append()' 调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作 'StringBuffer.append()'、'StringBuilder.append()' 或 'Appendable.append()' 的实参的 'String' 串联。 此类调用可以有利地转变为现有 'StringBuffer/Builder/Appendable' 中的链式追加调用，从而节省额外的 'StringBuffer/Builder' 分配成本。 此检查将忽略编译时求值的 'String' 串联，在这种情况下，转换只会降低性能。 示例： 'void bar(StringBuilder builder, String name) {\n    builder.append(\"Hello,\" + name);    //警告\n    builder.append(\"Hello,\" + \"world\"); //无警告\n  }'",
                  "markdown": "报告用作 `StringBuffer.append()`、`StringBuilder.append()` 或 `Appendable.append()` 的实参的 `String` 串联。\n\n\n此类调用可以有利地转变为现有 `StringBuffer/Builder/Appendable` 中的链式追加调用，从而节省额外的 `StringBuffer/Builder` 分配成本。\n此检查将忽略编译时求值的 `String` 串联，在这种情况下，转换只会降低性能。\n\n**示例：**\n\n\n      void bar(StringBuilder builder, String name) {\n        builder.append(\"Hello,\" + name);    //警告\n        builder.append(\"Hello,\" + \"world\"); //无警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInsideStringBufferAppend",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodWithMissingImplementations",
                "shortDescription": {
                  "text": "缺少实现的 abstract 方法"
                },
                "fullDescription": {
                  "text": "报告每个具体子类中没有实现的 'abstract' 方法。 这会导致子类发生编译时错误；该检查会报告 abstract 方法点处的问题，从而可以更快地检测出问题。",
                  "markdown": "报告每个具体子类中没有实现的 `abstract` 方法。\n\n\n这会导致子类发生编译时错误；该检查会报告 abstract 方法点处的问题，从而可以更快地检测出问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodWithMissingImplementations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FeatureEnvy",
                "shortDescription": {
                  "text": "特性依恋"
                },
                "fullDescription": {
                  "text": "报告特性依恋代码异味。 当方法调用另一个类的方法三次或更多次时，将抛出警告。 对库类、父类、包含类的调用不计入此检查。 特性依恋通常表明该功能位于错误的类中。 示例： 'class JobManager {\n    // 警告：此方法调用 Job 类的\n    // 三个方法\n    // 最好将此调用链\n    // 移至 Job 类本身。\n    void performJob(Job job) {\n      job.beforeStart();\n      job.process();\n      job.afterProcessing();\n    }\n  }'",
                  "markdown": "报告*特性依恋* 代码异味。 当方法调用另一个类的方法三次或更多次时，将抛出警告。 对库类、父类、包含类的调用不计入此检查。 特性依恋通常表明该功能位于错误的类中。\n\n示例：\n\n\n      class JobManager {\n        // 警告：此方法调用 Job 类的\n        // 三个方法\n        // 最好将此调用链\n        // 移至 Job 类本身。\n        void performJob(Job job) {\n          job.beforeStart();\n          job.process();\n          job.afterProcessing();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FeatureEnvy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BoxingBoxedValue",
                "shortDescription": {
                  "text": "装箱已装箱的值"
                },
                "fullDescription": {
                  "text": "报告已装箱值的装箱。 这是冗余的操作，因为任何装箱的值都会先自动拆箱，然后再次对该值装箱。 如果在内部循环中进行，此类代码可能会导致性能问题。 示例： 'Integer value = 1;\n  method(Integer.valueOf(value));' 在应用快速修复后： 'Integer value = 1;\n  method(value);'",
                  "markdown": "报告已装箱值的装箱。\n\n\n这是冗余的操作，因为任何装箱的值都会先自动拆箱，然后再次对该值装箱。 如果在内部循环中进行，此类代码可能会导致性能问题。\n\n**示例：**\n\n\n      Integer value = 1;\n      method(Integer.valueOf(value));\n\n在应用快速修复后：\n\n\n      Integer value = 1;\n      method(value);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BoxingBoxedValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2MethodRef",
                "shortDescription": {
                  "text": "lambda 可被替换为方法引用"
                },
                "fullDescription": {
                  "text": "报告可以替换为方法引用的 lambda。 方法引用比 lambda 更容易理解和阅读，尽管它们通常取决于您的喜好。 示例： 'Runnable r = () -> System.out.println();' 在应用快速修复后： 'Runnable r = System.out::println;' 即使 lambda 不调用任何方法，该检查也可能会建议方法引用，例如将 'obj -> obj != null' 替换为 'Objects::nonNull'。 使用设置 | 编辑器 | 代码样式 | Java | 代码生成设置来配置特殊方法引用。 此检查依赖于以下 Java 功能: Lambda 表达式 方法引用 这些功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为方法引用的 lambda。 方法引用比 lambda 更容易理解和阅读，尽管它们通常取决于您的喜好。\n\n示例：\n\n\n      Runnable r = () -> System.out.println();\n\n在应用快速修复后：\n\n\n      Runnable r = System.out::println;\n\n\n即使 lambda 不调用任何方法，该检查也可能会建议方法引用，例如将 `obj -> obj != null` 替换为 `Objects::nonNull`。\n使用[设置 \\| 编辑器 \\| 代码样式 \\| Java \\| 代码生成](settings://preferences.sourceCode.Java?Lambda%20Body)设置来配置特殊方法引用。\n\n此检查依赖于以下 Java 功能:\n\n* Lambda 表达式\n* 方法引用\n\n这些功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Convert2MethodRef",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCollectionOperation",
                "shortDescription": {
                  "text": "冗余的 'Collection' 操作"
                },
                "fullDescription": {
                  "text": "报告有更简单的替代方案的过于复杂的集合操作。 示例： 'void f(String[] array, Collection<String> collection) {\n    String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);\n    boolean contains = collection.containsAll(Collections.singletonList(\"x\"));\n  }' 在应用快速修复后： 'void f(String[] array, Collection<String> collection) {\n    String[] strings = Arrays.copyOf(array, 10);\n    boolean contains = collection.contains(\"x\");\n  }' 2018.1 最新变化",
                  "markdown": "报告有更简单的替代方案的过于复杂的集合操作。\n\n示例：\n\n\n      void f(String[] array, Collection<String> collection) {\n        String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);\n        boolean contains = collection.containsAll(Collections.singletonList(\"x\"));\n      }\n\n在应用快速修复后：\n\n\n      void f(String[] array, Collection<String> collection) {\n        String[] strings = Arrays.copyOf(array, 10);\n        boolean contains = collection.contains(\"x\");\n      }\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCollectionOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuppressionAnnotation",
                "shortDescription": {
                  "text": "检查禁止注解"
                },
                "fullDescription": {
                  "text": "报告禁止检查的注释或注解。 当有意保留禁止以供进一步检查时，此检查可能有用。 示例： '@SuppressWarnings(\"unused\")\nstatic Stream<String> stringProvider() {\n    return Stream.of(\"foo\", \"bar\");\n}'",
                  "markdown": "报告禁止检查的注释或注解。\n\n当有意保留禁止以供进一步检查时，此检查可能有用。\n\n**示例：**\n\n\n    @SuppressWarnings(\"unused\")\n    static Stream<String> stringProvider() {\n        return Stream.of(\"foo\", \"bar\");\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuppressionAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassOnlyUsedInOnePackage",
                "shortDescription": {
                  "text": "仅在其他软件包中使用的类"
                },
                "fullDescription": {
                  "text": "报告如下类：不依赖于其软件包中的任何其他类，而是依赖于其他软件包中的类，并且本身仅是此其他软件包中类的依赖项。 请考虑将这种类移到它们所依赖的软件包中。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告如下类：不依赖于其软件包中的任何其他类，而是依赖于其他软件包中的类，并且本身仅是此其他软件包中类的依赖项。 请考虑将这种类移到它们所依赖的软件包中。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassOnlyUsedInOnePackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryToStringCall",
                "shortDescription": {
                  "text": "对 'toString()' 的调用不必要"
                },
                "fullDescription": {
                  "text": "报告在以下情况下使用的 'toString()' 调用： 在字符串串联中 在 'java.lang.StringBuilder#append()' 或 'java.lang.StringBuffer#append()' 方法中 在 'java.io.PrintWriter' 或 'java.io.PrintStream' 的方法中 在 'org.slf4j.Logger' 的方法中 在这些情况下，转换为字符串将由底层库方法处理，不需要显式调用 'toString()'。 移除冗余的 'toString()' 调用有时甚至可以提高性能并减少对象分配。 示例： 'System.out.println(this.toString())' 在应用快速修复后： 'System.out.println(this)' 请注意，没有 'toString()' 调用，代码语义可能会有所不同：如果表达式为 null，则将使用 'null' 字符串，而不是抛出 'NullPointerException'。 使用 仅在已知限定符为非 null 时报告 选项以避免对可能为 null 的值发出警告。 在这些情况下移除显式 'toString()' 会改变运行时语义，从抛出 'NullPointException' 变为在其为 'null' 时静默接受该值。",
                  "markdown": "报告在以下情况下使用的 `toString()` 调用：\n\n* 在字符串串联中\n* 在 `java.lang.StringBuilder#append()` 或 `java.lang.StringBuffer#append()` 方法中\n* 在 `java.io.PrintWriter` 或 `java.io.PrintStream` 的方法中\n* 在 `org.slf4j.Logger` 的方法中\n\n在这些情况下，转换为字符串将由底层库方法处理，不需要显式调用 `toString()`。\n移除冗余的 `toString()` 调用有时甚至可以提高性能并减少对象分配。\n\n示例：\n\n\n      System.out.println(this.toString())\n\n在应用快速修复后：\n\n\n      System.out.println(this)\n\n\n请注意，没有 `toString()` 调用，代码语义可能会有所不同：如果表达式为 null，则将使用 `null` 字符串，而不是抛出 `NullPointerException`。\n\n使用 **仅在已知限定符为非 null 时报告** 选项以避免对可能为 null 的值发出警告。\n在这些情况下移除显式 `toString()` 会改变运行时语义，从抛出 `NullPointException` 变为在其为 `null` 时静默接受该值。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryToStringCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverriddenMethodCallDuringObjectConstruction",
                "shortDescription": {
                  "text": "重写的方法在对象构造期间调用"
                },
                "fullDescription": {
                  "text": "报告在对象构造期间对当前类的重写方法的任何调用。 如果对象构造在内部，则会发生这种情况： 构造函数 非 static 实例初始值设定项 非 static 字段初始值设定项 'clone()' 'readObject()' 'readObjectNoData()' 此类调用可能会导致难以捉摸的错误，因为不能保证对象在方法调用发生之前被初始化。 示例： 'abstract class Parent {\n    void someMethod() { }\n  }\n\n  class Child extends Parent {\n    Child() {\n      someMethod();\n    }\n\n    @Override\n    void someMethod() { }\n  }' 此检查与以下各项共享其功能： 对象构造期间调用的 abstract 方法检查 对象构造期间调用的可重写方法检查 一次只应启用一个检查，以防止重复警告。",
                  "markdown": "报告在对象构造期间对当前类的重写方法的任何调用。 如果对象构造在内部，则会发生这种情况：\n\n* 构造函数\n* 非 static 实例初始值设定项\n* 非 static 字段初始值设定项\n* `clone()`\n* `readObject()`\n* `readObjectNoData()`\n\n此类调用可能会导致难以捉摸的错误，因为不能保证对象在方法调用发生之前被初始化。\n\n示例：\n\n\n      abstract class Parent {\n        void someMethod() { }\n      }\n\n      class Child extends Parent {\n        Child() {\n          someMethod();\n        }\n\n        @Override\n        void someMethod() { }\n      }\n\n此检查与以下各项共享其功能：\n\n* **对象构造期间调用的 abstract 方法**检查\n* **对象构造期间调用的可重写方法**检查\n\n一次只应启用一个检查，以防止重复警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverriddenMethodCallDuringObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassWithoutAbstractMethods",
                "shortDescription": {
                  "text": "没有 'abstract' 方法的抽象类"
                },
                "fullDescription": {
                  "text": "报告没有任何 'abstract' 方法的 'abstract' 类。 在大多数情况下，没有任何 'abstract' 方法的 'abstract' 类没有意义，并且可以从该类中移除 'abstract' 修饰符。 如果类被声明为 'abstract' 以防止实例化，则使用 'private' 构造函数来防止实例化通常是更好的选择。 示例： 'abstract class Example {\n    public String getName() {\n      return \"IntelliJ IDEA\";\n    }\n  }' 使用该选项可以忽略实用程序类。",
                  "markdown": "报告没有任何 `abstract` 方法的 `abstract` 类。 在大多数情况下，没有任何 `abstract` 方法的 `abstract` 类没有意义，并且可以从该类中移除 `abstract` 修饰符。 如果类被声明为 `abstract` 以防止实例化，则使用 `private` 构造函数来防止实例化通常是更好的选择。\n\n**示例：**\n\n\n      abstract class Example {\n        public String getName() {\n          return \"IntelliJ IDEA\";\n        }\n      }\n\n使用该选项可以忽略实用程序类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassWithoutAbstractMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnSeparatedFromComputation",
                "shortDescription": {
                  "text": "与结果计算分离的 'return'"
                },
                "fullDescription": {
                  "text": "报告返回局部变量的 'return' 语句，其中变量的值在同一方法中的其他位置计算。 快速修复通过将 return 语句移动到计算变量值的位置来内联返回的变量。 当返回值无法内联到 'return' 语句中时，快速修复尝试将 return 语句移动到尽可能接近计算的返回值的位置。 示例： 'int n = -1;\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] == b) {\n      n = i;\n      break;\n    }\n  }\n  return n;' 在应用快速修复后： 'int n = -1;\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] == b) {\n      return i;\n    }\n  }\n  return n;'",
                  "markdown": "报告返回局部变量的 `return` 语句，其中变量的值在同一方法中的其他位置计算。\n\n快速修复通过将 return 语句移动到计算变量值的位置来内联返回的变量。\n当返回值无法内联到 `return` 语句中时，快速修复尝试将 return 语句移动到尽可能接近计算的返回值的位置。\n\n示例：\n\n\n      int n = -1;\n      for (int i = 0; i < a.length; i++) {\n        if (a[i] == b) {\n          n = i;\n          break;\n        }\n      }\n      return n;\n\n在应用快速修复后：\n\n\n      int n = -1;\n      for (int i = 0; i < a.length; i++) {\n        if (a[i] == b) {\n          return i;\n        }\n      }\n      return n;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReturnSeparatedFromComputation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnNonFinalField",
                "shortDescription": {
                  "text": "在非 final 字段上同步"
                },
                "fullDescription": {
                  "text": "报告由非 'final' 字段引用组成的 'synchronized' 语句锁定表达式。 此类语句不太可能包含有用的语义，因为不同的线程即便在对同一对象上操作时也可能获取不同的锁定。 示例： 'private Object o;\n  public void foo() {\n    synchronized (o) // 在非 final 字段上同步\n    { }\n  }'",
                  "markdown": "报告由非 `final` 字段引用组成的 `synchronized` 语句锁定表达式。 此类语句不太可能包含有用的语义，因为不同的线程即便在对同一对象上操作时也可能获取不同的锁定。\n\n**示例：**\n\n\n      private Object o;\n      public void foo() {\n        synchronized (o) // 在非 final 字段上同步\n        { }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizeOnNonFinalField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastThatLosesPrecision",
                "shortDescription": {
                  "text": "损失精度的数字转换"
                },
                "fullDescription": {
                  "text": "报告可能导致精度损失的基元数值类型之间的转换运算。 此类转换不一定是问题，但如果意外造成精度损失，则可能会导致难以跟踪错误。 示例： 'int a = 420;\n  byte b = (byte) a;' 使用忽略从 int 到 char 的转换选项可以忽略从 'int' 到 'char' 的转换。 在实现 I/O 操作时经常使用这种类型的转换，因为 'java.io.Reader' 类的 'read()' 方法会返回一个 'int'。 使用忽略从 int 128-255 到字节的转换选项可以忽略从 'int' 到 'byte' 的常量值 (128-255) 的转换。 此类值将溢出到仍能容纳在一个字节内的负数。",
                  "markdown": "报告可能导致精度损失的基元数值类型之间的转换运算。\n\n此类转换不一定是问题，但如果意外造成精度损失，则可能会导致难以跟踪错误。\n\n**示例：**\n\n\n      int a = 420;\n      byte b = (byte) a;\n\n使用**忽略从 int 到 char 的转换** 选项可以忽略从 `int` 到 `char` 的转换。\n在实现 I/O 操作时经常使用这种类型的转换，因为 `java.io.Reader` 类的 `read()` 方法会返回一个 `int`。\n\n使用**忽略从 int 128-255 到字节的转换** 选项可以忽略从 `int` 到 `byte` 的常量值 (128-255) 的转换。\n此类值将溢出到仍能容纳在一个字节内的负数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NumericCastThatLosesPrecision",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SameReturnValue",
                "shortDescription": {
                  "text": "方法始终返回相同的值"
                },
                "fullDescription": {
                  "text": "报告始终返回相同常量的方法和方法层次结构。 该检查在批处理模式（与代码 | 检查代码或代码 | 分析代码 | 按名称运行检查）和在编辑器中动态运行时的工作方式不同： 在批处理模式中，该检查会报告始终返回相同常量的方法和方法层次结构。 在编辑器中，该检查仅会报告有多条 'return' 语句、没有 super 方法，以及无法被重写的方法。 如果一个方法重写或实现了一个方法，约定可能会要求它返回一个特定的常量，但同时，我们可能希望有多个出口点。 如果一个方法可以被重写，则可能在子类中返回不同的值。 示例： 'class X {\n                // 仅在批处理模式下发出警告：\n    int xxx() { // 方法 'xxx()' 及其所有重写方法始终返回 '0'\n      return 0;\n    }\n  }\n\n  class Y extends X {\n    @Override\n    int xxx() {\n        return 0;\n    }\n\n                // 仅在批处理模式下发出警告：\n    int yyy() { // 方法 'yyy()' 始终返回 '0'\n        return 0;\n    }\n\n                                  // 在批处理模式下和动态运行时均发出警告：\n    final int zzz(boolean flag) { // 方法 'zzz()' 始终返回 '0'\n        if (Math.random() > 0.5) {\n            return 0;\n        }\n        return 0;\n    }\n  }'",
                  "markdown": "报告始终返回相同常量的方法和方法层次结构。\n\n\n该检查在批处理模式（与**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 按名称运行检查**）和在编辑器中动态运行时的工作方式不同：\n\n* 在批处理模式中，该检查会报告始终返回相同常量的方法和方法层次结构。\n* 在编辑器中，该检查仅会报告有多条 `return` 语句、没有 super 方法，以及无法被重写的方法。 如果一个方法重写或实现了一个方法，约定可能会要求它返回一个特定的常量，但同时，我们可能希望有多个出口点。 如果一个方法可以被重写，则可能在子类中返回不同的值。\n\n**示例：**\n\n\n      class X {\n                    // 仅在批处理模式下发出警告：\n        int xxx() { // 方法 'xxx()' 及其所有重写方法始终返回 '0'\n          return 0;\n        }\n      }\n\n      class Y extends X {\n        @Override\n        int xxx() {\n            return 0;\n        }\n\n                    // 仅在批处理模式下发出警告：\n        int yyy() { // 方法 'yyy()' 始终返回 '0'\n            return 0;\n        }\n\n                                      // 在批处理模式下和动态运行时均发出警告：\n        final int zzz(boolean flag) { // 方法 'zzz()' 始终返回 '0'\n            if (Math.random() > 0.5) {\n                return 0;\n            }\n            return 0;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SameReturnValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowablePrintStackTrace",
                "shortDescription": {
                  "text": "调用 'printStackTrace()'"
                },
                "fullDescription": {
                  "text": "报告对无实参的 'Throwable.printStackTrace()' 的调用。 此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。",
                  "markdown": "报告对无实参的 `Throwable.printStackTrace()` 的调用。\n\n此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToPrintStackTrace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferMustHaveInitialCapacity",
                "shortDescription": {
                  "text": "没有初始容量的 'StringBuilder'"
                },
                "fullDescription": {
                  "text": "报告对新 'StringBuffer' 或 'StringBuilder' 对象进行实例化而不指定其初始容量的尝试。 如果未指定初始容量，则使用默认容量，这很少是最佳选择。 如果在超出初始容量时需要重新分配空间并复制内存，则未指定 'StringBuffer' 的初始容量可能会导致性能问题。 示例： '// 未指定容量\n  var sb = new StringBuilder();'",
                  "markdown": "报告对新 `StringBuffer` 或 `StringBuilder` 对象进行实例化而不指定其初始容量的尝试。\n\n\n如果未指定初始容量，则使用默认容量，这很少是最佳选择。\n如果在超出初始容量时需要重新分配空间并复制内存，则未指定 `StringBuffer` 的初始容量可能会导致性能问题。\n\n示例：\n\n\n      // 未指定容量\n      var sb = new StringBuilder();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferWithoutInitialCapacity",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayObjectsEquals",
                "shortDescription": {
                  "text": "对数组使用浅层方法或 'Objects' 方法"
                },
                "fullDescription": {
                  "text": "报告似乎使用不当方法来确定数组相等性或计算其哈希代码的表达式。 报告的方法调用如下： 针对任何数组，报告 'Object.equals()' 针对多维数组，报告 'Arrays.equals()' 针对多维数组，报告 'Arrays.hashCode()'",
                  "markdown": "报告似乎使用不当方法来确定数组相等性或计算其哈希代码的表达式。\n\n报告的方法调用如下：\n\n* 针对任何数组，报告 `Object.equals()`\n* 针对多维数组，报告 `Arrays.equals()`\n* 针对多维数组，报告 `Arrays.hashCode()`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayObjectsEquals",
                    "cweIds": [
                      480
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadWithDefaultRunMethod",
                "shortDescription": {
                  "text": "使用默认的 'run()' 方法实例化 'Thread'"
                },
                "fullDescription": {
                  "text": "报告在不指定 'Runnable' 形参或重写 'run()' 方法的情况下 'Thread' 或其继承者的实例化。 此类线程没有任何用处。 示例： 'new Thread().start();'",
                  "markdown": "报告在不指定 `Runnable` 形参或重写 `run()` 方法的情况下 `Thread` 或其继承者的实例化。 此类线程没有任何用处。\n\n**示例：**\n\n\n      new Thread().start();\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstantiatingAThreadWithDefaultRunMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreeNegationsPerMethod",
                "shortDescription": {
                  "text": "具有三个以上否定的方法"
                },
                "fullDescription": {
                  "text": "报告有三个或更多否定的方法。 此类方法可能令人困惑。 示例： 'void doSmth(int a, int b, boolean flag1, boolean flag2) {\n    if (!flag && !flag2) {\n      if (a != b) {\n        doOther();\n      }\n    }\n  }' 没有否定，该方法变得更容易理解： 'void doSmth(int a, int b, boolean flag1, boolean flag2) {\n    if (flag1 || flag2 || a == b) return;\n    doOther();\n  }' 配置检查： 使用忽略 'equals()' 方法中的否定选项可禁用 'equals()' 方法中的检查。 使用忽略 'assert' 语句中的否定可禁用 'assert' 语句中的检查。",
                  "markdown": "报告有三个或更多否定的方法。 此类方法可能令人困惑。\n\n**示例：**\n\n\n      void doSmth(int a, int b, boolean flag1, boolean flag2) {\n        if (!flag && !flag2) {\n          if (a != b) {\n            doOther();\n          }\n        }\n      }\n\n没有否定，该方法变得更容易理解：\n\n\n      void doSmth(int a, int b, boolean flag1, boolean flag2) {\n        if (flag1 || flag2 || a == b) return;\n        doOther();\n      }\n\n配置检查：\n\n* 使用**忽略 'equals()' 方法中的否定** 选项可禁用 `equals()` 方法中的检查。\n* 使用**忽略 'assert' 语句中的否定** 可禁用 `assert` 语句中的检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithMoreThanThreeNegations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8MapApi",
                "shortDescription": {
                  "text": "可简化的 'Map' 运算"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Map' 常见的使用模式，并建议将其替换为： 'getOrDefault()'、'computeIfAbsent()'、'putIfAbsent()'、'merge()' 或 'replaceAll( )'。 示例： 'map.containsKey(key) ? map.get(key) : \"default\";' 在应用快速修复后： 'map.getOrDefault(key, \"default\");' 示例： 'List<String> list = map.get(key);\n  if (list == null) {\n    list = new ArrayList<>();\n    map.put(key, list);\n  }' 在应用快速修复后： 'map.computeIfAbsent(key, localKey -> new ArrayList<>());' 示例： 'Integer val = map.get(key);\n  if (val == null) map.put(key, 1);\n  else map.put(key, val + 1);' 在应用快速修复后： 'map.merge(key, 1, (localKey, localValue) -> localValue + 1);' 示例： 'for (Map.Entry<String, String> entry : map.entrySet()) {\n    map.put(entry.getKey(), transform(entry.getValue()));\n  }' 在应用快速修复后： 'map.replaceAll((localKey, localValue) -> transform(localValue));' 请注意，如果提取到 lambda 表达式的代码修改了相同的 'Map'，对于某些 'Map'，替换为 'computeIfAbsent()' 或 'merge()' 可能无法正常使用。 在默认情况下，如果这段代码有副作用，则不会出现警告。 如有必要，启用建议替换，即使 lambda 可能有副作用选项，以始终显示警告。 此外，由于 'put()' 等旧方法和 'computeIfAbsent()' 或 'merge()' 等新方法中对 'null' 值的不同处理，语义可能会改变，如果将 'null' 值存储到给定的 'Map' 中很重要，您需要考虑这一点。 当值是静态已知为 null 时，该检查不会建议进行替换。但对于可 null 性未知的值，仍然建议进行替换。 在这些情况下，我们建议禁止警告并添加说明注释。 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告 `java.util.Map` 常见的使用模式，并建议将其替换为： `getOrDefault()`、`computeIfAbsent()`、`putIfAbsent()`、`merge()` 或 `replaceAll( )`。\n\n示例：\n\n\n      map.containsKey(key) ? map.get(key) : \"default\";\n\n在应用快速修复后：\n\n\n      map.getOrDefault(key, \"default\");\n\n示例：\n\n\n      List<String> list = map.get(key);\n      if (list == null) {\n        list = new ArrayList<>();\n        map.put(key, list);\n      }\n\n在应用快速修复后：\n\n\n      map.computeIfAbsent(key, localKey -> new ArrayList<>());\n\n示例：\n\n\n      Integer val = map.get(key);\n      if (val == null) map.put(key, 1);\n      else map.put(key, val + 1);\n\n在应用快速修复后：\n\n\n      map.merge(key, 1, (localKey, localValue) -> localValue + 1);\n\n示例：\n\n\n      for (Map.Entry<String, String> entry : map.entrySet()) {\n        map.put(entry.getKey(), transform(entry.getValue()));\n      }\n\n在应用快速修复后：\n\n\n      map.replaceAll((localKey, localValue) -> transform(localValue));\n\n请注意，如果提取到 lambda 表达式的代码修改了相同的 `Map`，对于某些 `Map`，替换为 `computeIfAbsent()` 或 `merge()` 可能无法正常使用。 在默认情况下，如果这段代码有副作用，则不会出现警告。 如有必要，启用**建议替换，即使 lambda 可能有副作用**选项，以始终显示警告。\n\n此外，由于 `put()` 等旧方法和 `computeIfAbsent()` 或 `merge()` 等新方法中对 `null` 值的不同处理，语义可能会改变，如果将 `null` 值存储到给定的 `Map` 中很重要，您需要考虑这一点。 当值是静态已知为 null 时，该检查不会建议进行替换。但对于可 null 性未知的值，仍然建议进行替换。 在这些情况下，我们建议禁止警告并添加说明注释。\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8MapApi",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestOnlyProblems",
                "shortDescription": {
                  "text": "生产代码中的纯测试用法"
                },
                "fullDescription": {
                  "text": "报告生产代码中使用的 '@TestOnly' 和 '@VisibleForTesting' 注解的方法和类。 还报告将 '@TestOnly' '@VisibleForTesting' 应用于同一元素的用法。 如果引用了以下位置中的方法或类，则不报告这些问题： Test Sources 文件夹下的代码 测试类 (JUnit/TestNG) 另一个 '@TestOnly' 注解的方法 （生产代码中的）示例： '@TestOnly\n  fun foo() { ... }\n\n  fun main () {\n    foo()\n  }'",
                  "markdown": "报告生产代码中使用的 `@TestOnly` 和 `@VisibleForTesting` 注解的方法和类。 还报告将 `@TestOnly` `@VisibleForTesting` 应用于同一元素的用法。\n\n如果引用了以下位置中的方法或类，则不报告这些问题：\n\n* **Test Sources** 文件夹下的代码\n* 测试类 (JUnit/TestNG)\n* 另一个 `@TestOnly` 注解的方法\n\n**（生产代码中的）示例：**\n\n\n      @TestOnly\n      fun foo() { ... }\n\n      fun main () {\n        foo()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestOnlyProblems",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MeaninglessRecordAnnotationInspection",
                "shortDescription": {
                  "text": "无意义的记录注解"
                },
                "fullDescription": {
                  "text": "报告记录组件上使用但并没有效果的注解。 这可能发生在以下两种情况下： 报告的注解具有 METHOD 目标，但显式定义了相应的访问器。 报告的注解具有 PARAMETER 目标，但显式定义了规范构造函数。 示例： '@Target(ElementType.METHOD)\n@interface A { }\n  \n// 该注解根本不会出现在字节码中，\n// 因为它应当传播到访问器，但显式定义了访问器\nrecord R(@A int x) {\n  public int x() { return x; }\n}' 2021.1 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告记录组件上使用但并没有效果的注解。\n\n这可能发生在以下两种情况下：\n\n* 报告的注解具有 METHOD 目标，但显式定义了相应的访问器。\n* 报告的注解具有 PARAMETER 目标，但显式定义了规范构造函数。\n\n示例：\n\n\n    @Target(ElementType.METHOD)\n    @interface A { }\n      \n    // 该注解根本不会出现在字节码中，\n    // 因为它应当传播到访问器，但显式定义了访问器\n    record R(@A int x) {\n      public int x() { return x; }\n    }\n\n2021.1 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MeaninglessRecordAnnotationInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsWhichDoesntCheckParameterClass",
                "shortDescription": {
                  "text": "不检查形参的类的 'equals()' 方法"
                },
                "fullDescription": {
                  "text": "报告不检查其形参类型的 'equals()' 方法。 无法检查 'equals()' 方法中形参的类型时，如果在无类型集合中使用该对象，可能会导致潜在错误。 示例： 'class MyClass {\n    int x;\n\n    @Override\n    public boolean equals(Object obj) {\n      // 如果 obj 不为 MyClass，equals 方法应返回 false\n      return ((MyClass)obj).x == x;\n    }\n  }'",
                  "markdown": "报告不检查其形参类型的 `equals()` 方法。\n\n无法检查 `equals()` 方法中形参的类型时，如果在无类型集合中使用该对象，可能会导致潜在错误。\n\n**示例：**\n\n\n      class MyClass {\n        int x;\n\n        @Override\n        public boolean equals(Object obj) {\n          // 如果 obj 不为 MyClass，equals 方法应返回 false\n          return ((MyClass)obj).x == x;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsWhichDoesntCheckParameterClass",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseHashCodeMethodInspection",
                "shortDescription": {
                  "text": "可以使用标准 'hashCode()' 方法"
                },
                "fullDescription": {
                  "text": "报告可以替换为对 'Long.hashCode()' 或 'Double.hashCode()' 方法的调用的按位操作。 它会检测结构 '(int)(x ^ (x >>> 32))'，其中 'x' 是类型为 'long' 的变量，或者是前一个 'Double.doubleToLongBits()' 调用的结果。 此替换可以缩短代码，提高代码的可读性。 示例： 'int result = (int)(var ^ (var >>> 32));' 应用快速修复后： 'int result = Long.hashCode(var);' 仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。 2024.1 最新变化",
                  "markdown": "报告可以替换为对 `Long.hashCode()` 或 `Double.hashCode()` 方法的调用的按位操作。 它会检测结构 `(int)(x ^ (x >>> 32))`，其中 `x` 是类型为 `long` 的变量，或者是前一个 `Double.doubleToLongBits()` 调用的结果。 此替换可以缩短代码，提高代码的可读性。\n\n**示例：**\n\n\n      int result = (int)(var ^ (var >>> 32));\n\n应用快速修复后：\n\n\n      int result = Long.hashCode(var);\n\n仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。\n\n2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseHashCodeMethodInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NumericOverflow",
                "shortDescription": {
                  "text": "数值溢出"
                },
                "fullDescription": {
                  "text": "报告计算过程中溢出的表达式。 通常是意外发生这种情况，并且表明存在错误。 例如，使用了错误的类型或应当反方向移位。 示例： 'float a = 1.0f/0.0f;\n  long b = 30 * 24 * 60 * 60 * 1000;\n  long c = 1000L << 62;'",
                  "markdown": "报告计算过程中溢出的表达式。 通常是意外发生这种情况，并且表明存在错误。 例如，使用了错误的类型或应当反方向移位。\n\n**示例：**\n\n\n      float a = 1.0f/0.0f;\n      long b = 30 * 24 * 60 * 60 * 1000;\n      long c = 1000L << 62;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NumericOverflow",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousIndentAfterControlStatement",
                "shortDescription": {
                  "text": "没有大括号的控制语句后存在可疑缩进"
                },
                "fullDescription": {
                  "text": "报告不带大括号控制语句后面的语句的可疑缩进。 进行此类缩进时，语句看似在控制语句内部，其实它将在控制语句后无条件地执行。 示例： 'class Bar {\n      void foo(int i) {\n          if (i == 0)\n              System.out.println(\"foo\");\n              System.out.println(\"bar\"); // 警告\n          if (i == 1);\n              System.out.println(\"great\"); // 警告\n          if (i == 42)\n              System.out.println(\"answer\");\n                  System.out.println(\"question\"); // 警告\n      }\n  }'",
                  "markdown": "报告不带大括号控制语句后面的语句的可疑缩进。\n\n\n进行此类缩进时，语句看似在控制语句内部，其实它将在控制语句后无条件地执行。\n\n**示例：**\n\n\n      class Bar {\n          void foo(int i) {\n              if (i == 0)\n                  System.out.println(\"foo\");\n                  System.out.println(\"bar\"); // 警告\n              if (i == 1);\n                  System.out.println(\"great\"); // 警告\n              if (i == 42)\n                  System.out.println(\"answer\");\n                      System.out.println(\"question\"); // 警告\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousIndentAfterControlStatement",
                    "cweIds": [
                      483
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToSuperclassField",
                "shortDescription": {
                  "text": "构造函数将值赋给在超类中定义的字段"
                },
                "fullDescription": {
                  "text": "报告对超类中从子类构造函数中声明的字段的赋值或修改。 最好在其自己的构造函数中初始化超类的字段，并在子类中委托给该构造函数。 如果它在构造后没有改变，这还将允许声明一个字段 'final'。 示例： 'class Super {\n    int x;\n  }\n  class Sub extends Super {\n    Sub(int _x) {\n      // Warning: x is declared in a superclass\n      x = _x;\n    }\n  }' 要避免此问题，请声明超类构造函数： 'class Super {\n    final int x;\n\n    Super(int _x) {\n      x = _x;\n    }\n  }\n  class Sub extends Super {\n    Sub(int _x) {\n      super(_x);\n    }\n  }'",
                  "markdown": "报告对超类中从子类构造函数中声明的字段的赋值或修改。\n\n最好在其自己的构造函数中初始化超类的字段，并在子类中委托给该构造函数。 如果它在构造后没有改变，这还将允许声明一个字段 `final`。\n\n**示例：**\n\n\n      class Super {\n        int x;\n      }\n      class Sub extends Super {\n        Sub(int _x) {\n          // Warning: x is declared in a superclass\n          x = _x;\n        }\n      }\n\n要避免此问题，请声明超类构造函数：\n\n\n      class Super {\n        final int x;\n\n        Super(int _x) {\n          x = _x;\n        }\n      }\n      class Sub extends Super {\n        Sub(int _x) {\n          super(_x);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToSuperclassField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FillPermitsList",
                "shortDescription": {
                  "text": "密封类的 permits 子句中缺失同一文件子类"
                },
                "fullDescription": {
                  "text": "报告没有显式 'permits' 列表的 'sealed' 类。 只在同一文件中有子类的 sealed 类不需要有显式的 'permits' 列表。 默认情况下，此检查不会在编辑器中高亮显示，而仅提供修复。 示例： 'sealed class A {}\n  final class B extends A {}' 在应用快速修复后： 'sealed class A permits B {}\n  final class B extends A {}' 2020.3 最新变化 此检查取决于 Java 功能 '密封类'，该功能自 Java 17 起可用。",
                  "markdown": "报告没有显式 `permits` 列表的 `sealed` 类。 只在同一文件中有子类的 sealed 类不需要有显式的 `permits` 列表。 默认情况下，此检查不会在编辑器中高亮显示，而仅提供修复。\n\n示例：\n\n\n      sealed class A {}\n      final class B extends A {}\n\n在应用快速修复后：\n\n\n      sealed class A permits B {}\n      final class B extends A {}\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '密封类'，该功能自 Java 17 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FillPermitsList",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousDateFormat",
                "shortDescription": {
                  "text": "可疑的日期格式模式"
                },
                "fullDescription": {
                  "text": "报告可能错误使用的日期格式模式。 报告的模式如下： 大写的“Y”，除非“w”出现在附近。 它代表“周年”，几乎总是与正常的“年份”（小写的 \"y\" 模式）相同，但可能指向 12 月结束后的下一年。 靠近 \"H\"、\"K\"、\"h\" 或 \"k\"（小时）的大写 \"M\"（月份）。 可能本意是使用小写的 \"m\"（分钟）。 靠近 \"y\"（年份）或 \"d\"（一月中的某天）的小写 \"m\"（分钟）。 可能本意是使用大写的 \"M\"（分钟）。 靠近 \"M\" 或 \"L\"（月份）的大写的 \"D\"（一年中的某天）。 可能本意是使用小写的 \"d\"（一月中的某天）。 靠近 \"m\"（分钟）的大写的 \"S\"（毫秒）。 可能本意是使用小写的 \"s\"（秒）。 示例： 'new SimpleDateFormat(\"YYYY-MM-dd\")'：可能本意是使用 '\"yyyy-MM-dd\"'。 'new SimpleDateFormat(\"yyyy-MM-DD\")'：可能本意是使用 '\"yyyy-MM-dd\"'。 'new SimpleDateFormat(\"HH:MM\")'：可能本意是使用 '\"HH:mm\"'。 2020.1 最新变化",
                  "markdown": "报告可能错误使用的日期格式模式。\n\n报告的模式如下：\n\n* 大写的\"Y\"，除非\"w\"出现在附近。 它代表\"周年\"，几乎总是与正常的\"年份\"（小写的 \"y\" 模式）相同，但可能指向 12 月结束后的下一年。\n* 靠近 \"H\"、\"K\"、\"h\" 或 \"k\"（小时）的大写 \"M\"（月份）。 可能本意是使用小写的 \"m\"（分钟）。\n* 靠近 \"y\"（年份）或 \"d\"（一月中的某天）的小写 \"m\"（分钟）。 可能本意是使用大写的 \"M\"（分钟）。\n* 靠近 \"M\" 或 \"L\"（月份）的大写的 \"D\"（一年中的某天）。 可能本意是使用小写的 \"d\"（一月中的某天）。\n* 靠近 \"m\"（分钟）的大写的 \"S\"（毫秒）。 可能本意是使用小写的 \"s\"（秒）。\n\n\n示例：  \n\n`new SimpleDateFormat(\"YYYY-MM-dd\")`：可能本意是使用 `\"yyyy-MM-dd\"`。  \n\n`new SimpleDateFormat(\"yyyy-MM-DD\")`：可能本意是使用 `\"yyyy-MM-dd\"`。  \n\n`new SimpleDateFormat(\"HH:MM\")`：可能本意是使用 `\"HH:mm\"`。\n\n2020.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousDateFormat",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNewInstance",
                "shortDescription": {
                  "text": "对 'Class.newInstance()' 的调用不安全"
                },
                "fullDescription": {
                  "text": "报告对 'java.lang.Class.newInstance()' 的调用。 此方法会传播由无实参构造函数抛出的异常，包括已检查的异常。 使用此方法可以有效地绕过本由编译器执行的编译时异常检查。 建议通过快速修复将该调用替换为对 'java.lang.reflect.Constructor.newInstance()' 方法的调用，这种方式将构造函数抛出的任何异常包装在（已检查的）'java.lang.reflect.InvocationTargetException' 中，从而可以避免这个问题。 示例： 'clazz.newInstance()' 在应用快速修复后： 'clazz.getConstructor().newInstance();'",
                  "markdown": "报告对 `java.lang.Class.newInstance()` 的调用。\n\n\n此方法会传播由无实参构造函数抛出的异常，包括已检查的异常。 使用此方法可以有效地绕过本由编译器执行的编译时异常检查。\n\n\n建议通过快速修复将该调用替换为对 `java.lang.reflect.Constructor.newInstance()` 方法的调用，这种方式将构造函数抛出的任何异常包装在（已检查的）`java.lang.reflect.InvocationTargetException` 中，从而可以避免这个问题。\n\n**示例：**\n\n\n      clazz.newInstance()\n\n在应用快速修复后：\n\n\n      clazz.getConstructor().newInstance();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNewInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicConstant",
                "shortDescription": {
                  "text": "魔术常量"
                },
                "fullDescription": {
                  "text": "报告可以替换为“魔术”常量的表达式。 示例 1： '// 使用了裸文字 \"2\"，警告：\n  Font font = new Font(\"Arial\", 2)' 示例 2： '// 使用了预定义常量，良好：\n  Font font = new Font(\"Arial\", Font.ITALIC)' 如果可能，该快速修复会插入相应的预定义常量。 此检查的行为由 'org.intellij.lang.annotations.MagicConstant' 注解进行控制。 有些标准的 Java 库方法进行了预先注解，但您也可以在代码中使用该注解。",
                  "markdown": "报告可以替换为\"魔术\"常量的表达式。\n\n示例 1：\n\n\n      // 使用了裸文字 \"2\"，警告：\n      Font font = new Font(\"Arial\", 2)\n\n示例 2：\n\n\n      // 使用了预定义常量，良好：\n      Font font = new Font(\"Arial\", Font.ITALIC)\n\n\n如果可能，该快速修复会插入相应的预定义常量。\n\n\n此检查的行为由 `org.intellij.lang.annotations.MagicConstant` 注解进行控制。\n有些标准的 Java 库方法进行了预先注解，但您也可以在代码中使用该注解。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicConstant",
                    "cweIds": [
                      489
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LimitedScopeInnerClass",
                "shortDescription": {
                  "text": "局部类"
                },
                "fullDescription": {
                  "text": "报告本地类。 本地类是指在代码块中声明的命名嵌套类。 本地类不常见，因此可能令人困惑。 此外，有些代码标准不建议使用本地类。 示例： 'class Example {\n    void test() {\n      class Local { // 这里\n      }\n      new Local();\n    }\n  }' 在应用快速修复后： 'class Example {\n    void test() {\n      new Local();\n    }\n\n    private static class Local { // 这里\n    }\n  }'",
                  "markdown": "报告本地类。\n\n本地类是指在代码块中声明的命名嵌套类。\n本地类不常见，因此可能令人困惑。\n此外，有些代码标准不建议使用本地类。\n\n**示例：**\n\n\n      class Example {\n        void test() {\n          class Local { // 这里\n          }\n          new Local();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Example {\n        void test() {\n          new Local();\n        }\n\n        private static class Local { // 这里\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LimitedScopeInnerClass",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultiplyOrDivideByPowerOfTwo",
                "shortDescription": {
                  "text": "乘以或除以 2 的幂"
                },
                "fullDescription": {
                  "text": "报告整数值与可表示为 2 的幂的常量整数的乘积。 此类表达式可以替换为右移或左移运算，以提高性能。 请注意，此检查与现代 JVM（例如 HotSpot 或 OpenJ9）无关，因为它们的 JIT 编译器将执行此优化。 它可能只在一些不执行 JIT 编译的嵌入式系统中有用。 示例： 'int y = x * 4;' 建议通过快速修复将乘法或除法运算替换为移位运算： 'int y = x << 2;' 使用该选项可使检查也报告二次幂除法。 请注意，用移位替换二次幂除法不适用于负数。",
                  "markdown": "报告整数值与可表示为 2 的幂的常量整数的乘积。 此类表达式可以替换为右移或左移运算，以提高性能。\n\n\n请注意，此检查与现代 JVM（例如 HotSpot 或 OpenJ9）无关，因为它们的 JIT 编译器将执行此优化。\n它可能只在一些不执行 JIT 编译的嵌入式系统中有用。\n\n**示例：**\n\n\n      int y = x * 4;\n\n建议通过快速修复将乘法或除法运算替换为移位运算：\n\n\n      int y = x << 2;\n\n\n使用该选项可使检查也报告二次幂除法。\n请注意，用移位替换二次幂除法不适用于负数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultiplyOrDivideByPowerOfTwo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCallInLoopCondition",
                "shortDescription": {
                  "text": "循环条件下的方法调用"
                },
                "fullDescription": {
                  "text": "报告循环语句条件部分中的方法调用。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 此检查适用于 Java ME 和其他资源高度受限的环境。 示例： 'String s = \"example\";\n  for (int i = 0; i < s.length(); i++) {\n    System.out.println(s.charAt(i));\n  }' 在应用快速修复后： 'String s = \"example\";\n  int length = s.length();\n  for (int i = 0; i < length; i++) {\n    System.out.println(s.charAt(i));\n  }' 使用该选项可以忽略对常见 Java 迭代方法（例如 'Iterator.hasNext()'）和具有副作用的已知方法（例如 'Atomic*.compareAndSet'）的调用。",
                  "markdown": "报告循环语句条件部分中的方法调用。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。\n\n\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n此检查适用于 Java ME 和其他资源高度受限的环境。\n\n**示例：**\n\n\n      String s = \"example\";\n      for (int i = 0; i < s.length(); i++) {\n        System.out.println(s.charAt(i));\n      }\n\n在应用快速修复后：\n\n\n      String s = \"example\";\n      int length = s.length();\n      for (int i = 0; i < length; i++) {\n        System.out.println(s.charAt(i));\n      }\n\n\n使用该选项可以忽略对常见 Java 迭代方法（例如 `Iterator.hasNext()`）和具有副作用的已知方法（例如 `Atomic*.compareAndSet`）的调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodCallInLoopCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NumericToString",
                "shortDescription": {
                  "text": "调用 'Number.toString()'"
                },
                "fullDescription": {
                  "text": "报告扩展 'Number' 的类的对象上的 'toString()' 调用。 此类调用在国际化环境中通常是不正确的，应该使用一些特定于区域设置的格式。 示例： 'void print(Double d) {\n    System.out.println(d.toString());\n  }' 修正此问题的一种可能方式是： 'void print(Double d) {\n    System.out.printf(\"%f%n\", d);\n  }' 这将使用默认区域设置来格式化数字，该默认区域设置在 JVM 启动期间进行设置，并且基于主机环境。",
                  "markdown": "报告扩展 `Number` 的类的对象上的 `toString()` 调用。 此类调用在国际化环境中通常是不正确的，应该使用一些特定于区域设置的格式。\n\n**示例：**\n\n\n      void print(Double d) {\n        System.out.println(d.toString());\n      }\n\n修正此问题的一种可能方式是：\n\n\n      void print(Double d) {\n        System.out.printf(\"%f%n\", d);\n      }\n\n这将使用默认区域设置来格式化数字，该默认区域设置在 JVM 启动期间进行设置，并且基于主机环境。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToNumericToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCount",
                "shortDescription": {
                  "text": "方法过多的类"
                },
                "fullDescription": {
                  "text": "报告方法数超过指定最大值的类。 具有太多方法的类通常会试图“进行过多处理”。 请考虑将这种类拆分为多个较小的类。 配置检查： 使用方法计数限制字段可指定类中允许的最大方法数。 使用忽略简单的 getter 和 setter 方法选项可忽略方法计数中的简单 getter 和 setter。 使用忽略重写/实现 super 方法的方法可忽略重写或实现 super 类方法的方法。",
                  "markdown": "报告方法数超过指定最大值的类。\n\n具有太多方法的类通常会试图\"进行过多处理\"。 请考虑将这种类拆分为多个较小的类。\n\n配置检查：\n\n* 使用**方法计数限制**字段可指定类中允许的最大方法数。\n* 使用**忽略简单的 getter 和 setter 方法**选项可忽略方法计数中的简单 getter 和 setter。\n* 使用**忽略重写/实现 super 方法的方法**可忽略重写或实现 super 类方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForLoopReplaceableByWhile",
                "shortDescription": {
                  "text": "'for' 循环可被替换为 'while' 循环"
                },
                "fullDescription": {
                  "text": "报告不包含初始化和更新组件的 'for' 循环，并建议将它们转换为 'while' 循环。 这使代码更易于阅读。 示例： 'for(; exitCondition(); ) {\n    process();\n  }' 在应用快速修复后： 'while(exitCondition()) {\n    process();\n  }' 快速修复也可用于其他 'for' 循环，因此您可以用 'while' 循环替换任何 'for' 循环。 如果您想忽略具有不重要或不存在条件的 'for' 循环，使用 忽略无条件的 'infinite' for 循环 选项。",
                  "markdown": "报告不包含初始化和更新组件的 `for` 循环，并建议将它们转换为 `while` 循环。 这使代码更易于阅读。\n\n示例：\n\n\n      for(; exitCondition(); ) {\n        process();\n      }\n\n在应用快速修复后：\n\n\n      while(exitCondition()) {\n        process();\n      }\n\n快速修复也可用于其他 `for` 循环，因此您可以用 `while` 循环替换任何 `for` 循环。\n\n如果您想忽略具有不重要或不存在条件的 `for` 循环，使用 **忽略无条件的 'infinite' for 循环** 选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopReplaceableByWhile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryDefault",
                "shortDescription": {
                  "text": "枚举 'switch' 语句的 'default' 不必要"
                },
                "fullDescription": {
                  "text": "报告由于所有可能的值都被 'case' 分支覆盖而导致其 'default' 分支绝不会被接受的枚举 'switch' 语句或表达式。 此类元素冗余，对于 'switch' 表达式更是如此，因为当 'case' 分支没有覆盖所有枚举常量时，它们不会进行编译。 需要将语言级别配置为 14，才会报告 'switch' 表达式。 提供的快速修复可以移除 'default' 分支。 示例： 'enum E { A, B }\n  int foo(E e) {\n    return switch (e) {\n      case A -> 1;\n      case B -> 2;\n      default -> 3;\n    };\n  }' 在应用快速修复后： 'enum E { A, B }\n  int foo(E e) {\n    return switch (e) {\n      case A -> 1;\n      case B -> 2;\n    };\n  }' 使用仅报告 switch 表达式选项可以仅报告 switch 表达式中的冗余 'default' 分支。",
                  "markdown": "报告由于所有可能的值都被 `case` 分支覆盖而导致其 `default` 分支绝不会被接受的枚举 `switch` 语句或表达式。\n\n此类元素冗余，对于 `switch` 表达式更是如此，因为当 `case` 分支没有覆盖所有枚举常量时，它们不会进行编译。\n\n\n需要将语言级别配置为 14，才会报告 `switch` 表达式。\n\n提供的快速修复可以移除 `default` 分支。\n\n示例：\n\n\n      enum E { A, B }\n      int foo(E e) {\n        return switch (e) {\n          case A -> 1;\n          case B -> 2;\n          default -> 3;\n        };\n      }\n\n在应用快速修复后：\n\n\n      enum E { A, B }\n      int foo(E e) {\n        return switch (e) {\n          case A -> 1;\n          case B -> 2;\n        };\n      }\n\n使用**仅报告 switch 表达式** 选项可以仅报告 switch 表达式中的冗余 `default` 分支。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryDefault",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticFieldReferenceOnSubclass",
                "shortDescription": {
                  "text": "static 字段通过子类引用"
                },
                "fullDescription": {
                  "text": "报告对其中的调用由声明类的子类而不是由声明类本身限定的 static 字段的访问。 Java 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。 示例： 'class Parent {\n    static int foo = 0;\n  }\n\n  class Child extends Parent { }\n\n  void bar() {\n    System.out.println(Child.foo);\n  }' 应用快速修复后，结果如下所示： 'class Parent {\n    static int foo = 0;\n  }\n\n  class Child extends Parent { }\n\n  void bar() {\n    System.out.println(Parent.foo);\n  }'",
                  "markdown": "报告对其中的调用由声明类的子类而不是由声明类本身限定的 static 字段的访问。\n\n\nJava 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。\n\n**示例：**\n\n\n      class Parent {\n        static int foo = 0;\n      }\n\n      class Child extends Parent { }\n\n      void bar() {\n        System.out.println(Child.foo);\n      }\n\n应用快速修复后，结果如下所示：\n\n\n      class Parent {\n        static int foo = 0;\n      }\n\n      class Child extends Parent { }\n\n      void bar() {\n        System.out.println(Parent.foo);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticFieldReferencedViaSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VolatileArrayField",
                "shortDescription": {
                  "text": "volatile 数组字段"
                },
                "fullDescription": {
                  "text": "报告被声明为 'volatile' 的数组字段。 此类声明可能令人困惑，因为访问数组本身遵循 'volatile' 字段的规则，但访问数组的内容时并非如此。 示例： 'class Data {\n    private volatile int[] idx = new int[0];\n  }' 如果需要对数组内容进行此类可变访问，不妨改用 'java.util.concurrent.atomic' 类： 'class Data {\n    private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);\n  }'",
                  "markdown": "报告被声明为 `volatile` 的数组字段。 此类声明可能令人困惑，因为访问数组本身遵循 `volatile` 字段的规则，但访问数组的内容时并非如此。\n\n**示例：**\n\n\n      class Data {\n        private volatile int[] idx = new int[0];\n      }\n\n\n如果需要对数组内容进行此类可变访问，不妨改用 `java.util.concurrent.atomic` 类：\n\n\n      class Data {\n        private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VolatileArrayField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryInheritDoc",
                "shortDescription": {
                  "text": "不必要的 '{@inheritDoc}' Javadoc 注释"
                },
                "fullDescription": {
                  "text": "报告仅包含 '{@inheritDoc}' 标记的 Javadoc 注释。 由于 Javadoc 会在没有注释的情况下复制超类的注释，因此仅包含 '{@inheritDoc}' 的注释不会添加任何内容。 此外，它还会报告无效位置（例如，字段）中的 '{@inheritDoc}' 用法。 建议移除不必要的 Javadoc 注释。 示例： 'class Example implements Comparable<Example> {\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int compareTo(Example o) {\n      return 0;\n    }\n  }' 在应用快速修复后： 'class Example implements Comparable<Example> {\n    @Override\n    public int compareTo(Example o) {\n      return 0;\n    }\n  }'",
                  "markdown": "报告仅包含 `{@inheritDoc}` 标记的 Javadoc 注释。 由于 Javadoc 会在没有注释的情况下复制超类的注释，因此仅包含 `{@inheritDoc}` 的注释不会添加任何内容。\n\n此外，它还会报告无效位置（例如，字段）中的 `{@inheritDoc}` 用法。\n\n建议移除不必要的 Javadoc 注释。\n\n**示例：**\n\n\n      class Example implements Comparable<Example> {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int compareTo(Example o) {\n          return 0;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Example implements Comparable<Example> {\n        @Override\n        public int compareTo(Example o) {\n          return 0;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryInheritDoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IgnoreResultOfCall",
                "shortDescription": {
                  "text": "方法调用的结果已忽略"
                },
                "fullDescription": {
                  "text": "报告其结果被忽略的方法调用。 忽略结果对于许多方法完全合法，但对于某些方法，几乎肯定是错误。 忽略结果可能是错误之举的方法示例包括返回实际读取字节数的 'java.io.inputStream.read()'，以及 'java.lang.String' 或 'java.math.BigInteger' 上的任何方法。 这些方法不会产生副作用，因此忽略它们的结果将毫无意义。 将检查对以下方法的调用： 简单 getter（除返回字段外别无他用） 在此检查的设置中指定的方法 使用 'org.jetbrains.annotations.Contract(pure=true)' 注解的方法 使用 .*.'CheckReturnValue' 注解的方法 使用 'javax.annotation.CheckReturnValue' 注解的类或软件包中的方法 所有非库方法（可选） 不会报告对使用 Error Prone 或 AssertJ 的 '@CanIgnoreReturnValue' 注解进行注解的方法的调用。 使用检查设置指定要检查的类。 方法采用 Java 正则表达式语法按名称或名称模式进行匹配。 对于类，请使用完全限定名称。 每个条目都应用于该类及其所有继承者。",
                  "markdown": "报告其结果被忽略的方法调用。\n\n忽略结果对于许多方法完全合法，但对于某些方法，几乎肯定是错误。 忽略结果可能是错误之举的方法示例包括返回实际读取字节数的 `java.io.inputStream.read()`，以及 `java.lang.String` 或 `java.math.BigInteger` 上的任何方法。 这些方法不会产生副作用，因此忽略它们的结果将毫无意义。\n\n将检查对以下方法的调用：\n\n* 简单 getter（除返回字段外别无他用）\n* 在此检查的设置中指定的方法\n* 使用 `org.jetbrains.annotations.Contract(pure=true)` 注解的方法\n* 使用 .\\*.`CheckReturnValue` 注解的方法\n* 使用 `javax.annotation.CheckReturnValue` 注解的类或软件包中的方法\n* 所有非库方法（可选）\n\n不会报告对使用 Error Prone 或 AssertJ 的 `@CanIgnoreReturnValue` 注解进行注解的方法的调用。\n\n\n使用检查设置指定要检查的类。\n方法采用 Java 正则表达式语法按名称或名称模式进行匹配。\n对于类，请使用完全限定名称。 每个条目都应用于该类及其所有继承者。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ResultOfMethodCallIgnored",
                    "cweIds": [
                      252,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BlockingMethodInNonBlockingContext",
                "shortDescription": {
                  "text": "可能在非阻塞上下文中使用阻塞调用"
                },
                "fullDescription": {
                  "text": "报告不应阻塞线程的代码段中的线程阻塞方法调用。 示例（项目 Reactor）： 'Flux.just(\"1\").flatMap(f -> {\n    Flux<String> just = loadUsersFromDatabase();\n    just.toIterable(); // 错误：在非阻塞范围内调用阻塞运算符\n    return just;\n  }\n);' 考虑使用适当的计划程序（例如 'Schedulers.boundedElastic()'）运行阻塞代码，或者尝试寻找替代的非阻塞 API。 示例（Kotlin 协程）： 'suspend fun exampleFun() {\n    Thread.sleep(100); // 错误：在挂起函数中调用阻塞方法\n}' 考虑使用特殊调度程序（例如 'Dispatchers.IO'）运行阻塞代码，或尝试寻找替代的非阻塞 API。 配置检查： 在阻塞注解列表中，指定标记线程阻塞方法的注解。 在无阻塞注解列表中，指定标记非阻塞方法的注解。 指定的注解可用作外部注解",
                  "markdown": "报告不应阻塞线程的代码段中的线程阻塞方法调用。\n\n**示例（项目 Reactor）：**\n\n\n    Flux.just(\"1\").flatMap(f -> {\n        Flux<String> just = loadUsersFromDatabase();\n        just.toIterable(); // 错误：在非阻塞范围内调用阻塞运算符\n        return just;\n      }\n    );\n\n考虑使用[适当的计划程序](https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking)（例如 `Schedulers.boundedElastic()`）运行阻塞代码，或者尝试寻找替代的非阻塞 API。\n\n**示例（Kotlin 协程）：**\n\n\n    suspend fun exampleFun() {\n        Thread.sleep(100); // 错误：在挂起函数中调用阻塞方法\n    }\n\n考虑[使用特殊调度程序](https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html)（例如 `Dispatchers.IO`）运行阻塞代码，或尝试寻找替代的非阻塞 API。\n\n配置检查：\n\n* 在**阻塞注解**列表中，指定标记线程阻塞方法的注解。\n* 在**无阻塞注解**列表中，指定标记非阻塞方法的注解。\n\n指定的注解可用作[外部注解](https://www.jetbrains.com/help/idea/external-annotations.html)"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BlockingMethodInNonBlockingContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParametersPerConstructor",
                "shortDescription": {
                  "text": "形参过多的构造函数"
                },
                "fullDescription": {
                  "text": "报告形参数量超过指定最大值的构造函数。 此类对象很难实例化，特别是在某些形参是可选形参的情况下。 构造函数的形参过多可能表明有必要重构。 例如，请考虑应用构建器模式。 示例： 'public BankAccount(long accountNumber,\n                     String owner,\n                     double balance,\n                     double interestRate) {\n    // fields initialization\n  }' 配置检查： 使用形参限制字段可以指定构造函数中允许的最大形参数量。 使用忽略具有以下可见性的构造函数列表可指定检查是否应忽略具有特定可见性的构造函数。",
                  "markdown": "报告形参数量超过指定最大值的构造函数。 此类对象很难实例化，特别是在某些形参是可选形参的情况下。 构造函数的形参过多可能表明有必要重构。 例如，请考虑应用构建器模式。\n\n**示例：**\n\n\n      public BankAccount(long accountNumber,\n                         String owner,\n                         double balance,\n                         double interestRate) {\n        // fields initialization\n      }\n\n配置检查：\n\n* 使用**形参限制**字段可以指定构造函数中允许的最大形参数量。\n* 使用**忽略具有以下可见性的构造函数**列表可指定检查是否应忽略具有特定可见性的构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstructorWithTooManyParameters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonReproducibleMathCall",
                "shortDescription": {
                  "text": "对 'Math' 的不可重现调用"
                },
                "fullDescription": {
                  "text": "报告不能保证准确再现结果的对 'java.lang.Math' 方法的调用。 在需要结果重现性的环境中，应改用 'java.lang.StrictMath'。",
                  "markdown": "报告不能保证准确再现结果的对 `java.lang.Math` 方法的调用。\n\n在需要结果重现性的环境中，应改用 `java.lang.StrictMath`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonReproducibleMathCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "'assertEquals()' 位于不可转换类型的对象之间"
                },
                "fullDescription": {
                  "text": "报告“预期”实参和“实际”实参的类型不兼容时对断言方法的调用。 此类调用通常表明测试中存在错误。 该检查会检查相关的 JUnit、TestNG 和 AssertJ 方法。 示例： 'assertEquals(\"1\", 1);\n  assertNotSame(new int[0], 0);\n\n  // 弱警告，可能只测试 equals() 约定\n  assertThat(foo).as(\"user type\").isNotEqualTo(bar);'",
                  "markdown": "报告\"预期\"实参和\"实际\"实参的类型不兼容时对断言方法的调用。\n\n此类调用通常表明测试中存在错误。\n该检查会检查相关的 JUnit、TestNG 和 AssertJ 方法。\n\n**示例：**\n\n\n      assertEquals(\"1\", 1);\n      assertNotSame(new int[0], 0);\n\n      // 弱警告，可能只测试 equals() 约定\n      assertThat(foo).as(\"user type\").isNotEqualTo(bar);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MappingBeforeCount",
                "shortDescription": {
                  "text": "count() 之前的映射调用"
                },
                "fullDescription": {
                  "text": "报告冗余的 'Stream' API 调用，如 'map()' 或在 'count()' 调用之前的 'boxed()'。 此类调用不会改变最终计数，因此可以移除。 代码可能依赖于此类映射调用中 lambda 的副作用。 然而，依靠 Stream 链内部的副作用是非常不好的做法。 不能保证该调用在未来的 Java 版本中不会被优化。 示例： '// map() 调用是冗余的\n  long count = list.stream().filter(s -> !s.isEmpty()).map(s -> s.trim()).count();' 2024.1 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告冗余的 `Stream` API 调用，如 `map()` 或在 `count()` 调用之前的 `boxed()`。\n\n\n此类调用不会改变最终计数，因此可以移除。 代码可能依赖于此类映射调用中 lambda 的副作用。 然而，依靠 Stream 链内部的副作用是非常不好的做法。 不能保证该调用在未来的 Java 版本中不会被优化。\n\n**示例：**\n\n\n      // map() 调用是冗余的\n      long count = list.stream().filter(s -> !s.isEmpty()).map(s -> s.trim()).count();\n\n2024.1 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MappingBeforeCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchExpressionCanBePushedDown",
                "shortDescription": {
                  "text": "可以从 'switch' 中提取通用子表达式"
                },
                "fullDescription": {
                  "text": "报告每个分支都有通用子表达式，因此 switch 可以移动到内部的 'switch' 表达式和语句。 此操作会缩短代码。 在许多情况下，将得到的 switch 表达式提取到单独的变量或方法是合理的。 示例： 'switch (value) {\n    case 0 -> System.out.println(\"zero\");\n    case 1 -> System.out.println(\"one\");\n    case 2, 3, 4 -> System.out.println(\"few\");\n    default -> System.out.println(\"many\");\n  }' 在应用快速修复后： 'System.out.println(switch (value) {\n    case 0 -> \"zero\";\n    case 1 -> \"one\";\n    case 2, 3, 4 -> \"few\";\n    default -> \"many\";\n  });' 此检查仅适用于采用箭头语法的增强 switch。 2022.3 最新变化 此检查取决于 Java 功能 ''switch' 表达式'，该功能自 Java 14 起可用。",
                  "markdown": "报告每个分支都有通用子表达式，因此 switch 可以移动到内部的 `switch` 表达式和语句。 此操作会缩短代码。 在许多情况下，将得到的 switch 表达式提取到单独的变量或方法是合理的。\n\n示例：\n\n\n      switch (value) {\n        case 0 -> System.out.println(\"zero\");\n        case 1 -> System.out.println(\"one\");\n        case 2, 3, 4 -> System.out.println(\"few\");\n        default -> System.out.println(\"many\");\n      }\n\n在应用快速修复后：\n\n\n      System.out.println(switch (value) {\n        case 0 -> \"zero\";\n        case 1 -> \"one\";\n        case 2, 3, 4 -> \"few\";\n        default -> \"many\";\n      });\n\n\n此检查仅适用于采用箭头语法的增强 switch。\n\n2022.3 最新变化\n\n此检查取决于 Java 功能 ''switch' 表达式'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SwitchExpressionCanBePushedDown",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExtendableApiUsage",
                "shortDescription": {
                  "text": "不应扩展类、接口或方法"
                },
                "fullDescription": {
                  "text": "报告扩展、实现或重写使用 '@ApiStatus.NonExtendable' 标记的 API 元素的类、接口和方法。 '@ApiStatus.NonExtendable' 注解表示不得扩展、实现或重写类、接口或方法。 将此类接口和类转换为内部库实现很常见，因此，如果客户端提供不同的实现，将获得 'ClassCastException'。 将新的 abstract 方法添加到这种类和接口将破坏与客户端实现的兼容性。",
                  "markdown": "报告扩展、实现或重写使用 `@ApiStatus.NonExtendable` 标记的 API 元素的类、接口和方法。\n\n\n`@ApiStatus.NonExtendable` 注解表示**不得扩展、实现或重写** 类、接口或方法。\n将此类接口和类转换为内部库实现很常见，因此，如果客户端提供不同的实现，将获得 `ClassCastException`。\n将新的 abstract 方法添加到这种类和接口将破坏与客户端实现的兼容性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExtendableApiUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedFieldAccess",
                "shortDescription": {
                  "text": "未使用 'this' 限定的实例字段访问"
                },
                "fullDescription": {
                  "text": "报告未使用 'this' 或某些其他限定符限定的字段访问操作。 某些编码样式要求对所有字段访问操作进行限定，以防止与局部变量或局部形参访问混淆。 示例： 'class Foo {\n    int foo;\n\n    void bar() {\n      foo += 1;\n    }\n  }' 在应用快速修复后： 'class Foo {\n    int foo;\n\n    void bar() {\n      this.foo += 1;\n    }\n  }'",
                  "markdown": "报告未使用 `this` 或某些其他限定符限定的字段访问操作。\n\n\n某些编码样式要求对所有字段访问操作进行限定，以防止与局部变量或局部形参访问混淆。\n\n**示例：**\n\n\n      class Foo {\n        int foo;\n\n        void bar() {\n          foo += 1;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        int foo;\n\n        void bar() {\n          this.foo += 1;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedFieldAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedCollectionQueryUpdate",
                "shortDescription": {
                  "text": "不匹配的集合查询和更新"
                },
                "fullDescription": {
                  "text": "报告其内容已查询但未更新或已更新但未查询的集合。 此类不一致查询和更新毫无意义，可能表明有死码或拼写错误。 使用检查设置可以指定与更新/查询方法相对应的名称模式。 返回元素的查询方法会被自动检测，并且只需指定将数据写入输出形参的查询方法（例如 'OutputStream'）。 示例： 假设您有一个包含方法 'store()' 的自定义 'FixedStack' 类： 'public class FixedStack<T> extends Collection<T> {\n    public T store(T t) {\n      // 实现\n    }\n  }' 您可以将 'store' 添加到更新方法表中，以报告不匹配的查询，例如： 'void test(int i) {\n    FixedStack<Integer> stack = new FixedStack<>();\n    stack.store(i);\n  }'",
                  "markdown": "报告其内容已查询但未更新或已更新但未查询的集合。\n\n\n此类不一致查询和更新毫无意义，可能表明有死码或拼写错误。\n\n\n使用检查设置可以指定与更新/查询方法相对应的名称模式。\n返回元素的查询方法会被自动检测，并且只需指定将数据写入输出形参的查询方法（例如 `OutputStream`）。\n\n\n**示例：**\n\n假设您有一个包含方法 `store()` 的自定义 `FixedStack` 类：\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // 实现\n        }\n      }\n\n您可以将 `store` 添加到更新方法表中，以报告不匹配的查询，例如：\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedQueryAndUpdateOfCollection",
                    "cweIds": [
                      561,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CharacterComparison",
                "shortDescription": {
                  "text": "字符比较"
                },
                "fullDescription": {
                  "text": "报告 'char' 值的顺序比较。 在国际化环境中，此类比较很少是正确的。",
                  "markdown": "报告 `char` 值的顺序比较。 在国际化环境中，此类比较很少是正确的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CharacterComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassReferencedViaSubclass",
                "shortDescription": {
                  "text": "通过子类引用的内部类"
                },
                "fullDescription": {
                  "text": "报告对其中的调用由声明类的子类而不是声明类本身限定的内部类和嵌套类的访问。 Java 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。 示例： 'class Super {\n    static class Inner {}\n  }\n\n  class Sub extends Super {\n    void test() {\n      Sub.Inner s = new Sub.Inner(); // 'Inner' 类在 'Super' 类中声明，但通过 'Sub' 类引用\n    }\n  }' 在应用快速修复后： 'class Super {\n    static class Inner {}\n  }\n\n  class Sub extends Super {\n    void test() {\n      Super.Inner s = new Super.Inner();\n    }\n  }'",
                  "markdown": "报告对其中的调用由声明类的子类而不是声明类本身限定的内部类和嵌套类的访问。\n\n\nJava 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。\n\n**示例：**\n\n\n      class Super {\n        static class Inner {}\n      }\n\n      class Sub extends Super {\n        void test() {\n          Sub.Inner s = new Sub.Inner(); // 'Inner' 类在 'Super' 类中声明，但通过 'Sub' 类引用\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Super {\n        static class Inner {}\n      }\n\n      class Sub extends Super {\n        void test() {\n          Super.Inner s = new Super.Inner();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassReferencedViaSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingElse",
                "shortDescription": {
                  "text": "冗余的 'else'"
                },
                "fullDescription": {
                  "text": "在 'if'—'else' 语句和语句链中报告冗余的 'else' 关键字。 当所有之前的分支以 'return'、'throw'、'break' 或 'continue' 语句结尾时，'else' 关键字冗余。 在这种情况下，来自 'else' 分支的语句可以放在 'if' 语句之后，并且 'else' 关键字可以删除。 示例： 'if (name == null) {\n      throw new IllegalArgumentException();\n  } else {\n      System.out.println(name);\n  }' 在应用快速修复后： 'if (name == null) {\n      throw new IllegalArgumentException();\n  }\n  System.out.println(name);' 禁用当 'if' 语句之后没有其他语句时报告选项，以忽略 'if'—'else' 语句是代码块中最后一条语句的情况。",
                  "markdown": "在 `if`---`else` 语句和语句链中报告冗余的 `else` 关键字。\n\n\n当所有之前的分支以 `return`、`throw`、`break` 或 `continue` 语句结尾时，`else` 关键字冗余。 在这种情况下，来自 `else` 分支的语句可以放在 `if` 语句之后，并且 `else` 关键字可以删除。\n\n**示例：**\n\n\n      if (name == null) {\n          throw new IllegalArgumentException();\n      } else {\n          System.out.println(name);\n      }\n\n在应用快速修复后：\n\n\n      if (name == null) {\n          throw new IllegalArgumentException();\n      }\n      System.out.println(name);\n\n禁用**当 'if' 语句之后没有其他语句时报告** 选项，以忽略 `if`---`else` 语句是代码块中最后一条语句的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConfusingElseBranch",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChannelResource",
                "shortDescription": {
                  "text": "打开了 'Channel'，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的 'Channel' 资源，包括任何通过在文件或套接字资源上调用 'getChannel()' 而创建的实例。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'void send(Socket socket) throws IOException {\n    SocketChannel channel = socket.getChannel(); //警告\n    channel.write(ByteBuffer.wrap(\"message\".getBytes()));\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开 'Channel' 资源。 这种样式不太合意，因为它比在 'try' 块前面打开 'Channel' 更复杂。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的 `Channel` 资源，包括任何通过在文件或套接字资源上调用 `getChannel()` 而创建的实例。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      void send(Socket socket) throws IOException {\n        SocketChannel channel = socket.getChannel(); //警告\n        channel.write(ByteBuffer.wrap(\"message\".getBytes()));\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开 `Channel` 资源。 这种样式不太合意，因为它比在 `try` 块前面打开 `Channel` 更复杂。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChannelOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ScheduledThreadPoolExecutorWithZeroCoreThreads",
                "shortDescription": {
                  "text": "带零个核心线程的 'ScheduledThreadPoolExecutor'"
                },
                "fullDescription": {
                  "text": "报告任何通过 'setCorePoolSize' 方法或对象构造函数将 'corePoolSize' 设置为零的 'java.util.concurrent.ScheduledThreadPoolExecutor' 实例。 无核心线程的 'ScheduledThreadPoolExecutor' 不运行任何内容。 示例： 'void foo(int corePoolSize) {\n      if (corePoolSize != 0) return;\n      ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // 警告\n      executor.setCorePoolSize(corePoolSize); // 警告\n  }'",
                  "markdown": "报告任何通过 `setCorePoolSize` 方法或对象构造函数将 `corePoolSize` 设置为零的 `java.util.concurrent.ScheduledThreadPoolExecutor` 实例。\n\n\n无核心线程的 `ScheduledThreadPoolExecutor` 不运行任何内容。\n\n**示例：**\n\n\n      void foo(int corePoolSize) {\n          if (corePoolSize != 0) return;\n          ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // 警告\n          executor.setCorePoolSize(corePoolSize); // 警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ScheduledThreadPoolExecutorWithZeroCoreThreads",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnThis",
                "shortDescription": {
                  "text": "在 'this' 上同步"
                },
                "fullDescription": {
                  "text": "报告 'this' 或 'class' 表达式的同步。 报告的结构包括 'synchronized' 块以及对 'wait()'、'notify()' 或 'notifyAll()' 的调用。 同步 'this' 或 'class' 表达式可能并非好主意，原因有几点： 它使同步成为类的外部接口的一部分，导致将来很难更改为其他锁定机制， 难以跟踪究竟是谁锁定了给定对象， 使得故意为之或在子类化时很容易意外发生的拒绝服务攻击成为可能。 替代做法是考虑在 'private final' 锁定对象上同步，可以完全控制对该对象的访问。 示例： 'public void print() {\n    synchronized(this) { // 警告：对 'this' 的锁定操作可能会产生不可预见的副作用\n      System.out.println(\"synchronized\");\n    }\n  }'",
                  "markdown": "报告 `this` 或 `class` 表达式的同步。 报告的结构包括 `synchronized` 块以及对 `wait()`、`notify()` 或 `notifyAll()` 的调用。\n\n同步 `this` 或 `class` 表达式可能并非好主意，原因有几点：\n\n1. 它使同步成为类的外部接口的一部分，导致将来很难更改为其他锁定机制，\n2. 难以跟踪究竟是谁锁定了给定对象，\n3. 使得故意为之或在子类化时很容易意外发生的拒绝服务攻击成为可能。\n\n替代做法是考虑在 `private final` 锁定对象上同步，可以完全控制对该对象的访问。\n\n**示例：**\n\n\n      public void print() {\n        synchronized(this) { // 警告：对 'this' 的锁定操作可能会产生不可预见的副作用\n          System.out.println(\"synchronized\");\n        }\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizeOnThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaEmptyModuleInfoFile",
                "shortDescription": {
                  "text": "空的 'module-info.java' 文件"
                },
                "fullDescription": {
                  "text": "报告空的 'module-info.java' 文件，指示未解析的模块依赖项。 通过检查导入自动添加必要的 'requires' 语句。 要取消显示此警告，您可以在模块语句主体中写入任何注释，如下所示： 'module module.name {\n    // 无依赖项\n}' 快速修复： 填充模块依赖项会基于源代码导入填充缺少的 'requires'。 2024.1 最新变化",
                  "markdown": "报告空的 `module-info.java` 文件，指示未解析的模块依赖项。 通过检查导入自动添加必要的 `requires` 语句。 要取消显示此警告，您可以在模块语句主体中写入任何注释，如下所示：\n\n\n    module module.name {\n        // 无依赖项\n    }\n\n**快速修复：** *填充模块依赖项* 会基于源代码导入填充缺少的 `requires`。 2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaEmptyModuleInfoFile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedAssignment",
                "shortDescription": {
                  "text": "未使用的赋值"
                },
                "fullDescription": {
                  "text": "报告赋值后未使用的赋值。 如果不使用，最好移除该赋值，以缩短代码并避免冗余分配。 将报告以下情况： 变量在赋值后从未被读取 变量在被读取前始终被新值重写 变量初始值设定项冗余（出于以上两种原因之一） 配置检查： 使用报告冗余初始值设定项选项可以报告冗余的初始值设定项： 'int getI() {\n    int i = 0; // 冗余初始化\n    i = 2;\n    return i;\n  }' 使用报告可被替换为二元表达式的前缀表达式选项可以报告可将 '++i' 表达式替换为 'i + 1' 的情况： 'int preInc(int value) {\n    int res = value;\n    return ++res;\n  }' 使用报告未使用更改后的值的后缀表达式选项可以报告稍后未使用 'i' 的值的 'i++' 情况： 'int postInc(int value) {\n    int res = value;\n    return res++;\n  }' 使用报告其值从未被使用的模式变量选项可以报告模式变量的值在读取之前被覆盖的情况： 'if (object instanceof String s) {\n      s = \"hello\";\n      System.out.println(s);\n  }' 使用报告其值从未被使用的迭代形参选项可以报告增强的 'for' 语句的迭代形参的值在读取前被覆盖的情况： 'for (String arg : args) {\n      arg = \"test\";\n      System.out.println(arg);\n  }'",
                  "markdown": "报告赋值后未使用的赋值。 如果不使用，最好移除该赋值，以缩短代码并避免冗余分配。\n\n将报告以下情况：\n\n* 变量在赋值后从未被读取\n* 变量在被读取前始终被新值重写\n* 变量初始值设定项冗余（出于以上两种原因之一）\n\n配置检查：\n\n\n使用**报告冗余初始值设定项**选项可以报告冗余的初始值设定项：\n\n\n      int getI() {\n        int i = 0; // 冗余初始化\n        i = 2;\n        return i;\n      }\n\n\n使用**报告可被替换为二元表达式的前缀表达式** 选项可以报告可将 `++i` 表达式替换为 `i + 1` 的情况：\n\n\n      int preInc(int value) {\n        int res = value;\n        return ++res;\n      }\n\n\n使用**报告未使用更改后的值的后缀表达式** 选项可以报告稍后未使用 `i` 的值的 `i++` 情况：\n\n\n      int postInc(int value) {\n        int res = value;\n        return res++;\n      }\n\n\n使用**报告其值从未被使用的模式变量**选项可以报告模式变量的值在读取之前被覆盖的情况：\n\n\n      if (object instanceof String s) {\n          s = \"hello\";\n          System.out.println(s);\n      }\n\n\n使用**报告其值从未被使用的迭代形参** 选项可以报告增强的 `for` 语句的迭代形参的值在读取前被覆盖的情况：\n\n\n      for (String arg : args) {\n          arg = \"test\";\n          System.out.println(arg);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedAssignment",
                    "cweIds": [
                      561,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HashCodeUsesNonFinalVariable",
                "shortDescription": {
                  "text": "'hashCode()' 中引用了非 final 字段"
                },
                "fullDescription": {
                  "text": "报告访问非 'final' 变量的 'hashCode()' 的实现。 此类访问可能导致 'hashCode()' 在该对象生命周期的不同时刻返回不同的值，进而可能在使用标准集合类时导致问题。 示例： 'class Drink {\n    String name;\n    Drink(String name) { this.name = name; }\n    @Override public int hashCode() {\n      return Objects.hash(name); //警告\n    }\n  }\n  ...\n    Drink coffee = new Drink(\"Coffee\");\n    priceMap.put(coffee, 10.0);\n    coffee.name = \"Tea\";\n    double coffeePrice = priceMap.get(coffee); //找不到' 建议通过快速修复将该字段设为 final： 'class Drink {\n    final String name;\n    ...\n  }'",
                  "markdown": "报告访问非 `final` 变量的 `hashCode()` 的实现。\n\n\n此类访问可能导致 `hashCode()` 在该对象生命周期的不同时刻返回不同的值，进而可能在使用标准集合类时导致问题。\n\n**示例：**\n\n\n      class Drink {\n        String name;\n        Drink(String name) { this.name = name; }\n        @Override public int hashCode() {\n          return Objects.hash(name); //警告\n        }\n      }\n      ...\n        Drink coffee = new Drink(\"Coffee\");\n        priceMap.put(coffee, 10.0);\n        coffee.name = \"Tea\";\n        double coffeePrice = priceMap.get(coffee); //找不到\n\n建议通过快速修复将该字段设为 final：\n\n\n      class Drink {\n        final String name;\n        ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldReferencedInHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedField",
                "shortDescription": {
                  "text": "protected 字段"
                },
                "fullDescription": {
                  "text": "报告 'protected' 字段。 不报告常量（即标记为 'static' 或 'final' 的变量）。 示例： 'public class A {\n    protected Object object;              // 警告\n    protected final static int MODE = 0;  // 常量，无警告\n  }'",
                  "markdown": "报告 `protected` 字段。\n\n不报告常量（即标记为 `static` 或 `final` 的变量）。\n\n**示例：**\n\n\n      public class A {\n        protected Object object;              // 警告\n        protected final static int MODE = 0;  // 常量，无警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProtectedField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentUsedAsCondition",
                "shortDescription": {
                  "text": "用作条件的赋值"
                },
                "fullDescription": {
                  "text": "报告用作 'if'、'while'、'for' 或 'do' 语句或条件表达式的赋值。 虽然有时是有意为之，但这种用法令人困惑，并且可能表明存在拼写错误（例如，应使用 '=' 而不是 '=='）。 该快速修复会将 '=' 替换为 '=='。 示例： 'void update(String str, boolean empty) {\n    // 警告：'empty' 被重新赋值，\n    // 不与 str.isEmpty() 进行比较\n    if (empty = str.isEmpty()) {\n      ...\n    }\n  }' 在应用快速修复后： 'void update(String str, boolean empty) {\n    if (empty == str.isEmpty()) {\n      ...\n    }\n  }'",
                  "markdown": "报告用作 `if`、`while`、`for` 或 `do` 语句或条件表达式的赋值。\n\n虽然有时是有意为之，但这种用法令人困惑，并且可能表明存在拼写错误（例如，应使用 `=` 而不是 `==`）。\n\n该快速修复会将 `=` 替换为 `==`。\n\n**示例：**\n\n\n      void update(String str, boolean empty) {\n        // 警告：'empty' 被重新赋值，\n        // 不与 str.isEmpty() 进行比较\n        if (empty = str.isEmpty()) {\n          ...\n        }\n      }\n\n在应用快速修复后：\n\n\n      void update(String str, boolean empty) {\n        if (empty == str.isEmpty()) {\n          ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentUsedAsCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofThis",
                "shortDescription": {
                  "text": "'this' 的 'instanceof' 检查"
                },
                "fullDescription": {
                  "text": "报告在其中检查 'this' 表达式的 'instanceof' 或 'getClass() == SomeClass.class' 的用法。 此类表达式表明面向对象的设计失败，应该替换为多态构造。 示例： 'class Super {\n  void process() {\n    if (this instanceof Sub) { // 警告\n      doSomething();\n    } else {\n      doSomethingElse();\n    }\n  }\n}\n  \nclass Sub extends Super {}' 要修正该问题，可以使用重写方法： 'class Super {\n  void process() {\n    doSomethingElse();\n  }\n}\n  \nclass Sub extends Super {\n  @Override\n  void process() {\n    doSomething();\n  }\n}'",
                  "markdown": "报告在其中检查 `this` 表达式的 `instanceof` 或 `getClass() == SomeClass.class` 的用法。\n\n此类表达式表明面向对象的设计失败，应该替换为多态构造。\n\n示例：\n\n\n    class Super {\n      void process() {\n        if (this instanceof Sub) { // 警告\n          doSomething();\n        } else {\n          doSomethingElse();\n        }\n      }\n    }\n      \n    class Sub extends Super {}\n\n要修正该问题，可以使用重写方法：\n\n\n    class Super {\n      void process() {\n        doSomethingElse();\n      }\n    }\n      \n    class Sub extends Super {\n      @Override\n      void process() {\n        doSomething();\n      }\n    }  \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceofThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassMayBeInterface",
                "shortDescription": {
                  "text": "'abstract' 类可以是 'interface'"
                },
                "fullDescription": {
                  "text": "报告可以转换为接口的 'abstract' 类。 最好使用接口而不是类，因为 Java 不支持多类继承，而一个类可以实现多个接口。 如果一个类没有超类（Object 以外）、只有 'public static final' 字段、'public abstract' 方法和 'public' 内部类，则可以将其转换为接口。 示例： 'abstract class Example {\n    public static final int MY_CONST = 42;\n    public abstract void foo();\n}\n\nclass Inheritor extends Example {\n    @Override\n    public void foo() {\n        System.out.println(MY_CONST);\n    }\n}' 在应用快速修复后： 'interface Example {\n    int MY_CONST = 42;\n    void foo();\n}\n\nclass Inheritor implements Example {\n    @Override\n    public void foo() {\n        System.out.println(MY_CONST);\n    }\n}' 配置检查： 使用 Java 8 时报告包含非 abstract 方法的类 选项可用于仅报告其 'static' 和非 abstract 方法可以转换为 'default' 方法的类（仅适用于语言级别为 8 或更高时）。",
                  "markdown": "报告可以转换为接口的 `abstract` 类。\n\n最好使用接口而不是类，因为 Java 不支持多类继承，而一个类可以实现多个接口。\n\n如果一个类没有超类（Object 以外）、只有 `public static final` 字段、`public abstract` 方法和 `public` 内部类，则可以将其转换为接口。\n\n\n示例：\n\n\n    abstract class Example {\n        public static final int MY_CONST = 42;\n        public abstract void foo();\n    }\n\n    class Inheritor extends Example {\n        @Override\n        public void foo() {\n            System.out.println(MY_CONST);\n        }\n    }\n\n在应用快速修复后：\n\n\n    interface Example {\n        int MY_CONST = 42;\n        void foo();\n    }\n\n    class Inheritor implements Example {\n        @Override\n        public void foo() {\n            System.out.println(MY_CONST);\n        }\n    }\n\n配置检查：\n\n\n**使用 Java 8 时报告包含非 abstract 方法的类** 选项可用于仅报告其 `static` 和非 abstract 方法可以转换为 `default` 方法的类（仅适用于语言级别为 8 或更高时）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ClassMayBeInterface",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageInMultipleModules",
                "shortDescription": {
                  "text": "具有多个模块中的类的软件包"
                },
                "fullDescription": {
                  "text": "报告存在于多个模块中的非空软件包。 当软件包被包含在多个模块中时，很容易在两个模块中创建同名的类。 依赖于这些模块的模块如果尝试使用这种类，就会发生冲突。 Java Platform Module System 不允许包含在多个模块中的软件包（也称为 拆分软件包） 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告存在于多个模块中的非空软件包。 当软件包被包含在多个模块中时，很容易在两个模块中创建同名的类。 依赖于这些模块的模块如果尝试使用这种类，就会发生冲突。 Java Platform Module System 不允许包含在多个模块中的软件包（也称为 *拆分软件包* ）\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageInMultipleModules",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryCallToStringValueOf",
                "shortDescription": {
                  "text": "到 'String' 的不必要转换"
                },
                "fullDescription": {
                  "text": "报告对将其形参转换为字符串的 static 方法（例如 'String.valueOf()' 或 'Integer.toString()'）的不必要调用。 在字符串串联中使用时，此类调用是不必要的。 示例： 'System.out.println(\"Number: \" + Integer.toString(count));' 在应用快速修复后： 'System.out.println(\"Number: \" + count);' 此外，用作进行自身字符串转换的库方法的实参时，此类调用是不必要的。 一些进行自身字符串转换的库方法的示例如下： 类 'java.io.PrintWriter', 'java.io.PrintStream' 'print()', 'println()' 类 'java.lang.StringBuilder', 'java.lang.StringBuffer' 'append()' 类 'org.slf4j.Logger' 'trace()', 'debug()', 'info()', 'warn()', 'error()' 使用报告可被替换为带空字符串的串联的调用选项还可以报告可使用带空字符串的串联代替 'String.valueOf()' 调用的情况。",
                  "markdown": "报告对将其形参转换为字符串的 static 方法（例如 `String.valueOf()` 或 `Integer.toString()`）的不必要调用。 在字符串串联中使用时，此类调用是不必要的。\n\n示例：\n\n\n      System.out.println(\"Number: \" + Integer.toString(count));\n\n在应用快速修复后：\n\n\n      System.out.println(\"Number: \" + count);\n\n此外，用作进行自身字符串转换的库方法的实参时，此类调用是不必要的。 一些进行自身字符串转换的库方法的示例如下：\n\n* 类 `java.io.PrintWriter`, `java.io.PrintStream`\n  * `print()`, `println()`\n* 类 `java.lang.StringBuilder`, `java.lang.StringBuffer`\n  * `append()`\n* 类 `org.slf4j.Logger`\n  * `trace()`, `debug()`, `info()`, `warn()`, `error()`\n\n\n使用**报告可被替换为带空字符串的串联的调用** 选项还可以报告可使用带空字符串的串联代替 `String.valueOf()` 调用的情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryCallToStringValueOf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FloatingPointEquality",
                "shortDescription": {
                  "text": "浮点相等比较"
                },
                "fullDescription": {
                  "text": "报告使用 '==' 或 '!=' 运算符进行比较的浮点值。 浮点值本质上是不准确的，比较它们是否完全相等很少是所需的语义。 此检查会忽略与零和无穷大文字的比较。 示例： 'void m(double d1, double d2) {\n    if (d1 == d2) {}\n  }'",
                  "markdown": "报告使用 `==` 或 `!=` 运算符进行比较的浮点值。\n\n浮点值本质上是不准确的，比较它们是否完全相等很少是所需的语义。\n\n此检查会忽略与零和无穷大文字的比较。\n\n**示例：**\n\n\n      void m(double d1, double d2) {\n        if (d1 == d2) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FloatingPointEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringReplaceableByStringBuffer",
                "shortDescription": {
                  "text": "非常量 'String' 可被替换为 'StringBuilder'"
                },
                "fullDescription": {
                  "text": "报告被声明为 'java.lang.String' 且重复追加的变量。 此类变量可以更有效地被声明为 'java.lang.StringBuffer' 或 'java.lang.StringBuilder'。 示例： 'String s = \"\";\n  for (int i = 0; i < names.length; i++) {\n    String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n    s = s + name;\n  }' 此类循环可以替换为： 'StringBuilder s = new StringBuilder();\n  for (int i = 0; i < names.length; i++) {\n    String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n    s.append(name);\n  }' 或者甚至可以替换为： 'String s = String.join(\" \", names);' 使用该选项可使此检查仅在变量被附加到循环中时报告。",
                  "markdown": "报告被声明为 `java.lang.String` 且重复追加的变量。 此类变量可以更有效地被声明为 `java.lang.StringBuffer` 或 `java.lang.StringBuilder`。\n\n**示例：**\n\n\n      String s = \"\";\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n        s = s + name;\n      }\n\n此类循环可以替换为：\n\n\n      StringBuilder s = new StringBuilder();\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n        s.append(name);\n      }\n\n或者甚至可以替换为：\n\n\n      String s = String.join(\" \", names);\n\n\n使用该选项可使此检查仅在变量被附加到循环中时报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonConstantStringShouldBeStringBuffer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SequencedCollectionMethodCanBeUsed",
                "shortDescription": {
                  "text": "可以使用 SequencedCollection 方法"
                },
                "fullDescription": {
                  "text": "报告可以使用 'SequencedCollection' 方法简化的集合 API 方法调用。 支持以下转换： 'list.add(0, element)' → 'list.addFirst(element);' 'list.get(0)' → 'list.getFirst();' 'list.get(list.size() - 1)' → 'list.getLast();' 'list.remove(0)' → 'list.removeFirst();' 'list.remove(list.size() - 1)' → 'list.removeLast();' 'collection.iterator().next()' → 'collection.getFirst();' 2023.3 最新变化 此检查取决于 Java 功能 '有序集合'，该功能自 Java 21 起可用。",
                  "markdown": "报告可以使用 `SequencedCollection` 方法简化的集合 API 方法调用。\n\n支持以下转换：\n\n* `list.add(0, element)` → `list.addFirst(element);`\n* `list.get(0)` → `list.getFirst();`\n* `list.get(list.size() - 1)` → `list.getLast();`\n* `list.remove(0)` → `list.removeFirst();`\n* `list.remove(list.size() - 1)` → `list.removeLast();`\n* `collection.iterator().next()` → `collection.getFirst();`\n\n2023.3 最新变化\n\n此检查取决于 Java 功能 '有序集合'，该功能自 Java 21 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SequencedCollectionMethodCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicField",
                "shortDescription": {
                  "text": "'public' 字段"
                },
                "fullDescription": {
                  "text": "报告 'public' 字段。 不报告常量（标记 'static' 和 'final' 的字段）。 示例： 'class Main {\n    public String name;\n  }' 在应用快速修复后： 'class Main {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n  }' 配置检查： 使用有注解时忽略列表可指定要忽略的注解。 该检查将忽略包含其中任何注解的字段。 使用忽略枚举的 'public final' 字段选项，可以忽略 'enum' 类型的 'public final' 字段。",
                  "markdown": "报告 `public` 字段。 不报告常量（标记 `static` 和 `final` 的字段）。\n\n**示例：**\n\n\n      class Main {\n        public String name;\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n      }\n\n配置检查：\n\n* 使用**有注解时忽略**列表可指定要忽略的注解。 该检查将忽略包含其中任何注解的字段。\n* 使用**忽略枚举的 'public final' 字段** 选项，可以忽略 `enum` 类型的 `public final` 字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PublicField",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinallyBlockCannotCompleteNormally",
                "shortDescription": {
                  "text": "不能正常完成的 'finally' 块"
                },
                "fullDescription": {
                  "text": "报告在 'finally' 块内使用的 'return'、'throw'、'break'、'continue' 和 'yield' 语句。 这些会导致 'finally' 块无法正常完成，而是突然完成。 从同一 'try'-'catch' 语句的 'try' 和 'catch' 块抛出的任何异常将被禁止。 示例： 'void x() {\n    try {\n      throw new RuntimeException();\n    } finally {\n      // 如果 bar() 返回 true，则 RuntimeException 将被禁止\n      if (bar()) return;\n    }\n  }'",
                  "markdown": "报告在 `finally` 块内使用的 `return`、`throw`、`break`、`continue` 和 `yield` 语句。 这些会导致 `finally` 块无法正常完成，而是突然完成。 从同一 `try`-`catch` 语句的 `try` 和 `catch` 块抛出的任何异常将被禁止。\n\n**示例：**\n\n\n      void x() {\n        try {\n          throw new RuntimeException();\n        } finally {\n          // 如果 bar() 返回 true，则 RuntimeException 将被禁止\n          if (bar()) return;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "finally",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantOnWrongSideOfComparison",
                "shortDescription": {
                  "text": "常量位于比较的错误一侧"
                },
                "fullDescription": {
                  "text": "报告常量值在错误一侧的比较运算。 某些编码约定会指定常量应该位于比较的特定一侧，要么左侧，要么右侧。 示例： 'boolean compare(int x) {\n    return 1 > x; // 位于比较左侧的常量 '1'\n  }' 在应用快速修复后： 'boolean compare(int x) {\n    return x < 1;\n  }' 使用检查设置可以选择比较中的常量一侧，并选择 'null' 文字位于错误一侧时是否发出警告。 2019.2 最新变化",
                  "markdown": "报告常量值在错误一侧的比较运算。\n\n某些编码约定会指定常量应该位于比较的特定一侧，要么左侧，要么右侧。\n\n**示例：**\n\n\n      boolean compare(int x) {\n        return 1 > x; // 位于比较左侧的常量 '1'\n      }\n\n在应用快速修复后：\n\n\n      boolean compare(int x) {\n        return x < 1;\n      }\n\n\n使用检查设置可以选择比较中的常量一侧，并选择 `null` 文字位于错误一侧时是否发出警告。\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantOnWrongSideOfComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerialAnnotationUsedOnWrongMember",
                "shortDescription": {
                  "text": "对错误的成员使用了 '@Serial' 注解"
                },
                "fullDescription": {
                  "text": "报告 'Serializable' 和 'Externalizable' 类中不适合使用 'java.io.Serial' 注解进行注解的方法和字段。 示例： 'class Test implements Serializable {\n  @Serial // 注解的字段不是序列化机制的一部分，因为它并非 final\n  private static long serialVersionUID = 7874493593505141603L;\n\n  @Serial // 注解的方法不是序列化机制的一部分，因为它并非 private\n  void writeObject(ObjectOutputStream out) throws IOException {\n  }\n}' 'class Test implements Externalizable {\n  @Serial // 该注解方法不是序列化机制的一部分，因为它在 Externalizable 类内部\n  private void writeObject(ObjectOutputStream out) throws IOException {\n  }\n}' 有关所有有效情况的信息，请参阅 'java.io.Serial' 类的 Javadoc。 2020.3 最新变化 此检查取决于 Java 功能 '@Serial 注解'，该功能自 Java 14 起可用。",
                  "markdown": "报告 `Serializable` 和 `Externalizable` 类中不适合使用 `java.io.Serial` 注解进行注解的方法和字段。\n\n**示例：**\n\n\n    class Test implements Serializable {\n      @Serial // 注解的字段不是序列化机制的一部分，因为它并非 final\n      private static long serialVersionUID = 7874493593505141603L;\n\n      @Serial // 注解的方法不是序列化机制的一部分，因为它并非 private\n      void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\n\n    class Test implements Externalizable {\n      @Serial // 该注解方法不是序列化机制的一部分，因为它在 Externalizable 类内部\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\n有关所有有效情况的信息，请参阅 `java.io.Serial` 类的 Javadoc。\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '@Serial 注解'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "serial",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarilyQualifiedStaticallyImportedElement",
                "shortDescription": {
                  "text": "不必要的限定静态导入元素"
                },
                "fullDescription": {
                  "text": "报告用其包含类名限定的静态导入成员的用法。 此类限定不必要且可移除，因为可以通过成员名称直接访问静态导入成员。 示例： 'import static foo.Test.WIDTH;\n\n  class Bar {\n    void bar() {\n      System.out.println(Test.WIDTH);\n    }\n  }' 在应用快速修复后： 'import static foo.Test.WIDTH;\n\n  class Bar {\n    void bar() {\n      System.out.println(WIDTH);\n    }\n  }'",
                  "markdown": "报告用其包含类名限定的静态导入成员的用法。\n\n此类限定不必要且可移除，因为可以通过成员名称直接访问静态导入成员。\n\n**示例：**\n\n\n      import static foo.Test.WIDTH;\n\n      class Bar {\n        void bar() {\n          System.out.println(Test.WIDTH);\n        }\n      }\n\n在应用快速修复后：\n\n\n      import static foo.Test.WIDTH;\n\n      class Bar {\n        void bar() {\n          System.out.println(WIDTH);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarilyQualifiedStaticallyImportedElement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectToString",
                "shortDescription": {
                  "text": "调用默认 'toString()'"
                },
                "fullDescription": {
                  "text": "报告对使用 'java.lang.Object' 中默认实现的 'toString()' 的调用。 该默认实现很少是有意为之，可能是误用。 此检查将忽略对包含 'java.lang.Object'、接口或 abstract 类类型的对象的 'toString()' 调用。 示例： 'class Bar {\n      void foo1(Bar bar) {\n          String s = bar.toString(); // 警告\n          /* ... */\n      }\n\n      void foo2(Object obj) {\n          String s = obj.toString(); // 此处无警告\n          /* ... */\n      }\n  }'",
                  "markdown": "报告对使用 `java.lang.Object` 中默认实现的 `toString()` 的调用。\n\n该默认实现很少是有意为之，可能是误用。\n\n\n此检查将忽略对包含 `java.lang.Object`、接口或 abstract 类类型的对象的 `toString()` 调用。\n\n**示例：**\n\n\n      class Bar {\n          void foo1(Bar bar) {\n              String s = bar.toString(); // 警告\n              /* ... */\n          }\n\n          void foo2(Object obj) {\n              String s = obj.toString(); // 此处无警告\n              /* ... */\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfJDBCDriverClass",
                "shortDescription": {
                  "text": "使用具体的 JDBC 驱动程序类"
                },
                "fullDescription": {
                  "text": "报告使用特定 JDBC 驱动程序类的情况。 使用这种类会将您的项目绑定到特定的数据库和驱动程序，从而违背了 JDBC 的目的并导致失去可移植性。 示例： 'import java.sql.Driver;\n\n  abstract class Sample implements Driver {\n    public void foo() {\n        Sample sample;\n    }\n  }'",
                  "markdown": "报告使用特定 JDBC 驱动程序类的情况。 使用这种类会将您的项目绑定到特定的数据库和驱动程序，从而违背了 JDBC 的目的并导致失去可移植性。\n\n**示例：**\n\n\n      import java.sql.Driver;\n\n      abstract class Sample implements Driver {\n        public void foo() {\n            Sample sample;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfJDBCDriverClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JDBCResource",
                "shortDescription": {
                  "text": "JDBC 资源已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的 JDBC 资源。 此检查报告的 JDBC 资源包括 'java.sql.Connection'、'java.sql.Statement'、'java.sql.PreparedStatement'、'java.sql.CallableStatement' 和 'java.sql.ResultSet'。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'ResultSet findAllElements(Connection connection) throws SQLException {\n    PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM TABLE\");//语句未关闭\n    statement.execute();\n    return statement.getResultSet();\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开 JDBC 资源。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的 JDBC 资源。 此检查报告的 JDBC 资源包括 `java.sql.Connection`、`java.sql.Statement`、`java.sql.PreparedStatement`、`java.sql.CallableStatement` 和 `java.sql.ResultSet`。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      ResultSet findAllElements(Connection connection) throws SQLException {\n        PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM TABLE\");//语句未关闭\n        statement.execute();\n        return statement.getResultSet();\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开 JDBC 资源。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JDBCResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowsRuntimeException",
                "shortDescription": {
                  "text": "在 'throws' 子句中声明的未检查的异常"
                },
                "fullDescription": {
                  "text": "报告方法 'throws' 子句中未检查的异常的声明（'java.lang.RuntimeException' 或其子类之一）。 未检查的异常的声明不是必需的，可以删除或移动到 Javadoc '@throws' 标记。 示例： 'public class InvalidDataException extends RuntimeException {}\n\n  class TextEditor {\n    void readSettings() throws InvalidDataException {} // 警告：在 'throws' 子句中声明了未检查的异常 'InvalidDataException'\n  }'",
                  "markdown": "报告方法 `throws` 子句中未检查的异常的声明（`java.lang.RuntimeException` 或其子类之一）。\n\n未检查的异常的声明不是必需的，可以删除或移动到 Javadoc `@throws` 标记。\n\n**示例：**\n\n\n      public class InvalidDataException extends RuntimeException {}\n\n      class TextEditor {\n        void readSettings() throws InvalidDataException {} // 警告：在 'throws' 子句中声明了未检查的异常 'InvalidDataException'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowsRuntimeException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JNDIResource",
                "shortDescription": {
                  "text": "JNDI 资源已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的 JNDI 资源。 此检查报告的 JNDI 资源包括 'javax.naming.InitialContext'和 'javax.naming.NamingEnumeration'。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'Object findObject(Properties properties, String name) throws NamingException {\n    Context context = new InitialContext(properties); //上下文未关闭\n    return context.lookup(name);\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开 JNDI 资源。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的 JNDI 资源。 此检查报告的 JNDI 资源包括 `javax.naming.InitialContext`和 `javax.naming.NamingEnumeration`。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      Object findObject(Properties properties, String name) throws NamingException {\n        Context context = new InitialContext(properties); //上下文未关闭\n        return context.lookup(name);\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开 JNDI 资源。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JNDIResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewObjectEquality",
                "shortDescription": {
                  "text": "使用 '==' 比较新对象"
                },
                "fullDescription": {
                  "text": "报告将 '==' 或 '!=' 应用于新分配对象而不是调用 'equals()' 的代码。 对新分配对象的引用不能指向现有对象，因此比较结果始终为 'false'。 该检查还可以报告从简单方法返回的新建对象。 示例： 'void test(Object obj) {\n    if (new Object() == obj) {...}\n  }' 在应用快速修复后： 'void test(Object obj) {\n    if (new Object().equals(obj)) {...}\n  }' 2018.3 最新变化",
                  "markdown": "报告将 `==` 或 `!=` 应用于新分配对象而不是调用 `equals()` 的代码。\n\n\n对新分配对象的引用不能指向现有对象，因此比较结果始终为 `false`。 该检查还可以报告从简单方法返回的新建对象。\n\n**示例：**\n\n\n      void test(Object obj) {\n        if (new Object() == obj) {...}\n      }\n\n在应用快速修复后：\n\n\n      void test(Object obj) {\n        if (new Object().equals(obj)) {...}\n      }\n\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewObjectEquality",
                    "cweIds": [
                      480
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TryWithIdenticalCatches",
                "shortDescription": {
                  "text": "'try' 语句中的相同 'catch' 分支"
                },
                "fullDescription": {
                  "text": "报告单个 'try' 语句中相同的 'catch' 部分。 将这些部分折叠成一个 multi-catch 块可以减少代码重复，并防止出现一个 'catch' 部分更新而另一个部分未更新的情况。 示例： 'try {\n        doSmth();\n    }\n    catch (IOException e) {\n        LOG.error(e);\n    }\n    catch (URISyntaxException e) {\n        LOG.error(e);\n    }' 可通过快速修复使代码更加紧凑： 'try {\n        doSmth();\n    }\n    catch (IOException | URISyntaxException e) {\n        LOG.error(e);\n    }' 此检查取决于 Java 功能 '多 catch'，该功能自 Java 7 起可用。",
                  "markdown": "报告单个 `try` 语句中相同的 `catch` 部分。\n\n将这些部分折叠成一个 *multi-catch* 块可以减少代码重复，并防止出现一个 `catch` 部分更新而另一个部分未更新的情况。\n\n**示例：**\n\n\n        try {\n            doSmth();\n        }\n        catch (IOException e) {\n            LOG.error(e);\n        }\n        catch (URISyntaxException e) {\n            LOG.error(e);\n        }\n\n可通过快速修复使代码更加紧凑：\n\n\n        try {\n            doSmth();\n        }\n        catch (IOException | URISyntaxException e) {\n            LOG.error(e);\n        }\n\n此检查取决于 Java 功能 '多 catch'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TryWithIdenticalCatches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingSimilarMessage",
                "shortDescription": {
                  "text": "不可区分的日志记录调用"
                },
                "fullDescription": {
                  "text": "报告一个类中的 SLF4J 或 Log4j2 日志记录调用，例如具有类似日志消息的 'logger.info(\"message: {}\", key)'。 这些调用之间可能无法区分，这给理解某个日志消息来自何处带来了困难。 示例 (Java)： 'private static void request1(String text) {\n      log.info(\"Message: {}\", text); //类似调用\n      doSomething1();\n  }\n\n  private static void request2(int i) {\n      log.info(\"Message: {}\", i); //类似调用\n      doSomething2();\n  }' 使用相似序列的最小长度选项可设置相似序列的最小长度，之后将报告调用 使用不报告日志级别为 'error' 的调用选项可忽略日志级别为 `error` 且存在异常的消息。 隐藏警告可能会有用，因为仍然可以使用堆栈跟踪来定位调用站点 2024.1 最新变化",
                  "markdown": "报告一个类中的 SLF4J 或 Log4j2 日志记录调用，例如具有类似日志消息的 `logger.info(\"message: {}\", key)`。 这些调用之间可能无法区分，这给理解某个日志消息来自何处带来了困难。\n\n**示例 (Java)：**\n\n\n      private static void request1(String text) {\n          log.info(\"Message: {}\", text); //类似调用\n          doSomething1();\n      }\n\n      private static void request2(int i) {\n          log.info(\"Message: {}\", i); //类似调用\n          doSomething2();\n      }\n\n* 使用**相似序列的最小长度**选项可设置相似序列的最小长度，之后将报告调用\n* 使用**不报告日志级别为 'error' 的调用**选项可忽略日志级别为 \\`error\\` 且存在异常的消息。 隐藏警告可能会有用，因为仍然可以使用堆栈跟踪来定位调用站点\n\n2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LoggingSimilarMessage",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaCanBeReplacedWithAnonymous",
                "shortDescription": {
                  "text": "lambda 可被替换为匿名类"
                },
                "fullDescription": {
                  "text": "报告可以替换为匿名类的 lambda 表达式。 如果需要在匿名类中实现其他方法，则将 lambda 表达式扩展到匿名类会很有用。 示例： 's -> System.out.println(s)' 在应用快速修复后： 'new Consumer<String>() {\n  @Override\n  public void accept(String s) {\n    System.out.println(s);\n  }\n}' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为匿名类的 lambda 表达式。\n\n\n如果需要在匿名类中实现其他方法，则将 lambda 表达式扩展到匿名类会很有用。\n\n示例：\n\n\n      s -> System.out.println(s)\n\n在应用快速修复后：\n\n    new Consumer<String>() {\n      @Override\n      public void accept(String s) {\n        System.out.println(s);\n      }\n    }\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaCanBeReplacedWithAnonymous",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCompareCall",
                "shortDescription": {
                  "text": "冗余的 'compare()' 方法调用"
                },
                "fullDescription": {
                  "text": "报告其中的 'compare' 方法多余的比较。 示例： 'boolean result = Integer.compare(a, b) == 0;' 在应用快速修复后： 'boolean result = a == b;' 2018.2 最新变化",
                  "markdown": "报告其中的 `compare` 方法多余的比较。\n\n示例：\n\n\n      boolean result = Integer.compare(a, b) == 0;\n\n在应用快速修复后：\n\n\n      boolean result = a == b;\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCompareCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfCanBeAssertion",
                "shortDescription": {
                  "text": "语句可被替换为 'assert' 或 'Objects.requireNonNull'"
                },
                "fullDescription": {
                  "text": "报告仅从 'then' 分支抛出 'java.lang.Throwable' 而没有 'else' 分支的 'if' 语句。 此类语句可以转换为更紧凑的 'assert' 语句。 检查还报告 Guava 的 'Preconditions.checkNotNull()'。 它们可以替换为不需要库 'Objects.requireNonNull()' 调用。 示例： 'if (x == 2) throw new RuntimeException(\"fail\");\n  if (y == null) throw new AssertionError();\n  Preconditions.checkNotNull(z, \"z\");' 在应用快速修复后： 'assert x != 2 : \"fail\";\n  Objects.requireNonNull(y);\n  Objects.requireNonNull(z, \"z\");' 默认情况下，此检查在编辑器中提供快速修复，而没有高亮显示代码。 此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。",
                  "markdown": "报告仅从 `then` 分支抛出 `java.lang.Throwable` 而没有 `else` 分支的 `if` 语句。 此类语句可以转换为更紧凑的 `assert` 语句。\n\n\n检查还报告 Guava 的 `Preconditions.checkNotNull()`。\n它们可以替换为不需要库 `Objects.requireNonNull()` 调用。\n\n示例：\n\n\n      if (x == 2) throw new RuntimeException(\"fail\");\n      if (y == null) throw new AssertionError();\n      Preconditions.checkNotNull(z, \"z\");\n\n在应用快速修复后：\n\n\n      assert x != 2 : \"fail\";\n      Objects.requireNonNull(y);\n      Objects.requireNonNull(z, \"z\");\n\n默认情况下，此检查在编辑器中提供快速修复，而没有高亮显示代码。\n\n此检查取决于 Java 功能 '断言'，该功能自 Java 1.4 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfCanBeAssertion",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyClass",
                "shortDescription": {
                  "text": "空类"
                },
                "fullDescription": {
                  "text": "报告空类和空 Java 文件。 如果一个类不包含任何字段、方法、构造函数或初始值设定项，则为空类。 在进行重大更改或重构后，空类有时会被保留下来。 示例： 'class Example {\n    List<String> getList() {\n       return new ArrayList<>() {\n\n       };\n    }\n  }' 在应用快速修复后： 'class Example {\n    List<String> getList() {\n       return new ArrayList<>();\n    }\n  }' 配置检查： 使用有注解时忽略选项可以指定特殊注解。 该检查将忽略用这些注解标记的类。 使用如果类是父类型的形参化，则将其忽略选项，可以忽略形参化超类的类。 示例： 'class MyList extends ArrayList<String> {}' 使用忽略 java.lang.Throwable 的子类，可以忽略扩展 'java.lang.Throwable' 的类。 使用注释计为内容选项可忽略包含注释的类。",
                  "markdown": "报告空类和空 Java 文件。\n\n如果一个类不包含任何字段、方法、构造函数或初始值设定项，则为空类。 在进行重大更改或重构后，空类有时会被保留下来。\n\n**示例：**\n\n\n      class Example {\n        List<String> getList() {\n           return new ArrayList<>() {\n\n           };\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Example {\n        List<String> getList() {\n           return new ArrayList<>();\n        }\n      }\n\n配置检查：\n\n* 使用**有注解时忽略**选项可以指定特殊注解。 该检查将忽略用这些注解标记的类。\n*\n  使用**如果类是父类型的形参化，则将其忽略**选项，可以忽略形参化超类的类。 示例：\n\n      class MyList extends ArrayList<String> {}\n\n* 使用**忽略 java.lang.Throwable 的子类** ，可以忽略扩展 `java.lang.Throwable` 的类。\n* 使用**注释计为内容**选项可忽略包含注释的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextBlockBackwardMigration",
                "shortDescription": {
                  "text": "文本块可被替换为正则字符串文字"
                },
                "fullDescription": {
                  "text": "报告可以替换为常规字符串文字的文本块。 此检查有助于为向后兼容早期 Java 版本而降级。 示例： 'Object obj = engine.eval(\"\"\"\n                           function hello() {\n                             print('\"Hello, world\"');\n                           }\n\n                           hello();\n                           \"\"\");' 在应用快速修复后： 'Object obj = engine.eval(\"function hello() {\\n\" +\n                           \"  print('\\\"Hello, world\\\"');\\n\" +\n                           \"}\\n\" +\n                           \"\\n\" +\n                           \"hello();\\n\");' 2019.3 最新变化 此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。",
                  "markdown": "报告可以替换为常规字符串文字的文本块。 此检查有助于为向后兼容早期 Java 版本而降级。\n\n**示例：**\n\n\n      Object obj = engine.eval(\"\"\"\n                               function hello() {\n                                 print('\"Hello, world\"');\n                               }\n\n                               hello();\n                               \"\"\");\n\n在应用快速修复后：\n\n\n      Object obj = engine.eval(\"function hello() {\\n\" +\n                               \"  print('\\\"Hello, world\\\"');\\n\" +\n                               \"}\\n\" +\n                               \"\\n\" +\n                               \"hello();\\n\");\n\n2019.3 最新变化\n\n此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TextBlockBackwardMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 15",
                      "index": 101,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocDeclaration",
                "shortDescription": {
                  "text": "Javadoc 声明问题"
                },
                "fullDescription": {
                  "text": "报告具有以下问题的 Javadoc 注释和标记： 标记名称无效 标记描述不完整 标记重复 缺少 Javadoc 描述 示例： '/**\n   * 标记名称无效\n   * @poram param description\n   */\n  public void sample(int param){\n  }' 示例： '/**\n   * 指向自身 {@link #sample(int)}\n   */\n  public void sample(int param){\n  }' 该快速修复会将未知的 Javadoc 标记添加到用户定义的附加标记列表中。 使用下面的文本字段可以定义附加 Javadoc 标记。 使用第一个复选框可以忽略重复的 'throws' 标记。 使用第二个复选框可以忽略描述中第一句话缺失或不完整的问题。 使用第三个复选框可以忽略指向自身的引用。",
                  "markdown": "报告具有以下问题的 Javadoc 注释和标记：\n\n* 标记名称无效\n* 标记描述不完整\n* 标记重复\n* 缺少 Javadoc 描述\n\n示例：\n\n\n      /**\n       * 标记名称无效\n       * @poram param description\n       */\n      public void sample(int param){\n      }\n\n示例：\n\n\n      /**\n       * 指向自身 {@link #sample(int)}\n       */\n      public void sample(int param){\n      }\n\n该快速修复会将未知的 Javadoc 标记添加到用户定义的附加标记列表中。\n\n使用下面的文本字段可以定义附加 Javadoc 标记。\n\n使用第一个复选框可以忽略重复的 'throws' 标记。\n\n使用第二个复选框可以忽略描述中第一句话缺失或不完整的问题。\n\n使用第三个复选框可以忽略指向自身的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalCanBeOptional",
                "shortDescription": {
                  "text": "条件可被替换为 Optional"
                },
                "fullDescription": {
                  "text": "报告 null 检查条件并建议用 'Optional' 链替换它们。 示例： 'return str == null ? \"\" : str.trim();' 应用快速修复后： 'return Optional.ofNullable(str).map(String::trim).orElse(\"\");' 虽然替换并不总是更短，但它可能有助于进一步重构（例如，将方法返回值更改为 'Optional'）。 请注意，当条件的非 null 分支返回 null 值时，相应的映射步骤将产生一个空的 'Optional'，可能会改变语义。 如果不能静态证明保留语义，则快速修复操作名称将包含 “（可能更改语义）” 通知，并关闭检查高亮显示。 2018.1 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告 null 检查条件并建议用 `Optional` 链替换它们。\n\n示例：\n\n\n      return str == null ? \"\" : str.trim();\n\n应用快速修复后：\n\n\n      return Optional.ofNullable(str).map(String::trim).orElse(\"\");\n\n虽然替换并不总是更短，但它可能有助于进一步重构（例如，将方法返回值更改为 `Optional`）。\n\n请注意，当条件的非 null 分支返回 null 值时，相应的映射步骤将产生一个空的 `Optional`，可能会改变语义。 如果不能静态证明保留语义，则快速修复操作名称将包含 \"（可能更改语义）\" 通知，并关闭检查高亮显示。\n\n2018.1 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConditionalCanBeOptional",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToMethodParameter",
                "shortDescription": {
                  "text": "赋值给方法形参"
                },
                "fullDescription": {
                  "text": "报告对方法形参的赋值或修改。 虽然有时是有意为之，但此结构可能令人困惑，因此在一些 Java 项目中被禁止使用。 该快速修复会添加新变量的声明。 示例： 'void printTrimmed(String s) {\n    s = s.trim();\n    System.out.println(s);\n  }' 在应用快速修复后： 'void printTrimmed(String s) {\n    String trimmed = s.trim();\n    System.out.println(trimmed);\n  }' 使用如果赋值是原始形参的转换，则忽略选项可忽略根据先前值修改形参值的赋值。",
                  "markdown": "报告对方法形参的赋值或修改。\n\n虽然有时是有意为之，但此结构可能令人困惑，因此在一些 Java 项目中被禁止使用。\n\n该快速修复会添加新变量的声明。\n\n**示例：**\n\n\n      void printTrimmed(String s) {\n        s = s.trim();\n        System.out.println(s);\n      }\n\n在应用快速修复后：\n\n\n      void printTrimmed(String s) {\n        String trimmed = s.trim();\n        System.out.println(trimmed);\n      }\n\n\n使用**如果赋值是原始形参的转换，则忽略**选项可忽略根据先前值修改形参值的赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToMethodParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalVariableHidingMemberVariable",
                "shortDescription": {
                  "text": "局部变量隐藏字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的局部变量。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该变量。 建议通过快速修复重命名该变量。 示例： 'public class Foo {\n    public Object foo;\n\n    void bar() {\n      Object o = new Object() {\n        void baz() {\n          Object foo; // 局部变量 'foo' 隐藏类 'Foo' 中的字段\n        }\n      };\n    }\n  }' 您可以为此检查配置以下选项： 忽略不可访问字段 - 忽略与不可见的超类字段同名的局部变量（例如，由于这些字段是 private 字段）。 忽略隐藏非 static 字段的 static 上下文中的局部变量 - 例如，当局部变量位于 static 方法内部或位于 static 内部类中的方法内部时。",
                  "markdown": "报告与周围类的字段同名的局部变量。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该变量。\n\n建议通过快速修复重命名该变量。\n\n**示例：**\n\n\n      public class Foo {\n        public Object foo;\n\n        void bar() {\n          Object o = new Object() {\n            void baz() {\n              Object foo; // 局部变量 'foo' 隐藏类 'Foo' 中的字段\n            }\n          };\n        }\n      }\n\n\n您可以为此检查配置以下选项：\n\n1. **忽略不可访问字段** - 忽略与不可见的超类字段同名的局部变量（例如，由于这些字段是 private 字段）。\n2. **忽略隐藏非 static 字段的 static 上下文中的局部变量** - 例如，当局部变量位于 static 方法内部或位于 static 内部类中的方法内部时。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableHidesMemberVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToLambdaParameter",
                "shortDescription": {
                  "text": "赋值给 lambda 形参"
                },
                "fullDescription": {
                  "text": "报告对 lambda 形参的赋值或修改。 虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量所致。 该快速修复会添加新变量的声明。 示例： 'list.forEach(s -> {\n    s = s.trim();\n    System.out.println(\"String: \" + s);\n  });' 在应用快速修复后： 'list.forEach(s -> {\n    String trimmed = s.trim();\n    System.out.println(\"String: \" + trimmed);\n  });' 使用如果赋值是原始形参的转换，则忽略选项可以忽略根据先前值修改形参值的赋值。 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告对 lambda 形参的赋值或修改。 虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量所致。\n\n该快速修复会添加新变量的声明。\n\n**示例：**\n\n\n      list.forEach(s -> {\n        s = s.trim();\n        System.out.println(\"String: \" + s);\n      });\n\n在应用快速修复后：\n\n\n      list.forEach(s -> {\n        String trimmed = s.trim();\n        System.out.println(\"String: \" + trimmed);\n      });\n\n使用**如果赋值是原始形参的转换，则忽略**选项可以忽略根据先前值修改形参值的赋值。\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToLambdaParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryTemporaryOnConversionToString",
                "shortDescription": {
                  "text": "转换为 'String' 时有不必要的临时对象"
                },
                "fullDescription": {
                  "text": "报告从基元类型转换为 'String' 时创建的不必要的临时对象。 示例： 'String foo = new Integer(3).toString();' 在应用快速修复后： 'String foo = Integer.toString(3);'",
                  "markdown": "报告从基元类型转换为 `String` 时创建的不必要的临时对象。\n\n**示例：**\n\n\n      String foo = new Integer(3).toString();\n\n在应用快速修复后：\n\n\n      String foo = Integer.toString(3);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryTemporaryOnConversionToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemGetenv",
                "shortDescription": {
                  "text": "调用 'System.getenv()'"
                },
                "fullDescription": {
                  "text": "报告对 'System.getenv()' 的调用。 对 'System.getenv()' 的调用本质上不可移植。",
                  "markdown": "报告对 `System.getenv()` 的调用。 对 `System.getenv()` 的调用本质上不可移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemGetenv",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceMayBeAnnotatedFunctional",
                "shortDescription": {
                  "text": "接口可以注解为 '@FunctionalInterface'"
                },
                "fullDescription": {
                  "text": "报告可以用 '@FunctionalInterface' 注解的接口。 使用 '@FunctionalInterface' 对接口进行注解会指示该接口为函数式接口，不能再向其添加其他 'abstract' 方法。 示例： 'interface FileProcessor {\n    void execute(File file);\n  }' 在应用快速修复后： '@FunctionalInterface\n  interface FileProcessor {\n    void execute(File file);\n  }' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以用 `@FunctionalInterface` 注解的接口。\n\n使用 `@FunctionalInterface` 对接口进行注解会指示该接口为函数式接口，不能再向其添加其他 `abstract` 方法。\n\n**示例：**\n\n\n      interface FileProcessor {\n        void execute(File file);\n      }\n\n在应用快速修复后：\n\n\n      @FunctionalInterface\n      interface FileProcessor {\n        void execute(File file);\n      }\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceMayBeAnnotatedFunctional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BreakStatementWithLabel",
                "shortDescription": {
                  "text": "带标签的 'break' 语句"
                },
                "fullDescription": {
                  "text": "报告包含标签的 'break' 语句。 'break' 标签语句导致重构复杂化，可能令人困惑。 示例： 'void handle(List<String> strs) {\n    outer:\n    for (String s: strs) {\n      for (char ch : s.toCharArray()) {\n        if ('s' == ch) break outer;\n        handleChar(ch);\n      }\n    }\n  }'",
                  "markdown": "报告包含标签的 `break` 语句。\n\n`break` 标签语句导致重构复杂化，可能令人困惑。\n\n示例：\n\n\n      void handle(List<String> strs) {\n        outer:\n        for (String s: strs) {\n          for (char ch : s.toCharArray()) {\n            if ('s' == ch) break outer;\n            handleChar(ch);\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BreakStatementWithLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousLiteralUnderscore",
                "shortDescription": {
                  "text": "数字文字中的可疑下划线"
                },
                "fullDescription": {
                  "text": "报告使用下划线数字分隔符且组的位数不为 3 的小数文字。 此类文字可能包含拼写错误。 此检查不会对包含两个连续下划线的文字发出警告。 还可以忽略 'double' 和 'float' 文字的分数部分的下划线。 示例：'int oneMillion = 1_000_0000;'",
                  "markdown": "报告使用下划线数字分隔符且组的位数不为 3 的小数文字。 此类文字可能包含拼写错误。\n\n此检查不会对包含两个连续下划线的文字发出警告。\n还可以忽略 `double` 和 `float` 文字的分数部分的下划线。\n\n**示例** ：`int oneMillion = 1_000_0000;`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousLiteralUnderscore",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringEquality",
                "shortDescription": {
                  "text": "使用 '==' 而不是 'equals()' 进行字符串比较"
                },
                "fullDescription": {
                  "text": "报告使用 == 或 != 比较字符串的代码。 这些运算符确定引用相等，而不是比较内容。 在大多数情况下，应使用 'equals()' 对字符串进行比较，当字符串为不同的对象时，会逐字符进行比较。 示例： 'void foo(String s, String t) {\n    final boolean b = t == s;\n  }' 如果已知 't' 为非 null 值，则可以安全地应用“不安全”的快速修复，并获得类似于以下的结果： 'void foo(String s, String t) {\n    final boolean b = t.equals(s);\n  }'",
                  "markdown": "报告使用 **==** 或 **!=** 比较字符串的代码。\n\n\n这些运算符确定引用相等，而不是比较内容。\n在大多数情况下，应使用 `equals()` 对字符串进行比较，当字符串为不同的对象时，会逐字符进行比较。\n\n**示例：**\n\n\n      void foo(String s, String t) {\n        final boolean b = t == s;\n      }\n\n如果已知 `t` 为非 null 值，则可以安全地应用\"不安全\"的快速修复，并获得类似于以下的结果：\n\n\n      void foo(String s, String t) {\n        final boolean b = t.equals(s);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringEquality",
                    "cweIds": [
                      597
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticCallOnSubclass",
                "shortDescription": {
                  "text": "static 方法通过子类引用"
                },
                "fullDescription": {
                  "text": "报告其中的调用由声明类的子类而不是声明类本身限定的 static 方法调用。 Java 允许对类进行此类限定，但是此类调用可能表明继承和重写之间存在微妙的混淆。 示例： 'class Parent {\n    public static void print(String str) {}\n  }\n  class Child extends Parent {}\n\n  Child.print(\"Hello, world!\");' 在应用快速修复后： 'Parent.print(\"Hello, world!\");'",
                  "markdown": "报告其中的调用由声明类的子类而不是声明类本身限定的 static 方法调用。\n\n\nJava 允许对类进行此类限定，但是此类调用可能表明继承和重写之间存在微妙的混淆。\n\n**示例：**\n\n\n      class Parent {\n        public static void print(String str) {}\n      }\n      class Child extends Parent {}\n\n      Child.print(\"Hello, world!\");\n\n在应用快速修复后：\n\n\n      Parent.print(\"Hello, world!\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticMethodReferencedViaSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantExpression",
                "shortDescription": {
                  "text": "可以对常量表达式求值"
                },
                "fullDescription": {
                  "text": "报告可静态求值的常量表达式，并建议将其替换为其实际值。 例如，系统会提示您将 '2 + 2' 替换为 '4'，或将 'Math.sqrt(9.0)' 替换为 '3.0'。 2018.1 最新变化",
                  "markdown": "报告可静态求值的常量表达式，并建议将其替换为其实际值。 例如，系统会提示您将 `2 + 2` 替换为 `4`，或将 `Math.sqrt(9.0)` 替换为 `3.0`。\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConstantExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadResolveAndWriteReplaceProtected",
                "shortDescription": {
                  "text": "'readResolve()' 或 'writeReplace()' 未被声明为 'protected'"
                },
                "fullDescription": {
                  "text": "报告实现 'java.io.Serializable' 且其中的 'readResolve()' 或 'writeReplace()' 方法未被声明为 'protected' 的类。 将 'readResolve()' 和 'writeReplace()' 方法声明为 'private' 可以强制子类无提示地忽略它们，而声明为 'public' 则允许不受信任的代码调用它们。 如果包含类被声明为 'final'，这些方法就可以被声明为 'private'。 示例： 'class ClassWithSerialization implements Serializable {\n    public Object writeReplace() { // 警告：'writeReplace()' 未被声明为 protected\n        ...\n    }\n  }'",
                  "markdown": "报告实现 `java.io.Serializable` 且其中的 `readResolve()` 或 `writeReplace()` 方法未被声明为 `protected` 的类。\n\n\n将 `readResolve()` 和 `writeReplace()` 方法声明为 `private` 可以强制子类无提示地忽略它们，而声明为 `public` 则允许不受信任的代码调用它们。\n\n\n如果包含类被声明为 `final`，这些方法就可以被声明为 `private`。\n\n**示例：**\n\n\n      class ClassWithSerialization implements Serializable {\n        public Object writeReplace() { // 警告：'writeReplace()' 未被声明为 protected\n            ...\n        }\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReadResolveAndWriteReplaceProtected",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLabelOnContinueStatement",
                "shortDescription": {
                  "text": "'continue' 语句上的不必要标签"
                },
                "fullDescription": {
                  "text": "报告包含不必要标签的 'continue' 语句。 示例： 'LABEL:\n  while (a > b) {\n    System.out.println(\"Hello\");\n    //下面的代码是循环中的最后一条语句，\n    //因此可以移除不必要的标签和 continue\n    continue LABEL;\n  }'",
                  "markdown": "报告包含不必要标签的 `continue` 语句。\n\n示例：\n\n\n      LABEL:\n      while (a > b) {\n        System.out.println(\"Hello\");\n        //下面的代码是循环中的最后一条语句，\n        //因此可以移除不必要的标签和 continue\n        continue LABEL;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLabelOnContinueStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageDotHtmlMayBePackageInfo",
                "shortDescription": {
                  "text": "'package.html' 可以转换为 'package-info.java'"
                },
                "fullDescription": {
                  "text": "报告用于记录软件包的任何 'package.html' 文件。 从 JDK 1.5 开始，建议您改用 'package-info.java' 文件，因为此类文件还可以包含软件包注解。 这样，package-info.java 就变成了软件包级别注解和文档的唯一仓库。 示例：'package.html' '<html>\n  <body>\n    Documentation example.\n  </body>\n</html>' 应用该快速修复后：'package-info.java' '/**\n * Documentation example.\n */\npackage com.sample;'",
                  "markdown": "报告用于记录软件包的任何 `package.html` 文件。\n\n从 JDK 1.5 开始，建议您改用 `package-info.java` 文件，因为此类文件还可以包含软件包注解。 这样，package-info.java 就变成了软件包级别注解和文档的唯一仓库。\n\n示例：`package.html`\n\n\n    <html>\n      <body>\n        Documentation example.\n      </body>\n    </html>\n\n应用该快速修复后：`package-info.java`\n\n\n    /**\n     * Documentation example.\n     */\n    package com.sample;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageDotHtmlMayBePackageInfo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LongLiteralsEndingWithLowercaseL",
                "shortDescription": {
                  "text": "'long' 文字以 'l' 而不是 'L' 结尾"
                },
                "fullDescription": {
                  "text": "报告以小写 'l' 结尾的 'long' 文字。 这些文字可能令人困惑，因为小写的 'l' 与文字 '1'（一）非常相似。 示例： 'long nights = 100l;' 在应用快速修复后： 'long nights = 100L;'",
                  "markdown": "报告以小写 'l' 结尾的 `long` 文字。 这些文字可能令人困惑，因为小写的 'l' 与文字 '1'（一）非常相似。\n\n**示例：**\n\n\n      long nights = 100l;\n\n在应用快速修复后：\n\n\n      long nights = 100L;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LongLiteralEndingWithLowercaseL",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantArrayCreation",
                "shortDescription": {
                  "text": "冗余数组创建"
                },
                "fullDescription": {
                  "text": "报告专门创建以作为 vararg 形参传递的数组。 示例： 'Arrays.asList(new String[]{\"Hello\", \"world\"})' 该快速修复会将数组初始值设定项替换为单个实参： 'Arrays.asList(\"Hello\", \"world\")'",
                  "markdown": "报告专门创建以作为 vararg 形参传递的数组。\n\n示例：\n\n`Arrays.asList(new String[]{\"Hello\", \"world\"})`\n\n该快速修复会将数组初始值设定项替换为单个实参：\n\n`Arrays.asList(\"Hello\", \"world\")`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantArrayCreation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterNamingConvention",
                "shortDescription": {
                  "text": "方法形参命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的方法形参。 示例：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告 'void fooBar(int X)'。 配置检查： 使用选项部分中的字段可指定方法形参名称的最小长度、最大长度以及预期的正则表达式。 指定 0 以便不检查名称的长度。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的方法形参。\n\n**示例** ：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告 `void fooBar(int X)`。\n\n配置检查：\n\n\n使用**选项** 部分中的字段可指定方法形参名称的最小长度、最大长度以及预期的正则表达式。 指定 **0** 以便不检查名称的长度。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodParameterNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCanBeVariableArityMethod",
                "shortDescription": {
                  "text": "方法可以有 varargs 形参"
                },
                "fullDescription": {
                  "text": "报告可以转换为可变 arity 方法的方法。 示例： 'void process(String name, Object[] objects);' 在应用快速修复后： 'void process(String name, Object... objects);' 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告可以转换为可变 arity 方法的方法。\n\n**示例：**\n\n\n      void process(String name, Object[] objects);\n\n在应用快速修复后：\n\n\n      void process(String name, Object... objects);\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MethodCanBeVariableArityMethod",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonShortCircuitBoolean",
                "shortDescription": {
                  "text": "非短路布尔表达式"
                },
                "fullDescription": {
                  "text": "报告布尔 'and' 和 'or' 的非短路形式（'&'、'|'、'&=' 和 '|='）的用法。 尽管非短路版本偶尔有用，但在大多数情况下，本应使用短路形式（'&&' 和 '||'），此类无意的用法可能会导致难以捉摸的错误。 建议通过快速修复来使用短路版本。 示例： 'void foo(boolean x, boolean y, boolean z) {\n    if (x | y) { x |= z; }\n  }' 在应用快速修复后： 'void foo(boolean x, boolean y) {\n    if (x || y) { x = x || z; }\n  }'",
                  "markdown": "报告布尔 'and' 和 'or' 的非短路形式（`&`、`|`、`&=` 和 `|=`）的用法。 尽管非短路版本偶尔有用，但在大多数情况下，本应使用短路形式（`&&` 和 `||`），此类无意的用法可能会导致难以捉摸的错误。\n\n\n建议通过快速修复来使用短路版本。\n\n**示例：**\n\n\n      void foo(boolean x, boolean y, boolean z) {\n        if (x | y) { x |= z; }\n      }\n\n在应用快速修复后：\n\n\n      void foo(boolean x, boolean y) {\n        if (x || y) { x = x || z; }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonShortCircuitBooleanExpression",
                    "cweIds": [
                      480,
                      691
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassNeverImplemented",
                "shortDescription": {
                  "text": "没有具体子类的抽象类"
                },
                "fullDescription": {
                  "text": "报告没有任何具体子类的 'abstract' 类。",
                  "markdown": "报告没有任何具体子类的 `abstract` 类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassNeverImplemented",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowablePrintedToSystemOut",
                "shortDescription": {
                  "text": "'Throwable' 打印到 'System.out'"
                },
                "fullDescription": {
                  "text": "报告以异常作为实参的 'System.out.println()' 调用。 使用 print 语句记录异常会隐藏堆栈跟踪，这可能会使问题的调查变得复杂。 建议您改用记录器。 也会报告以异常作为实参的 'System.out.print()'、'System.err.println()' 和 'System.err.print()' 调用。 建议使用记录器来记录异常。 提供的快速修复支持 SLF4J 和 Log4j 2。 它会将 'System.out.println()' 调用替换为日志调用 示例： 'try {\n      foo();\n  } catch (Exception e) {\n      System.out.println(e);\n  }' 在应用快速修复后： 'try {\n      foo();\n  } catch (Exception e) {\n    log.error(\"e: \", e);\n  }' 使用用于修复的日志方法选项可以指定用于记录消息的方法。",
                  "markdown": "报告以异常作为实参的 `System.out.println()` 调用。\n\n使用 print 语句记录异常会隐藏堆栈跟踪，这可能会使问题的调查变得复杂。\n建议您改用记录器。\n\n也会报告以异常作为实参的 `System.out.print()`、`System.err.println()` 和 `System.err.print()` 调用。 建议使用记录器来记录异常。\n\n提供的快速修复支持 **SLF4J** 和 **Log4j 2** 。\n它会将 `System.out.println()` 调用替换为日志调用\n\n**示例：**\n\n\n      try {\n          foo();\n      } catch (Exception e) {\n          System.out.println(e);\n      }\n\n在应用快速修复后：\n\n\n      try {\n          foo();\n      } catch (Exception e) {\n        log.error(\"e: \", e);\n      }\n\n\n使用**用于修复的日志方法**选项可以指定用于记录消息的方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowablePrintedToSystemOut",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StreamToLoop",
                "shortDescription": {
                  "text": "Stream API 调用链可被替换为循环"
                },
                "fullDescription": {
                  "text": "报告可以自动转换为经典循环的 Stream API 链、'Iterable.forEach()' 和 'Map.forEach()' 调用。 此检查有助于为向后兼容早期 Java 版本而降级。 示例： 'String joinNonEmpty(List<String> list) {\n    return list.stream() // 流可以转换为循环\n      .filter(s -> !s.isEmpty())\n      .map(String::trim)\n      .collect(Collectors.joining(\", \"));\n  }' 在应用快速修复后： 'String joinNonEmpty(List<String> list) {\n    StringJoiner joiner = new StringJoiner(\", \");\n    for (String s : list) {\n      if (!s.isEmpty()) {\n        String trim = s.trim();\n        joiner.add(trim);\n      }\n    }\n    return joiner.toString();\n  }' 请注意，有时此检查可能会导致轻微的语义变化。 必须特别注意短路，因为流短路未指定读取的实际元素数。 配置检查： 使用 通过 Stream.iterator() 迭代未知的流源 选项来建议转换来源无法识别的流。 在这种情况下，迭代器将从流中创建。 例如，选择复选框时，此处将建议转换： 'List<ProcessHandle> handles = ProcessHandle.allProcesses().collect(Collectors.toList());' 在这种情况下，结果如下： 'List<ProcessHandle> handles = new ArrayList<>();\n  for (Iterator<ProcessHandle> it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {\n    ProcessHandle allProcess = it.next();\n    handles.add(allProcess);\n  }' 2017.1 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以自动转换为经典循环的 Stream API 链、`Iterable.forEach()` 和 `Map.forEach()` 调用。 此检查有助于为向后兼容早期 Java 版本而降级。\n\n**示例：**\n\n\n      String joinNonEmpty(List<String> list) {\n        return list.stream() // 流可以转换为循环\n          .filter(s -> !s.isEmpty())\n          .map(String::trim)\n          .collect(Collectors.joining(\", \"));\n      }\n\n在应用快速修复后：\n\n\n      String joinNonEmpty(List<String> list) {\n        StringJoiner joiner = new StringJoiner(\", \");\n        for (String s : list) {\n          if (!s.isEmpty()) {\n            String trim = s.trim();\n            joiner.add(trim);\n          }\n        }\n        return joiner.toString();\n      }\n\n\n请注意，有时此检查可能会导致轻微的语义变化。\n必须特别注意短路，因为流短路未指定读取的实际元素数。\n\n配置检查：\n\n使用 **通过 Stream.iterator() 迭代未知的流源** 选项来建议转换来源无法识别的流。\n在这种情况下，迭代器将从流中创建。\n例如，选择复选框时，此处将建议转换：\n\n\n      List<ProcessHandle> handles = ProcessHandle.allProcesses().collect(Collectors.toList());\n\n在这种情况下，结果如下：\n\n\n      List<ProcessHandle> handles = new ArrayList<>();\n      for (Iterator<ProcessHandle> it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {\n        ProcessHandle allProcess = it.next();\n        handles.add(allProcess);\n      }\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "StreamToLoop",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantRecordConstructor",
                "shortDescription": {
                  "text": "冗余记录构造函数"
                },
                "fullDescription": {
                  "text": "报告在 Java 记录中声明的冗余构造函数。 示例 1： 'record Point(int x, int y) {\n    public Point {} // 可以移除\n  }\n  \n  record Point(int x, int y) {\n    public Point(int x, int y) { // 可以移除\n      this.x = x;\n      this.y = y;\n    }\n  }' 该快速修复会移除冗余的构造函数。 示例 2： '// 可以转换为压缩构造函数\n  record Range(int from, int to) {\n    public Range(int from, int to) {\n      if (from > to) throw new IllegalArgumentException();\n      this.from = from;\n      this.to = to;\n    }\n  }' 该快速修复会将此代码转换为紧凑构造函数。 2020.1 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告在 Java 记录中声明的冗余构造函数。\n\n**示例 1：**\n\n\n      record Point(int x, int y) {\n        public Point {} // 可以移除\n      }\n      \n      record Point(int x, int y) {\n        public Point(int x, int y) { // 可以移除\n          this.x = x;\n          this.y = y;\n        }\n      }\n\n该快速修复会移除冗余的构造函数。\n\n**示例 2：**\n\n\n       // 可以转换为压缩构造函数\n      record Range(int from, int to) {\n        public Range(int from, int to) {\n          if (from > to) throw new IllegalArgumentException();\n          this.from = from;\n          this.to = to;\n        }\n      }\n\n该快速修复会将此代码转换为紧凑构造函数。\n\n2020.1 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantRecordConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NotifyWithoutCorrespondingWait",
                "shortDescription": {
                  "text": "没有相应 'wait()' 的 'notify()'"
                },
                "fullDescription": {
                  "text": "报告对无法为之找到相应 'Object.wait()' 调用的 'Object.notify()' 或 'Object.notifyAll()' 的调用。 此检查仅报告以当前类的目标字段为目标的调用。 示例： 'synchronized (synList) {\n    synList.notify(); //从未调用 synList.wait()\n  }'",
                  "markdown": "报告对无法为之找到相应 `Object.wait()` 调用的 `Object.notify()` 或 `Object.notifyAll()` 的调用。\n\n此检查仅报告以当前类的目标字段为目标的调用。\n\n**示例：**\n\n\n      synchronized (synList) {\n        synList.notify(); //从未调用 synList.wait()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NotifyWithoutCorrespondingWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousMethodCall",
                "shortDescription": {
                  "text": "对继承方法的调用类似于对本地方法的调用"
                },
                "fullDescription": {
                  "text": "如果在类周围的代码中存在具有相同签名的方法，则报告从匿名类、内部类或局部类对超类方法的调用。 在这种情况下，看似调用了来自周围代码的方法，而实际上调用的是来自超类的方法。 为了阐明代码的意图，建议对方法调用添加显式的 'super' 限定符。 示例： 'class Parent {\n    void ambiguous(){}\n  }\n\n  class Example {\n    void ambiguous(){}\n\n    class Inner extends Parent {\n      void example(){\n        ambiguous(); //警告\n      }\n    }\n  }' 在应用快速修复后： 'class Parent {\n    void ambiguous(){}\n  }\n\n  class Example {\n    void ambiguous(){}\n\n    class Inner extends Parent {\n      void example(){\n        super.ambiguous();\n      }\n    }\n  }'",
                  "markdown": "如果在类周围的代码中存在具有相同签名的方法，则报告从匿名类、内部类或局部类对超类方法的调用。 在这种情况下，看似调用了来自周围代码的方法，而实际上调用的是来自超类的方法。\n\n\n为了阐明代码的意图，建议对方法调用添加显式的 ` super ` 限定符。\n\n**示例：**\n\n\n      class Parent {\n        void ambiguous(){}\n      }\n\n      class Example {\n        void ambiguous(){}\n\n        class Inner extends Parent {\n          void example(){\n            ambiguous(); //警告\n          }\n        }\n      }\n      \n在应用快速修复后：\n\n\n      class Parent {\n        void ambiguous(){}\n      }\n\n      class Example {\n        void ambiguous(){}\n\n        class Inner extends Parent {\n          void example(){\n            super.ambiguous();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AmbiguousMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassInitializerMayBeStatic",
                "shortDescription": {
                  "text": "类初始值设定项可能为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以使之为 'static' 的实例初始值设定项。 如果实例初始值设定项不引用其类的任何非 static 成员，则可以为 static。 static 初始值设定项在类解析后执行，而实例初始值设定项对此类的每个实例化执行。 此检查不报告匿名类中的实例空初始值设定项和初始值设定项。 示例： 'class A {\n     public static String CONSTANT;\n     {\n        CONSTANT = \"Hello\";\n     }\n  }' 在应用快速修复后： 'class A {\n     public static String CONSTANT;\n     static {\n        CONSTANT = \"Hello\"; // 现在每个类仅实例化一次\n     }\n  }'",
                  "markdown": "报告可以使之为 `static` 的实例初始值设定项。\n\n\n如果实例初始值设定项不引用其类的任何非 static 成员，则可以为 static。\nstatic 初始值设定项在类解析后执行，而实例初始值设定项对此类的每个实例化执行。\n\n此检查不报告匿名类中的实例空初始值设定项和初始值设定项。\n\n**示例：**\n\n\n      class A {\n         public static String CONSTANT;\n         {\n            CONSTANT = \"Hello\";\n         }\n      }\n\n在应用快速修复后：\n\n\n      class A {\n         public static String CONSTANT;\n         static {\n            CONSTANT = \"Hello\"; // 现在每个类仅实例化一次\n         }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassInitializerMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicCharacter",
                "shortDescription": {
                  "text": "魔幻字符"
                },
                "fullDescription": {
                  "text": "报告在没有常量声明的情况下使用的字符文字。 这些字符可能导致代码可读性差。 此外，如果只在代码中的一处更改某个字符，而不是在代码中的每一处都更改该字符，可能会出现错误。 示例： 'char c = 'c';'",
                  "markdown": "报告在没有常量声明的情况下使用的字符文字。 这些字符可能导致代码可读性差。 此外，如果只在代码中的一处更改某个字符，而不是在代码中的每一处都更改该字符，可能会出现错误。\n\n**示例：**\n\n    char c = 'c';\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicCharacter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SlowAbstractSetRemoveAll",
                "shortDescription": {
                  "text": "调用 'set.removeAll(list)' 可能较为缓慢"
                },
                "fullDescription": {
                  "text": "报告对包含 'java.util.List' 实参的 'java.util.Set.removeAll()' 的调用。 当实参大小大于或等于集合大小，并且集合是 'java.util.AbstractSet' 的子类时，此类调用可能会很慢。 在本例中，对集合中的每个元素调用了 'List.contains()'，将执行线性搜索。 示例： 'public void check(String... ss) {\n    // 可能的 O(n^2) 复杂度\n    mySet.removeAll(List.of(ss));\n  }' 在应用快速修复后： 'public void check(String... ss) {\n    // O(n) 复杂度\n    List.of(ss).forEach(mySet::remove);\n  }' 2020.3 最新变化",
                  "markdown": "报告对包含 `java.util.List` 实参的 `java.util.Set.removeAll()` 的调用。\n\n\n当实参大小大于或等于集合大小，并且集合是 `java.util.AbstractSet` 的子类时，此类调用可能会很慢。\n在本例中，对集合中的每个元素调用了 `List.contains()`，将执行线性搜索。\n\n**示例：**\n\n\n      public void check(String... ss) {\n        // 可能的 O(n^2) 复杂度\n        mySet.removeAll(List.of(ss));\n      }\n\n在应用快速修复后：\n\n\n      public void check(String... ss) {\n        // O(n) 复杂度\n        List.of(ss).forEach(mySet::remove);\n      }\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SlowAbstractSetRemoveAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayEquality",
                "shortDescription": {
                  "text": "使用 '==' 而不是 'Arrays.equals()' 进行数组比较"
                },
                "fullDescription": {
                  "text": "报告用于测试数组相等性的运算符 '==' 和 '!='。 在大多数情况下，如果原本就要测试数组内容的相等性，可以通过 'java.util.Arrays.equals()' 方法来完成。 建议通过快速修复将 '==' 替换为 'java.util.Arrays.equals()'。 示例： 'void foo(Object[] x, Object[] y) {\n    boolean comparison = x == y;\n  }' 在应用快速修复后： 'void foo(Object[] x, Object[] y) {\n    boolean comparison = Arrays.equals(x, y);\n  }'",
                  "markdown": "报告用于测试数组相等性的运算符 `==` 和 `!=`。 在大多数情况下，如果原本就要测试数组内容的相等性，可以通过 `java.util.Arrays.equals()` 方法来完成。\n\n\n建议通过快速修复将 `==` 替换为 `java.util.Arrays.equals()`。\n\n**示例：**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\n在应用快速修复后：\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticInheritance",
                "shortDescription": {
                  "text": "静态继承"
                },
                "fullDescription": {
                  "text": "报告仅为提供对常量的访问而实现的接口。 这种继承常常令人困惑，可能隐藏重要的依赖关系信息。",
                  "markdown": "报告仅为提供对常量的访问而实现的接口。 这种继承常常令人困惑，可能隐藏重要的依赖关系信息。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticInheritance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticCollection",
                "shortDescription": {
                  "text": "静态集合"
                },
                "fullDescription": {
                  "text": "报告 'Collection' 类型的 static 字段。 虽然这不一定是问题，但静态集合通常会导致内存泄漏，因此会被某些编码标准禁止。 示例： 'public class Example {\n    static List<String> list = new ArrayList<>();\n\n  }' 配置检查： 使用忽略弱静态集合或映射选项可以忽略 'java.util.WeakHashMap' 类型的字段。",
                  "markdown": "报告 `Collection` 类型的 static 字段。 虽然这不一定是问题，但静态集合通常会导致内存泄漏，因此会被某些编码标准禁止。\n\n**示例：**\n\n\n      public class Example {\n        static List<String> list = new ArrayList<>();\n\n      }\n\n\n配置检查：\n\n* 使用**忽略弱静态集合或映射** 选项可以忽略 `java.util.WeakHashMap` 类型的字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantUnmodifiable",
                "shortDescription": {
                  "text": "不可修改的集合包装器的冗余用法"
                },
                "fullDescription": {
                  "text": "报告从 'Collections' 类对不可修改的集合包装器的冗余调用。 如果传递给不可修改的集合包装器的实参已不可变，此类包装会变得冗余。 示例： 'List<String> x = Collections.unmodifiableList(Collections.singletonList(\"abc\"));' 在应用快速修复后： 'List<String> x = Collections.singletonList(\"abc\");' 为了检测返回不可修改集合的方法，该检查使用 'org.jetbrains.annotations.Unmodifiable' 和 'org.jetbrains.annotations.UnmodifiableView' 注解。 使用它们将检查扩展为您自己的不可修改的集合包装器。 2020.3 最新变化",
                  "markdown": "报告从 `Collections` 类对不可修改的集合包装器的冗余调用。\n\n如果传递给不可修改的集合包装器的实参已不可变，此类包装会变得冗余。\n\n示例：\n\n\n      List<String> x = Collections.unmodifiableList(Collections.singletonList(\"abc\"));\n\n在应用快速修复后：\n\n\n      List<String> x = Collections.singletonList(\"abc\");\n\n为了检测返回不可修改集合的方法，该检查使用 `org.jetbrains.annotations.Unmodifiable`\n和 `org.jetbrains.annotations.UnmodifiableView` 注解。\n使用它们将检查扩展为您自己的不可修改的集合包装器。\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantUnmodifiable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExceptionNameEndsWithException",
                "shortDescription": {
                  "text": "非异常类名以 'Exception' 结尾"
                },
                "fullDescription": {
                  "text": "报告名称以 'Exception' 结尾的非 'exception' 类。 这种类可能会违反通用的命名约定而引起混淆，并且通常表示缺少 'extends Exception' 子句。 示例： 'public class NotStartedException {}' 只能在编辑器中采用快速修复来重命名这种类。",
                  "markdown": "报告名称以 `Exception` 结尾的非 `exception` 类。\n\n这种类可能会违反通用的命名约定而引起混淆，并且通常表示缺少 `extends Exception` 子句。\n\n**示例：**\n\n    public class NotStartedException {}\n\n只能在编辑器中采用快速修复来重命名这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExceptionNameEndsWithException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantValue",
                "shortDescription": {
                  "text": "常量值"
                },
                "fullDescription": {
                  "text": "报告始终产生相同结果的表达式和条件，如 true、false、null 或零。 此类表达式可被替换为相应的常量值。 但通常情况下，它们表示代码中存在 bug。 示例： '// 始终为 true\n  // 根本原因：使用了 ||，而非 &&\n  if (x > 0 || x < 10) {}\n\n  System.out.println(str.trim());\n  // 始终为 false\n  // 根本原因：在 null 检查之前变量被取消引用\n  if (str == null) {}' 检查行为可能由许多注解控制，例如可 null 性注解、'@Contract' 注解、'@Range' 注解等。 配置检查： 使用不报告条件静态证明始终为 true 的断言选项可避免报告静态证明始终为 true 的断言。 这还包括 'if (alwaysFalseCondition) throw new IllegalArgumentException();' 等条件。 使用忽略 assert 语句选项可控制检查如何处理 'assert' 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。 使用当常量存储在变量中时发出警告选项可以在使用已知其值为常量的变量时显示警告。 在 IntelliJ IDEA 2022.3 版本之前，此检查为“常量条件和异常”检查的一部分。 现在，它被拆分成两个检查：“常量值”和“为 null 性和数据流问题”。",
                  "markdown": "报告始终产生相同结果的表达式和条件，如 true、false、null 或零。 此类表达式可被替换为相应的常量值。 但通常情况下，它们表示代码中存在 bug。\n\n示例：\n\n      // 始终为 true\n      // 根本原因：使用了 ||，而非 &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // 始终为 false\n      // 根本原因：在 null 检查之前变量被取消引用\n      if (str == null) {}\n\n\n检查行为可能由许多注解控制，例如[可 null 性](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html)注解、[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) 注解、`@Range` 注解等。\n\n配置检查：\n\n* 使用**不报告条件静态证明始终为 true 的断言** 选项可避免报告静态证明始终为 true 的断言。 这还包括 `if (alwaysFalseCondition) throw new IllegalArgumentException();` 等条件。\n* 使用**忽略 assert 语句** 选项可控制检查如何处理 `assert` 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。\n* 使用**当常量存储在变量中时发出警告**选项可以在使用已知其值为常量的变量时显示警告。\n\n\n在 IntelliJ IDEA 2022.3 版本之前，此检查为\"常量条件和异常\"检查的一部分。 现在，它被拆分成两个检查：\"常量值\"和\"为 null 性和数据流问题\"。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantValue",
                    "cweIds": [
                      570,
                      571
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastCanBeReplacedWithVariable",
                "shortDescription": {
                  "text": "转换可被替换为变量"
                },
                "fullDescription": {
                  "text": "报告可被替换为具有相同值的现有局部或模式变量的类型转换运算。 示例： 'void foo(Object obj) {\n    String s = (String) obj;\n    System.out.println(((String) obj).trim());\n  }' 在应用快速修复后： 'void foo(Object obj) {\n    String s = (String) obj;\n    System.out.println(s.trim());\n  }' 2022.3 最新变化",
                  "markdown": "报告可被替换为具有相同值的现有局部或模式变量的类型转换运算。\n\n示例：\n\n\n      void foo(Object obj) {\n        String s = (String) obj;\n        System.out.println(((String) obj).trim());\n      }\n\n在应用快速修复后：\n\n\n      void foo(Object obj) {\n        String s = (String) obj;\n        System.out.println(s.trim());\n      }\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CastCanBeReplacedWithVariable",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2Diamond",
                "shortDescription": {
                  "text": "显式类型可被替换为 '<>'"
                },
                "fullDescription": {
                  "text": "报告其类型实参可被替换为菱形类型 '<>' 的所有 'new' 表达式。 示例： 'List<String> list = new ArrayList<String>(); // 报告数组列表类型实参' 在应用快速修复后： 'List<String> list = new ArrayList<>();' 此检查取决于 Java 功能 'Diamond 类型'，该功能自 Java 7 起可用。",
                  "markdown": "报告其类型实参可被替换为菱形类型 `<>` 的所有 `new` 表达式。\n\n示例：\n\n\n      List<String> list = new ArrayList<String>(); // 报告数组列表类型实参\n\n在应用快速修复后：\n\n\n      List<String> list = new ArrayList<>();\n\n此检查取决于 Java 功能 'Diamond 类型'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Convert2Diamond",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VarargParameter",
                "shortDescription": {
                  "text": "vararg 方法"
                },
                "fullDescription": {
                  "text": "报告接受任意数量形参的方法（也称为 vararg 方法）。 示例： 'enum EnumConstants {\n  A(null), B, C;\n\n  EnumConstants(String... ss) {}\n}' 可通过快速修复将可变实参形参替换为等效的数组形参。 方法调用中的相关实参包装在数组初始值设定项表达式中。 在应用快速修复后： 'enum EnumConstants {\n  A(null), B(new String[]{}), C(new String[]{});\n\n  EnumConstants(String[] ss) {}\n}' Varargs 方法在 Java 5 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告接受任意数量形参的方法（也称为 vararg 方法）。\n\n**示例：**\n\n\n      enum EnumConstants {\n      A(null), B, C;\n\n      EnumConstants(String... ss) {}\n    }\n\n可通过快速修复将可变实参形参替换为等效的数组形参。 方法调用中的相关实参包装在数组初始值设定项表达式中。\n在应用快速修复后：\n\n\n      enum EnumConstants {\n      A(null), B(new String[]{}), C(new String[]{});\n\n      EnumConstants(String[] ss) {}\n    }\n\n\n*Varargs 方法*在 Java 5 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "VariableArgumentMethod",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassComplexity",
                "shortDescription": {
                  "text": "过度复杂的类"
                },
                "fullDescription": {
                  "text": "报告总复杂度超过指定最大值的类。 类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。 过高的复杂度表明该类应该被重构为几个更小的类。 使用下面的循环复杂度限制字段可指定类允许的最大复杂度。",
                  "markdown": "报告总复杂度超过指定最大值的类。\n\n类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。\n\n过高的复杂度表明该类应该被重构为几个更小的类。\n\n使用下面的**循环复杂度限制**字段可指定类允许的最大复杂度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemGC",
                "shortDescription": {
                  "text": "调用 'System.gc()' 或 'Runtime.gc()'"
                },
                "fullDescription": {
                  "text": "报告 'System.gc()' 或 'Runtime.gc()' 调用。 虽然在测试中偶尔有用，但在生产代码中几乎从不推荐通过 'System.gc()' 显式触发垃圾回收，这可能会导致严重的性能问题。",
                  "markdown": "报告 `System.gc()` 或 `Runtime.gc()` 调用。 虽然在测试中偶尔有用，但在生产代码中几乎从不推荐通过 `System.gc()` 显式触发垃圾回收，这可能会导致严重的性能问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemGC",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayLengthInLoopCondition",
                "shortDescription": {
                  "text": "循环条件下的 Array.length"
                },
                "fullDescription": {
                  "text": "报告对循环语句条件部分中数组的 '.length' 属性的访问。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 示例： 'void foo(Object[] x) {\n    for (int i = 0; i < x.length; i++) { /**/ }\n  }'",
                  "markdown": "报告对循环语句条件部分中数组的 `.length` 属性的访问。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n**示例：**\n\n\n      void foo(Object[] x) {\n        for (int i = 0; i < x.length; i++) { /**/ }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayLengthInLoopCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckForOutOfMemoryOnLargeArrayAllocation",
                "shortDescription": {
                  "text": "没有 OutOfMemoryError 检查的大型数组分配"
                },
                "fullDescription": {
                  "text": "报告不检查 'java.lang.OutOfMemoryError' 的大型数组分配。 在内存受限的环境中，可能应该检查大数据对象的分配是否存在内存耗尽的情况。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 使用该选项可以指定在未检查的数组分配中允许的最大元素数。",
                  "markdown": "报告不检查 `java.lang.OutOfMemoryError` 的大型数组分配。 在内存受限的环境中，可能应该检查大数据对象的分配是否存在内存耗尽的情况。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n\n使用该选项可以指定在未检查的数组分配中允许的最大元素数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckForOutOfMemoryOnLargeArrayAllocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithoutConstructor",
                "shortDescription": {
                  "text": "不带构造函数的类"
                },
                "fullDescription": {
                  "text": "报告没有构造函数的类。 某些编码标准禁止这种类。",
                  "markdown": "报告没有构造函数的类。\n\n某些编码标准禁止这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithoutConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverflowingLoopIndex",
                "shortDescription": {
                  "text": "循环执行零次或无限次"
                },
                "fullDescription": {
                  "text": "报告没有索引溢出就无法完成的循环或根本不循环的循环。 之所以发生这种情况，通常是因为更新操作中有错误。 示例： 'void foo(int s) {\n    for (int i = s; i > 12; i++) { // i-- 应在此处\n      System.out.println(i);\n    }\n  }' 2019.1 最新变化",
                  "markdown": "报告没有索引溢出就无法完成的循环或根本不循环的循环。 之所以发生这种情况，通常是因为更新操作中有错误。\n\n示例：\n\n\n      void foo(int s) {\n        for (int i = s; i > 12; i++) { // i-- 应在此处\n          System.out.println(i);\n        }\n      }\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverflowingLoopIndex",
                    "cweIds": [
                      691,
                      835
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SetReplaceableByEnumSet",
                "shortDescription": {
                  "text": "'Set' 可被替换为 'EnumSet'"
                },
                "fullDescription": {
                  "text": "报告内容类型为枚举类的 'java.util.Set' 对象的实例化。 此类 'Set' 对象可以替换为 'java.util.EnumSet' 对象。 与其他集合相比，'EnumSet' 实现的效率更高，因为底层数据结构是位向量。 使用该快速修复可以将初始值设定项替换为 'EnumSet.noneOf()' 调用。 当变量类型是 'Set' 的子类时，此快速修复不可用。 示例： 'enum MyEnum { FOO, BAR; }\n\n  Set<MyEnum> enums = new HashSet<MyEnum>();' 在应用快速修复后： 'enum MyEnum { FOO, BAR; }\n\n  Set<MyEnum> enums = EnumSet.noneOf(MyEnum.class);'",
                  "markdown": "报告内容类型为枚举类的 `java.util.Set` 对象的实例化。 此类 `Set` 对象可以替换为 `java.util.EnumSet` 对象。\n\n\n与其他集合相比，`EnumSet` 实现的效率更高，因为底层数据结构是位向量。 使用该快速修复可以将初始值设定项替换为 `EnumSet.noneOf()` 调用。 当变量类型是 `Set` 的子类时，此快速修复不可用。\n\n**示例：**\n\n\n      enum MyEnum { FOO, BAR; }\n\n      Set<MyEnum> enums = new HashSet<MyEnum>();\n\n在应用快速修复后：\n\n\n      enum MyEnum { FOO, BAR; }\n\n      Set<MyEnum> enums = EnumSet.noneOf(MyEnum.class);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SetReplaceableByEnumSet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9UndeclaredServiceUsage",
                "shortDescription": {
                  "text": "服务的使用未在 'module-info' 中声明"
                },
                "fullDescription": {
                  "text": "报告使用 'java.util.ServiceLoader' 加载服务但未使用 'module-info.java' 文件中的 'uses' 子句声明的情况，并建议插入它。 2018.1 最新变化 此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。",
                  "markdown": "报告使用 `java.util.ServiceLoader` 加载服务但未使用 `module-info.java` 文件中的 `uses` 子句声明的情况，并建议插入它。\n\n2018.1 最新变化\n\n此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9UndeclaredServiceUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassMayBeStatic",
                "shortDescription": {
                  "text": "内部类可能为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以设置为 'static' 的内部类。 'static' 内部类不保留对其封闭实例的隐式引用。 使用 Java 17 或更早版本时，这可以防止常见的内存泄漏，减少类的每个实例使用的内存。 示例： 'public class Outer {\n    class Inner { // 非 static\n      public void foo() {\n        bar(\"x\");\n      }\n\n      private void bar(String string) {}\n    }\n  }' 在应用快速修复后： 'public class Outer {\n    static class Inner {\n      public void foo() {\n        bar(\"x\");\n      }\n\n      private void bar(String string) {}\n    }\n  }'",
                  "markdown": "报告可以设置为 `static` 的内部类。\n\n`static` 内部类不保留对其封闭实例的隐式引用。\n使用 Java 17 或更早版本时，这可以防止常见的内存泄漏，减少类的每个实例使用的内存。\n\n**示例：**\n\n\n      public class Outer {\n        class Inner { // 非 static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageInfoWithoutPackage",
                "shortDescription": {
                  "text": "不带 'package' 语句的 'package-info.java'"
                },
                "fullDescription": {
                  "text": "报告没有 'package' 语句的 'package-info.java' 文件。 即便该文件位于其他位置，Javadoc 工具也会考虑默认软件包的此类文件。",
                  "markdown": "报告没有 `package` 语句的 `package-info.java` 文件。\n\n\n即便该文件位于其他位置，Javadoc 工具也会考虑默认软件包的此类文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageInfoWithoutPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToSimpleSetterInClass",
                "shortDescription": {
                  "text": "从类内调用简单 setter"
                },
                "fullDescription": {
                  "text": "报告从属性的类内部对简单属性 setter 的调用。 简单的属性 setter 被定义为只将其形参的值分配给一个字段，而不进行其他计算。 可以安全地内联此类简单的 setter 调用。 为了保持代码清晰，某些编码标准还建议不使用简单的 setter。 示例： 'class Foo {\n  private int index;\n    public Foo(int idx) {\n       setIndex(idx);\n    }\n    public void setIndex(int idx) {\n       index = idx;\n    }\n  }' 在应用快速修复后： 'class Foo {\n    private int index;\n    public Foo(int idx) {\n      index = idx;\n    }\n    public void setIndex(int idx) {\n      index = idx;\n    }\n  }' 使用以下选项配置检查： 是否仅报告 'this' 上的 setter 调用，而不报告作为形参传入的相同类型的对象。 是否忽略非 'private' setter。",
                  "markdown": "报告从属性的类内部对简单属性 setter 的调用。\n\n\n简单的属性 setter 被定义为只将其形参的值分配给一个字段，而不进行其他计算。 可以安全地内联此类简单的 setter 调用。\n为了保持代码清晰，某些编码标准还建议不使用简单的 setter。\n\n**示例：**\n\n\n      class Foo {\n      private int index;\n        public Foo(int idx) {\n           setIndex(idx);\n        }\n        public void setIndex(int idx) {\n           index = idx;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        private int index;\n        public Foo(int idx) {\n          index = idx;\n        }\n        public void setIndex(int idx) {\n          index = idx;\n        }\n      }\n\n使用以下选项配置检查：\n\n* 是否仅报告 `this` 上的 setter 调用，而不报告作为形参传入的相同类型的对象。\n* 是否忽略非 `private` setter。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSimpleSetterFromWithinClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneReturnsClassType",
                "shortDescription": {
                  "text": "'clone()' 应当具有等于其所包含类的返回值类型"
                },
                "fullDescription": {
                  "text": "报告返回类型与其所在的类不同的 'clone()' 方法。 'clone()' 方法的返回类型通常为 'java.lang.Object'，这导致其难以被客户端使用。 Effective Java（第二版和第三版）建议将 'clone()' 方法的返回类型设为与其返回对象的类的类型相同。 示例： 'class Foo implements Cloneable {\n    public Object clone() {\n      try {\n        return super.clone();\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }' 在应用快速修复后： 'class Foo implements Cloneable {\n    public Foo clone() {\n      try {\n        return (Foo)super.clone();\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }'",
                  "markdown": "报告返回类型与其所在的类不同的 `clone()` 方法。\n\n`clone()` 方法的返回类型通常为 `java.lang.Object`，这导致其难以被客户端使用。\n*Effective Java* （第二版和第三版）建议将 `clone()` 方法的返回类型设为与其返回对象的类的类型相同。\n\n**示例：**\n\n\n      class Foo implements Cloneable {\n        public Object clone() {\n          try {\n            return super.clone();\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo implements Cloneable {\n        public Foo clone() {\n          try {\n            return (Foo)super.clone();\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneReturnsClassType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableWithSerializationMethods",
                "shortDescription": {
                  "text": "具有 'readObject()' 或 'writeObject()' 的不可序列化类"
                },
                "fullDescription": {
                  "text": "报告定义 'readObject()' 或 'writeObject()' 方法的非 'Serializable' 类。 该上下文中的此类方法通常表明有错误。 示例： 'public class SampleClass {\n    private void readObject(ObjectInputStream str) {}\n    private void writeObject(ObjectOutputStream str) {}\n  }'",
                  "markdown": "报告定义 `readObject()` 或 `writeObject()` 方法的非 `Serializable` 类。 该上下文中的此类方法通常表明有错误。\n\n**示例：**\n\n\n      public class SampleClass {\n        private void readObject(ObjectInputStream str) {}\n        private void writeObject(ObjectOutputStream str) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableClassWithSerializationMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalToIf",
                "shortDescription": {
                  "text": "'Optional' 可被替换为 'if' 语句序列"
                },
                "fullDescription": {
                  "text": "报告可替换为 'if' 语句序列的 'Optional' 调用链。 示例： 'return Optional.ofNullable(name)\n    .map(this::extractInitials)\n    .map(initials -> initials.toUpperCase(Locale.ENGLISH))\n    .orElseGet(this::getDefault);' 在应用快速修复后： 'if (name != null) {\n    String initials = extractInitials(name);\n    if (initials != null) return initials.toUpperCase(Locale.ENGLISH);\n  }\n  return getDefault();' 此检查有助于为向后兼容早期 Java 版本而降级。 2020.2 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可替换为 `if` 语句序列的 `Optional` 调用链。\n\n示例：\n\n\n      return Optional.ofNullable(name)\n        .map(this::extractInitials)\n        .map(initials -> initials.toUpperCase(Locale.ENGLISH))\n        .orElseGet(this::getDefault);\n\n在应用快速修复后：\n\n\n      if (name != null) {\n        String initials = extractInitials(name);\n        if (initials != null) return initials.toUpperCase(Locale.ENGLISH);\n      }\n      return getDefault();\n\n\n此检查有助于为向后兼容早期 Java 版本而降级。\n\n2020.2 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "OptionalToIf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryFinalOnLocalVariableOrParameter",
                "shortDescription": {
                  "text": "局部变量或形参上存在不必要的 'final'"
                },
                "fullDescription": {
                  "text": "报告不必要地声明为 'final' 的局部变量或形参。 出于简洁的原因，某些编码标准不赞成声明为 'final' 的变量。 示例： 'class Foo {\n    Foo(Object o) {}\n\n    void bar(final Object o) {\n      new Foo(o);\n    }\n  }' 在应用快速修复后： 'class Foo {\n    Foo(Object o) {}\n\n    void bar(Object o) {\n      new Foo(o);\n    }\n  }' 使用检查选项可以切换以下各项的报告： 局部变量 形参（包括 'catch' 块的形参和增强型 'for' 语句） 此外，您可以将检查配置为仅报告 'abstract' 或接口方法的 'final' 形参，这可能被认为是多余的，因为此类标记不会影响这些方法的实现。",
                  "markdown": "报告不必要地声明为 `final` 的局部变量或形参。\n\n出于简洁的原因，某些编码标准不赞成声明为 `final` 的变量。\n\n**示例：**\n\n\n      class Foo {\n        Foo(Object o) {}\n\n        void bar(final Object o) {\n          new Foo(o);\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        Foo(Object o) {}\n\n        void bar(Object o) {\n          new Foo(o);\n        }\n      }\n\n\n使用检查选项可以切换以下各项的报告：\n\n* 局部变量\n* 形参（包括 `catch` 块的形参和增强型 `for` 语句）\n\n\n此外，您可以将检查配置为仅报告 `abstract` 或接口方法的 `final` 形参，这可能被认为是多余的，因为此类标记不会影响这些方法的实现。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryFinalOnLocalVariableOrParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IllegalDependencyOnInternalPackage",
                "shortDescription": {
                  "text": "对内部软件包的非法依赖"
                },
                "fullDescription": {
                  "text": "报告软件包上不包含 'module-info.java' 且未从命名模块中导出的模块中的引用。 当项目中的某些模块已经迁移到 Java 模块，而其他模块仍然处于非模块化状态时，可能会出现此类配置。 与 JDK 类似，此类非模块化代码不得访问命名模块中未显式导出的代码。",
                  "markdown": "报告软件包上不包含 `module-info.java` 且未从命名模块中导出的模块中的引用。\n\n当项目中的某些模块已经迁移到 Java 模块，而其他模块仍然处于非模块化状态时，可能会出现此类配置。\n与 JDK 类似，此类非模块化代码不得访问命名模块中未显式导出的代码。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "IllegalDependencyOnInternalPackage",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonBooleanMethodNameMayNotStartWithQuestion",
                "shortDescription": {
                  "text": "非布尔方法名称不能以疑问词开头"
                },
                "fullDescription": {
                  "text": "报告名称以疑问词开头的非布尔方法。 此类方法名称可能令人困惑。 此检查将忽略重写库方法的非布尔方法。 示例： 'public void hasName(String name) {\n    assert names.contains(name);\n  }' 只能在编辑器中使用重命名此类方法的快速修复。 配置检查： 使用布尔方法名称前缀列表可指定应仅用于布尔方法的疑问词。 使用忽略具有 'java.lang.Boolean' 返回类型的方法选项可忽略返回类型为 'java.lang.Boolean' 的方法。 使用忽略重写/实现 super 方法的方法选项可忽略具有 super 方法的方法。",
                  "markdown": "报告名称以疑问词开头的非布尔方法。 此类方法名称可能令人困惑。\n\n此检查将忽略重写库方法的非布尔方法。\n\n**示例：**\n\n\n      public void hasName(String name) {\n        assert names.contains(name);\n      }\n\n只能在编辑器中使用重命名此类方法的快速修复。\n\n配置检查：\n\n* 使用**布尔方法名称前缀**列表可指定应仅用于布尔方法的疑问词。\n* 使用**忽略具有 'java.lang.Boolean' 返回类型的方法** 选项可忽略返回类型为 `java.lang.Boolean` 的方法。\n* 使用**忽略重写/实现 super 方法的方法**选项可忽略具有 super 方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonBooleanMethodNameMayNotStartWithQuestion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WeakerAccess",
                "shortDescription": {
                  "text": "声明访问可以更弱"
                },
                "fullDescription": {
                  "text": "报告可能缩小其访问修饰符范围的字段、方法或类。 示例： 'class Sample {\n    void foo() {\n        bar(\"foo\", \"foo\");\n    }\n    void bar(String x, String y) { } // 可以为 private\n  }' 在应用快速修复后： 'class Sample {\n    void foo() {\n        bar(\"foo\", \"foo\");\n    }\n    private void bar(String x, String y) { }\n  }' 使用检查选项可以定义修饰符更改建议的规则。",
                  "markdown": "报告可能缩小其访问修饰符范围的字段、方法或类。\n\n示例：\n\n\n      class Sample {\n        void foo() {\n            bar(\"foo\", \"foo\");\n        }\n        void bar(String x, String y) { } // 可以为 private\n      }\n\n在应用快速修复后：\n\n\n      class Sample {\n        void foo() {\n            bar(\"foo\", \"foo\");\n        }\n        private void bar(String x, String y) { }\n      }\n\n使用检查选项可以定义修饰符更改建议的规则。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WeakerAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithJavadoc",
                "shortDescription": {
                  "text": "可用 Javadoc 替换的注释"
                },
                "fullDescription": {
                  "text": "报告属于可被替换为 Javadoc 注释的字段、方法或类的常规注释。 示例： 'public class Main {\n    /*\n    * Hello,\n    */\n    // World!\n    void f() {\n    }\n  }' 在应用快速修复后： 'public class Main {\n    /**\n     * Hello,\n     * World!\n     */\n    void f() {\n    }\n  }'",
                  "markdown": "报告属于可被替换为 Javadoc 注释的字段、方法或类的常规注释。\n\n**示例：**\n\n\n      public class Main {\n        /*\n        * Hello,\n        */\n        // World!\n        void f() {\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Main {\n        /**\n         * Hello,\n         * World!\n         */\n        void f() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceWithJavadoc",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BigDecimalMethodWithoutRoundingCalled",
                "shortDescription": {
                  "text": "'BigDecimal' 方法调用没有舍入模式实参"
                },
                "fullDescription": {
                  "text": "报告对没有舍入模式实参的 'divide()' 或 'setScale()' 的调用。 在结果中不能表示精确值时（例如由于具有非终止十进制扩展），此类调用可能导致 'ArithmeticException'。 指定舍入模式可防止 'ArithmeticException'。 示例： 'BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));'",
                  "markdown": "报告对没有舍入模式实参的 `divide()` 或 `setScale()` 的调用。\n\n在结果中不能表示精确值时（例如由于具有非终止十进制扩展），此类调用可能导致 `ArithmeticException`。\n\n指定舍入模式可防止 `ArithmeticException`。\n\n**示例：**\n\n\n      BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BigDecimalMethodWithoutRoundingCalled",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyComplexArithmeticExpression",
                "shortDescription": {
                  "text": "过于复杂的算术表达式"
                },
                "fullDescription": {
                  "text": "报告具有过多项的算术表达式。 此类表达式可能难以理解并且可能包含错误。 形参、字段引用和其他主要表达式均计为一项。 示例： 'int calc(int a, int b) {\n        return a + a + a + b + b + b + b; // 该行包含 7 个项并将被报告。\n    }' 使用下面的字段可指定算术表达式中允许的项数。",
                  "markdown": "报告具有过多项的算术表达式。 此类表达式可能难以理解并且可能包含错误。\n\n形参、字段引用和其他主要表达式均计为一项。\n\n**示例：**\n\n    int calc(int a, int b) {\n            return a + a + a + b + b + b + b; // 该行包含 7 个项并将被报告。\n        }\n\n使用下面的字段可指定算术表达式中允许的项数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexArithmeticExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DriverManagerGetConnection",
                "shortDescription": {
                  "text": "使用 'DriverManager' 获取 JDBC 连接"
                },
                "fullDescription": {
                  "text": "报告任何使用 'java.sql.DriverManager' 获取 JDBC 连接的情况。 'java.sql.DriverManager' 已被 'javax.sql.Datasource' 取代，后者允许连接池和其他优化。 示例： 'Connection conn = DriverManager.getConnection(url, username, password);'",
                  "markdown": "报告任何使用 `java.sql.DriverManager` 获取 JDBC 连接的情况。\n\n\n`java.sql.DriverManager` 已被 `javax.sql.Datasource` 取代，后者允许连接池和其他优化。\n\n**示例：**\n\n      Connection conn = DriverManager.getConnection(url, username, password);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToDriverManagerGetConnection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrapperTypeMayBePrimitive",
                "shortDescription": {
                  "text": "包装器类型可能是基元"
                },
                "fullDescription": {
                  "text": "报告主要用作基元类型的包装器类型的局部变量。 在某些情况下，装箱可能会导致严重的性能损失，尤其是在循环中。 采用启发估计装箱操作次数。 例如，循环内的转换数量视为更多。 示例： 'public void example() {\n    Integer value = 12;\n    needBox(value);\n    for (int i = 0; i < 10; i++) {\n      // 循环的用法正变得越来越频繁\n      needPrimitive(value);\n    }\n  }\n\n  void needPrimitive(int value) {}\n  void needBox(Integer value) {}' 在应用快速修复后： 'public void example() {\n    int value = 12;\n    needBox(value);\n    for (int i = 0; i < 10; i++) {\n      // 循环的用法正变得越来越频繁\n      needPrimitive(value);\n    }\n  }\n\n  void needPrimitive(int value) {}\n  void needBox(Integer value) {}' 2018.2 最新变化",
                  "markdown": "报告主要用作基元类型的包装器类型的局部变量。\n\n在某些情况下，装箱可能会导致严重的性能损失，尤其是在循环中。\n\n采用启发估计装箱操作次数。 例如，循环内的转换数量视为更多。\n\n**示例：**\n\n      public void example() {\n        Integer value = 12;\n        needBox(value);\n        for (int i = 0; i < 10; i++) {\n          // 循环的用法正变得越来越频繁\n          needPrimitive(value);\n        }\n      }\n\n      void needPrimitive(int value) {}\n      void needBox(Integer value) {}\n\n在应用快速修复后：\n\n      public void example() {\n        int value = 12;\n        needBox(value);\n        for (int i = 0; i < 10; i++) {\n          // 循环的用法正变得越来越频繁\n          needPrimitive(value);\n        }\n      }\n\n      void needPrimitive(int value) {}\n      void needBox(Integer value) {}\n\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WrapperTypeMayBePrimitive",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyStatementBody",
                "shortDescription": {
                  "text": "带空体的语句"
                },
                "fullDescription": {
                  "text": "报告语句体为空的 'if'、'while'、'do'、'for'、'switch' 语句。 虽然偶尔是有意为之，但此类代码令人困惑，并且通常是由拼写错误所致。 JSP 文件中禁用了此检查。",
                  "markdown": "报告语句体为空的 `if`、`while`、`do`、`for`、`switch` 语句。\n\n虽然偶尔是有意为之，但此类代码令人困惑，并且通常是由拼写错误所致。\n\nJSP 文件中禁用了此检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StatementWithEmptyBody",
                    "cweIds": [
                      561
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyFinallyBlock",
                "shortDescription": {
                  "text": "空 'finally' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'finally' 块。 空的 'finally' 块通常表明存在编码错误。 在代码重构后它们可能保留下来，可以安全移除。 此检查不报告在 JSP 文件中发现的空 'finally' 块。 示例： 'try {\n    Files.readString(Paths.get(\"in.txt\"));\n  } catch (IOException e) {\n    throw new RuntimeException(e);\n  } finally {\n\n  }' 在应用快速修复后： 'try {\n    Files.readString(Paths.get(\"in.txt\"));\n  } catch (IOException e) {\n    throw new RuntimeException(e);\n  }'",
                  "markdown": "报告空的 `finally` 块。\n\n空的 `finally` 块通常表明存在编码错误。 在代码重构后它们可能保留下来，可以安全移除。\n\n此检查不报告在 JSP 文件中发现的空 `finally` 块。\n\n**示例：**\n\n\n      try {\n        Files.readString(Paths.get(\"in.txt\"));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      } finally {\n\n      }\n\n在应用快速修复后：\n\n\n      try {\n        Files.readString(Paths.get(\"in.txt\"));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentLanguageLevel",
                "shortDescription": {
                  "text": "语言级别设置不一致"
                },
                "fullDescription": {
                  "text": "报告依赖于具有更高语言级别的其他模块的模块。 应该移除此类依赖项或提高模块的语言级别。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告依赖于具有更高语言级别的其他模块的模块。\n\n应该移除此类依赖项或提高模块的语言级别。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentLanguageLevel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadDumpStack",
                "shortDescription": {
                  "text": "调用 'Thread.dumpStack()'"
                },
                "fullDescription": {
                  "text": "报告 'Thread.dumpStack()' 的用法。 此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。",
                  "markdown": "报告 `Thread.dumpStack()` 的用法。\n\n此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadDumpStack",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumerationCanBeIteration",
                "shortDescription": {
                  "text": "枚举可以是迭代"
                },
                "fullDescription": {
                  "text": "报告对集合使用的可以替换为等效 'Iterator' 结构的 'Enumeration' 方法的调用。 示例： 'Enumeration<String> keys = map.keys();\n  while (keys.hasMoreElements()) {\n    String name = keys.nextElement();\n  }' 在应用快速修复后： 'Iterator<String> iterator = map.keySet().iterator();\n  while (iterator.hasNext()) {\n    String name = iterator.next();\n  }'",
                  "markdown": "报告对集合使用的可以替换为等效 `Iterator` 结构的 `Enumeration` 方法的调用。\n\n**示例：**\n\n\n      Enumeration<String> keys = map.keys();\n      while (keys.hasMoreElements()) {\n        String name = keys.nextElement();\n      }\n\n在应用快速修复后：\n\n\n      Iterator<String> iterator = map.keySet().iterator();\n      while (iterator.hasNext()) {\n        String name = iterator.next();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumerationCanBeIteration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级迁移帮助",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryBlockStatement",
                "shortDescription": {
                  "text": "不必要的代码块"
                },
                "fullDescription": {
                  "text": "报告对程序的语义冗余的代码块，并且可以用其内容替换。 作为 'if'、'do'、'while' 或 'for' 语句主体的代码块将不会被此检查报告。 示例： 'void foo() {\n    { // 不必要\n      int result = call();\n      analyze(result);\n    } // 不必要\n  }' 配置检查： 使用 忽略 'switch' 语句的分支 选项来忽略用作 switch 语句分支的代码块。",
                  "markdown": "报告对程序的语义冗余的代码块，并且可以用其内容替换。\n\n作为 `if`、`do`、`while` 或 `for` 语句主体的代码块将不会被此检查报告。\n\n示例：\n\n\n      void foo() {\n        { // 不必要\n          int result = call();\n          analyze(result);\n        } // 不必要\n      }\n\n配置检查：\n\n\n使用 **忽略 'switch' 语句的分支** 选项来忽略用作 switch 语句分支的代码块。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryCodeBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalMethodInFinalClass",
                "shortDescription": {
                  "text": "'final' 类位于 'final' 方法中"
                },
                "fullDescription": {
                  "text": "报告 'final' 类中的 'final' 方法。 由于不能继承 'final' 类，将方法标记为 'final' 可能是多余之举，而且令人困惑。 示例： 'record Bar(int a, int b) {\n  public final int sum() { \n     return a + b;\n  }\n}'\n 在应用快速修复后： 'record Bar(int a, int b) {\n  public int sum() { \n     return a + b;\n  }\n}' 如本例所示，可以显式或隐式地将类标记为 'final'。",
                  "markdown": "报告 `final` 类中的 `final` 方法。\n\n由于不能继承 `final` 类，将方法标记为 `final` 可能是多余之举，而且令人困惑。\n\n**示例：**\n\n    record Bar(int a, int b) {\n      public final int sum() { \n         return a + b;\n      }\n    }\n\n在应用快速修复后：\n\n    record Bar(int a, int b) {\n      public int sum() { \n         return a + b;\n      }\n    }\n\n如本例所示，可以显式或隐式地将类标记为 `final`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalMethodInFinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalPrivateMethod",
                "shortDescription": {
                  "text": "'private' 方法被声明为 'final'"
                },
                "fullDescription": {
                  "text": "报告同时标有 'final' 和 'private' 关键字的方法。 由于 'private' 方法因其可见性而无法被有意义地重写，因此将它们声明为 'final' 是冗余的。",
                  "markdown": "报告同时标有 `final` 和 `private` 关键字的方法。\n\n由于 `private` 方法因其可见性而无法被有意义地重写，因此将它们声明为 `final` 是冗余的。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalPrivateMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalStaticMethod",
                "shortDescription": {
                  "text": "'static' 方法被声明为 'final'"
                },
                "fullDescription": {
                  "text": "报告标记为 'final' 的 static 方法。 此类代码可能表示错误或关于 'final' 关键字效果的不正确的假设。 由于 static 方法不受运行时多态性影响，因此与 static 方法一起使用的 'final' 关键字的唯一目的是确保该方法不会在子类中被隐藏。",
                  "markdown": "报告标记为 `final` 的 static 方法。\n\n此类代码可能表示错误或关于 `final` 关键字效果的不正确的假设。\n由于 static 方法不受运行时多态性影响，因此与 static 方法一起使用的 `final` 关键字的唯一目的是确保该方法不会在子类中被隐藏。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalStaticMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantTypeArguments",
                "shortDescription": {
                  "text": "冗余类型实参"
                },
                "fullDescription": {
                  "text": "报告对显式实参类型可以忽略（因为编译器将明确推断出这些实参类型）的形参化方法的调用。 使用冗余类型实参不必要，并且会降低代码的可读性。 示例： 'List<String> list = Arrays.<String>asList(\"Hello\", \"World\");' 通过快速修复可以移除冗余类型实参： 'List<String> list = Arrays.asList(\"Hello\", \"World\");'",
                  "markdown": "报告对显式实参类型可以忽略（因为编译器将明确推断出这些实参类型）的形参化方法的调用。\n\n\n使用冗余类型实参不必要，并且会降低代码的可读性。\n\n示例：\n\n\n      List<String> list = Arrays.<String>asList(\"Hello\", \"World\");\n\n通过快速修复可以移除冗余类型实参：\n\n\n      List<String> list = Arrays.asList(\"Hello\", \"World\");\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantTypeArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldHasSetterButNoGetter",
                "shortDescription": {
                  "text": "字段具有 setter 但没有 getter"
                },
                "fullDescription": {
                  "text": "报告含有 setter 方法但没有 getter 方法的字段。 在某些 bean 容器中，当在 Java bean 规范中使用时，这些字段可能难以使用。",
                  "markdown": "报告含有 setter 方法但没有 getter 方法的字段。\n\n\n在某些 bean 容器中，当在 Java bean 规范中使用时，这些字段可能难以使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldHasSetterButNoGetter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RuntimeExecWithNonConstantString",
                "shortDescription": {
                  "text": "'Runtime.exec()' 调用具有非常量字符串"
                },
                "fullDescription": {
                  "text": "报告对 'java.lang.Runtime.exec()' 的调用，该调用会将动态构造的字符串作为要执行的命令。 构造的执行字符串是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。 示例： 'String i = getUserInput();\n  Runtime runtime = Runtime.getRuntime();\n  runtime.exec(\"foo\" + i); // 报告警告' 使用检查设置可以将任何 'static' 'final' 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略： 'static final String COMMAND = \"ping \" + getDomainFromUserInput() + \"'\";'",
                  "markdown": "报告对 `java.lang.Runtime.exec()` 的调用，该调用会将动态构造的字符串作为要执行的命令。\n\n\n构造的执行字符串是安全漏洞的常见来源。\n默认情况下，此检查会忽略编译时常量。\n\n**示例：**\n\n\n      String i = getUserInput();\n      Runtime runtime = Runtime.getRuntime();\n      runtime.exec(\"foo\" + i); // 报告警告\n\n\n使用检查设置可以将任何 `static` `final` 字段视为常量。\n请小心，因为启用该选项时，像下面这样的字符串将被忽略：\n\n\n      static final String COMMAND = \"ping \" + getDomainFromUserInput() + \"'\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToRuntimeExecWithNonConstantString",
                    "cweIds": [
                      20,
                      77,
                      78,
                      88,
                      94
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentOrReturnOfFieldWithMutableType",
                "shortDescription": {
                  "text": "具有可变类型的字段的赋值或返回"
                },
                "fullDescription": {
                  "text": "报告从方法形参到数组或可变类型（如 'Collection'、'Date'、'Map'、'Calendar' 等）的返回或赋值 由于这种类型是可变的，此结构可能会导致来自所属类之外的对象状态发生意外修改。 尽管出于性能原因，此结构可能很有用，但它本质上很容易出现错误。 报告了以下可变类型： 'java.util.Date' 'java.util.Calendar' 'java.util.Collection' 'java.util.Map' 'com.google.common.collect.Multimap' 'com.google.common.collect.Table' 该快速修复会添加对字段的 '.clone()' 方法的调用。 示例： 'class Log {\n    String[] messages;\n    ...\n\n    String[] getMessages() {\n      return messages; // 警告：返回 String[] 字段 'messages'\n    }\n  }' 在应用快速修复后： 'class Log {\n    String[] messages;\n    ...\n\n    String[] getMessages() {\n      return messages.clone();\n    }\n  }' 使用忽略 private 方法中的赋值和返回值选项可忽略 'private'方法中的赋值和返回值。",
                  "markdown": "报告从方法形参到数组或可变类型（如 `Collection`、`Date`、`Map`、`Calendar` 等）的返回或赋值\n\n由于这种类型是可变的，此结构可能会导致来自所属类之外的对象状态发生意外修改。 尽管出于性能原因，此结构可能很有用，但它本质上很容易出现错误。\n\n报告了以下可变类型：\n\n* `java.util.Date`\n* `java.util.Calendar`\n* `java.util.Collection`\n* `java.util.Map`\n* `com.google.common.collect.Multimap`\n* `com.google.common.collect.Table`\n\n该快速修复会添加对字段的 `.clone()` 方法的调用。\n\n**示例：**\n\n\n      class Log {\n        String[] messages;\n        ...\n\n        String[] getMessages() {\n          return messages; // 警告：返回 String[] 字段 'messages'\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Log {\n        String[] messages;\n        ...\n\n        String[] getMessages() {\n          return messages.clone();\n        }\n      }\n\n使用**忽略 private 方法中的赋值和返回值** 选项可忽略 `private`方法中的赋值和返回值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentOrReturnOfFieldWithMutableType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryUnboxing",
                "shortDescription": {
                  "text": "不必要的拆箱"
                },
                "fullDescription": {
                  "text": "报告取消装箱，即显式解开已环绕的基元值。 对于 Java 5 和更高版本，拆箱不必要，并且可以安全移除。 示例： 'Integer i = Integer.valueOf(42).intValue();' → 'Integer i = Integer.valueOf(42);' 'int k = Integer.valueOf(42).intValue();' → 'int k = Integer.valueOf(42);' （仅在未选中仅报告真正多余的拆箱表达式选项时报告） 使用仅报告真正多余的拆箱表达式选项，可仅报告真正多余的拆箱，其中的拆箱值立即隐式或显式地装箱。 在本例中，可以移除整个拆箱-装箱步骤。 该检查不报告简单的显式拆箱。 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告取消装箱，即显式解开已环绕的基元值。\n\n对于 Java 5 和更高版本，拆箱不必要，并且可以安全移除。\n\n**示例：**\n\n* `Integer i = Integer.valueOf(42).intValue();` → `Integer i = Integer.valueOf(42);`\n* `int k = Integer.valueOf(42).intValue();` → `int k = Integer.valueOf(42);`\n\n  （仅在未选中**仅报告真正多余的拆箱表达式**选项时报告）\n\n\n使用**仅报告真正多余的拆箱表达式**选项，可仅报告真正多余的拆箱，其中的拆箱值立即隐式或显式地装箱。\n在本例中，可以移除整个拆箱-装箱步骤。 该检查不报告简单的显式拆箱。\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryUnboxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalAssignedToNull",
                "shortDescription": {
                  "text": "Optional 类型的 null 值"
                },
                "fullDescription": {
                  "text": "报告 'null' 分配给 'Optional' 变量或从返回 'Optional' 的方法返回。 建议您使用 'Optional.empty()'（或 'Optional.absent()' 用于 Guava）来表示空值。 示例： 'Optional<Integer> foo(boolean flag) {\n    return flag ? Optional.of(42) : null;\n  }' 在应用快速修复后： 'Optional<Integer> foo(boolean flag) {\n    return flag ? Optional.of(42) : Optional.empty();\n  }' 配置检查： 使用 报告 Optional 与 null 的比较 选项还可以报告'optional == null' 之类的比较。 虽然在极少数情况下（例如延迟初始化的可选字段）这可能是正确的，但可选变量通常不会为 null，并且可能应为 'optional.isPresent()'。 2017.2 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告 `null` 分配给 `Optional` 变量或从返回 `Optional` 的方法返回。\n\n建议您使用 `Optional.empty()`（或 `Optional.absent()` 用于 Guava）来表示空值。\n\n示例：\n\n\n      Optional<Integer> foo(boolean flag) {\n        return flag ? Optional.of(42) : null;\n      }\n\n在应用快速修复后：\n\n\n      Optional<Integer> foo(boolean flag) {\n        return flag ? Optional.of(42) : Optional.empty();\n      }\n\n配置检查：\n\n\n使用 **报告 Optional 与 null 的比较** 选项还可以报告`optional == null` 之类的比较。 虽然在极少数情况下（例如延迟初始化的可选字段）这可能是正确的，但可选变量通常不会为 null，并且可能应为 `optional.isPresent()`。\n\n2017.2 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalAssignedToNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessIndexOfComparison",
                "shortDescription": {
                  "text": "无意义的 'indexOf()' 比较"
                },
                "fullDescription": {
                  "text": "报告与 '.indexOf()' 表达式的不必要比较。 此类表达式的一个示例是将 '.indexOf()' 的结果与小于 -1 的数字进行比较。",
                  "markdown": "报告与 `.indexOf()` 表达式的不必要比较。 此类表达式的一个示例是将 `.indexOf()` 的结果与小于 -1 的数字进行比较。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessIndexOfComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ErrorRethrown",
                "shortDescription": {
                  "text": "'Error' 未重新抛出"
                },
                "fullDescription": {
                  "text": "报告捕获 'java.lang.Error' 或其任何子类并且不重新抛出错误的 'try' 语句。 不会报告捕获 'java.lang.ThreadDeath' 的语句。 示例： 'try {\n    executeTests(request);\n  }\n  catch (OutOfMemoryError ex) { // 警告：错误 'ex' 未重新抛出\n    return false;\n  }'",
                  "markdown": "报告捕获 `java.lang.Error` 或其任何子类并且不重新抛出错误的 `try` 语句。\n\n不会报告捕获 `java.lang.ThreadDeath` 的语句。\n\n**示例：**\n\n\n      try {\n        executeTests(request);\n      }\n      catch (OutOfMemoryError ex) { // 警告：错误 'ex' 未重新抛出\n        return false;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ErrorNotRethrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsAndHashcode",
                "shortDescription": {
                  "text": "'equals()' 和 'hashCode()' 未配对"
                },
                "fullDescription": {
                  "text": "报告重写 'equals()' 方法但不重写 'hashCode()' 方法的类，反之亦然。将类添加到 'Collection' 或 'HashMap' 时，可能会导致问题。 该快速修复会为不存在的方法生成默认实现。 示例： 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' 在应用快速修复后： 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
                  "markdown": "报告重写 `equals()` 方法但不重写 `hashCode()` 方法的类，反之亦然。将类添加到 `Collection` 或 `HashMap` 时，可能会导致问题。\n\n该快速修复会为不存在的方法生成默认实现。\n\n示例：\n\n\n    class StringHolder {\n      String s;\n\n      @Override public int hashCode() {\n        return s != null ? s.hashCode() : 0;\n      }\n    }\n\n在应用快速修复后：\n\n\n    class StringHolder {\n      String s;\n\n      @Override public int hashCode() {\n        return s != null ? s.hashCode() : 0;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof StringHolder)) return false;\n\n        StringHolder holder = (StringHolder)o;\n\n        if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n        return true;\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsAndHashcode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IteratorHasNextCallsIteratorNext",
                "shortDescription": {
                  "text": "调用 'next()' 的 'Iterator.hasNext()'"
                },
                "fullDescription": {
                  "text": "报告迭代器实例上调用 'Iterator.next()' 或 'ListIterator.previous()' 的 'Iterator.hasNext()' 或 'ListIterator.hasPrevious()' 的实现。 此类调用几乎肯定是错误，因为 'hasNext()' 之类的方法不应修改迭代器状态，而 'next()' 应修改迭代器状态。 示例： 'class MyIterator implements Iterator<Integer> {\n    public boolean hasNext() {\n      return next() != null;\n    }\n  }'",
                  "markdown": "报告迭代器实例上调用 `Iterator.next()` 或 `ListIterator.previous()` 的 `Iterator.hasNext()` 或 `ListIterator.hasPrevious()` 的实现。 此类调用几乎肯定是错误，因为 `hasNext()` 之类的方法不应修改迭代器状态，而 `next()` 应修改迭代器状态。\n\n**示例：**\n\n\n      class MyIterator implements Iterator<Integer> {\n        public boolean hasNext() {\n          return next() != null;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IteratorHasNextCallsIteratorNext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclicPackageDependency",
                "shortDescription": {
                  "text": "循环软件包依赖关系"
                },
                "fullDescription": {
                  "text": "报告相互依赖或循环依赖于其他软件包的软件包。 此类循环依赖项会使代码变得脆弱且难以维护。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告相互依赖或循环依赖于其他软件包的软件包。\n\n此类循环依赖项会使代码变得脆弱且难以维护。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CyclicPackageDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringRepeatCanBeUsed",
                "shortDescription": {
                  "text": "可以使用 String.repeat()"
                },
                "fullDescription": {
                  "text": "报告可以替换为单一 'String.repeat()' 方法的循环（自 Java 11 起提供）。 示例： 'void append(StringBuilder sb, int count, Object obj) {\n    for (int i = 0; i < count; i++) {\n      sb.append(obj);\n    }\n  }' 在应用快速修复后： 'void append(StringBuilder sb, int count, Object obj) {\n    sb.append(String.valueOf(obj).repeat(Math.max(0, count)));\n  }' 默认情况下，如果不能静态地证明 'count' 非负，则该检查可以使用 'Math.max(0, count)' 来包装 'count'。 这样做的目的是防止可能发生的语义更改，因为 'String.repeat()' 拒绝负数。 必要时，可使用添加 Math.max(0, count) 以避免可能的语义更改选项禁用此行为。 同样，如果不知道要重复的字符串能否为 'null'，可将其包装在 'String.valueOf' 中，以防止可能发生的 'NullPointerException'。 仅当项目或模块的语言级别为 11 或更高时，此检查才会报告。 2019.1 最新变化",
                  "markdown": "报告可以替换为单一 `String.repeat()` 方法的循环（自 Java 11 起提供）。\n\n**示例：**\n\n\n      void append(StringBuilder sb, int count, Object obj) {\n        for (int i = 0; i < count; i++) {\n          sb.append(obj);\n        }\n      }\n\n在应用快速修复后：\n\n\n      void append(StringBuilder sb, int count, Object obj) {\n        sb.append(String.valueOf(obj).repeat(Math.max(0, count)));\n      }\n\n\n默认情况下，如果不能静态地证明 `count` 非负，则该检查可以使用 `Math.max(0, count)` 来包装 `count`。 这样做的目的是防止可能发生的语义更改，因为 `String.repeat()` 拒绝负数。\n必要时，可使用**添加 Math.max(0, count) 以避免可能的语义更改**选项禁用此行为。\n\n同样，如果不知道要重复的字符串能否为 `null`，可将其包装在 `String.valueOf` 中，以防止可能发生的 `NullPointerException`。\n\n仅当项目或模块的语言级别为 11 或更高时，此检查才会报告。\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringRepeatCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 11",
                      "index": 125,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemSetSecurityManager",
                "shortDescription": {
                  "text": "调用 'System.setSecurityManager()'"
                },
                "fullDescription": {
                  "text": "报告对 'System.setSecurityManager()' 的调用。 虽然通常是良性的，但任何对 'System.setSecurityManager()' 的调用都应在每个安全审核中仔细检查。",
                  "markdown": "报告对 `System.setSecurityManager()` 的调用。\n\n虽然通常是良性的，但任何对 `System.setSecurityManager()` 的调用都应在每个安全审核中仔细检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemSetSecurityManager",
                    "cweIds": [
                      250
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsatisfiedRange",
                "shortDescription": {
                  "text": "返回值超出声明的范围"
                },
                "fullDescription": {
                  "text": "报告从不符合所声明方法返回范围的方法返回的数值。 您可以使用许多注解声明方法的返回范围： JetBrains 注解软件包中的 'org.jetbrains.annotations.Range'（指定 'from' 和 'to'） Checker Framework 注解软件包中的 'org.checkerframework.common.value.qual.IntRange'（指定 'from' 和 'to'） Checker Framework 注解软件包中的 'org.checkerframework.checker.index.qual.GTENegativeOne'（范围为 '>= -1'） Checker Framework 注解软件包中的 'org.checkerframework.checker.index.qual.NonNegative'（范围为 '>= 0'） Checker Framework 注解软件包中的 'org.checkerframework.checker.index.qual.Positive'（范围为 '> 0'） JSR 305 注解软件包中的 'javax.annotation.Nonnegative'（范围为 '>= 0'） 'javax.validation.constraints.Min'（指定最小值） 'javax.validation.constraints.Max'（指定最大值） 示例： '@Range(from = 0, to = Integer.MAX_VALUE) int getValue() {\n    // 警告：-1 超出声明的范围\n    return -1;\n  }' 2021.2 最新变化",
                  "markdown": "报告从不符合所声明方法返回范围的方法返回的数值。 您可以使用许多注解声明方法的返回范围：\n\n* JetBrains 注解软件包中的 `org.jetbrains.annotations.Range`（指定 'from' 和 'to'）\n* Checker Framework 注解软件包中的 `org.checkerframework.common.value.qual.IntRange`（指定 'from' 和 'to'）\n* Checker Framework 注解软件包中的 `org.checkerframework.checker.index.qual.GTENegativeOne`（范围为 '\\>= -1'）\n* Checker Framework 注解软件包中的 `org.checkerframework.checker.index.qual.NonNegative`（范围为 '\\>= 0'）\n* Checker Framework 注解软件包中的 `org.checkerframework.checker.index.qual.Positive`（范围为 '\\> 0'）\n* JSR 305 注解软件包中的 `javax.annotation.Nonnegative`（范围为 '\\>= 0'）\n* `javax.validation.constraints.Min`（指定最小值）\n* `javax.validation.constraints.Max`（指定最大值）\n\n示例：\n\n\n      @Range(from = 0, to = Integer.MAX_VALUE) int getValue() {\n        // 警告：-1 超出声明的范围\n        return -1;\n      }\n\n2021.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsatisfiedRange",
                    "cweIds": [
                      129,
                      682
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithoutNoArgConstructor",
                "shortDescription": {
                  "text": "没有无实参构造函数的类"
                },
                "fullDescription": {
                  "text": "报告没有构造函数（不带实参，即没有形参）的类。 无实参构造函数在某些上下文中是必需的。 例如，如果需要使用反射来创建类。 示例： 'public class Bean {\n    private String name;\n\n    public Bean(String name) {\n      this.name = name;\n    }\n  }' 使用下面的复选框可忽略没有显式构造函数的类。 编译器为这种类提供了默认的无实参构造函数。",
                  "markdown": "报告没有构造函数（不带实参，即没有形参）的类。 无实参构造函数在某些上下文中是必需的。 例如，如果需要使用反射来创建类。\n\n**示例：**\n\n\n      public class Bean {\n        private String name;\n\n        public Bean(String name) {\n          this.name = name;\n        }\n      }\n\n\n使用下面的复选框可忽略没有显式构造函数的类。\n编译器为这种类提供了默认的无实参构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithoutNoArgConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyDependencies",
                "shortDescription": {
                  "text": "依赖过多的类"
                },
                "fullDescription": {
                  "text": "报告直接依赖于项目中过多其他类的类。 对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。 仅报告顶级类。 使用最大依赖项数字段可指定类允许的最大依赖项数。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告直接依赖于项目中过多其他类的类。\n\n对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。\n\n仅报告顶级类。\n\n使用**最大依赖项数**字段可指定类允许的最大依赖项数。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyDependencies",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastConflictsWithInstanceof",
                "shortDescription": {
                  "text": "转换与 'instanceof' 冲突"
                },
                "fullDescription": {
                  "text": "报告前面包含用于检查不同类型的 'instanceof' 的类型转换表达式。 尽管这可能是有意为之，但此类结构很可能是错误，在运行时将导致 'java.lang.ClassCastException'。 示例： 'class Main {\n    int whenCharSequenceCastToNumber(Object o){\n      if (o instanceof CharSequence) {\n        return ((Number) o).intValue();\n      }\n      return 0;\n    }\n\n    int earlyReturnWhenNotCharSequence(Object o){\n      if (!(o instanceof CharSequence)) return 0;\n      return ((Number)o).intValue();\n    }\n  }'",
                  "markdown": "报告前面包含用于检查不同类型的 `instanceof` 的类型转换表达式。\n\n\n尽管这可能是有意为之，但此类结构很可能是错误，在运行时将导致 `java.lang.ClassCastException`。\n\n**示例：**\n\n\n      class Main {\n        int whenCharSequenceCastToNumber(Object o){\n          if (o instanceof CharSequence) {\n            return ((Number) o).intValue();\n          }\n          return 0;\n        }\n\n        int earlyReturnWhenNotCharSequence(Object o){\n          if (!(o instanceof CharSequence)) return 0;\n          return ((Number)o).intValue();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastConflictsWithInstanceof",
                    "cweIds": [
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MathRoundingWithIntArgument",
                "shortDescription": {
                  "text": "使用 'int' 实参调用数学舍入"
                },
                "fullDescription": {
                  "text": "报告对以 'int' 为实参的 'Math' 和 'StrictMath' 的 'round()'、'ceil()'、 'floor()'、'rint()' 方法的调用。 这些方法可以在预期实参为 'long' 或 'double' 的情况下调用，且可能会产生意外结果。 该检查提供了一种修复，能够将此类表达式（除了 'round'）简化为转换成 'double'。 示例： 'int i = 2;\n  double d1 = Math.floor(i);' 在应用快速修复后： 'int i = 2;\n  double d1 = i;' 2023.1 最新变化",
                  "markdown": "报告对以 `int` 为实参的 `Math` 和 `StrictMath` 的 `round()`、`ceil()`、 `floor()`、`rint()` 方法的调用。\n\n这些方法可以在预期实参为 `long` 或 `double` 的情况下调用，且可能会产生意外结果。\n\n该检查提供了一种修复，能够将此类表达式（除了 `round`）简化为转换成 `double`。\n\n**示例：**\n\n\n      int i = 2;\n      double d1 = Math.floor(i);\n\n在应用快速修复后：\n\n\n      int i = 2;\n      double d1 = i;\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MathRoundingWithIntArgument",
                    "cweIds": [
                      681
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Contract",
                "shortDescription": {
                  "text": "合同的问题"
                },
                "fullDescription": {
                  "text": "报告方法 '@Contract' 注解中的问题。 可以报告的问题类型有： 约定语法错误 不符合方法签名的约定（错误的形参计数） 与约定不一致的方法实现（例如，即使约定声明 'false'，也返回 'true'） 示例： '// 方法没有形参，参约定预期 1\n  @Contract(\"_ -> fail\")\n  void x() {\n    throw new AssertionError();\n  }'",
                  "markdown": "报告方法 `@Contract` 注解中的问题。 可以报告的问题类型有：\n\n* 约定语法错误\n* 不符合方法签名的约定（错误的形参计数）\n* 与约定不一致的方法实现（例如，即使约定声明 ` false`，也返回 `true`）\n\n示例：\n\n\n      // 方法没有形参，参约定预期 1\n      @Contract(\"_ -> fail\")\n      void x() {\n        throw new AssertionError();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Contract",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewExceptionWithoutArguments",
                "shortDescription": {
                  "text": "未使用实参调用异常构造函数"
                },
                "fullDescription": {
                  "text": "报告未指定任何实参的异常实例的创建。 当异常被构造为没有任何实参时，它不包含有关所发生问题的信息，这会使调试变得不必要地困难。 示例： 'throw new IOException(); // 警告：没有实参的异常'",
                  "markdown": "报告未指定任何实参的异常实例的创建。\n\n当异常被构造为没有任何实参时，它不包含有关所发生问题的信息，这会使调试变得不必要地困难。\n\n**示例：**\n\n\n      throw new IOException(); // 警告：没有实参的异常\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewExceptionWithoutArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnhancedSwitchBackwardMigration",
                "shortDescription": {
                  "text": "增强的 'switch'"
                },
                "fullDescription": {
                  "text": "报告增强型 'switch' 语句和表达式。 建议将它们替换为常规的 'switch' 语句。 示例： 'boolean even = switch (condition) {\n    case 1, 3, 5, 7, 9 -> false;\n    default -> true;\n  };' 在应用快速修复后： 'boolean even;\n  switch (condition) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 9:\n      even = false;\n      break;\n    default:\n      even = true;\n      break;\n}' 增强型 'switch' 在 Java 14 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。 2019.1 最新变化",
                  "markdown": "报告增强型 `switch` 语句和表达式。 建议将它们替换为常规的 `switch` 语句。\n\n**示例：**\n\n\n      boolean even = switch (condition) {\n        case 1, 3, 5, 7, 9 -> false;\n        default -> true;\n      };\n\n在应用快速修复后：\n\n\n      boolean even;\n      switch (condition) {\n        case 1:\n        case 3:\n        case 5:\n        case 7:\n        case 9:\n          even = false;\n          break;\n        default:\n          even = true;\n          break;\n    }\n\n\n*增强型* `switch` 在 Java 14 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EnhancedSwitchBackwardMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 14",
                      "index": 102,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageWithTooManyClasses",
                "shortDescription": {
                  "text": "类过多的软件包"
                },
                "fullDescription": {
                  "text": "报告包含过多类的软件包。 过大的软件包可能表明设计不够明确。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用最大类数字段可指定软件包中允许的最大类数。",
                  "markdown": "报告包含过多类的软件包。\n\n过大的软件包可能表明设计不够明确。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**最大类数**字段可指定软件包中允许的最大类数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageWithTooManyClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingGuardedByCondition",
                "shortDescription": {
                  "text": "日志调用受日志条件保护"
                },
                "fullDescription": {
                  "text": "报告被保护条件包围的日志记录调用。 此检查可用于调整自定义代码样式。 示例： 'public class TestObject {\n    void test(Object object) {\n      if(LOG.isDebugEnabled()){\n        LOG.debug(\"some logging \" + expensiveCalculation(1));\n      }\n    }\n  }' 在应用快速修复后： 'public class TestObject {\n    void test(Object object) {\n      LOG.debug(\"some logging \" + expensiveCalculation(1));\n    }\n  }' 此检查支持 Log4j2 和 SLF4J 日志记录框架（ 构建器除外）。 2024.2 最新变化",
                  "markdown": "报告被保护条件包围的日志记录调用。 此检查可用于调整自定义代码样式。\n\n**示例：**\n\n\n      public class TestObject {\n        void test(Object object) {\n          if(LOG.isDebugEnabled()){\n            LOG.debug(\"some logging \" + expensiveCalculation(1));\n          }\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class TestObject {\n        void test(Object object) {\n          LOG.debug(\"some logging \" + expensiveCalculation(1));\n        }\n      }\n\n此检查支持 *Log4j2* 和 *SLF4J* 日志记录框架（ 构建器除外）。\n\n2024.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LoggingGuardedByCondition",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TryFinallyCanBeTryWithResources",
                "shortDescription": {
                  "text": "'try finally' 可被替换为 'try' with resources"
                },
                "fullDescription": {
                  "text": "报告可能使用 Java 7 Automatic Resource Management（这样不容易出错）的 'try'-'finally' 语句。 可以通过快速修复将 'try'-'finally' 语句转换为 'try'-with-resources 语句。 示例： 'PrintStream printStream = new PrintStream(fileName);\n  try {\n    printStream.print(true);\n  } finally {\n    printStream.close();\n  }' 通过快速修复将原因传递给构造函数： 'try (PrintStream printStream = new PrintStream(fileName)) {\n    printStream.print(true);\n  }' 此检查取决于 Java 功能 'Try-with-resources'，该功能自 Java 7 起可用。",
                  "markdown": "报告可能使用 Java 7 Automatic Resource Management（这样不容易出错）的 `try`-`finally` 语句。\n\n可以通过快速修复将 `try`-`finally` 语句转换为 `try`-with-resources 语句。\n\n**示例：**\n\n\n      PrintStream printStream = new PrintStream(fileName);\n      try {\n        printStream.print(true);\n      } finally {\n        printStream.close();\n      }\n\n通过快速修复将原因传递给构造函数：\n\n\n      try (PrintStream printStream = new PrintStream(fileName)) {\n        printStream.print(true);\n      }\n\n此检查取决于 Java 功能 'Try-with-resources'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TryFinallyCanBeTryWithResources",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizationOnStaticField",
                "shortDescription": {
                  "text": "在 'static' 字段上同步"
                },
                "fullDescription": {
                  "text": "报告 'static' 字段的同步。 虽然并非完全不正确，但 'static' 字段上的同步可能会因争用而导致性能不佳。",
                  "markdown": "报告 `static` 字段的同步。 虽然并非完全不正确，但 `static` 字段上的同步可能会因争用而导致性能不佳。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizationOnStaticField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementWithConfusingDeclaration",
                "shortDescription": {
                  "text": "在不同 'switch' 分支中使用并声明的局部变量"
                },
                "fullDescription": {
                  "text": "报告在 'switch' 语句的一个分支中声明并在另一个分支中使用的局部变量。 此类声明可能格外令人困惑。 示例： 'switch(i) {\n      case 2:\n          int x = 0;\n          break;\n      case 3:\n          x = 3;\n          System.out.println(x);\n          break;\n    }'",
                  "markdown": "报告在 `switch` 语句的一个分支中声明并在另一个分支中使用的局部变量。 此类声明可能格外令人困惑。\n\n示例：\n\n\n        switch(i) {\n          case 2:\n              int x = 0;\n              break;\n          case 3:\n              x = 3;\n              System.out.println(x);\n              break;\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableUsedAndDeclaredInDifferentSwitchBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SamePackageImport",
                "shortDescription": {
                  "text": "相同软件包中的不必要 import"
                },
                "fullDescription": {
                  "text": "报告引用的软件包与包含文件相同的 'import' 语句。 相同软件包的文件始终隐式导入，因此，此类 'import' 语句冗余，而且令人困惑。 由于 IntelliJ IDEA 可以通过优化导入命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。",
                  "markdown": "报告引用的软件包与包含文件相同的 `import` 语句。\n\n\n相同软件包的文件始终隐式导入，因此，此类 `import` 语句冗余，而且令人困惑。\n\n\n由于 IntelliJ IDEA 可以通过**优化导入**命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SamePackageImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadLocalSetWithNull",
                "shortDescription": {
                  "text": "以 null 作为实参的 'ThreadLocal.set()'"
                },
                "fullDescription": {
                  "text": "报告以 null 作为实参的 'java.lang.ThreadLocal.set()'。 此调用不会释放资源，并且可能导致内存泄漏。 这可能是因为： 首先，'ThreadLocal.set(null)' 会查找与当前线程相关联的映射。 如果没有此类映射，则会创建该映射 它会设置键和值：'map.set(this, value)'，其中 'this' 是指 'ThreadLocal' 的实例 应使用 'java.lang.ThreadLocal.remove()' 来释放资源。 示例： 'ThreadLocal<Integer> threadLocal = new ThreadLocal<>();\n  threadLocal.set(null);' 在应用快速修复后： 'threadLocal.remove();' 2023.2 最新变化",
                  "markdown": "报告以 null 作为实参的 `java.lang.ThreadLocal.set()`。\n\n此调用不会释放资源，并且可能导致内存泄漏。\n这可能是因为：\n\n* 首先，`ThreadLocal.set(null)` 会查找与当前线程相关联的映射。 如果没有此类映射，则会创建该映射\n* 它会设置键和值：`map.set(this, value)`，其中 `this` 是指 `ThreadLocal` 的实例\n\n应使用 `java.lang.ThreadLocal.remove()` 来释放资源。\n\n示例：\n\n\n      ThreadLocal<Integer> threadLocal = new ThreadLocal<>();\n      threadLocal.set(null);\n\n在应用快速修复后：\n\n\n      threadLocal.remove();\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ThreadLocalSetWithNull",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldMayBeFinal",
                "shortDescription": {
                  "text": "字段可能为 'final'"
                },
                "fullDescription": {
                  "text": "报告可以安全地设为 'final' 的字段。 所有 'final' 字段都应具有一个不会更改的值，从而使代码更易于推理。 为避免分析开销过大，此检查仅报告字段是否具有 'private' 修饰符或者是否在局部类或匿名类中定义。 如果满足以下条件，字段可以为 'final'： 字段为 'static'，并在其声明或 'static' 初始值设定项中进行了一次初始化。 字段为非 'static'，并在其声明、实例初始值设定项或每个构造函数中进行了一次初始化 并且字段未在其他任何地方进行修改。 示例： 'public class Person {\n    private String name; // 可以为 final\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n  }' 在应用快速修复后： 'public class Person {\n    private final String name;\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n  }' 使用“注解”按钮修改假定隐式字段写入的注解列表。",
                  "markdown": "报告可以安全地设为 `final` 的字段。 所有 `final` 字段都应具有一个不会更改的值，从而使代码更易于推理。\n\n为避免分析开销过大，此检查仅报告字段是否具有 `private` 修饰符或者是否在局部类或匿名类中定义。\n如果满足以下条件，字段可以为 `final`：\n\n* 字段为 `static`，并在其声明或 `static` 初始值设定项中进行了一次初始化。\n* 字段为非 `static`，并在其声明、实例初始值设定项或每个构造函数中进行了一次初始化\n\n并且字段未在其他任何地方进行修改。\n\n**示例：**\n\n\n      public class Person {\n        private String name; // 可以为 final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\n使用\"注解\"按钮修改假定隐式字段写入的注解列表。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldMayBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingJavadoc",
                "shortDescription": {
                  "text": "缺少 Javadoc"
                },
                "fullDescription": {
                  "text": "报告缺少 Javadoc 注释和标记。 示例： '/**\n   * 报告缺少 \"@param\"（如果配置）。\n   */\n  public void sample(int param){\n  }' 该快速修复会添加缺少的标记或缺少的 Javadoc 注释： '/**\n   * 报告缺少 \"@param\"（如果配置）。\n   * @param param\n   */\n  public void sample(int param){\n  }' 可以将检查配置为忽略弃用的元素或简单的访问器方法，如 'getField()' 或 'setField()'。 您还可以使用以下选项为方法、字段、类、软件包、模块等特定代码元素配置必需标记和最低要求的可见性。",
                  "markdown": "报告缺少 Javadoc 注释和标记。\n\n示例：\n\n\n      /**\n       * 报告缺少 \"@param\"（如果配置）。\n       */\n      public void sample(int param){\n      }\n\n该快速修复会添加缺少的标记或缺少的 Javadoc 注释：\n\n\n      /**\n       * 报告缺少 \"@param\"（如果配置）。\n       * @param param\n       */\n      public void sample(int param){\n      }\n\n\n可以将检查配置为忽略弃用的元素或简单的访问器方法，如 `getField()` 或 `setField()`。\n您还可以使用以下选项为方法、字段、类、软件包、模块等特定代码元素配置必需标记和最低要求的可见性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingJavadoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousArrayMethodCall",
                "shortDescription": {
                  "text": "可疑的 'Arrays' 方法调用"
                },
                "fullDescription": {
                  "text": "报告对 'Arrays.fill()' 等实参类型不匹配的非泛型数组操作方法的调用。 此类调用不会执行任何有用的工作，很可能是错误的。 示例： 'int foo(String[] strings) {\n    return Arrays.binarySearch(strings, 1);\n  }' 2017.2 最新变化",
                  "markdown": "报告对 `Arrays.fill()` 等实参类型不匹配的非泛型数组操作方法的调用。 此类调用不会执行任何有用的工作，很可能是错误的。\n\n**示例：**\n\n\n      int foo(String[] strings) {\n        return Arrays.binarySearch(strings, 1);\n      }\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousArrayMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassHasNoToStringMethod",
                "shortDescription": {
                  "text": "类不会重写 'toString()' 方法"
                },
                "fullDescription": {
                  "text": "报告没有 'toString()' 方法的类。",
                  "markdown": "报告没有 `toString()` 方法的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassHasNoToStringMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/toString() 问题",
                      "index": 122,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AwaitWithoutCorrespondingSignal",
                "shortDescription": {
                  "text": "没有相应 'signal()' 的 'await()'"
                },
                "fullDescription": {
                  "text": "报告对无法为之找到相应 'Condition.signal()' 或 'Condition.signalAll()' 调用的 'Condition.await()' 的调用。 在没有相应 'Condition.signal()' 的线程中调用 'Condition.await()' 可能导致该线程被禁用，直到它被中断或发生“可疑唤醒”为止。 此检查仅报告以当前类的目标字段为目标的调用。 示例： 'class Queue {\n    private final Condition isEmpty = ...;\n\n    void add(Object elem) {\n      // ...\n      // isEmpty.signal();\n      // ...\n    }\n\n    void remove(Object elem) throws InterruptedException {\n      // ...\n      isEmpty.await(); // 'await()' 不包含相应的 'signal()'/'signalAll()' 调用\n      // ...\n    }\n  }'",
                  "markdown": "报告对无法为之找到相应 `Condition.signal()` 或 `Condition.signalAll()` 调用的 `Condition.await()` 的调用。\n\n\n在没有相应 `Condition.signal()` 的线程中调用 `Condition.await()` 可能导致该线程被禁用，直到它被中断或发生\"可疑唤醒\"为止。\n\n此检查仅报告以当前类的目标字段为目标的调用。\n\n**示例：**\n\n\n      class Queue {\n        private final Condition isEmpty = ...;\n\n        void add(Object elem) {\n          // ...\n          // isEmpty.signal();\n          // ...\n        }\n\n        void remove(Object elem) throws InterruptedException {\n          // ...\n          isEmpty.await(); // 'await()' 不包含相应的 'signal()'/'signalAll()' 调用\n          // ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AwaitWithoutCorrespondingSignal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLocalVariable",
                "shortDescription": {
                  "text": "冗余局部变量"
                },
                "fullDescription": {
                  "text": "报告不必要的、不会增加方法的可理解性的局部变量，包括： 立即返回的局部变量。 立刻赋值给另一个变量并且不再使用的局部变量。 始终与另一个局部变量或形参具有相同值的局部变量。 示例： 'boolean yes() {\n    boolean b = true;\n    return b;\n  }' 在应用快速修复后： 'boolean yes() {\n    return true;\n  }' 配置检查： 使用忽略立即返回或抛出的变量选项可以忽略立即返回或抛出的变量。 为清晰起见和易于调试，某些编码样式建议使用此类变量。 使用忽略具有注解的变量选项可以忽略注解的变量。",
                  "markdown": "报告不必要的、不会增加方法的可理解性的局部变量，包括：\n\n* 立即返回的局部变量。\n* 立刻赋值给另一个变量并且不再使用的局部变量。\n* 始终与另一个局部变量或形参具有相同值的局部变量。\n\n**示例：**\n\n\n      boolean yes() {\n        boolean b = true;\n        return b;\n      }\n\n在应用快速修复后：\n\n\n      boolean yes() {\n        return true;\n      }\n      \n配置检查：\n\n* 使用**忽略立即返回或抛出的变量**选项可以忽略立即返回或抛出的变量。 为清晰起见和易于调试，某些编码样式建议使用此类变量。\n* 使用**忽略具有注解的变量**选项可以忽略注解的变量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLocalVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9RedundantRequiresStatement",
                "shortDescription": {
                  "text": "module-info 中的冗余 'requires' 指令"
                },
                "fullDescription": {
                  "text": "报告 Java Platform Module System 'module-info.java' 文件中的冗余 'requires' 指令。 当模块 'A' 需要模块 'B'，但模块 'A' 中的代码不从 'B' 导入任何软件包或类时，则 'requires' 指令冗余。 此外，所有模块都具有对 'java.base' 模块的隐式声明依赖，因此 'requires java.base;' 指令始终冗余。 该快速修复会删除冗余的 'requires' 指令。 如果删除的依赖项重新导出了实际使用的模块，则修复会为这些模块添加 'requires' 指令。 仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。 2017.1 最新变化",
                  "markdown": "报告 Java Platform Module System `module-info.java` 文件中的冗余 `requires` 指令。 当模块 `A` 需要模块 `B`，但模块 `A` 中的代码不从 `B` 导入任何软件包或类时，则 `requires` 指令冗余。 此外，所有模块都具有对 `java.base` 模块的隐式声明依赖，因此 `requires java.base;` 指令始终冗余。\n\n\n该快速修复会删除冗余的 `requires` 指令。\n如果删除的依赖项重新导出了实际使用的模块，则修复会为这些模块添加 `requires` 指令。\n\n仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9RedundantRequiresStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldAccessNotGuarded",
                "shortDescription": {
                  "text": "不受保护的字段访问或方法调用"
                },
                "fullDescription": {
                  "text": "报告对声明为 '@GuardedBy' 且不受适当同步结构保护的字段的访问。 示例： '@GuardedBy(\"this\")\n    void x() {\n        notify();\n    }\n    void y() {\n        x(); // 不受保护的方法调用\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告对声明为 `@GuardedBy` 且不受适当同步结构保护的字段的访问。\n\n示例：\n\n\n        @GuardedBy(\"this\")\n        void x() {\n            notify();\n        }\n        void y() {\n            x(); // 不受保护的方法调用\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldAccessNotGuarded",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BusyWait",
                "shortDescription": {
                  "text": "忙等待"
                },
                "fullDescription": {
                  "text": "报告在循环内发生的对 'java.lang.Thread.sleep()' 的调用。 此类调用表示“忙等待”。 忙等待通常效率低下，并且可能导致意外死锁，因为忙等待线程不会释放锁定的资源。 示例： 'class X {\n     volatile int x;\n     public void waitX() throws Exception {\n      while (x > 0) {\n        Thread.sleep(10);// 警告：在循环中调用 'Thread.sleep()'，可能处于忙等待\n      }\n    }\n  }'",
                  "markdown": "报告在循环内发生的对 `java.lang.Thread.sleep()` 的调用。\n\n此类调用表示\"忙等待\"。 忙等待通常效率低下，并且可能导致意外死锁，因为忙等待线程不会释放锁定的资源。\n\n**示例：**\n\n\n      class X {\n         volatile int x;\n         public void waitX() throws Exception {\n          while (x > 0) {\n            Thread.sleep(10);// 警告：在循环中调用 'Thread.sleep()'，可能处于忙等待\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BusyWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForLoopWithMissingComponent",
                "shortDescription": {
                  "text": "缺少组件的 'for' 循环"
                },
                "fullDescription": {
                  "text": "报告缺少初始化、条件或 update 子句的 'for' 循环。 某些编码样式禁止此类循环。 示例： 'for (int i = 0;;i++) {\n    //主体\n  }' 使用忽略集合迭代选项可以忽略使用迭代器的循环。 这是在 'for' 循环没有 update 子句的集合中迭代的标准方式。",
                  "markdown": "报告缺少初始化、条件或 update 子句的 `for` 循环。 某些编码样式禁止此类循环。\n\n示例：\n\n\n      for (int i = 0;;i++) {\n        //主体\n      }\n\n\n使用**忽略集合迭代** 选项可以忽略使用迭代器的循环。\n这是在 `for` 循环没有 update 子句的集合中迭代的标准方式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopWithMissingComponent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicStaticArrayField",
                "shortDescription": {
                  "text": "'public static' 数组字段"
                },
                "fullDescription": {
                  "text": "报告 'public' 'static' 数组字段。 此类字段通常用于存储常量值数组。 尽管如此，它们仍然存在安全隐患，因为它们的内容可能会被修改，即使该字段被声明为 'final'。 示例： 'public static String[] allowedPasswords = {\"foo\", \"bar\"};'",
                  "markdown": "报告 `public` `static` 数组字段。\n\n\n此类字段通常用于存储常量值数组。 尽管如此，它们仍然存在安全隐患，因为它们的内容可能会被修改，即使该字段被声明为 `final`。\n\n**示例：**\n\n\n      public static String[] allowedPasswords = {\"foo\", \"bar\"};\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicStaticArrayField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicNumber",
                "shortDescription": {
                  "text": "幻数"
                },
                "fullDescription": {
                  "text": "报告“幻数”：未通过常量声明来命名的数值文字。 使用幻数会导致代码不清晰，并且如果幻数在一个位置更改但在另一个位置保持不变，则会导致错误。 此检查不会报告数字 0、1、2、3、4、5、6、7、8、9、10、100、1000、0L、1L、2L、0.0、1.0、0.0F 和 1.0F。 示例： 'void checkFileSize(long bytes) {\n    if (bytes > 1_048_576) {\n      throw new IllegalArgumentException(\"too big\");\n    }\n  }' 快速修复引入了一个新常量： 'static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;\n\n  void checkFileSize(long bytes) {\n    if (bytes > MAX_SUPPORTED_FILE_SIZE) {\n      throw new IllegalArgumentException(\"too big\");\n    }\n  }' 配置检查： 使用忽略 'hashCode()' 方法中的常量选项可在 'hashCode()' 方法中禁用此检查。 使用在注解中忽略选项可以忽略注解中的幻数。 在构造 'Collection'、'Map'、'StringBuilder' 或 'StringBuffer' 对象时，使用忽略 StringBuilders 和 Collections 的初始容量选项可以忽略用作初始容量的幻数。",
                  "markdown": "报告\"幻数\"：未通过常量声明来命名的数值文字。\n\n使用幻数会导致代码不清晰，并且如果幻数在一个位置更改但在另一个位置保持不变，则会导致错误。 此检查不会报告数字 0、1、2、3、4、5、6、7、8、9、10、100、1000、0L、1L、2L、0.0、1.0、0.0F 和 1.0F。\n\n示例：\n\n\n      void checkFileSize(long bytes) {\n        if (bytes > 1_048_576) {\n          throw new IllegalArgumentException(\"too big\");\n        }\n      }\n\n快速修复引入了一个新常量：\n\n\n      static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;\n\n      void checkFileSize(long bytes) {\n        if (bytes > MAX_SUPPORTED_FILE_SIZE) {\n          throw new IllegalArgumentException(\"too big\");\n        }\n      }\n\n配置检查：\n\n* 使用**忽略 'hashCode()' 方法中的常量** 选项可在 `hashCode()` 方法中禁用此检查。\n* 使用**在注解中忽略**选项可以忽略注解中的幻数。\n* 在构造 `Collection`、`Map`、`StringBuilder` 或 `StringBuffer` 对象时，使用**忽略 StringBuilders 和 Collections 的初始容量**选项可以忽略用作初始容量的幻数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicNumber",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverwrittenKey",
                "shortDescription": {
                  "text": "被覆盖的 Map、Set 或数组元素"
                },
                "fullDescription": {
                  "text": "报告覆盖 'Map' 键、'Set' 元素或 'add'/'put' 调用序列中的数组元素或使用类似于 'Set.of' 的 Java 9 工厂方法（将导致运行时异常）的代码。 这通常是复制粘贴错误所致。 示例： 'map.put(\"A\", 1);\n  map.put(\"B\", 2);\n  map.put(\"C\", 3);\n  map.put(\"D\", 4);\n  map.put(\"A\", 5); // 键 \"A\" 重复，覆盖以前写入的条目' 2017.3 最新变化",
                  "markdown": "报告覆盖 `Map` 键、`Set` 元素或 `add`/`put` 调用序列中的数组元素或使用类似于 `Set.of` 的 Java 9 工厂方法（将导致运行时异常）的代码。\n\n这通常是复制粘贴错误所致。\n\n**示例：**\n\n\n      map.put(\"A\", 1);\n      map.put(\"B\", 2);\n      map.put(\"C\", 3);\n      map.put(\"D\", 4);\n      map.put(\"A\", 5); // 键 \"A\" 重复，覆盖以前写入的条目\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverwrittenKey",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousClassMethodCount",
                "shortDescription": {
                  "text": "具有太多方法的匿名类"
                },
                "fullDescription": {
                  "text": "报告方法数超过指定最大值的匿名内部类。 具有大量方法的匿名类可能难以理解，应该提升为命名内部类。 使用方法计数限制字段可指定匿名内部类中允许的最大方法数。",
                  "markdown": "报告方法数超过指定最大值的匿名内部类。\n\n具有大量方法的匿名类可能难以理解，应该提升为命名内部类。\n\n使用**方法计数限制**字段可指定匿名内部类中允许的最大方法数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousInnerClassWithTooManyMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumSwitchStatementWhichMissesCases",
                "shortDescription": {
                  "text": "缺少 case 的枚举 'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告为不详尽的枚举类型执行的 'switch' 语句。 示例： 'enum AlphaBetaGamma {\n    A, B, C;\n\n    void x(AlphaBetaGamma e) {\n      switch (e) {\n\n      }\n    }\n  }' 在应用快速修复后： 'enum AlphaBetaGamma {\n    A, B, C;\n\n    void x(AlphaBetaGamma e) {\n      switch (e) {\n        case A -> {}\n        case B -> {}\n        case C -> {}\n      }\n    }\n  }' 使用 忽略具有默认分支的 switch 语句 选项忽略具有 'default' 分支的 'switch' 语句。 此检查取决于 Java 功能 '枚举'，该功能自 Java 5 起可用。",
                  "markdown": "报告为不详尽的枚举类型执行的 `switch` 语句。\n\n**示例：**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\n在应用快速修复后：\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\n使用 **忽略具有默认分支的 switch 语句** 选项忽略具有 `default` 分支的 `switch` 语句。\n\n\n此检查取决于 Java 功能 '枚举'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EnumSwitchStatementWhichMissesCases",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodWithMultipleLoops",
                "shortDescription": {
                  "text": "具有多个循环的方法"
                },
                "fullDescription": {
                  "text": "报告包含多个循环语句的方法。 示例： 以下方法将被报告，因为它包含两个循环： 'void methodWithTwoLoops(int n1, int n2) {\n    for (int i = 0; i < n1; i++) {\n      System.out.println(i);\n    }\n\n    int j = 0;\n    while (j < n2) {\n      System.out.println(j);\n      j++;\n    }\n  }' 以下方法也会被报告，因为它包含嵌套循环： 'void methodWithNestedLoop(int n1, int n2) {\n    for (int i = 0; i < n1; i++) {\n      for (int j = 0; j < n2; j++) {\n        System.out.println(i + j);\n      }\n    }\n  }'",
                  "markdown": "报告包含多个循环语句的方法。\n\n**示例：**\n\n以下方法将被报告，因为它包含两个循环：\n\n\n      void methodWithTwoLoops(int n1, int n2) {\n        for (int i = 0; i < n1; i++) {\n          System.out.println(i);\n        }\n\n        int j = 0;\n        while (j < n2) {\n          System.out.println(j);\n          j++;\n        }\n      }\n\n以下方法也会被报告，因为它包含嵌套循环：\n\n\n      void methodWithNestedLoop(int n1, int n2) {\n        for (int i = 0; i < n1; i++) {\n          for (int j = 0; j < n2; j++) {\n            System.out.println(i + j);\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithMultipleLoops",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousIntegerDivAssignment",
                "shortDescription": {
                  "text": "可疑的整数除法赋值"
                },
                "fullDescription": {
                  "text": "报告其右侧是不应截断为整数的除法的赋值。 虽然偶尔是有意为之，但此结构通常表明有错误。 示例： 'int x = 18;\n  x *= 3/2; // 不会因为整数除法的结果而改变 x' 此代码应替换为： 'int x = 18;\n  x *= 3.0/2;' 在检查选项中，可以禁用对可疑但可能正确的除法的警告，例如不能静态计算被除数时。 'void calc(int d) {\n     int x = 18;\n     x *= d/2;\n  }' 2019.2 最新变化",
                  "markdown": "报告其右侧是不应截断为整数的除法的赋值。\n\n虽然偶尔是有意为之，但此结构通常表明有错误。\n\n**示例：**\n\n\n      int x = 18;\n      x *= 3/2; // 不会因为整数除法的结果而改变 x\n\n\n此代码应替换为：\n\n\n      int x = 18;\n      x *= 3.0/2;\n\n\n在检查选项中，可以禁用对可疑但可能正确的除法的警告，例如不能静态计算被除数时。\n\n\n      void calc(int d) {\n         int x = 18;\n         x *= d/2;\n      }\n\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousIntegerDivAssignment",
                    "cweIds": [
                      682
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegativelyNamedBooleanVariable",
                "shortDescription": {
                  "text": "否定命名的布尔变量"
                },
                "fullDescription": {
                  "text": "报告否定命名的变量，例如：'disabled'、'hidden' 或 'isNotChanged'。 反转 'boolean' 值并从名称中移除否定通常有助于使代码更容易理解。 示例： 'boolean disabled = false;'",
                  "markdown": "报告否定命名的变量，例如：`disabled`、`hidden` 或 `isNotChanged`。\n\n反转 `boolean` 值并从名称中移除否定通常有助于使代码更容易理解。\n\n示例：\n\n\n        boolean disabled = false;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegativelyNamedBooleanVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SleepWhileHoldingLock",
                "shortDescription": {
                  "text": "同步时调用 'Thread.sleep()'"
                },
                "fullDescription": {
                  "text": "报告对发生在 'synchronized' 块或方法中的'java.lang.Thread.sleep()' 方法的调用。 'synchronized' 块中的 'sleep()' 可能导致性能下降，可扩展性变差，甚至可能导致死锁。 不妨改用 'wait()'，因为它将释放持有的锁定。 示例： 'synchronized (lock) {\n    Thread.sleep(100);\n  }'",
                  "markdown": "报告对发生在 `synchronized` 块或方法中的`java.lang.Thread.sleep()` 方法的调用。\n\n\n`synchronized` 块中的 `sleep()` 可能导致性能下降，可扩展性变差，甚至可能导致死锁。 不妨改用 `wait()`，因为它将释放持有的锁定。\n\n**示例：**\n\n\n      synchronized (lock) {\n        Thread.sleep(100);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SleepWhileHoldingLock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedClassUsageInspection",
                "shortDescription": {
                  "text": "XML 中的弃用 API 用法"
                },
                "fullDescription": {
                  "text": "报告 XML 文件中已弃用的类和方法的用法。",
                  "markdown": "报告 XML 文件中已弃用的类和方法的用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedClassUsageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalOfNullableMisuse",
                "shortDescription": {
                  "text": "使用具有 null 或非 null 实参的 Optional.ofNullable"
                },
                "fullDescription": {
                  "text": "报告传递始终为 null 或始终为非 null 实参的 'Optional.ofNullable()' 用法。 在这种情况下使用 'Optional.ofNullable()' 没有意义：'Optional.empty()' 或 'Optional.of()' 应分别用于显式声明创建始终为空或始终非空的可选项的意图。 也可能是 'Optional.ofNullable()' 实参中存在错误，因此应对其进行检查。 示例： 'Optional<String> empty = Optional.ofNullable(null); // 应为 Optional.empty();\nOptional<String> present = Optional.ofNullable(\"value\"); // 应为 Optional.of(\"value\");' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告传递始终为 null 或始终为非 null 实参的 `Optional.ofNullable()` 用法。 在这种情况下使用 `Optional.ofNullable()` 没有意义：`Optional.empty()` 或 `Optional.of()` 应分别用于显式声明创建始终为空或始终非空的可选项的意图。 也可能是 `Optional.ofNullable()` 实参中存在错误，因此应对其进行检查。\n\n\n示例：\n\n\n    Optional<String> empty = Optional.ofNullable(null); // 应为 Optional.empty();\n    Optional<String> present = Optional.ofNullable(\"value\"); // 应为 Optional.of(\"value\"); \n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalOfNullableMisuse",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastToIncompatibleInterface",
                "shortDescription": {
                  "text": "转换为不兼容的类型"
                },
                "fullDescription": {
                  "text": "报告类型转换表达式，其中转换后的表达式具有既不扩展/实现转换类/接口类型的类/接口类型，也没有进行上述操作的子类。 此类结构很可能是错误的，并将在运行时抛出 'java.lang.ClassCastException'。 示例： 'interface A {}\n  interface Z {}\n  static class C {}\n\n  void x(C c) {\n    if (c instanceof Z) {\n      A a = ((A)c); // 转换为不兼容的接口 'A'\n    }\n  }'",
                  "markdown": "报告类型转换表达式，其中转换后的表达式具有既不扩展/实现转换类/接口类型的类/接口类型，也没有进行上述操作的子类。\n\n\n此类结构很可能是错误的，并将在运行时抛出 `java.lang.ClassCastException`。\n\n**示例：**\n\n\n      interface A {}\n      interface Z {}\n      static class C {}\n\n      void x(C c) {\n        if (c instanceof Z) {\n          A a = ((A)c); // 转换为不兼容的接口 'A'\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastToIncompatibleInterface",
                    "cweIds": [
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodReturnAlwaysConstant",
                "shortDescription": {
                  "text": "方法返回类特定的常量"
                },
                "fullDescription": {
                  "text": "报告仅返回常量（继承者不同，常量也可能不同）的方法。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告仅返回常量（继承者不同，常量也可能不同）的方法。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodReturnAlwaysConstant",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateBranchesInSwitch",
                "shortDescription": {
                  "text": "'switch' 中存在重复分支"
                },
                "fullDescription": {
                  "text": "报告在不同分支中包含相同代码的 'switch' 语句或表达式，并建议合并重复的分支。 示例： 'switch (n) {\n    case 1:\n      System.out.println(n);\n      break;\n    case 2:\n      System.out.println(n);\n      break;\n    default:\n      System.out.println(\"default\");\n  }' 在应用快速修复后： 'switch (n) {\n    case 1:\n    case 2:\n      System.out.println(n);\n      break;\n    default:\n      System.out.println(\"default\");\n  }' 2019.1 最新变化",
                  "markdown": "报告在不同分支中包含相同代码的 `switch` 语句或表达式，并建议合并重复的分支。\n\n示例：\n\n\n      switch (n) {\n        case 1:\n          System.out.println(n);\n          break;\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\n在应用快速修复后：\n\n\n      switch (n) {\n        case 1:\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DuplicateBranchesInSwitch",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleElementAnnotation",
                "shortDescription": {
                  "text": "非规范化注解"
                },
                "fullDescription": {
                  "text": "报告速记形式的注解并建议以具有特性名称的正常形式重写它们。 示例： '@SuppressWarnings(\"foo\")' 在应用快速修复后： '@SuppressWarnings(value = \"foo\")'",
                  "markdown": "报告速记形式的注解并建议以具有特性名称的正常形式重写它们。\n\n示例：\n\n\n      @SuppressWarnings(\"foo\")\n\n在应用快速修复后：\n\n\n      @SuppressWarnings(value = \"foo\")\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SingleElementAnnotation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableConditionalExpression",
                "shortDescription": {
                  "text": "可简化的条件表达式"
                },
                "fullDescription": {
                  "text": "报告并建议简化条件表达式。 示例： 'condition ? true : foo → condition || foo' 'condition ? false : foo → !condition && foo' 'condition ? foo : !foo → condition == foo' 'condition ? true : false → condition' 'a == b ? b : a → a' 'result != null ? result : null → result'",
                  "markdown": "报告并建议简化条件表达式。\n\n示例：\n\n    condition ? true : foo → condition || foo\n\n    condition ? false : foo → !condition && foo\n\n    condition ? foo : !foo → condition == foo\n\n    condition ? true : false → condition\n\n    a == b ? b : a → a\n\n    result != null ? result : null → result\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ManualMinMaxCalculation",
                "shortDescription": {
                  "text": "手动最小值/最大值计算"
                },
                "fullDescription": {
                  "text": "报告可以使用 'Math.max()' 或 'Math.min()' 调用而不是手动计算两个数字的最小值或最大值的情况。 示例： 'public int min(int a, int b) {\n    return b < a ? b : a;\n  }' 在应用快速修复后： 'public int min(int a, int b) {\n    return Math.min(a, b);\n  }' 使用禁用 float 和 double 选项，可对 'double' 和 'float' 类型禁用此检查。 由于该快速修复在处理 'NaN' 时可能会略微更改 'float'/ 'double' 类型的语义，因此这很有用。 然而，如果不考虑 'NaN'，此快速修复在大多数情况下其实会修正难以捉摸的错误。 2019.2 最新变化",
                  "markdown": "报告可以使用 `Math.max()` 或 `Math.min()` 调用而不是手动计算两个数字的最小值或最大值的情况。\n\n**示例：**\n\n\n      public int min(int a, int b) {\n        return b < a ? b : a;\n      }\n\n在应用快速修复后：\n\n\n      public int min(int a, int b) {\n        return Math.min(a, b);\n      }\n\n\n使用**禁用 float 和 double** 选项，可对 `double` 和 `float` 类型禁用此检查。\n由于该快速修复在处理 `NaN` 时可能会略微更改 `float`/\n`double` 类型的语义，因此这很有用。 然而，如果不考虑 `NaN`，此快速修复在大多数情况下其实会修正难以捉摸的错误。\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ManualMinMaxCalculation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SillyAssignment",
                "shortDescription": {
                  "text": "变量被赋值给自己"
                },
                "fullDescription": {
                  "text": "报告变量对自身的赋值。 示例： 'a = a;' 该快速修复会移除赋值。",
                  "markdown": "报告变量对自身的赋值。\n\n**示例：**\n\n\n      a = a;\n\n该快速修复会移除赋值。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SillyAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BoundedWildcard",
                "shortDescription": {
                  "text": "可以使用有界通配符"
                },
                "fullDescription": {
                  "text": "报告可以使用有界通配符的通用方法形参。 示例： 'void process(Consumer<Number> consumer);' 应替换为： 'void process(Consumer<? super Number> consumer);' 此方法签名更灵活，因为它接受更多类型：不仅是 'Consumer<Number>'，还有 'Consumer<Object>'。 同样，在协变位置输入形参： 'T produce(Producer<T> p);' 应替换为： 'T produce(Producer<? extends T> p);' 引用 Effective Java 第三版中的 Joshua Bloch： 第 31 项：使用有界通配符增加 API 灵活性 在 API 中使用通配符类型虽然麻烦，但会使 API 更加灵活。 如果您编写的库将被广泛使用，则应强制正确使用通配符类型。 记住基本规则：生产者-extends, 使用者-super (PECS)。 还要记住，所有 Comparable 和 Comparator 都是消费者。 使用检查选项可以切换以下各项的报告： 不变类。 一个不变类的示例是 'java.util.List<T>'，因为它既接受值（通过 'List.add(T)' 方法）又生成值（通过 'T List.get()' 方法）。 另一方面，'contravariant' 类只接收值，例如，只有方法 'accept(T)' 的 'java.util.function.Consumer<T>'。 类似地，'covariant' 类只产生值，例如，只有方法 'T get()' 的 'java.util.function.Supplier<T>'。 人们经常在协变/逆变类中使用有界通配符，但避免在不变类中使用通配符，例如 'void process(List<? extends T> l)'。 禁用此选项可以忽略这种不变类并保留它们的严格类型，例如 'void process(List<T> l)'。 可视为不属于公共 API 一部分的 'private' 方法 实例方法",
                  "markdown": "报告可以使用[有界通配符](https://en.wikipedia.org/wiki/Wildcard_(Java))的通用方法形参。\n\n**示例：**\n\n\n      void process(Consumer<Number> consumer);\n\n应替换为：\n\n\n      void process(Consumer<? super Number> consumer);\n\n\n此方法签名更灵活，因为它接受更多类型：不仅是 `Consumer<Number>`，还有 `Consumer<Object>`。\n\n同样，在协变位置输入形参：\n\n\n      T produce(Producer<T> p);\n\n应替换为：\n\n\n      T produce(Producer<? extends T> p);\n\n\n引用 *Effective Java* 第三版中的 [Joshua Bloch](https://en.wikipedia.org/wiki/Joshua_Bloch#Effective_Java)：\n>\n> #### 第 31 项：使用有界通配符增加 API 灵活性\n>\n> 在 API 中使用通配符类型虽然麻烦，但会使 API 更加灵活。 如果您编写的库将被广泛使用，则应强制正确使用通配符类型。 记住基本规则：生产者-extends, 使用者-super (PECS)。 还要记住，所有 Comparable 和 Comparator 都是消费者。\n\n\n使用检查选项可以切换以下各项的报告：\n\n*\n  不变类。 一个不变类的示例是 `java.util.List<T>`，因为它既接受值（通过 `List.add(T)` 方法）又生成值（通过 `T List.get()` 方法）。\n\n\n  另一方面，`contravariant` 类只接收值，例如，只有方法 `accept(T)` 的 `java.util.function.Consumer<T>`。 类似地，`covariant` 类只产生值，例如，只有方法 `T get()` 的 `java.util.function.Supplier<T>`。\n\n\n  人们经常在协变/逆变类中使用有界通配符，但避免在不变类中使用通配符，例如 `void process(List<? extends T> l)`。\n  禁用此选项可以忽略这种不变类并保留它们的严格类型，例如 `void process(List<T> l)`。\n*\n  可视为不属于公共 API 一部分的 `private` 方法\n\n*\n  实例方法"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BoundedWildcard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedMethodAccess",
                "shortDescription": {
                  "text": "未使用 'this' 限定的实例方法调用"
                },
                "fullDescription": {
                  "text": "报告对同一实例上未使用 'this' 限定的非 'static' 方法的调用。 示例： 'class Foo {\n    void bar() {}\n\n    void foo() {\n      bar();\n    }\n  }' 在应用快速修复后： 'class Foo {\n    void bar() {}\n\n    void foo() {\n      this.bar();\n    }\n  }'",
                  "markdown": "报告对同一实例上未使用 `this` 限定的非 `static` 方法的调用。\n\n**示例：**\n\n\n      class Foo {\n        void bar() {}\n\n        void foo() {\n          bar();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        void bar() {}\n\n        void foo() {\n          this.bar();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedMethodAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofIncompatibleInterface",
                "shortDescription": {
                  "text": "具有不兼容类型的 'instanceof'"
                },
                "fullDescription": {
                  "text": "报告 'instanceof' 表达式，其中检查的表达式的类/接口类型既不扩展/实现 'instanceof' 表达式右侧的类/接口类型，也没有进行上述操作的子类。 尽管它可以用于库代码，但此类构造很可能是错误的，因为项目中声明的任何类的任何实例都无法通过此 'instanceof' 测试。 示例： 'class Foo { }\n\n  interface Bar { }\n  \n  class Main {\n      void test(Foo f, Bar b) {\n          if (f instanceof Bar) { // 问题\n              System.out.println(\"fail\");\n          }\n          if (b instanceof Foo) { // 问题\n              System.out.println(\"fail\");\n          }\n      }\n  }'",
                  "markdown": "报告 `instanceof` 表达式，其中检查的表达式的类/接口类型既不扩展/实现 `instanceof` 表达式右侧的类/接口类型，也没有进行上述操作的子类。\n\n\n尽管它可以用于库代码，但此类构造很可能是错误的，因为项目中声明的任何类的任何实例都无法通过此 `instanceof` 测试。\n\n**示例：**\n\n\n      class Foo { }\n\n      interface Bar { }\n      \n      class Main {\n          void test(Foo f, Bar b) {\n              if (f instanceof Bar) { // 问题\n                  System.out.println(\"fail\");\n              }\n              if (b instanceof Foo) { // 问题\n                  System.out.println(\"fail\");\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceofIncompatibleInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionalExpressionCanBeFolded",
                "shortDescription": {
                  "text": "函数表达式可以折叠"
                },
                "fullDescription": {
                  "text": "报告指向具有自己的函数接口类型的方法的方法引用或 lambda 表达式，因此您可以通过替换为它们的限定符来移除不必要的对象分配。 示例： 'SwingUtilities.invokeLater(r::run);\n  SwingUtilities.invokeAndWait(() -> r.run());' 在应用快速修复后： 'SwingUtilities.invokeLater(r);\n  SwingUtilities.invokeAndWait(r);' 仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。",
                  "markdown": "报告指向具有自己的函数接口类型的方法的方法引用或 lambda 表达式，因此您可以通过替换为它们的限定符来移除不必要的对象分配。\n\n示例：\n\n\n      SwingUtilities.invokeLater(r::run);\n      SwingUtilities.invokeAndWait(() -> r.run());\n\n在应用快速修复后：\n\n\n      SwingUtilities.invokeLater(r);\n      SwingUtilities.invokeAndWait(r);\n\n仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FunctionalExpressionCanBeFolded",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceVariableInitialization",
                "shortDescription": {
                  "text": "实例字段可能无法初始化"
                },
                "fullDescription": {
                  "text": "报告在对象初始化时可能未被初始化的实例变量。 示例： 'class Foo {\n    public int bar;\n\n    static { }\n  }' 请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。 使用忽略基元字段选项可以忽略未初始化的基元字段。",
                  "markdown": "报告在对象初始化时可能未被初始化的实例变量。\n\n**示例：**\n\n\n      class Foo {\n        public int bar;\n\n        static { }\n      }\n\n请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。\n\n使用**忽略基元字段**选项可以忽略未初始化的基元字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceVariableMayNotBeInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CustomClassloader",
                "shortDescription": {
                  "text": "声明了自定义的 'ClassLoader'"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.ClassLoader' 的用户定义子类。 虽然不一定代表安全漏洞，但应彻底检查这种类是否存在可能的安全问题。",
                  "markdown": "报告 `java.lang.ClassLoader` 的用户定义子类。\n\n\n虽然不一定代表安全漏洞，但应彻底检查这种类是否存在可能的安全问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CustomClassloader",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementWithTooManyBranches",
                "shortDescription": {
                  "text": "'if' 语句的分支过多"
                },
                "fullDescription": {
                  "text": "报告分支太多的 'if' 语句。 此类语句可能令人困惑，并且通常表明设计抽象级别不足。 使用最大分支数字段指定 'if' 语句可以具备的最大分支数。",
                  "markdown": "报告分支太多的 `if` 语句。\n\n此类语句可能令人困惑，并且通常表明设计抽象级别不足。\n\n\n使用**最大分支数** 字段指定 `if` 语句可以具备的最大分支数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementWithTooManyBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThisEscapedInConstructor",
                "shortDescription": {
                  "text": "对象构造中转义的 'this' 引用"
                },
                "fullDescription": {
                  "text": "报告对象初始化期间可能的 'this' 转义。 当 'this' 用作构造函数或初始值设定项中的方法实参或赋值对象时，就会发生转义。 此类转义可能会导致难以捉摸的错误，因为现在该对象在不保证得到初始化的上下文中可用。 示例： 'class Foo {\n    {\n      System.out.println(this);\n    }\n  }'",
                  "markdown": "报告对象初始化期间可能的 `this` 转义。 当 `this` 用作构造函数或初始值设定项中的方法实参或赋值对象时，就会发生转义。 此类转义可能会导致难以捉摸的错误，因为现在该对象在不保证得到初始化的上下文中可用。\n\n**示例：**\n\n\n      class Foo {\n        {\n          System.out.println(this);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThisEscapedInObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarySuperConstructor",
                "shortDescription": {
                  "text": "对 'super()' 的调用不必要"
                },
                "fullDescription": {
                  "text": "报告在对象构造期间对无实参超类构造函数的调用。 此类调用不必要，可以移除。 示例： 'class Foo {\n    Foo() {\n      super();\n    }\n  }' 在应用快速修复后： 'class Foo {\n    Foo() {\n    }\n  }'",
                  "markdown": "报告在对象构造期间对无实参超类构造函数的调用。\n\n此类调用不必要，可以移除。\n\n**示例：**\n\n\n      class Foo {\n        Foo() {\n          super();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        Foo() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryCallToSuper",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableObjectPassedToObjectStream",
                "shortDescription": {
                  "text": "不可序列化的对象被传递给了 'ObjectOutputStream'"
                },
                "fullDescription": {
                  "text": "报告用作 'java.io.ObjectOutputStream.write()' 实参的非 'Serializable' 对象。 此类调用将导致运行时异常。 此检查假定 'java.util.Collection' 和 'java.util.Map' 类型的对象为 'Serializable'，除非声明它们的类型为非 'Serializable'。 示例： 'public class IWantToSerializeThis {\n    public static void main(String[] args) throws IOException {\n      try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get(\"output\")))) {\n        // 警告 -- 将会失败并抛出 NotSerializableException\n        stream.writeObject(new IWantToSerializeThis());\n      }\n    }\n  }'",
                  "markdown": "报告用作 `java.io.ObjectOutputStream.write()` 实参的非 `Serializable` 对象。 此类调用将导致运行时异常。\n\n\n此检查假定 `java.util.Collection` 和 `java.util.Map` 类型的对象为 `Serializable`，除非声明它们的类型为非 `Serializable`。\n\n**示例：**\n\n\n      public class IWantToSerializeThis {\n        public static void main(String[] args) throws IOException {\n          try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get(\"output\")))) {\n            // 警告 -- 将会失败并抛出 NotSerializableException\n            stream.writeObject(new IWantToSerializeThis());\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableObjectPassedToObjectStream",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfCanBeSwitch",
                "shortDescription": {
                  "text": "'if' 可被替换为 'switch'"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'switch' 语句的 'if' 语句。 替换结果通常更简短、更清晰。 示例： 'void test(String str) {\n    if (str.equals(\"1\")) {\n      System.out.println(1);\n    } else if (str.equals(\"2\")) {\n      System.out.println(2);\n    } else if (str.equals(\"3\")) {\n      System.out.println(3);\n    } else {\n      System.out.println(4);\n    }\n  }' 在应用快速修复后： 'void test(String str) {\n    switch (str) {\n      case \"1\" -> System.out.println(1);\n      case \"2\" -> System.out.println(2);\n      case \"3\" -> System.out.println(3);\n      default -> System.out.println(4);\n    }\n  }' 仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。 使用 'if' 条件分支的最小数量字段可指定必须报告 'if' 语句的最小 'if' 条件分支数。 注意，不计入终端 'else' 分支（无 'if'）。 使用对数字启用 switch 建议选项，可以对基元和装箱的数字及字符启用 'switch' 语句建议。 使用对枚举启用 switch 建议选项，可以对 'enum' 常量启用 'switch' 语句建议。 使用仅对 null-safe 表达式启用建议选项，可仅建议不能引入 'NullPointerException' 的 'switch' 语句。",
                  "markdown": "报告可以替换为 `switch` 语句的 `if` 语句。\n\n替换结果通常更简短、更清晰。\n\n**示例：**\n\n\n      void test(String str) {\n        if (str.equals(\"1\")) {\n          System.out.println(1);\n        } else if (str.equals(\"2\")) {\n          System.out.println(2);\n        } else if (str.equals(\"3\")) {\n          System.out.println(3);\n        } else {\n          System.out.println(4);\n        }\n      }\n\n在应用快速修复后：\n\n\n      void test(String str) {\n        switch (str) {\n          case \"1\" -> System.out.println(1);\n          case \"2\" -> System.out.println(2);\n          case \"3\" -> System.out.println(3);\n          default -> System.out.println(4);\n        }\n      }\n      \n仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。\n\n使用 **'if' 条件分支的最小数量** 字段可指定必须报告 `if` 语句的最小 `if` 条件分支数。 注意，不计入终端 `else` 分支（无 `if`）。\n\n\n使用**对数字启用 switch 建议** 选项，可以对基元和装箱的数字及字符启用 `switch` 语句建议。\n\n\n使用**对枚举启用 switch 建议** 选项，可以对 `enum` 常量启用 `switch` 语句建议。\n\n\n使用**仅对 null-safe 表达式启用建议** 选项，可仅建议不能引入 `NullPointerException` 的 `switch` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfCanBeSwitch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级迁移帮助",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonPublicClone",
                "shortDescription": {
                  "text": "'clone()' 方法不是 'public'"
                },
                "fullDescription": {
                  "text": "报告 'protected' 而不是 'public' 的 'clone()' 方法。 从 'java.lang.Object' 重写 'clone()' 方法时，应将该方法设为 'public'，以便从软件包外部的非子类进行访问。",
                  "markdown": "报告 `protected` 而不是 `public` 的 `clone()` 方法。\n\n从 `java.lang.Object` 重写 `clone()` 方法时，应将该方法设为 `public`，以便从软件包外部的非子类进行访问。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonPublicClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfiniteRecursion",
                "shortDescription": {
                  "text": "无限递归"
                },
                "fullDescription": {
                  "text": "报告具有无限递归的方法和函数。 示例： 'int factorial(int n) {\n    return n * factorial(n - 1);\n  }'",
                  "markdown": "报告具有无限递归的方法和函数。\n\n**示例：**\n\n\n      int factorial(int n) {\n        return n * factorial(n - 1);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InfiniteRecursion",
                    "cweIds": [
                      674,
                      835
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfObsoleteDateTimeApi",
                "shortDescription": {
                  "text": "使用废弃的日期时间 API"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Date'、'java.util.Calendar'、'java.util.GregorianCalendar'、'java.util.TimeZone'、'java.util.SimpleTimeZone' 的用法。 虽然仍受支持，但 JDK8 Date-Time API 中已废弃这些类，或许不宜在新开发中使用。",
                  "markdown": "报告 `java.util.Date`、`java.util.Calendar`、`java.util.GregorianCalendar`、`java.util.TimeZone`、`java.util.SimpleTimeZone` 的用法。\n\n虽然仍受支持，但 JDK8 Date-Time API 中已废弃这些类，或许不宜在新开发中使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfObsoleteDateTimeApi",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ModuleWithTooFewClasses",
                "shortDescription": {
                  "text": "类过少的模块"
                },
                "fullDescription": {
                  "text": "报告包含的类太少的模块。 模块过小可能表明设计过于分散。 Java、Kotlin 和 Groovy 类均计算在内。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用最小类数字段可指定模块可能拥有的最小类数。",
                  "markdown": "报告包含的类太少的模块。 模块过小可能表明设计过于分散。 Java、Kotlin 和 Groovy 类均计算在内。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**最小类数**字段可指定模块可能拥有的最小类数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ModuleWithTooFewClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullArgumentToVariableArgMethod",
                "shortDescription": {
                  "text": "引起混淆的 vararg 方法实参"
                },
                "fullDescription": {
                  "text": "报告对可变 arity 方法的调用，该调用在 vararg 形参位置有一个实参，这个实参要么是 'null'，要么是 vararg 形参子类型的数组。 此类实参可能令人困惑，因为不清楚需要 vararg 调用还是非 vararg 调用。 示例： 'String[] ss = new String[]{\"foo\", \"bar\"};\n  System.out.printf(\"%s\", ss);' 在本例中，不会打印整个数组，而是只打印数组的第一个元素。 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告对可变 arity 方法的调用，该调用在 vararg 形参位置有一个实参，这个实参要么是 `null`，要么是 vararg 形参子类型的数组。 此类实参可能令人困惑，因为不清楚需要 vararg 调用还是非 vararg 调用。\n\n**示例：**\n\n\n      String[] ss = new String[]{\"foo\", \"bar\"};\n      System.out.printf(\"%s\", ss);\n\n在本例中，不会打印整个数组，而是只打印数组的第一个元素。\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingArgumentToVarargsMethod",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverloadedVarargsMethod",
                "shortDescription": {
                  "text": "重载 vararg 方法"
                },
                "fullDescription": {
                  "text": "报告与类或超类中的其他方法同名的 vararg 方法。 采用可变数量实参的重载方法可能非常令人困惑，因为通常不清楚调用的是哪个重载。 示例： 'public void execute(Runnable... r) {} // 警告\n    public void execute(Runnable r1, Runnable r2) {}' 使用该选项可以忽略形参类型绝对不兼容的重载方法。",
                  "markdown": "报告与类或超类中的其他方法同名的 vararg 方法。 采用可变数量实参的重载方法可能非常令人困惑，因为通常不清楚调用的是哪个重载。\n\n**示例：**\n\n\n        public void execute(Runnable... r) {} // 警告\n        public void execute(Runnable r1, Runnable r2) {}\n\n\n使用该选项可以忽略形参类型绝对不兼容的重载方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverloadedVarargsMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousInnerClassMayBeStatic",
                "shortDescription": {
                  "text": "匿名类可能是命名为 'static' 的内部类"
                },
                "fullDescription": {
                  "text": "报告可以安全地替换为 'static' 内部类的匿名类。 如果某个匿名类没有从周围方法显式引用其封闭实例或局部类，则它可能是 'static' 内部类。 'static' 内部类不保留对其封闭实例的隐式引用。 这可以防止常见的内存泄漏，并减少每个类实例使用的内存。 从 Java 18 开始，只有可序列化的匿名类在不使用该引用的情况下，才保留对其封闭实例的隐式引用。 因此，如果模块语言级别为 Java 18 或更高，则此检查只报告可序列化的类。 该快速修复会将匿名类提取到命名的 'static' 内部类中。 示例： 'void sample(){\n    Thread thread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n      }\n    });\n  }' 在应用快速修复后： 'void sample() {\n    Thread thread = new Thread(new Task());\n  }\n\n  private static class Task implements Runnable {\n    @Override\n    public void run() {\n    }\n  }'",
                  "markdown": "报告可以安全地替换为 `static` 内部类的匿名类。 如果某个匿名类没有从周围方法显式引用其封闭实例或局部类，则它可能是 `static` 内部类。\n\n\n`static` 内部类不保留对其封闭实例的隐式引用。\n这可以防止常见的内存泄漏，并减少每个类实例使用的内存。\n\n\n从 Java 18 开始，只有可序列化的匿名类在不使用该引用的情况下，才保留对其封闭实例的隐式引用。 因此，如果模块语言级别为 Java 18 或更高，则此检查只报告可序列化的类。\n\n该快速修复会将匿名类提取到命名的 `static` 内部类中。\n\n**示例：**\n\n\n      void sample(){\n        Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n          }\n        });\n      }\n\n在应用快速修复后：\n\n\n      void sample() {\n        Thread thread = new Thread(new Task());\n      }\n\n      private static class Task implements Runnable {\n        @Override\n        public void run() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousInnerClassMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedIsStillUsed",
                "shortDescription": {
                  "text": "弃用的成员仍在使用"
                },
                "fullDescription": {
                  "text": "报告代码中使用的已弃用的类、方法和字段。 示例： 'class MyCode {\n  @Deprecated\n  void oldMethod() {}// 警告：\"弃用的成员仍在使用\"\n\n  void newMethod() {\n    oldMethod(); // 被遗忘的用法\n  }\n  }' 已弃用的元素中的用法将被忽略。 注意：由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。",
                  "markdown": "报告代码中使用的已弃用的类、方法和字段。\n\n示例：\n\n\n      class MyCode {\n      @Deprecated\n      void oldMethod() {}// 警告：\"弃用的成员仍在使用\"\n\n      void newMethod() {\n        oldMethod(); // 被遗忘的用法\n      }\n      }\n\n已弃用的元素中的用法将被忽略。\n\n**注意**：由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedIsStillUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicConstructor",
                "shortDescription": {
                  "text": "'public' 构造函数可被替换为工厂方法"
                },
                "fullDescription": {
                  "text": "报告 'public' 构造函数。 有些编码标准不建议使用 'public' 构造函数，而是建议使用 'static' 工厂方法。 这样就可以在不影响调用点的情况下交换实现。 示例： 'class Test {\n    private String name;\n\n    public Test(String name) {\n        this.name = name;\n    }\n\n    public void test() {\n        System.out.println(name);\n    }\n\n    public static void main(String[] args) {\n        new Test(\"str\").test();\n    }\n  }' 在应用快速修复后： 'class Test {\n    private String name;\n\n    private Test(String name) {\n        this.name = name;\n    }\n\n    public static Test getInstance(String name) {\n        return new Test(name);\n    }\n\n    public void test() {\n        System.out.println(name);\n    }\n\n    public static void main(String[] args) {\n        getInstance(\"str\").test();\n    }\n  }'",
                  "markdown": "报告 `public` 构造函数。\n\n有些编码标准不建议使用 `public` 构造函数，而是建议使用 `static` 工厂方法。\n这样就可以在不影响调用点的情况下交换实现。\n\n**示例：**\n\n\n      class Test {\n        private String name;\n\n        public Test(String name) {\n            this.name = name;\n        }\n\n        public void test() {\n            System.out.println(name);\n        }\n\n        public static void main(String[] args) {\n            new Test(\"str\").test();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Test {\n        private String name;\n\n        private Test(String name) {\n            this.name = name;\n        }\n\n        public static Test getInstance(String name) {\n            return new Test(name);\n        }\n\n        public void test() {\n            System.out.println(name);\n        }\n\n        public static void main(String[] args) {\n            getInstance(\"str\").test();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantComparatorComparing",
                "shortDescription": {
                  "text": "可以简化 Comparator 方法"
                },
                "fullDescription": {
                  "text": "报告可简化的 'Comparator' 连结符构造。 示例： 'c.thenComparing(Comparator.comparing(function));\n\n  Comparator.comparing(Map.Entry::getKey);\n\n  Collections.max(list, Comparator.reverseOrder());' 在应用快速修复后： 'c.thenComparing(function)\n\n  Map.Entry.comparingByKey()\n\n  Collections.min(list, Comparator.naturalOrder());' 2018.1 最新变化",
                  "markdown": "报告可简化的 `Comparator` 连结符构造。\n\n示例：\n\n\n      c.thenComparing(Comparator.comparing(function));\n\n      Comparator.comparing(Map.Entry::getKey);\n\n      Collections.max(list, Comparator.reverseOrder());\n\n在应用快速修复后：\n\n\n      c.thenComparing(function)\n\n      Map.Entry.comparingByKey()\n\n      Collections.min(list, Comparator.naturalOrder());\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantComparatorComparing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEmbeddedExpression",
                "shortDescription": {
                  "text": "字符串模板中的冗余嵌入表达式"
                },
                "fullDescription": {
                  "text": "报告 'STR' 模板中冗余的嵌入式表达式，例如普通文字或空表达式。 示例： 'System.out.println(STR.\"Hello \\{\"world\"}\");' 在应用快速修复后： 'System.out.println(STR.\"Hello world\");' 2023.3 最新变化 此检查取决于 Java 功能 '字符串模板'，该功能自 Java 21-preview 起可用。",
                  "markdown": "报告 `STR` 模板中冗余的嵌入式表达式，例如普通文字或空表达式。\n\n示例：\n\n\n      System.out.println(STR.\"Hello \\{\"world\"}\");\n\n在应用快速修复后：\n\n\n      System.out.println(STR.\"Hello world\");\n\n2023.3 最新变化\n\n此检查取决于 Java 功能 '字符串模板'，该功能自 Java 21-preview 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantEmbeddedExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementWithTooFewBranches",
                "shortDescription": {
                  "text": "最小 'switch' 分支"
                },
                "fullDescription": {
                  "text": "报告带有太少 'case' 标签的 'switch' 语句和表达式，并建议将它们重写为 'if' 和 'else if' 语句。 示例 (minimum branches == 3)： 'switch (expression) {\n    case \"foo\" -> foo();\n    case \"bar\" -> bar();\n  }' 在应用快速修复后： 'if (\"foo\".equals(expression)) {\n    foo();\n  } else if (\"bar\".equals(expression)) {\n    bar();\n  }' 不报告详尽的 switch 表达式 (Java 14+) 或不带 'default' 分支的模式 switch 语句（Java 17 预览版）。 这是因为当 'switch' 被转换为 'if' 后，编译时详尽性检查将丢失（可能是不希望发生的结果）。 配置检查： 使用最小分支数 字段指定 'case' 标签的最小预期数量。 使用不报告模式 switch 语句选项可避免报告具有模式分支的 switch 语句和表达式。 例如： 'String result = switch(obj) {\n    case String str -> str.trim();\n    default -> \"none\";\n  };' 即使只有一个模式分支，也应该保留 switch，而不是使用 'instanceof' 语句。",
                  "markdown": "报告带有太少 `case` 标签的 `switch` 语句和表达式，并建议将它们重写为 `if` 和 `else if` 语句。\n\n示例 (minimum branches == 3)：\n\n\n      switch (expression) {\n        case \"foo\" -> foo();\n        case \"bar\" -> bar();\n      }\n\n在应用快速修复后：\n\n\n      if (\"foo\".equals(expression)) {\n        foo();\n      } else if (\"bar\".equals(expression)) {\n        bar();\n      }\n\n不报告详尽的 switch 表达式 (Java 14+) 或不带 'default' 分支的模式 switch 语句（Java 17 预览版）。\n这是因为当 `switch` 被转换为 `if` 后，编译时详尽性检查将丢失（可能是不希望发生的结果）。\n\n配置检查：\n\n使用**最小分支数** 字段指定 `case` 标签的最小预期数量。\n\n使用**不报告模式 switch 语句**选项可避免报告具有模式分支的 switch 语句和表达式。 例如：\n\n\n      String result = switch(obj) {\n        case String str -> str.trim();\n        default -> \"none\";\n      };\n\n即使只有一个模式分支，也应该保留 switch，而不是使用 `instanceof` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatementWithTooFewBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VariableNotUsedInsideIf",
                "shortDescription": {
                  "text": "'if' 内未使用检查为 'null' 的引用"
                },
                "fullDescription": {
                  "text": "报告对在 'if' 语句或条件表达式的条件中检查可 null 性但未在该 'if' 语句内部使用的变量的引用。 这通常意味着不必要进行该检查，或者在 'if' 语句中没有错误引用变量。 示例： 'void test(Integer i) {\n    if (i != null) { // 这里的 'i' 没有在 'if' 语句内部使用\n      System.out.println();\n    }\n  }'",
                  "markdown": "报告对在 `if` 语句或条件表达式的条件中检查可 null 性但未在该 `if` 语句内部使用的变量的引用。\n\n\n这通常意味着不必要进行该检查，或者在 `if` 语句中没有错误引用变量。\n\n**示例：**\n\n\n      void test(Integer i) {\n        if (i != null) { // 这里的 'i' 没有在 'if' 语句内部使用\n          System.out.println();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VariableNotUsedInsideIf",
                    "cweIds": [
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UsagesOfObsoleteApi",
                "shortDescription": {
                  "text": "ApiStatus.@Obsolete 的用法"
                },
                "fullDescription": {
                  "text": "报告注解为 '@ApiStatus.Obsolete' 的声明（类、方法、字段）。 有时无法删除当前的 API，尽管它可能无法正常工作，但有一个较新、更好或更通用的 API。 这样，它就是 '@Deprecated' 注解的一个较弱变体。 不应该在新代码中使用带注解的 API，但是允许推迟现有代码的迁移，因此这种用法不被视为警告。",
                  "markdown": "报告注解为 `@ApiStatus.Obsolete` 的声明（类、方法、字段）。\n\n\n有时无法删除当前的 API，尽管它可能无法正常工作，但有一个较新、更好或更通用的 API。\n这样，它就是 `@Deprecated` 注解的一个较弱变体。\n不应该在新代码中使用带注解的 API，但是允许推迟现有代码的迁移，因此这种用法不被视为警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UsagesOfObsoleteApi",
                    "ideaSeverity": "TEXT ATTRIBUTES",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionAddAllCanBeReplacedWithConstructor",
                "shortDescription": {
                  "text": "冗余的 'Collection.addAll()' 调用"
                },
                "fullDescription": {
                  "text": "在使用无参构造函数实例化集合后，立即报告 'Collection.addAll()' 和 'Map.putAll()' 调用。 此类结构可被替换为对形参化构造函数的单次调用，从而简化代码。 此外，对于某些集合，替换可能会更高效。 示例： 'Set<String> set = new HashSet<>();\n  set.addAll(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));' 在应用快速修复后： 'Set<String> set = new HashSet<>(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));' 默认支持 JDK 集合类。 此外，还可以使用要检查的类面板指定其他类。",
                  "markdown": "在使用无参构造函数实例化集合后，立即报告 `Collection.addAll()` 和 `Map.putAll()` 调用。\n\n此类结构可被替换为对形参化构造函数的单次调用，从而简化代码。 此外，对于某些集合，替换可能会更高效。\n\n**示例：**\n\n\n      Set<String> set = new HashSet<>();\n      set.addAll(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\n在应用快速修复后：\n\n\n      Set<String> set = new HashSet<>(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\n\n默认支持 JDK 集合类。\n此外，还可以使用**要检查的类**面板指定其他类。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionAddAllCanBeReplacedWithConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleReturnPointsPerMethod",
                "shortDescription": {
                  "text": "具有多个返回点的方法"
                },
                "fullDescription": {
                  "text": "报告 'return' 点数超过指定最大值的方法。 具有太多 'return' 点的方法可能令人困惑且难以重构。 一个 'return' 点可以是 'return' 语句，也可以是从 'void' 方法或构造函数底部的直落。 示例： 如果只允许两个 'return' 语句，则报告以下方法： 'void doSmth(User[] users) {\n    for (User user : users) {\n      if (cond1(user)) {\n        user.setId(getId());\n        return;\n      } else if (cond2(user)) {\n        if (cond3(user)) {\n          user.setId(getId());\n          return;\n        }\n      }\n    }\n  }' 请考虑重写该方法，使其更容易理解： 'void doSmth(User[] users) {\n    for (User user : users) {\n      if (cond1(user) || cond2(user) && cond3(user)) {\n        user.setId(getId());\n        return;\n      }\n    }\n  }' 配置检查： 使用 return 点限制字段可指定方法允许的最大 'return' 点数。 使用忽略临界子句选项可忽略临界子句。 临界子句是只包含 'return' 语句的 'if' 语句 使用对 'equals()' 方法忽略选项可忽略 'equals()' 方法中的 'return' 点。",
                  "markdown": "报告 `return` 点数超过指定最大值的方法。 具有太多 `return` 点的方法可能令人困惑且难以重构。\n\n一个 `return` 点可以是 `return` 语句，也可以是从 `void` 方法或构造函数底部的直落。\n\n**示例：**\n\n如果只允许两个 `return` 语句，则报告以下方法：\n\n\n      void doSmth(User[] users) {\n        for (User user : users) {\n          if (cond1(user)) {\n            user.setId(getId());\n            return;\n          } else if (cond2(user)) {\n            if (cond3(user)) {\n              user.setId(getId());\n              return;\n            }\n          }\n        }\n      }\n\n请考虑重写该方法，使其更容易理解：\n\n\n      void doSmth(User[] users) {\n        for (User user : users) {\n          if (cond1(user) || cond2(user) && cond3(user)) {\n            user.setId(getId());\n            return;\n          }\n        }\n      }\n\n配置检查：\n\n* 使用 **return 点限制** 字段可指定方法允许的最大 `return` 点数。\n* 使用**忽略临界子句** 选项可忽略临界子句。 临界子句是只包含 `return` 语句的 `if` 语句\n* 使用**对 'equals()' 方法忽略** 选项可忽略 `equals()` 方法中的 `return` 点。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithMultipleReturnPoints",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousMethodCalls",
                "shortDescription": {
                  "text": "可疑的集合方法调用"
                },
                "fullDescription": {
                  "text": "报告实际实参类型与集合的元素类型不一致的形参化集合的方法调用。 示例： 'List<Integer> list = getListOfElements();\n  list.remove(\"\"); //remove 被高亮显示' 在检查设置中，可以禁用对可能正确的代码发出警告，如下所示： 'public boolean accept(Map<Integer, String> map, Object key) {\n    return map.containsKey(key);\n  }'",
                  "markdown": "报告实际实参类型与集合的元素类型不一致的形参化集合的方法调用。\n\n**示例：**\n\n\n      List<Integer> list = getListOfElements();\n      list.remove(\"\"); //remove 被高亮显示\n\n\n在检查设置中，可以禁用对可能正确的代码发出警告，如下所示：\n\n\n      public boolean accept(Map<Integer, String> map, Object key) {\n        return map.containsKey(key);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousMethodCalls",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantDeclaredInInterface",
                "shortDescription": {
                  "text": "在接口中声明的常量"
                },
                "fullDescription": {
                  "text": "报告在接口中声明的常量（'public static final' 字段）。 有些编码标准要求在 abstract 类中声明常量。",
                  "markdown": "报告在接口中声明的常量（`public static final` 字段）。\n\n有些编码标准要求在 abstract 类中声明常量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantDeclaredInInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForwardCompatibility",
                "shortDescription": {
                  "text": "前向兼容性"
                },
                "fullDescription": {
                  "text": "报告未来 Java 版本中可能无法编译的 Java 代码结构。 报告的问题如下： 使用 'assert'、'enum' 或 '_' 作为标识符 使用 'var'、'yield' 或 'record' 受限标识符作为类型名称 对 'yield' 方法的非限定调用 'module-info.java' 内部的 'requires java.base' 语句的修饰符 import 语句之间的冗余分号 示例： '// 这个以前合法的类无法在 Java 14 中编译，\n  // 因为 'yield' 变成了一个受限的标识符。\n  public class yield {}' 及时解决这些问题，可以简化向未来 Java 版本的迁移。",
                  "markdown": "报告未来 Java 版本中可能无法编译的 Java 代码结构。\n\n报告的问题如下：\n\n* 使用 `assert`、`enum` 或 `_` 作为标识符\n* 使用 `var`、`yield` 或 `record` 受限标识符作为类型名称\n* 对 `yield` 方法的非限定调用\n* `module-info.java` 内部的 `requires java.base` 语句的修饰符\n* import 语句之间的冗余分号\n\n**示例：**\n\n\n      // 这个以前合法的类无法在 Java 14 中编译，\n      // 因为 'yield' 变成了一个受限的标识符。\n      public class yield {} \n\n及时解决这些问题，可以简化向未来 Java 版本的迁移。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForwardCompatibility",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DiamondCanBeReplacedWithExplicitTypeArguments",
                "shortDescription": {
                  "text": "diamond 可被替换为显式类型实参"
                },
                "fullDescription": {
                  "text": "报告泛型类的实例化，其中使用 <> 符号（菱形）代替类型形参。 快速修复会将 <>（菱形）替换为显式类型形参。 示例： 'List <String> list = new ArrayList<>()' 在应用快速修复后： 'List <String> list = new ArrayList<String>()' 菱形运算符在 Java 7 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告泛型类的实例化，其中使用 **\\<\\>** 符号（菱形）代替类型形参。\n\n快速修复会将 **\\<\\>**（菱形）替换为显式类型形参。\n\n示例：\n\n    List <String> list = new ArrayList<>()\n\n在应用快速修复后：\n\n    List <String> list = new ArrayList<String>()\n\n\n*菱形运算符*在 Java 7 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DiamondCanBeReplacedWithExplicitTypeArguments",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfProcessBuilder",
                "shortDescription": {
                  "text": "使用 'java.lang.ProcessBuilder' 类"
                },
                "fullDescription": {
                  "text": "报告使用 'java.lang.ProcessBuilder' 的情况，由于可执行文件、环境变量、命令行实参及其转义的路径可能会因操作系统而异，可能无法在操作系统之间移植。",
                  "markdown": "报告使用 `java.lang.ProcessBuilder` 的情况，由于可执行文件、环境变量、命令行实参及其转义的路径可能会因操作系统而异，可能无法在操作系统之间移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfProcessBuilder",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaRequiresAutoModule",
                "shortDescription": {
                  "text": "依赖于自动模块"
                },
                "fullDescription": {
                  "text": "报告 'requires' 指令中自动模块的用法。 自动模块不可靠，因为它可能依赖于类路径中的类型，而且当它转换为显式模块时，它的名称和导出的软件包可能会改变。 对应于 '-Xlint:requires-automatic' 和 '-Xlint:requires-transitive-automatic' Javac 选项。 第一个选项增加了对何时使用自动模块的了解。 第二个选项则是警示模块的作者，建立自动模块的隐含可读性将使该模块的用户面临风险。 示例： '//module-info.java\n  module org.printer {\n    requires transitive drivers.corp.org; // 在 'drivers.corp.org' 为自动模块时报告\n  }' 使用仅高亮显示传递依赖选项，可仅对传递依赖发出警告。 此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。",
                  "markdown": "报告 `requires` 指令中自动模块的用法。\n\n自动模块不可靠，因为它可能依赖于类路径中的类型，而且当它转换为显式模块时，它的名称和导出的软件包可能会改变。\n\n对应于 `-Xlint:requires-automatic` 和 `-Xlint:requires-transitive-automatic` Javac 选项。\n第一个选项增加了对何时使用自动模块的了解。\n第二个选项则是警示模块的作者，建立自动模块的隐含可读性将使该模块的用户面临风险。\n\n**示例：**\n\n\n      //module-info.java\n      module org.printer {\n        requires transitive drivers.corp.org; // 在 'drivers.corp.org' 为自动模块时报告\n      }\n\n\n使用**仅高亮显示传递依赖**选项，可仅对传递依赖发出警告。\n\n此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "requires-transitive-automatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 9",
                      "index": 76,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExcessiveRangeCheck",
                "shortDescription": {
                  "text": "过度范围检查"
                },
                "fullDescription": {
                  "text": "报告检查值范围的条件链，这些条件链可以简化为单个检查。 该快速修复会将条件链替换为简化的表达式： 示例： 'x > 2 && x < 4' 在应用快速修复后： 'x == 3' 示例： 'arr.length == 0 || arr.length > 1' 在应用快速修复后： 'arr.length != 1' 2019.1 最新变化",
                  "markdown": "报告检查值范围的条件链，这些条件链可以简化为单个检查。\n\n该快速修复会将条件链替换为简化的表达式：\n\n示例：\n\n\n      x > 2 && x < 4\n\n在应用快速修复后：\n\n\n      x == 3\n\n示例：\n\n\n      arr.length == 0 || arr.length > 1\n\n在应用快速修复后：\n\n\n      arr.length != 1\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExcessiveRangeCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoExplicitFinalizeCalls",
                "shortDescription": {
                  "text": "'finalize()' 被显式调用"
                },
                "fullDescription": {
                  "text": "报告对 'Object.finalize()' 的调用。 显式调用 'Object.finalize()' 可能导致对象处于不一致的状态。 垃圾收集器在确定没有对该对象的引用时，自动对该对象调用此方法。 该检查不报告 'finalize()' 实现中对 'super.finalize()' 的调用，因为它们是良性的。 示例： 'MyObject m = new MyObject();\n  m.finalize();\n  System.gc()'",
                  "markdown": "报告对 `Object.finalize()` 的调用。\n\n显式调用 `Object.finalize()` 可能导致对象处于不一致的状态。\n垃圾收集器在确定没有对该对象的引用时，自动对该对象调用此方法。\n\n该检查不报告 `finalize()` 实现中对 `super.finalize()` 的调用，因为它们是良性的。\n\n**示例：**\n\n\n      MyObject m = new MyObject();\n      m.finalize();\n      System.gc()\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalizeCalledExplicitly",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/完成",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticImport",
                "shortDescription": {
                  "text": "static import"
                },
                "fullDescription": {
                  "text": "报告 'import static' 语句。 Java 1.4 或更早版本的 JVM 不支持此类 'import' 语句。 配置检查： 使用下表可以指定在 'import static' 语句中使用时该检查将忽略的类。 使用忽略单字段 static import复选框可以忽略单字段 'import static' 语句。 使用忽略单方法 static import 复选框可以忽略单方法 'import static' 语句。",
                  "markdown": "报告 `import static` 语句。\n\nJava 1.4 或更早版本的 JVM 不支持此类 `import` 语句。\n\n配置检查：\n\n* 使用下表可以指定在 `import static` 语句中使用时该检查将忽略的类。\n* 使用**忽略单字段 static import** 复选框可以忽略单字段 `import static` 语句。\n* 使用**忽略单方法 static import** 复选框可以忽略单方法 `import static` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceNullCheck",
                "shortDescription": {
                  "text": "Null 检查可被替换为方法调用"
                },
                "fullDescription": {
                  "text": "报告可被替换为从 'Objects' 或 'Stream' 对 static 方法的调用的 'null' 检查。 示例： 'if (message == null) {\n    application.messageStorage().save(new EmptyMessage());\n  } else {\n    application.messageStorage().save(message);\n  }' 在应用快速修复后： 'application.messageStorage()\n    .save(Objects.requireNonNullElseGet(message, () -> new EmptyMessage()));' 使用替换长度大于原始长度时不发出警告选项，可以忽略替换长度超过原始代码的情况。 2017.3 最新变化",
                  "markdown": "报告可被替换为从 `Objects` 或 `Stream` 对 static 方法的调用的 `null` 检查。\n\n**示例：**\n\n\n      if (message == null) {\n        application.messageStorage().save(new EmptyMessage());\n      } else {\n        application.messageStorage().save(message);\n      }\n\n在应用快速修复后：\n\n\n      application.messageStorage()\n        .save(Objects.requireNonNullElseGet(message, () -> new EmptyMessage()));\n\n\n使用**替换长度大于原始长度时不发出警告**选项，可以忽略替换长度超过原始代码的情况。\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceNullCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 9",
                      "index": 76,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedIfElse",
                "shortDescription": {
                  "text": "具有否定条件的 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告包含 'else' 分支并且条件被否定的 'if' 语句。 翻转 'if' 和 'else' 分支的顺序通常会增加此类语句的清晰度。 可以通过修正反转当前 'if' 语句。 示例： 'void m(Object o1, Object o2) {\n        if (o1 != o2) {\n            System.out.println(1);\n        }\n        else {\n            System.out.println(2);\n        }\n    }' 应用快速修复后： 'void m(Object o1, Object o2) {\n        if (o1 == o2) {\n            System.out.println(2);\n        } else {\n            System.out.println(1);\n        }\n    }' 使用忽略 '!= null' 比较选项可以忽略 '!= null' 形式的比较。 使用忽略 '!= 0' 比较选项可以忽略 '!= 0' 形式的比较。",
                  "markdown": "报告包含 `else` 分支并且条件被否定的 `if` 语句。\n\n翻转 `if` 和 `else` 分支的顺序通常会增加此类语句的清晰度。\n\n可以通过修正反转当前 `if` 语句。\n\n示例：\n\n\n        void m(Object o1, Object o2) {\n            if (o1 != o2) {\n                System.out.println(1);\n            }\n            else {\n                System.out.println(2);\n            }\n        }\n\n应用快速修复后：\n\n\n        void m(Object o1, Object o2) {\n            if (o1 == o2) {\n                System.out.println(2);\n            } else {\n                System.out.println(1);\n            }\n        }\n\n使用**忽略 '!= null' 比较** 选项可以忽略 `!= null` 形式的比较。\n\n使用**忽略 '!= 0' 比较** 选项可以忽略 `!= 0` 形式的比较。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementWithNegatedCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldCount",
                "shortDescription": {
                  "text": "字段过多的类"
                },
                "fullDescription": {
                  "text": "报告字段数超过指定最大值的类。 具有大量字段的类通常会试图进行过多处理。 请考虑将这种类拆分为多个较小的类。 配置检查： 使用字段计数限制字段可指定类中允许的最大字段数。 使用在计数中包含常量字段选项可指示是否应计算常量字段。 默认情况下，只有不可变的 'static final' 对象会被计为常量。 使用将 'static final' 字段计为常量选项可将任何 'static final' 字段计为常量。 使用在计数中包含枚举常量选项可指定是否应计算 'enum' 类中的 'enum' 常量。",
                  "markdown": "报告字段数超过指定最大值的类。\n\n具有大量字段的类通常会试图进行过多处理。 请考虑将这种类拆分为多个较小的类。\n\n配置检查：\n\n* 使用**字段计数限制**字段可指定类中允许的最大字段数。\n* 使用**在计数中包含常量字段**选项可指示是否应计算常量字段。\n* 默认情况下，只有不可变的 `static final` 对象会被计为常量。 使用**将 'static final' 字段计为常量** 选项可将任何 `static final` 字段计为常量。\n* 使用**在计数中包含枚举常量** 选项可指定是否应计算 `enum` 类中的 `enum` 常量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyFields",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenation",
                "shortDescription": {
                  "text": "字符串串联"
                },
                "fullDescription": {
                  "text": "报告 'String' 串联。 在国际化环境中，串联可能不正确，可被替换为 'java.text.MessageFormat' 或类似的类的用法。 示例： 'String getMessage(String string, int number) {\n    return string + number;\n  }'",
                  "markdown": "报告 `String` 串联。 在国际化环境中，串联可能不正确，可被替换为 `java.text.MessageFormat` 或类似的类的用法。\n\n**示例：**\n\n\n      String getMessage(String string, int number) {\n        return string + number;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassCanBeRecord",
                "shortDescription": {
                  "text": "类可以是记录类"
                },
                "fullDescription": {
                  "text": "报告可以转换为记录类的类。 记录类侧重于对不可变数据进行建模，而不是对可扩展行为进行建模。 数据驱动方法的自动隐式实现（例如 'equals()' 和访问器）有助于减少样板代码。 请注意，不是每个类都可以是记录类。 以下是一些限制： 该类不能有子类。 类中的所有非 static 字段必须为 final。 不能存在初始值设定项、泛型构造函数和原生方法。 有关记录类的完整描述，请参阅 < Java 语言规范。 示例： 'class Point {\n    private final double x;\n    private final double y;\n\n    Point(double x, double y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    double getX() {\n      return x;\n    }\n\n    double getY() {\n      return y;\n    }\n  }' 在应用快速修复后： 'record Point(int x, int y) {\n  }' 启用建议重命名访问器方法选项可自动将 'getX()'/'isX()' 访问器重命名为 'x()'。 使用如果成员变得更易于访问选项可指定当转换将使成员更易于访问时要执行的操作： 选择不建议转换选项可在成员变得更易于访问时不进行转换。 选择显示冲突视图选项可显示受影响的成员并要求继续。 在批处理模式下，将不建议进行转换。 选择静默转换选项可在需要时以静默方式提高可访问性。 使用禁止转换有以下注解的类列表可在要转换的类中排除其注解匹配指定模式的类。 2020.3 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告可以转换为记录类的类。\n\n记录类侧重于对不可变数据进行建模，而不是对可扩展行为进行建模。\n数据驱动方法的自动隐式实现（例如 `equals()` 和访问器）有助于减少样板代码。\n\n\n请注意，不是每个类都可以是记录类。 以下是一些限制：\n\n* 该类不能有子类。\n* 类中的所有非 static 字段必须为 final。\n* 不能存在初始值设定项、泛型构造函数和原生方法。\n\n有关记录类的完整描述，请参阅 \\<\n[Java 语言规范](https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10)。\n\n示例：\n\n\n      class Point {\n        private final double x;\n        private final double y;\n\n        Point(double x, double y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        double getX() {\n          return x;\n        }\n\n        double getY() {\n          return y;\n        }\n      }\n\n在应用快速修复后：\n\n\n      record Point(int x, int y) {\n      }\n\n启用**建议重命名访问器方法** 选项可自动将 `getX()`/`isX()` 访问器重命名为 `x()`。\n\n\n使用**如果成员变得更易于访问**选项可指定当转换将使成员更易于访问时要执行的操作：\n\n* 选择**不建议转换**选项可在成员变得更易于访问时不进行转换。\n* 选择**显示冲突视图**选项可显示受影响的成员并要求继续。 在批处理模式下，将不建议进行转换。\n* 选择**静默转换**选项可在需要时以静默方式提高可访问性。\n\n使用**禁止转换有以下注解的类**列表可在要转换的类中排除其注解匹配指定模式的类。\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ClassCanBeRecord",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 16",
                      "index": 113,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantAssertArgument",
                "shortDescription": {
                  "text": "常量断言实参"
                },
                "fullDescription": {
                  "text": "报告 'assertTrue()'、'assertFalse()'、'assertNull()' 和 'assertNotNull()' 调用中的常量实参。 对这些包含常量实参的方法的调用要么总是成功，要么总是失败。 此类语句很容易在重构后遗留下来，并且可能并非有意为之。 示例： 'assertNotNull(\"foo\");'",
                  "markdown": "报告 `assertTrue()`、`assertFalse()`、`assertNull()` 和 `assertNotNull()` 调用中的常量实参。\n\n\n对这些包含常量实参的方法的调用要么总是成功，要么总是失败。\n此类语句很容易在重构后遗留下来，并且可能并非有意为之。\n\n**示例：**\n\n\n      assertNotNull(\"foo\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantAssertArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 97,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.kotlin",
            "version": "242.23339.11-IJ",
            "rules": [
              {
                "id": "RedundantRunCatching",
                "shortDescription": {
                  "text": "冗余 'runCatching' 调用"
                },
                "fullDescription": {
                  "text": "报告后面紧跟 'getOrThrow' 的 'runCatching' 调用。 此类调用可以仅替换为 'run'。 示例： 'fun foo() = runCatching { doSomething() }.getOrThrow()' 在应用快速修复后： 'fun foo() = run { doSomething() }'",
                  "markdown": "报告后面紧跟 `getOrThrow` 的 `runCatching` 调用。 此类调用可以仅替换为 `run`。\n\n**示例：**\n\n\n      fun foo() = runCatching { doSomething() }.getOrThrow()\n\n在应用快速修复后：\n\n\n      fun foo() = run { doSomething() }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantRunCatching",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimpleRedundantLet",
                "shortDescription": {
                  "text": "基于接收器的冗余 'let' 调用"
                },
                "fullDescription": {
                  "text": "报告基于接收器的冗余 'let' 调用。 该快速修复会移除冗余 'let' 调用。 示例： 'fun test(s: String?): Int? = s?.let { it.length }' 在应用快速修复后： 'fun test(s: String?): Int? = s?.length'",
                  "markdown": "报告基于接收器的冗余 `let` 调用。\n\n该快速修复会移除冗余 `let` 调用。\n\n**示例：**\n\n\n      fun test(s: String?): Int? = s?.let { it.length }\n\n在应用快速修复后：\n\n\n      fun test(s: String?): Int? = s?.length\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimpleRedundantLet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveSingleExpressionStringTemplate",
                "shortDescription": {
                  "text": "冗余字符串模板"
                },
                "fullDescription": {
                  "text": "报告可以安全移除的单表达式字符串模板。 示例： 'val x = \"Hello\"\n  val y = \"$x\"' 在应用快速修复后： 'val x = \"Hello\"\n  val y = x // <== 已更新'",
                  "markdown": "报告可以安全移除的单表达式字符串模板。\n\n**示例：**\n\n      val x = \"Hello\"\n      val y = \"$x\"\n\n在应用快速修复后：\n\n      val x = \"Hello\"\n      val y = x // <== 已更新\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveSingleExpressionStringTemplate",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExhaustiveWhenStatementMigration",
                "shortDescription": {
                  "text": "将从 1.7 开始禁止非穷举的 'when' 语句"
                },
                "fullDescription": {
                  "text": "报告从 1.7 版开始会导致编译错误的非详尽 'when' 语句。 动机类型： 需要劝阻/阻止的有问题/无意义的用法模式（例如反直觉的行为） 代码容易出错 设计中的不一致（在不同的上下文中存在不同的处理方式） 影响类型： 编译。 一些过去可以编译的代码将无法编译 在某些情况下，此类代码可以无异常地工作 某些此类代码可以在没有任何警告的情况下编译 更多详细信息：KT-47709：默认情况下使带有枚举、sealed 和布尔主体的 when 语句详尽 快速修复会添加缺少的 'else -> {}' 分支。 示例： 'sealed class Base {\n      class A : Base()\n      class B : Base()\n  }\n\n  fun test(base: Base) {\n      when (base) {\n          is Base.A -> \"\"\n      }\n  }' 在应用快速修复后： 'sealed class Base {\n      class A : Base()\n      class B : Base()\n  }\n\n  fun test(base: Base) {\n      when (base) {\n          is Base.A -> \"\"\n          else -> {}\n      }\n  }' 仅当项目或模块的 Kotlin 语言级别为 1.6 或更高时，此检查才会报告。",
                  "markdown": "报告从 1.7 版开始会导致编译错误的非详尽 `when` 语句。\n\n动机类型：\n\n* 需要劝阻/阻止的有问题/无意义的用法模式（例如反直觉的行为）\n  * 代码容易出错\n* 设计中的不一致（在不同的上下文中存在不同的处理方式）\n\n影响类型：\n\n* 编译。 一些过去可以编译的代码将无法编译\n  * 在某些情况下，此类代码可以无异常地工作\n    * 某些此类代码可以在没有任何警告的情况下编译\n\n**更多详细信息** ：[KT-47709：默认情况下使带有枚举、sealed 和布尔主体的 when 语句详尽](https://youtrack.jetbrains.com/issue/KT-47709)\n\n快速修复会添加缺少的 `else -> {}` 分支。\n\n**示例：**\n\n\n      sealed class Base {\n          class A : Base()\n          class B : Base()\n      }\n\n      fun test(base: Base) {\n          when (base) {\n              is Base.A -> \"\"\n          }\n      }\n\n在应用快速修复后：\n\n\n      sealed class Base {\n          class A : Base()\n          class B : Base()\n      }\n\n      fun test(base: Base) {\n          when (base) {\n              is Base.A -> \"\"\n              else -> {}\n          }\n      }\n\n仅当项目或模块的 Kotlin 语言级别为 1.6 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExhaustiveWhenStatementMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertLambdaToReference",
                "shortDescription": {
                  "text": "可被替换为函数引用"
                },
                "fullDescription": {
                  "text": "报告可以替换为函数引用的函数文字表达式。 将 lambda 替换为函数引用通常会使代码看起来更简洁易懂。 示例： 'fun Int.isEven() = this % 2 == 0\n\n  fun example() {\n      val numbers = listOf(1, 2, 4, 7, 9, 10)\n      val evenNumbers = numbers.filter { it.isEven() }\n  }' 在应用快速修复后： 'fun Int.isEven() = this % 2 == 0\n\n  fun example() {\n      val numbers = listOf(1, 2, 4, 7, 9, 10)\n      val evenNumbers = numbers.filter(Int::isEven)\n  }'",
                  "markdown": "报告可以替换为函数引用的函数文字表达式。\n\n将 lambda 替换为函数引用通常会使代码看起来更简洁易懂。\n\n**示例：**\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter { it.isEven() }\n      }\n\n在应用快速修复后：\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter(Int::isEven)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertLambdaToReference",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSetter",
                "shortDescription": {
                  "text": "冗余属性 setter"
                },
                "fullDescription": {
                  "text": "报告冗余属性 setter。 在以下情况之一中，setter 被认为是冗余的： setter 没有主体。 访问器可见性未更改，声明不是 'external' 并且没有注解。 'var myPropWithRedundantSetter: Int = 0\n      set // redundant\n\n  var myPropA: Int = 0\n      private set // 可以 - 属性可见性被更改为 private\n\n  var myPropB: Int = 0\n      external set // 可以 - 未在 Kotlin 中实现（外部）\n\n  var myPropC: Int = 0\n      @Inject set // 可以 - 访问器被注解' setter 主体是一个具有单语句的块，其将形参分配给支持字段。 'var prop: Int = 0\n      set(value) { // 冗余\n          field = value\n      }'",
                  "markdown": "报告冗余属性 setter。\n\n\n在以下情况之一中，setter 被认为是冗余的：\n\n1. setter 没有主体。 访问器可见性未更改，声明不是 `external` 并且没有注解。\n\n\n         var myPropWithRedundantSetter: Int = 0\n             set // redundant\n\n         var myPropA: Int = 0\n             private set // 可以 - 属性可见性被更改为 private\n\n         var myPropB: Int = 0\n             external set // 可以 - 未在 Kotlin 中实现（外部）\n\n         var myPropC: Int = 0\n             @Inject set // 可以 - 访问器被注解\n               \n2. setter 主体是一个具有单语句的块，其将形参分配给支持字段。\n\n\n         var prop: Int = 0\n             set(value) { // 冗余\n                 field = value\n             }\n              \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantSetter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncompleteDestructuring",
                "shortDescription": {
                  "text": "析构声明不完整"
                },
                "fullDescription": {
                  "text": "报告不完整的析构声明。 示例： 'data class Person(val name: String, val age: Int)\n  val person = Person(\"\", 0)\n  val (name) = person' 该快速修复会使用新变量完成析构声明： 'data class Person(val name: String, val age: Int)\n  val person = Person(\"\", 0)\n  val (name, age) = person'",
                  "markdown": "报告不完整的析构声明。\n\n**示例：**\n\n\n      data class Person(val name: String, val age: Int)\n      val person = Person(\"\", 0)\n      val (name) = person\n\n该快速修复会使用新变量完成析构声明：\n\n\n      data class Person(val name: String, val age: Int)\n      val person = Person(\"\", 0)\n      val (name, age) = person\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncompleteDestructuring",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ScopeFunctionConversion",
                "shortDescription": {
                  "text": "作用域函数可以转换为另一个"
                },
                "fullDescription": {
                  "text": "报告可彼此转换的范围函数（'let'、'run'、'apply'、'also'）。 使用相应函数可使代码更简单。 该快速修复会在范围函数之间彼此替换。 示例： 'val x = \"\".let {\n      it.length\n  }' 在应用快速修复后： 'val x = \"\".run {\n      length\n  }'",
                  "markdown": "报告可彼此转换的范围函数（`let`、`run`、`apply`、`also`）。\n\n使用相应函数可使代码更简单。\n\n该快速修复会在范围函数之间彼此替换。\n\n**示例：**\n\n\n      val x = \"\".let {\n          it.length\n      }\n\n在应用快速修复后：\n\n\n      val x = \"\".run {\n          length\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ScopeFunctionConversion",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrailingComma",
                "shortDescription": {
                  "text": "尾随逗号推荐"
                },
                "fullDescription": {
                  "text": "报告未遵循建议的样式指南的尾随逗号。",
                  "markdown": "报告未遵循建议的[样式指南](https://kotlinlang.org/docs/coding-conventions.html#trailing-commas)的尾随逗号。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TrailingComma",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FoldInitializerAndIfToElvis",
                "shortDescription": {
                  "text": "If-Null return/break/… 可折叠为 '?:'"
                },
                "fullDescription": {
                  "text": "报告在初始化后立即检查变量是否为 null 的 'if' 表达式，该表达式可以在初始值设定项中转换为 elvis 运算符。 示例： 'fun test(foo: Int?, bar: Int): Int {\n      var i = foo\n      if (i == null) {\n          return bar\n      }\n      return i\n  }' 该快速修复会将带有初始值设定项的 'if' 表达式转换为 elvis 表达式： 'fun test(foo: Int?, bar: Int): Int {\n      var i = foo ?: return bar\n      return i\n  }'",
                  "markdown": "报告在初始化后立即检查变量是否为 null 的 `if` 表达式，该表达式可以在初始值设定项中转换为 elvis 运算符。\n\n**示例：**\n\n\n      fun test(foo: Int?, bar: Int): Int {\n          var i = foo\n          if (i == null) {\n              return bar\n          }\n          return i\n      }\n\n该快速修复会将带有初始值设定项的 `if` 表达式转换为 elvis 表达式：\n\n\n      fun test(foo: Int?, bar: Int): Int {\n          var i = foo ?: return bar\n          return i\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FoldInitializerAndIfToElvis",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanSealedSubClassBeObject",
                "shortDescription": {
                  "text": "没有状态和重写的 equals 的 sealed 子类"
                },
                "fullDescription": {
                  "text": "报告没有状态和被重写的 'equals()' 方法的 'sealed' 类的直接继承者。 强烈建议重写 'equals()' 以提供比较稳定性，或将 'class' 转换为 'object' 以达到相同的效果。 示例： 'sealed class Receiver {\n      class Everyone : Receiver()\n      class User(val id: Int) : Receiver()\n  }' 该快速修复会将 'class' 转换为 'object'： 'sealed class Receiver {\n      object Everyone : Receiver()\n      class User(val id: Int) : Receiver()\n  }'",
                  "markdown": "报告没有状态和被重写的 `equals()` 方法的 `sealed` 类的直接继承者。\n\n强烈建议重写 `equals()` 以提供比较稳定性，或将 `class` 转换为 `object` 以达到相同的效果。\n\n**示例：**\n\n\n      sealed class Receiver {\n          class Everyone : Receiver()\n          class User(val id: Int) : Receiver()\n      }\n\n该快速修复会将 `class` 转换为 `object`：\n\n\n      sealed class Receiver {\n          object Everyone : Receiver()\n          class User(val id: Int) : Receiver()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CanSealedSubClassBeObject",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PropertyName",
                "shortDescription": {
                  "text": "属性命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循推荐命名约定的属性名称。 一致的命名会让阅读和理解代码变得更容易。 根据 Kotlin 官方样式指南，属性名称应以小写字母开头并使用驼峰拼写法。 可以通过更改“模式”正则表达式来引入其他命名规则。 示例： 'val My_Cool_Property = \"\"' 该快速修复会根据 Kotlin 命名约定重命名类： 'val myCoolProperty = \"\"'",
                  "markdown": "报告不遵循推荐命名约定的属性名称。\n\n\n一致的命名会让阅读和理解代码变得更容易。\n根据 [Kotlin 官方样式指南](https://kotlinlang.org/docs/coding-conventions.html#naming-rules)，属性名称应以小写字母开头并使用驼峰拼写法。\n\n可以通过更改\"模式\"正则表达式来引入其他命名规则。\n\n**示例：**\n\n\n      val My_Cool_Property = \"\"\n\n该快速修复会根据 Kotlin 命名约定重命名类：\n\n\n      val myCoolProperty = \"\"\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InlineClassDeprecatedMigration",
                "shortDescription": {
                  "text": "从 1.5 版本开始，内联类已弃用。"
                },
                "fullDescription": {
                  "text": "报告在 Kotlin 1.5 和更高版本中已弃用并会导致编译警告的内联类。 请参阅 Kotlin 1.5.0 最新变化 示例： 'inline class Password(val s: String)' 在应用快速修复后： '@JvmInline\n  value class Password(val s: String)' 从 1.5 版开始，可对 Kotlin 语言级别进行检查。",
                  "markdown": "报告在 Kotlin 1.5 和更高版本中已弃用并会导致编译警告的内联类。\n请参阅 [Kotlin 1.5.0 最新变化](https://kotlinlang.org/docs/whatsnew15.html#inline-classes)\n\n示例：\n\n\n      inline class Password(val s: String)\n\n在应用快速修复后：\n\n\n      @JvmInline\n      value class Password(val s: String)\n\n从 1.5 版开始，可对 Kotlin 语言级别进行检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InlineClassDeprecatedMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinMavenPluginPhase",
                "shortDescription": {
                  "text": "Kotlin Maven 插件配置错误"
                },
                "fullDescription": {
                  "text": "报告 kotlin-maven-plugin 配置问题",
                  "markdown": "报告 kotlin-maven-plugin 配置问题"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinMavenPluginPhase",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousNonLocalJump",
                "shortDescription": {
                  "text": "不明确的非局部 'break' 或 'continue'"
                },
                "fullDescription": {
                  "text": "报告类循环函数的 lambda 内的 'break' 或 'continue' 用法。 'break' 和 'continue' 关键字始终适用于实际循环（'for'、'while'、'do-while'）。 'break' 和 'continue' 从不适用于函数；例如，'break' 和 'continue' 不适用于 'forEach'、'filter'、'map'。 在类循环函数（如 'forEach'）内使用 'break'或 'continue' 可能会引起混淆。 该检查会建议添加标签，以澄清 'Break' 或 'Continue' 适用于哪条语句。 由于 Kotlin 没有类循环函数的概念，该检查将使用启发。 它假设没有 'callsInPlace(EXACTLY_ONCE)' 或 'callsInPlace(AT_LEAST_ONCE)' 其中一个约定的函数是类循环函数。 示例： 'for (file in files) {\n        file.readLines().forEach { line ->\n            if (line == commentMarkerLine) continue\n            println(line)\n        }\n    }' 该快速修复会添加澄清标签： 'loop@ for (file in files) {\n        file.readLines().forEach { line ->\n            if (line == commentMarkerLine) continue@loop\n            println(line)\n        }\n    }'",
                  "markdown": "报告类循环函数的 lambda 内的 `break` 或 `continue` 用法。\n\n\n`break` 和 `continue` 关键字始终适用于实际循环（`for`、`while`、`do-while`）。 `break` 和 `continue` 从不适用于函数；例如，`break` 和 `continue` 不适用于 `forEach`、`filter`、`map`。\n\n\n在类循环函数（如 `forEach`）内使用 `break`或 `continue` 可能会引起混淆。\n该检查会建议添加标签，以澄清 `Break` 或 `Continue` 适用于哪条语句。\n\n\n由于 Kotlin 没有类循环函数的概念，该检查将使用启发。 它假设没有 `callsInPlace(EXACTLY_ONCE)` 或 `callsInPlace(AT_LEAST_ONCE)` 其中一个约定的函数是类循环函数。\n\n**示例：**\n\n\n        for (file in files) {\n            file.readLines().forEach { line ->\n                if (line == commentMarkerLine) continue\n                println(line)\n            }\n        }\n\n该快速修复会添加澄清标签：\n\n\n        loop@ for (file in files) {\n            file.readLines().forEach { line ->\n                if (line == commentMarkerLine) continue@loop\n                println(line)\n            }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AmbiguousNonLocalJump",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithStringBuilderAppendRange",
                "shortDescription": {
                  "text": "JVM 上的 'StringBuilder.append(CharArray, offset, len)' 调用"
                },
                "fullDescription": {
                  "text": "报告 JVM 平台上应被替换为 'StringBuilder.appendRange(CharArray, startIndex, endIndex)' 函数调用的 'StringBuilder.append(CharArray, offset, len)' 函数调用。 'append' 函数在 JVM、JS 和 Native 平台上的行为不同，因此推荐使用 'appendRange' 函数。 示例： 'fun f(charArray: CharArray, offset: Int, len: Int): String {\n      return buildString {\n          append(charArray, offset, len)\n      }\n  }' 在应用快速修复后： 'fun f(charArray: CharArray, offset: Int, len: Int): String {\n      return buildString {\n          appendRange(charArray, offset, offset + len)\n      }\n  }'",
                  "markdown": "报告 JVM 平台上应被替换为 `StringBuilder.appendRange(CharArray, startIndex, endIndex)` 函数调用的 `StringBuilder.append(CharArray, offset, len)` 函数调用。\n\n`append` 函数在 JVM、JS 和 Native 平台上的行为不同，因此推荐使用 `appendRange` 函数。\n\n**示例：**\n\n\n      fun f(charArray: CharArray, offset: Int, len: Int): String {\n          return buildString {\n              append(charArray, offset, len)\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun f(charArray: CharArray, offset: Int, len: Int): String {\n          return buildString {\n              appendRange(charArray, offset, offset + len)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceWithStringBuilderAppendRange",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertToStringTemplate",
                "shortDescription": {
                  "text": "可以转换为字符串模板的字符串串联"
                },
                "fullDescription": {
                  "text": "报告可以转换为字符串模板的字符串串联。 建议使用字符串模板，因为这样会使代码更容易读取。 示例： 'fun example() {\n      val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n      for ((country, capital) in capitals) {\n          print(capital + \" is a capital of \" + country)\n      }\n  }' 在应用快速修复后： 'fun example() {\n      val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n      for ((country, capital) in capitals) {\n          print(\"$capital is a capital of $country\")\n      }\n  }'",
                  "markdown": "报告可以转换为字符串模板的字符串串联。\n\n建议使用字符串模板，因为这样会使代码更容易读取。\n\n**示例：**\n\n\n      fun example() {\n          val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n          for ((country, capital) in capitals) {\n              print(capital + \" is a capital of \" + country)\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun example() {\n          val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n          for ((country, capital) in capitals) {\n              print(\"$capital is a capital of $country\")\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertToStringTemplate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinInvalidBundleOrProperty",
                "shortDescription": {
                  "text": "无效属性健"
                },
                "fullDescription": {
                  "text": "报告 Kotlin 文件中未解析的 '.properties' 文件密钥和资源包引用。",
                  "markdown": "报告 Kotlin 文件中未解析的 `.properties` 文件密钥和资源包引用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "InvalidBundleOrProperty",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UselessCallOnCollection",
                "shortDescription": {
                  "text": "对集合类型的无用调用"
                },
                "fullDescription": {
                  "text": "报告标准库中已筛选的集合上的 'filter…' 调用。 只有在类型不同于结果类型的接收器上调用时，标准库中 'filterNotNull()' 或 'filterIsInstance' 之类的几个函数才有意义。 在其他情况下，可以忽略此类调用，因为结果将相同。 移除冗余调用快速修复可用于自动修正代码。 示例： 'fun test(list: List<String>) {\n      val x = list.filterNotNull() // 快速修复会简化为 'list'\n      val y = list.filterIsInstance<String>() // 快速修复会简化为 'list'\n  }'",
                  "markdown": "报告标准库中已筛选的集合上的 `filter...` 调用。\n\n只有在类型不同于结果类型的接收器上调用时，标准库中 `filterNotNull()` 或 `filterIsInstance` 之类的几个函数才有意义。 在其他情况下，可以忽略此类调用，因为结果将相同。\n\n**移除冗余调用**快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun test(list: List<String>) {\n          val x = list.filterNotNull() // 快速修复会简化为 'list'\n          val y = list.filterIsInstance<String>() // 快速修复会简化为 'list'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UselessCallOnCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableCall",
                "shortDescription": {
                  "text": "可以简化库函数调用"
                },
                "fullDescription": {
                  "text": "报告可替换为简化形式的库函数调用。 使用相应函数可使代码更简单。 该快速修复会在函数调用之间彼此替换。 示例： 'fun test(list: List<Any>) {\n      list.filter { it is String }\n  }' 在应用快速修复后： 'fun test(list: List<Any>) {\n      list.filterIsInstance<String>()\n  }'",
                  "markdown": "报告可替换为简化形式的库函数调用。\n\n使用相应函数可使代码更简单。\n\n该快速修复会在函数调用之间彼此替换。\n\n**示例：**\n\n\n      fun test(list: List<Any>) {\n          list.filter { it is String }\n      }\n\n在应用快速修复后：\n\n\n      fun test(list: List<Any>) {\n          list.filterIsInstance<String>()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifiableCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectLiteralToLambda",
                "shortDescription": {
                  "text": "对象文字可以转换为 lambda"
                },
                "fullDescription": {
                  "text": "报告使用单个 abstract 方法实现 Java 接口的匿名对象文字，该方法可使用 lambda 表达式转换为调用。 示例： 'class SomeService {\n  val threadPool = Executors.newCachedThreadPool()\n    \n  fun foo() {\n    threadPool.submit(object : Runnable {\n      override fun run() {\n        println(\"hello\")\n      }\n    })\n  }\n}' 在应用快速修复后： 'fun foo() {\n    threadPool.submit { println(\"hello\") }\n  }'",
                  "markdown": "报告使用单个 abstract 方法实现 Java 接口的匿名对象文字，该方法可使用 lambda 表达式转换为调用。\n\n**示例：**\n\n\n    class SomeService {\n      val threadPool = Executors.newCachedThreadPool()\n        \n      fun foo() {\n        threadPool.submit(object : Runnable {\n          override fun run() {\n            println(\"hello\")\n          }\n        })\n      }\n    }\n\n在应用快速修复后：\n\n\n      fun foo() {\n        threadPool.submit { println(\"hello\") }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectLiteralToLambda",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLambdaOrAnonymousFunction",
                "shortDescription": {
                  "text": "创建冗余 lambda 或匿名函数"
                },
                "fullDescription": {
                  "text": "报告立即创建和使用的 lambda 或匿名函数。 'fun test() {\n      ({ println() })() // 冗余\n      (fun() { println() })() // 冗余\n  }'",
                  "markdown": "报告立即创建和使用的 lambda 或匿名函数。\n\n\n      fun test() {\n          ({ println() })() // 冗余\n          (fun() { println() })() // 冗余\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLambdaOrAnonymousFunction",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantRequireNotNullCall",
                "shortDescription": {
                  "text": "冗余 'requireNotNull' 或 'checkNotNull' 调用"
                },
                "fullDescription": {
                  "text": "报告对不可为 null 表达式的冗余 'requireNotNull' 或 'checkNotNull' 调用。 示例： 'fun foo(i: Int) {\n      requireNotNull(i) //此 'i' 始终不为 null，因此该 'requireNotNull' 为冗余调用。\n      ...\n  }' 在应用快速修复后： 'fun foo(i: Int) {\n      ...\n  }'",
                  "markdown": "报告对不可为 null 表达式的冗余 `requireNotNull` 或 `checkNotNull` 调用。\n\n**示例：**\n\n\n      fun foo(i: Int) {\n          requireNotNull(i) //此 'i' 始终不为 null，因此该 'requireNotNull' 为冗余调用。\n          ...\n      }\n\n在应用快速修复后：\n\n\n      fun foo(i: Int) {\n          ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantRequireNotNullCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectPropertyName",
                "shortDescription": {
                  "text": "object 属性命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循命名约定的属性。 报告了以下属性： 顶级属性 对象和伴生对象中的属性 您可以在检查选项中指定所需的模式。 建议的命名约定：必须以大写字母开头，使用驼峰拼写法并且没有下划线。 示例： '// 顶级属性\n  val USER_NAME_FIELD = \"UserName\"\n  // 包含对单例对象的引用的顶级属性\n  val PersonComparator: Comparator<Person> = /*...*/\n\n  class Person {\n    companion object {\n      // 伴生对象中的属性\n      val NO_NAME = Person()\n    }\n  }'",
                  "markdown": "报告不遵循命名约定的属性。\n\n报告了以下属性：\n\n* 顶级属性\n* 对象和伴生对象中的属性\n\n您可以在检查选项中指定所需的模式。\n\n[建议的命名约定](https://kotlinlang.org/docs/coding-conventions.html#naming-rules)：必须以大写字母开头，使用驼峰拼写法并且没有下划线。\n\n**示例：**\n\n\n      // 顶级属性\n      val USER_NAME_FIELD = \"UserName\"\n      // 包含对单例对象的引用的顶级属性\n      val PersonComparator: Comparator<Person> = /*...*/\n\n      class Person {\n        companion object {\n          // 伴生对象中的属性\n          val NO_NAME = Person()\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectPropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageDirectoryMismatch",
                "shortDescription": {
                  "text": "软件包名称与包含的目录不匹配"
                },
                "fullDescription": {
                  "text": "报告与文件位置不匹配的 'package' 指令。 在应用修正时，“移动重构”默认值用于更新已更改声明的用法，即： 搜索注释和文本 搜索文本匹配项",
                  "markdown": "报告与文件位置不匹配的 `package` 指令。\n\n\n在应用修正时，\"移动重构\"默认值用于更新已更改声明的用法，即：\n\n* 搜索注释和文本\n* 搜索文本匹配项"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PackageDirectoryMismatch",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 互操作问题",
                      "index": 67,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertObjectToDataObject",
                "shortDescription": {
                  "text": "将 'object' 转换为 'data object'"
                },
                "fullDescription": {
                  "text": "报告可转换为 'data object' 的 'object' 'data object' 会自动生成 'toString'、'equals' 和 'hashCode' 该检查会在以下 2 中情况下建议将 'object' 转换为 'data object'： 当自定义 'toString' 返回类的名称时 当 'object' 继承 sealed 'class'/'interface' 时 示例： 'object Foo {\n        override fun toString(): String = \"Foo\"\n    }' 在应用快速修复后： '数据对象 Foo' 仅当项目或模块的 Kotlin 语言级别为 1.9 或更高时，此检查才会报告",
                  "markdown": "报告可转换为 `data object` 的 `object`\n\n`data object` 会自动生成 `toString`、`equals` 和 `hashCode`\n\n该检查会在以下 2 中情况下建议将 `object` 转换为 `data object`：\n\n* 当自定义 `toString` 返回类的名称时\n* 当 `object` 继承 sealed `class`/`interface` 时\n\n**示例：**\n\n\n        object Foo {\n            override fun toString(): String = \"Foo\"\n        }\n\n在应用快速修复后：\n\n\n        数据对象 Foo\n\n仅当项目或模块的 Kotlin 语言级别为 1.9 或更高时，此检查才会报告"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertObjectToDataObject",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanLiteralArgument",
                "shortDescription": {
                  "text": "不包含形参名称的布尔文字实参"
                },
                "fullDescription": {
                  "text": "报告类型为 'Boolean' 但未指定显式形参名称的调用实参。 按顺序传递多个布尔文字时，很容易忘记形参顺序，这可能会导致错误。 显式形参名称让阅读和理解代码变得更容易。 示例： 'fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n  fun usage() {\n      check(true, false, true) //这是什么意思？\n  }' 该快速修复会添加缺少的形参名称： 'fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n  fun usage() {\n      check(checkName = true, checkAddress = false, checkPhone = true)\n  }'",
                  "markdown": "报告类型为 `Boolean` 但未指定显式形参名称的调用实参。\n\n\n按顺序传递多个布尔文字时，很容易忘记形参顺序，这可能会导致错误。\n显式形参名称让阅读和理解代码变得更容易。\n\n**示例：**\n\n\n      fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n      fun usage() {\n          check(true, false, true) //这是什么意思？\n      }\n\n该快速修复会添加缺少的形参名称：\n\n\n      fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n      fun usage() {\n          check(checkName = true, checkAddress = false, checkPhone = true)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "BooleanLiteralArgument",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertArgumentToSet",
                "shortDescription": {
                  "text": "实参可以转换为 'Set' 以提高性能"
                },
                "fullDescription": {
                  "text": "检测可以通过将实参转换为 'Set' 而加快速度的函数调用。 当实参为集合时，'minus' 或 'intersect' 等运算更高效。 将 'Iterable<T>' 或 'Array<T>' 显式转换为 'Set<T>' 通常可以提高代码效率。 该快速修复会向函数调用添加显式转换。 示例： 'fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n      a.intersect(b).size' 在应用快速修复后： 'fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n      a.intersect(b.toSet()).size'",
                  "markdown": "检测可以通过将实参转换为 `Set` 而加快速度的函数调用。\n\n\n当实参为集合时，'minus' 或 'intersect' 等运算更高效。\n将 `Iterable<T>` 或 `Array<T>` 显式转换为 `Set<T>` 通常可以提高代码效率。\n\n\n该快速修复会向函数调用添加显式转换。\n\n**示例：**\n\n\n      fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n          a.intersect(b).size\n\n在应用快速修复后：\n\n\n      fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n          a.intersect(b.toSet()).size\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertArgumentToSet",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinCovariantEquals",
                "shortDescription": {
                  "text": "协变 'equals()'"
                },
                "fullDescription": {
                  "text": "报告当该类没有另一个采用 'Any?' 作为其实参类型的 'equals()' 时，采用除 'Any?' 以外的实参类型的 'equals()'。 示例： 'class Foo {\n      fun equals(other: Foo?): Boolean {\n          return true\n      }\n  }' 要修正此问题，请创建采用 'Any?' 类型实参的 'equals()' 方法。",
                  "markdown": "报告当该类没有另一个采用 `Any?` 作为其实参类型的 `equals()` 时，采用除 `Any?` 以外的实参类型的 `equals()`。\n\n**示例：**\n\n\n      class Foo {\n          fun equals(other: Foo?): Boolean {\n              return true\n          }\n      }\n\n要修正此问题，请创建采用 `Any?` 类型实参的 `equals()` 方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CovariantEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSizeZeroCheckWithIsEmpty",
                "shortDescription": {
                  "text": "零大小检查可被替换为 'isEmpty()'"
                },
                "fullDescription": {
                  "text": "报告应替换为 'isEmpty()' 的 'Collections/Array/String' 的 'size == 0' 检查。 使用 'isEmpty()' 可使代码更简单。 该快速修复会将大小检查替换为 'isEmpty()'。 示例： 'fun foo() {\n      val arrayOf = arrayOf(1, 2, 3)\n      arrayOf.size == 0\n  }' 在应用快速修复后： 'fun foo() {\n      val arrayOf = arrayOf(1, 2, 3)\n      arrayOf.isEmpty()\n  }'",
                  "markdown": "报告应替换为 `isEmpty()` 的 `Collections/Array/String` 的 `size == 0` 检查。\n\n使用 `isEmpty()` 可使代码更简单。\n\n该快速修复会将大小检查替换为 `isEmpty()`。\n\n**示例：**\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.size == 0\n      }\n\n在应用快速修复后：\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.isEmpty()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSizeZeroCheckWithIsEmpty",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceGuardClauseWithFunctionCall",
                "shortDescription": {
                  "text": "临界子句可被替换为 Kotlin 的函数调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为函数调用的临界子句。 示例： 'fun test(foo: Int?) {\n      if (foo == null) throw IllegalArgumentException(\"foo\") // 可替换的子句\n  }' 在应用快速修复后： 'fun test(foo: Int?) {\n      checkNotNull(foo)\n  }'",
                  "markdown": "报告可以替换为函数调用的临界子句。\n\n**示例：**\n\n      fun test(foo: Int?) {\n          if (foo == null) throw IllegalArgumentException(\"foo\") // 可替换的子句\n      }\n\n在应用快速修复后：\n\n      fun test(foo: Int?) {\n          checkNotNull(foo)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceGuardClauseWithFunctionCall",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousExpressionInWhenBranchMigration",
                "shortDescription": {
                  "text": "自 1.7 起 'when' 分支中不明确的逻辑表达式"
                },
                "fullDescription": {
                  "text": "报告会在 Kotlin 1.8 及更高版本中导致编译错误的 'when' 分支中的模糊逻辑表达式。 'fun Int.matches(strict: Boolean): Boolean = when (strict) {\n      true -> this == 6\n      this in (4..7) -> true // 不明确\n      else -> false\n  }' 在应用快速修复后： 'fun Int.matches(strict: Boolean): Boolean = when (strict) {\n      true -> this == 6\n      (this in (4..7)) -> true // 包装在圆括号中\n      else -> false\n  }' 从 1.7 版开始，可对 Kotlin 语言级别进行检查。",
                  "markdown": "报告会在 Kotlin 1.8 及更高版本中导致编译错误的 `when` 分支中的模糊逻辑表达式。\n\n\n      fun Int.matches(strict: Boolean): Boolean = when (strict) {\n          true -> this == 6\n          this in (4..7) -> true // 不明确\n          else -> false\n      }\n\n在应用快速修复后：\n\n\n      fun Int.matches(strict: Boolean): Boolean = when (strict) {\n          true -> this == 6\n          (this in (4..7)) -> true // 包装在圆括号中\n          else -> false\n      }\n\n从 1.7 版开始，可对 Kotlin 语言级别进行检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AmbiguousExpressionInWhenBranchMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEnumConstructorInvocation",
                "shortDescription": {
                  "text": "冗余枚举构造函数调用"
                },
                "fullDescription": {
                  "text": "报告枚举条目上的冗余构造函数调用。 示例： 'enum class Baz(i: Int = 0) {\n      A(1),\n      B(),\n      C(),\n  }' 在应用快速修复后： 'enum class Baz(i: Int = 0) {\n      A(1),\n      B,\n      C,\n  }'",
                  "markdown": "报告枚举条目上的冗余构造函数调用。\n\n**示例：**\n\n\n      enum class Baz(i: Int = 0) {\n          A(1),\n          B(),\n          C(),\n      }\n\n在应用快速修复后：\n\n\n      enum class Baz(i: Int = 0) {\n          A(1),\n          B,\n          C,\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantEnumConstructorInvocation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceToStringWithStringTemplate",
                "shortDescription": {
                  "text": "'toString' 的调用可被替换为字符串模板"
                },
                "fullDescription": {
                  "text": "报告可以替换为字符串模板的 'toString' 函数调用。 使用字符串模板可使代码更简单。 该快速修复会将 'toString' 替换为字符串模板。 示例： 'fun test(): String {\n      val x = 1\n      return x.toString()\n  }' 在应用快速修复后： 'fun test(): String {\n      val x = 1\n      return \"$x\"\n  }'",
                  "markdown": "报告可以替换为字符串模板的 `toString` 函数调用。\n\n使用字符串模板可使代码更简单。\n\n该快速修复会将 `toString` 替换为字符串模板。\n\n**示例：**\n\n\n      fun test(): String {\n          val x = 1\n          return x.toString()\n      }\n\n在应用快速修复后：\n\n\n      fun test(): String {\n          val x = 1\n          return \"$x\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceToStringWithStringTemplate",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedInFinal",
                "shortDescription": {
                  "text": "'protected' 可见性在 final 类中实际是 'private'"
                },
                "fullDescription": {
                  "text": "报告在 'final' 类内部使用的 'protected' 可见性。 在这种情况下，'protected' 成员只能在类本身中访问，因此它们实际上是 'private'。 示例： 'class FinalClass {\n      protected fun foo() {}\n  }' 在应用快速修复后： 'class FinalClass {\n      private fun foo() {}\n  }'",
                  "markdown": "报告在 `final` 类内部使用的 `protected` 可见性。 在这种情况下，`protected` 成员只能在类本身中访问，因此它们实际上是 `private`。\n\n**示例：**\n\n\n      class FinalClass {\n          protected fun foo() {}\n      }\n\n在应用快速修复后：\n\n\n      class FinalClass {\n          private fun foo() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ProtectedInFinal",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FakeJvmFieldConstant",
                "shortDescription": {
                  "text": "Kotlin 非 const 属性用作 Java 常量"
                },
                "fullDescription": {
                  "text": "报告不是 'const' 并用作 Java 注解实参的 Kotlin 属性。 例如，具有 '@JvmField' 注解的属性有一个可以在编译时评估的初始值设定项，它有一个基元类型或 'String' 类型。 此类属性在 Kotlin 1.1-1.2 中的字节码中具有 'ConstantValue' 特性。 此特性允许 javac 折叠相应字段的用法并在注解中使用该字段。 在混合 Java/Kotlin 代码中单独或增量编译的情况下，这可能导致错误行为。 此行为在 Kotlin 1.3 中可能发生变化（不再有 'ConstantValue' 特性）。 示例： foo.kt 文件中的 Kotlin 代码： 'annotation class Ann(val s: String)\n  @JvmField val importantString = \"important\"' Java 代码： 'public class JavaUser {\n      // 这很危险\n      @Ann(s = FooKt.importantString)\n      public void foo() {}\n  }' 要修正此问题，请将 '@JvmField' 注解替换为相关 Kotlin 属性上的 'const' 修饰符或将其内联。",
                  "markdown": "报告不是 `const` 并用作 Java 注解实参的 Kotlin 属性。\n\n\n例如，具有 `@JvmField` 注解的属性有一个可以在编译时评估的初始值设定项，它有一个基元类型或 `String` 类型。\n\n\n此类属性在 Kotlin 1.1-1.2 中的字节码中具有 `ConstantValue` 特性。\n此特性允许 javac 折叠相应字段的用法并在注解中使用该字段。\n在混合 Java/Kotlin 代码中单独或增量编译的情况下，这可能导致错误行为。\n此行为在 Kotlin 1.3 中可能发生变化（不再有 `ConstantValue` 特性）。\n\n**示例：**\n\nfoo.kt 文件中的 Kotlin 代码：\n\n\n      annotation class Ann(val s: String)\n      @JvmField val importantString = \"important\"\n\nJava 代码：\n\n\n      public class JavaUser {\n          // 这很危险\n          @Ann(s = FooKt.importantString)\n          public void foo() {}\n      }\n\n要修正此问题，请将 `@JvmField` 注解替换为相关 Kotlin 属性上的 `const` 修饰符或将其内联。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FakeJvmFieldConstant",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 互操作问题",
                      "index": 67,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhenWithOnlyElse",
                "shortDescription": {
                  "text": "'when' 仅包含 'else' 分支且可以简化"
                },
                "fullDescription": {
                  "text": "报告只有一个 'else' 分支且可以简化的 'when' 表达式。 简化表达式快速修复可用于自动修正代码。 示例： 'fun redundant() {\n      val x = when { // <== 冗余，快速修复会将 when 表达式简化为 \"val x = 1\"\n          else -> 1\n      }\n  }'",
                  "markdown": "报告只有一个 `else` 分支且可以简化的 `when` 表达式。\n\n**简化表达式**快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun redundant() {\n          val x = when { // <== 冗余，快速修复会将 when 表达式简化为 \"val x = 1\"\n              else -> 1\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WhenWithOnlyElse",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceRangeStartEndInclusiveWithFirstLast",
                "shortDescription": {
                  "text": "装箱的属性应替换为未装箱的属性"
                },
                "fullDescription": {
                  "text": "报告装箱的 'Range.start' 和 'Range.endInclusive' 属性。 这些属性可替换为未装箱的 'first' 和 'last' 属性以避免冗余调用。 该快速修复会将 'start' 和 'endInclusive' 属性替换为相应的 'first' 和 'last'。 示例： 'fun foo(range: CharRange) {\n      val lastElement = range.endInclusive\n  }' 在应用快速修复后： 'fun foo(range: CharRange) {\n      val lastElement = range.last\n  }'",
                  "markdown": "报告**装箱的** `Range.start` 和 `Range.endInclusive` 属性。\n\n这些属性可替换为**未装箱的** `first` 和 `last` 属性以避免冗余调用。\n\n该快速修复会将 `start` 和 `endInclusive` 属性替换为相应的 `first` 和 `last`。\n\n**示例：**\n\n\n      fun foo(range: CharRange) {\n          val lastElement = range.endInclusive\n      }\n\n在应用快速修复后：\n\n\n      fun foo(range: CharRange) {\n          val lastElement = range.last\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceRangeStartEndInclusiveWithFirstLast",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSizeCheckWithIsNotEmpty",
                "shortDescription": {
                  "text": "大小检查可被替换为 'isNotEmpty()'"
                },
                "fullDescription": {
                  "text": "报告应替换为 'isNotEmpty()' 的 'Collections/Array/String' 的大小检查。 使用 'isNotEmpty()' 可使代码更简单。 该快速修复会将大小检查替换为 'isNotEmpty()'。 示例： 'fun foo() {\n      val arrayOf = arrayOf(1, 2, 3)\n      arrayOf.size > 0\n  }' 在应用快速修复后： 'fun foo() {\n      val arrayOf = arrayOf(1, 2, 3)\n      arrayOf.isNotEmpty()\n  }'",
                  "markdown": "报告应替换为 `isNotEmpty()` 的 `Collections/Array/String` 的大小检查。\n\n使用 `isNotEmpty()` 可使代码更简单。\n\n该快速修复会将大小检查替换为 `isNotEmpty()`。\n\n**示例：**\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.size > 0\n      }\n\n在应用快速修复后：\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.isNotEmpty()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSizeCheckWithIsNotEmpty",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSemicolon",
                "shortDescription": {
                  "text": "冗余分号"
                },
                "fullDescription": {
                  "text": "报告可以安全移除的冗余分号 (';')。 Kotlin 不要求在每个语句或表达式的末尾使用分号。 建议使用该快速修复移除冗余的分号。 示例： 'val myMap = mapOf(\"one\" to 1, \"two\" to 2);\n  myMap.forEach { (key, value) ->  print(\"$key -> $value\")};' 在应用快速修复后： 'val myMap = mapOf(\"one\" to 1, \"two\" to 2)\n  myMap.forEach { (key, value) ->  print(\"$key -> $value\")}' 有两种情况需要使用分号： 放在一个行里的多个语句需要用分号隔开： 'map.forEach { val (key, value) = it; println(\"$key -> $value\") }' 同时声明了属性或函数的 'enum' 类要求在枚举常量列表后加一个分号： 'enum class Mode {\n      SILENT, VERBOSE;\n\n      fun isSilent(): Boolean = this == SILENT\n  }'",
                  "markdown": "报告可以安全移除的冗余分号 (`;`)。\n\n\nKotlin 不要求在每个语句或表达式的末尾使用分号。\n建议使用该快速修复移除冗余的分号。\n\n**示例：**\n\n\n      val myMap = mapOf(\"one\" to 1, \"two\" to 2);\n      myMap.forEach { (key, value) ->  print(\"$key -> $value\")};\n\n在应用快速修复后：\n\n\n      val myMap = mapOf(\"one\" to 1, \"two\" to 2)\n      myMap.forEach { (key, value) ->  print(\"$key -> $value\")}\n\n有两种情况需要使用分号：\n\n1. 放在一个行里的多个语句需要用分号隔开：\n\n\n         map.forEach { val (key, value) = it; println(\"$key -> $value\") }\n\n2. 同时声明了属性或函数的 `enum` 类要求在枚举常量列表后加一个分号：\n\n\n         enum class Mode {\n             SILENT, VERBOSE;\n\n             fun isSilent(): Boolean = this == SILENT\n         }\n               \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSemicolon",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfixCallToOrdinary",
                "shortDescription": {
                  "text": "中缀调用可以是点调用"
                },
                "fullDescription": {
                  "text": "报告可以用点限定函数调用替换的中缀函数调用。 示例： '1 xor 2' '1.xor(2)'",
                  "markdown": "报告可以用点限定函数调用替换的中缀函数调用。\n\n示例：\n\n\n        1 xor 2\n\n\n        1.xor(2)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "InfixCallToOrdinary",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/代码迁移",
                      "index": 86,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntroduceWhenSubject",
                "shortDescription": {
                  "text": "可以通过引入实参简化的 'when'"
                },
                "fullDescription": {
                  "text": "报告可以通过引入主体实参进行简化的 'when' 表达式。 示例： 'fun test(obj: Any): String {\n      return when {\n          obj is String -> \"string\"\n          obj is Int -> \"int\"\n          else -> \"unknown\"\n      }\n  }' 该快速修复会引入一个主体实参： 'fun test(obj: Any): String {\n      return when (obj) {\n          is String -> \"string\"\n          is Int -> \"int\"\n          else -> \"unknown\"\n      }\n  }'",
                  "markdown": "报告可以通过引入主体实参进行简化的 `when` 表达式。\n\n**示例：**\n\n\n      fun test(obj: Any): String {\n          return when {\n              obj is String -> \"string\"\n              obj is Int -> \"int\"\n              else -> \"unknown\"\n          }\n      }\n\n该快速修复会引入一个主体实参：\n\n\n      fun test(obj: Any): String {\n          return when (obj) {\n              is String -> \"string\"\n              is Int -> \"int\"\n              else -> \"unknown\"\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IntroduceWhenSubject",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinTestJUnit",
                "shortDescription": {
                  "text": "kotlin-test-junit 可以使用"
                },
                "fullDescription": {
                  "text": "报告 'kotlin-test' 和 'junit' 依赖项（无 'kotlin-test-junit'）的用法。 建议使用 'kotlin-test-junit' 依赖项来处理 Kotlin 和 JUnit。",
                  "markdown": "报告 `kotlin-test` 和 `junit` 依赖项（无 `kotlin-test-junit`）的用法。\n\n建议使用 `kotlin-test-junit` 依赖项来处理 Kotlin 和 JUnit。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinTestJUnit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SafeCastWithReturn",
                "shortDescription": {
                  "text": "带有 'return' 的安全转换应替换为 'if' 类型检查"
                },
                "fullDescription": {
                  "text": "报告带 'return' 且可以替换为 'if' 类型检查的安全转换。 使用相应函数可使代码更简单。 该快速修复会将安全转换替换为 'if' 类型检查。 示例： 'fun test(x: Any) {\n      x as? String ?: return\n  }' 在应用快速修复后： 'fun test(x: Any) {\n      if (x !is String) return\n  }'",
                  "markdown": "报告带 `return` 且可以替换为 `if` 类型检查的安全转换。\n\n使用相应函数可使代码更简单。\n\n该快速修复会将安全转换替换为 `if` 类型检查。\n\n**示例：**\n\n\n      fun test(x: Any) {\n          x as? String ?: return\n      }\n\n在应用快速修复后：\n\n\n      fun test(x: Any) {\n          if (x !is String) return\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SafeCastWithReturn",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedCallableAddReplaceWith",
                "shortDescription": {
                  "text": "不包含 'replaceWith' 实参的 @Deprecated 注解"
                },
                "fullDescription": {
                  "text": "报告在其 'kotlin.deprecated' 注解中没有 'kotlin.ReplaceWith' 实参的已弃用函数和属性，IDE 会建议根据它们的主体进行添加。 Kotlin 提供 'ReplaceWith' 实参来自动替换已弃用的声明。 建议使用实参来修正代码中的弃用问题。 示例： '@Deprecated(\"Use refined() instead.\")\n  fun deprecated() = refined()\n\n  fun refined() = 42' 该快速修复会添加 'ReplaceWith()' 实参： '@Deprecated(\"Use refined() instead.\", ReplaceWith(\"refined()\"))\n  fun deprecated() = refined()\n\n  fun refined() = 42'",
                  "markdown": "报告在其 `kotlin.deprecated` 注解中没有 `kotlin.ReplaceWith` 实参的已弃用函数和属性，IDE 会建议根据它们的主体进行添加。\n\n\nKotlin 提供 `ReplaceWith` 实参来自动替换已弃用的声明。\n建议使用实参来修正代码中的弃用问题。\n\n**示例：**\n\n\n      @Deprecated(\"Use refined() instead.\")\n      fun deprecated() = refined()\n\n      fun refined() = 42\n\n该快速修复会添加 `ReplaceWith()` 实参：\n\n\n      @Deprecated(\"Use refined() instead.\", ReplaceWith(\"refined()\"))\n      fun deprecated() = refined()\n\n      fun refined() = 42\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DeprecatedCallableAddReplaceWith",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAssertBooleanWithAssertEquality",
                "shortDescription": {
                  "text": "断言布尔可被替换为断言等式"
                },
                "fullDescription": {
                  "text": "报告对可以替换为断言相等函数的 'assertTrue()' 和 'assertFalse()' 的调用。 'assertEquals()'、'assertSame()' 及其否定对应项 (-Not-) 可以提供有关失败的更多信息。 示例： 'assertTrue(a == b)' 在应用快速修复后： 'assertEquals(a, b)'",
                  "markdown": "报告对可以替换为断言相等函数的 `assertTrue()` 和 `assertFalse()` 的调用。\n\n\n`assertEquals()`、`assertSame()` 及其否定对应项 (-Not-) 可以提供有关失败的更多信息。\n\n**示例：**\n\n      assertTrue(a == b)\n\n在应用快速修复后：\n\n      assertEquals(a, b)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceAssertBooleanWithAssertEquality",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryOptInAnnotation",
                "shortDescription": {
                  "text": "不必要的 '@OptIn' 注解"
                },
                "fullDescription": {
                  "text": "报告不必要并可以安全删除的选择加入注解。 使用实验性 API 的代码需要 '@OptIn' 注解，因为这些 API 将来随时都可能更改。 如果此类 API 未使用（例如，当实验性 API 稳定后，就不再要求选择加入了），此注解将变得没有意义，且可能具有误导性。 移除注解快速修复可用于移除不必要的 '@OptIn' 注解。 示例： '@OptIn(ExperimentalApi::class)\n  fun foo(x: Bar) {\n      x.baz()\n  }' 在应用快速修复后： 'fun foo(x: Bar) {\n      x.baz()\n  }'",
                  "markdown": "报告不必要并可以安全删除的选择加入注解。\n\n使用实验性 API 的代码需要 `@OptIn` 注解，因为这些 API 将来随时都可能更改。 如果此类 API 未使用（例如，当实验性 API 稳定后，就不再要求选择加入了），此注解将变得没有意义，且可能具有误导性。\n\n\n**移除注解** 快速修复可用于移除不必要的 `@OptIn` 注解。\n\n示例：\n\n\n      @OptIn(ExperimentalApi::class)\n      fun foo(x: Bar) {\n          x.baz()\n      }\n\n在应用快速修复后：\n\n\n      fun foo(x: Bar) {\n          x.baz()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryOptInAnnotation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComplexRedundantLet",
                "shortDescription": {
                  "text": "基于实参的冗余 'let' 调用"
                },
                "fullDescription": {
                  "text": "报告基于实参的冗余 'let' 调用。 当 lambda 形参仅用作调用表达式中的限定符时，'let' 冗余。 如果需要为限定表达式命名，请声明一个局部变量。 示例： 'fun splitNumbers() {\n      \"1,2,3\".let { it.split(',') }\n  }' 该快速修复会移除额外的 'let()' 调用： 'fun example() {\n      \"1,2,3\".split(',')\n  }' 或者： 'fun splitNumbers() {\n      val numbers = \"1,2,3\"\n      numbers.split(',')\n  }'",
                  "markdown": "报告基于实参的冗余 `let` 调用。\n\n当 lambda 形参仅用作调用表达式中的限定符时，`let` 冗余。\n\n如果需要为限定表达式命名，请声明一个局部变量。\n\n**示例：**\n\n\n      fun splitNumbers() {\n          \"1,2,3\".let { it.split(',') }\n      }\n\n该快速修复会移除额外的 `let()` 调用：\n\n\n      fun example() {\n          \"1,2,3\".split(',')\n      }\n\n或者：\n\n\n      fun splitNumbers() {\n          val numbers = \"1,2,3\"\n          numbers.split(',')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ComplexRedundantLet",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveRedundantSpreadOperator",
                "shortDescription": {
                  "text": "冗余展开运算符"
                },
                "fullDescription": {
                  "text": "报告针对一系列 'arrayOf' 函数调用而使用冗余展开运算符的情况。 使用“移除冗余展开运算符”快速修复可清理代码。 示例： 'fun foo(vararg s: String) { }\n\n  fun bar(ss: Array<String>) {\n      foo(*arrayOf(\"abc\"))       // 对于 'foo' 的两次调用，数组创建\n      foo(*arrayOf(*ss, \"zzz\"))  // 及其后续分配均冗余\n  }' 在应用快速修复后： 'fun foo(vararg s: String) { }\n\n  fun bar(ss: Array<String>) {\n      foo(\"abc\")\n      foo(*ss, \"zzz\")\n  }'",
                  "markdown": "报告针对一系列 `arrayOf` 函数调用而使用冗余展开运算符的情况。\n\n使用\"移除冗余展开运算符\"快速修复可清理代码。\n\n**示例：**\n\n\n      fun foo(vararg s: String) { }\n\n      fun bar(ss: Array<String>) {\n          foo(*arrayOf(\"abc\"))       // 对于 'foo' 的两次调用，数组创建\n          foo(*arrayOf(*ss, \"zzz\"))  // 及其后续分配均冗余\n      }\n\n在应用快速修复后：\n\n\n      fun foo(vararg s: String) { }\n\n      fun bar(ss: Array<String>) {\n          foo(\"abc\")\n          foo(*ss, \"zzz\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveRedundantSpreadOperator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonVarPropertyInExternalInterface",
                "shortDescription": {
                  "text": "external 接口包含 val 属性"
                },
                "fullDescription": {
                  "text": "报告外部接口中的非 var 属性。 在迁移指南中阅读更多信息。",
                  "markdown": "报告外部接口中的非 var 属性。 在[迁移指南](https://kotlinlang.org/docs/js-ir-migration.html#convert-properties-of-external-interfaces-to-var)中阅读更多信息。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonVarPropertyInExternalInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProhibitJvmOverloadsOnConstructorsOfAnnotationClassesMigration",
                "shortDescription": {
                  "text": "从 1.4 起，'@JvmOverloads' 注解无法用于注解类的构造函数"
                },
                "fullDescription": {
                  "text": "报告注解类的构造函数的 '@JvmOverloads'，因为其毫无意义。 生成的字节码和 Kotlin 元数据中没有 '@JvmOverloads' 的占用空间，因此 '@JvmOverloads' 不会影响生成的字节码和代码行为。 自 Kotlin 1.4 起，注解类构造函数上的 '@JvmOverloads' 会导致编译错误。 示例： 'annotation class A @JvmOverloads constructor(val x: Int = 1)' 在应用快速修复后： 'annotation class A constructor(val x: Int = 1)'",
                  "markdown": "报告注解类的构造函数的 `@JvmOverloads`，因为其毫无意义。\n\n\n生成的字节码和 Kotlin 元数据中没有 `@JvmOverloads` 的占用空间，因此 `@JvmOverloads` 不会影响生成的字节码和代码行为。\n\n自 Kotlin 1.4 起，注解类构造函数上的 `@JvmOverloads` 会导致编译错误。\n\n**示例：**\n\n\n      annotation class A @JvmOverloads constructor(val x: Int = 1)\n\n在应用快速修复后：\n\n\n      annotation class A constructor(val x: Int = 1)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ProhibitJvmOverloadsOnConstructorsOfAnnotationClassesMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveSetterParameterType",
                "shortDescription": {
                  "text": "冗余 setter 形参类型"
                },
                "fullDescription": {
                  "text": "报告在属性 setter 中明确指定的形参类型。 setter 形参类型始终与属性类型匹配，因此不要求为显式。 “移除显式类型规范”快速修复允许相应地修改代码。 示例： 'fun process(x: Int) {}\n\n  var x: Int = 0\n      set(value: Int) = process(value) // <== 'Int' 规格可以安全忽略' 在应用快速修复后： 'fun process(x: Int) {}\n\n  var x: Int = 0\n      set(value) = process(value)'",
                  "markdown": "报告在属性 setter 中明确指定的形参类型。\n\n\nsetter 形参类型始终与属性类型匹配，因此不要求为显式。\n\"移除显式类型规范\"快速修复允许相应地修改代码。\n\n**示例：**\n\n\n      fun process(x: Int) {}\n\n      var x: Int = 0\n          set(value: Int) = process(value) // <== 'Int' 规格可以安全忽略\n\n在应用快速修复后：\n\n\n      fun process(x: Int) {}\n\n      var x: Int = 0\n          set(value) = process(value)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveSetterParameterType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectPrivatePropertyName",
                "shortDescription": {
                  "text": "对象 private 属性命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循命名约定的属性。 报告了以下属性： 对象和伴生对象中的 private 属性 您可以在检查选项中指定所需的模式。 建议的命名约定：必须以下划线或大写字母开头，使用驼峰拼写法。 示例： 'class Person {\n    companion object {\n      // 伴生对象中的属性\n      private val NO_NAME = Person()\n    }\n  }'",
                  "markdown": "报告不遵循命名约定的属性。\n\n报告了以下属性：\n\n* 对象和伴生对象中的 private 属性\n\n您可以在检查选项中指定所需的模式。\n\n[建议的命名约定](https://kotlinlang.org/docs/coding-conventions.html#naming-rules)：必须以下划线或大写字母开头，使用驼峰拼写法。\n\n**示例：**\n\n\n      class Person {\n        companion object {\n          // 伴生对象中的属性\n          private val NO_NAME = Person()\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectPrivatePropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfThenToElvis",
                "shortDescription": {
                  "text": "If-Then 可折叠为 '?:'"
                },
                "fullDescription": {
                  "text": "报告可以折叠到 elvis ('?:') 表达式中的 'if-then' 表达式。 示例： 'fun maybeFoo(): String? = \"foo\"\n\n  var foo = maybeFoo()\n  val bar = if (foo == null) \"hello\" else foo' 该快速修复会将 'if-then' 表达式转换为 elvis ('?:') 表达式： 'fun maybeFoo(): String? = \"foo\"\n\n  var foo = maybeFoo()\n  val bar = foo ?: \"hello\"'",
                  "markdown": "报告可以折叠到 elvis (`?:`) 表达式中的 `if-then` 表达式。\n\n**示例：**\n\n\n      fun maybeFoo(): String? = \"foo\"\n\n      var foo = maybeFoo()\n      val bar = if (foo == null) \"hello\" else foo\n\n该快速修复会将 `if-then` 表达式转换为 elvis (`?:`) 表达式：\n\n\n      fun maybeFoo(): String? = \"foo\"\n\n      var foo = maybeFoo()\n      val bar = foo ?: \"hello\"\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfThenToElvis",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrapUnaryOperator",
                "shortDescription": {
                  "text": "模糊一元运算符与数字常量一同使用"
                },
                "fullDescription": {
                  "text": "报告后跟 '-1.inc()' 等点限定符的一元运算符。 '-1.inc()' 之类的代码可能会产生误导，因为 '-' 的优先级低于 '.inc()'。 因此，'-1.inc()' 计算结果为 '-2'，而非预期的 '0'。 使用 () 包装一元运算符和值快速修复可用于自动修正代码。",
                  "markdown": "报告后跟 `-1.inc()` 等点限定符的一元运算符。\n\n`-1.inc()` 之类的代码可能会产生误导，因为 `-` 的优先级低于 `.inc()`。\n因此，`-1.inc()` 计算结果为 `-2`，而非预期的 `0`。\n\n**使用 () 包装一元运算符和值**快速修复可用于自动修正代码。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WrapUnaryOperator",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConflictingExtensionProperty",
                "shortDescription": {
                  "text": "扩展属性与合成属性冲突"
                },
                "fullDescription": {
                  "text": "报告与那些从 Java 'get' 或 'set' 方法自动生成的合成属性相冲突的扩展属性。 应移除或重命名此类属性，以避免将来在编译器中进行更改时破坏代码。 该快速修复会删除扩展属性。 示例： 'val File.name: String\n      get() = getName()' 该快速修复会添加 '@Deprecated' 注解： '@Deprecated(\"Is replaced with automatic synthetic extension\", ReplaceWith(\"name\"), level = DeprecationLevel.HIDDEN)\n  val File.name: String\n      get() = getName()'",
                  "markdown": "报告与那些从 Java `get` 或 `set` 方法自动生成的合成属性相冲突的扩展属性。\n\n应移除或重命名此类属性，以避免将来在编译器中进行更改时破坏代码。\n\n该快速修复会删除扩展属性。\n\n**示例：**\n\n\n      val File.name: String\n          get() = getName()\n\n该快速修复会添加 `@Deprecated` 注解：\n\n\n      @Deprecated(\"Is replaced with automatic synthetic extension\", ReplaceWith(\"name\"), level = DeprecationLevel.HIDDEN)\n      val File.name: String\n          get() = getName()\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConflictingExtensionProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceStringFormatWithLiteral",
                "shortDescription": {
                  "text": "'String.format' 调用可被替换为字符串模板"
                },
                "fullDescription": {
                  "text": "报告可以替换为字符串模板的 'String.format' 调用。 使用字符串模板可使代码更简单。 该快速修复会将调用替换为字符串模板。 示例： 'fun main() {\n      val id = \"abc\"\n      val date = \"123\"\n      val s = String.format(\"%s_%s_%s\", id, date, id)\n  }' 在应用快速修复后： 'fun main() {\n      val id = \"abc\"\n      val date = \"123\"\n      val s = \"${id}_${date}_$id\"\n  }'",
                  "markdown": "报告可以替换为字符串模板的 `String.format` 调用。\n\n使用字符串模板可使代码更简单。\n\n该快速修复会将调用替换为字符串模板。\n\n**示例：**\n\n\n      fun main() {\n          val id = \"abc\"\n          val date = \"123\"\n          val s = String.format(\"%s_%s_%s\", id, date, id)\n      }\n\n在应用快速修复后：\n\n\n      fun main() {\n          val id = \"abc\"\n          val date = \"123\"\n          val s = \"${id}_${date}_$id\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceStringFormatWithLiteral",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceNotNullAssertionWithElvisReturn",
                "shortDescription": {
                  "text": "非 null 断言可被替换为 'return'"
                },
                "fullDescription": {
                  "text": "报告可以替换为 elvis 运算符和 return ('?: return') 的非 null 断言 ('!!') 调用。 非 null 断言会产生非预期的 NPE (NullPointerException)。 比较好的做法是避免使用 '!!'。 该快速修复会将非 null 断言替换为 'return' 或 'return null'。 示例： 'fun test(number: Int?) {\n      val x = number!!\n  }' 在应用快速修复后： 'fun test(number: Int?) {\n      val x = number ?: return\n  }'",
                  "markdown": "报告可以替换为 elvis 运算符和 return (`?: return`) 的非 null 断言 (`!!`) 调用。\n\n非 null 断言会产生非预期的 NPE (NullPointerException)。 比较好的做法是避免使用 `!!`。\n\n该快速修复会将非 null 断言替换为 `return` 或 `return null`。\n\n**示例：**\n\n\n      fun test(number: Int?) {\n          val x = number!!\n      }\n\n在应用快速修复后：\n\n\n      fun test(number: Int?) {\n          val x = number ?: return\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceNotNullAssertionWithElvisReturn",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithSubstringBefore",
                "shortDescription": {
                  "text": "'substring' 调用应被替换为 'substringBefore'"
                },
                "fullDescription": {
                  "text": "报告可以替换为 's.substringBefore(x)' 的 's.substring(0, s.indexOf(x))' 等调用。 使用 'substringBefore()' 可使代码更简单。 该快速修复会将 'substring' 调用替换为 'substringBefore'。 示例： 'fun foo(s: String) {\n      s.substring(0, s.indexOf('x'))\n  }' 在应用快速修复后： 'fun foo(s: String) {\n      s.substringBefore('x')\n  }'",
                  "markdown": "报告可以替换为 `s.substringBefore(x)` 的 `s.substring(0, s.indexOf(x))` 等调用。\n\n使用 `substringBefore()` 可使代码更简单。\n\n该快速修复会将 `substring` 调用替换为 `substringBefore`。\n\n**示例：**\n\n\n      fun foo(s: String) {\n          s.substring(0, s.indexOf('x'))\n      }\n\n在应用快速修复后：\n\n\n      fun foo(s: String) {\n          s.substringBefore('x')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithSubstringBefore",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceJavaStaticMethodWithKotlinAnalog",
                "shortDescription": {
                  "text": "Java 方法应替换为 Kotlin 模拟"
                },
                "fullDescription": {
                  "text": "报告可以替换为 Kotlin 函数的 Java 方法调用，例如 'System.out.println()'。 替换该代码会去除 Java 的依赖项并使 Kotlin 代码更地道。 该快速修复会替换相同 Kotlin 调用上的 Java 方法调用。 示例： 'import java.util.Arrays\n\n  fun main() {\n      val a = Arrays.asList(1, 3, null)\n  }' 在应用快速修复后： 'fun main() {\n      val a = listOf(1, 3, null)\n  }'",
                  "markdown": "报告可以替换为 Kotlin 函数的 Java 方法调用，例如 `System.out.println()`。\n\n替换该代码会去除 Java 的依赖项并使 Kotlin 代码更地道。\n\n该快速修复会替换相同 Kotlin 调用上的 Java 方法调用。\n\n**示例：**\n\n\n      import java.util.Arrays\n\n      fun main() {\n          val a = Arrays.asList(1, 3, null)\n      }\n\n在应用快速修复后：\n\n\n      fun main() {\n          val a = listOf(1, 3, null)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceJavaStaticMethodWithKotlinAnalog",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptyParenthesesFromLambdaCall",
                "shortDescription": {
                  "text": "带 lambda 的函数调用中不必要的圆括号"
                },
                "fullDescription": {
                  "text": "报告函数调用的冗余空圆括号，其中唯一的形参是圆括号外的 lambda。 使用“从带 lambda 的函数调用中移除不必要的圆括号”快速修复可清理代码。 示例： 'fun foo() {\n      listOf(1).forEach() {  }\n  }' 在应用快速修复后： 'fun foo() {\n      listOf(1).forEach {  }\n  }'",
                  "markdown": "报告函数调用的冗余空圆括号，其中唯一的形参是圆括号外的 lambda。\n\n使用\"从带 lambda 的函数调用中移除不必要的圆括号\"快速修复可清理代码。\n\n**示例：**\n\n\n      fun foo() {\n          listOf(1).forEach() {  }\n      }\n\n在应用快速修复后：\n\n\n      fun foo() {\n          listOf(1).forEach {  }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptyParenthesesFromLambdaCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithOperatorAssignment",
                "shortDescription": {
                  "text": "赋值可被替换为运算符赋值"
                },
                "fullDescription": {
                  "text": "报告带简单赋值（例如 'y = y + x'）且可以替换为运算符赋值的变量的修改。 该快速修复会将赋值替换为赋值运算符。 示例： 'fun foo() {\n      val list = mutableListOf(1, 2, 3)\n      list = list + 4\n  }' 在应用快速修复后： 'fun foo() {\n      val list = mutableListOf(1, 2, 3)\n      list += 4\n  }'",
                  "markdown": "报告带简单赋值（例如 `y = y + x`）且可以替换为运算符赋值的变量的修改。\n\n该快速修复会将赋值替换为赋值运算符。\n\n**示例：**\n\n\n      fun foo() {\n          val list = mutableListOf(1, 2, 3)\n          list = list + 4\n      }\n\n在应用快速修复后：\n\n\n      fun foo() {\n          val list = mutableListOf(1, 2, 3)\n          list += 4\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceWithOperatorAssignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveExplicitSuperQualifier",
                "shortDescription": {
                  "text": "不必要的父类型限定"
                },
                "fullDescription": {
                  "text": "报告具有冗余父类型限定的 'super' 成员调用。 派生类中的代码可以使用 'super' 关键字调用其父类函数和属性访问器实现。 要指定从中获取继承实现的父类型，可以通过尖括号中的父类型名称来限定 'super' ，例如 'super<Base>'。 有时这种限定是冗余的，可以省略。 使用“移除显式父类型限定”快速修复可清理代码。 示例： 'open class B {\n      open fun foo(){}\n  }\n\n  class A : B() {\n      override fun foo() {\n         super<B>.foo() // <== 冗余，因为 'B' 是唯一父类型\n      }\n  }\n\n  interface I {\n      fun foo() {}\n  }\n\n  class C : B(), I {\n      override fun foo() {\n          super<B>.foo() // <== 在这里，需要 <B> 限定符以将 'B.foo()' 与 'I.foo()' 区分\n      }\n  }' 在应用快速修复后： 'open class B {\n      open fun foo(){}\n  }\n\n  class A : B() {\n      override fun foo() {\n         super.foo() // <== 已更新\n      }\n  }\n\n  interface I {\n      fun foo() {}\n  }\n\n  class C : B(), I {\n      override fun foo() {\n          super<B>.foo()\n      }\n  }'",
                  "markdown": "报告具有冗余父类型限定的 `super` 成员调用。\n\n\n派生类中的代码可以使用 `super` 关键字调用其父类函数和属性访问器实现。\n要指定从中获取继承实现的父类型，可以通过尖括号中的父类型名称来限定 `super` ，例如 `super<Base>`。 有时这种限定是冗余的，可以省略。\n使用\"移除显式父类型限定\"快速修复可清理代码。\n\n**示例：**\n\n\n      open class B {\n          open fun foo(){}\n      }\n\n      class A : B() {\n          override fun foo() {\n             super<B>.foo() // <== 冗余，因为 'B' 是唯一父类型\n          }\n      }\n\n      interface I {\n          fun foo() {}\n      }\n\n      class C : B(), I {\n          override fun foo() {\n              super<B>.foo() // <== 在这里，需要 <B> 限定符以将 'B.foo()' 与 'I.foo()' 区分\n          }\n      }\n\n在应用快速修复后：\n\n\n      open class B {\n          open fun foo(){}\n      }\n\n      class A : B() {\n          override fun foo() {\n             super.foo() // <== 已更新\n          }\n      }\n\n      interface I {\n          fun foo() {}\n      }\n\n      class C : B(), I {\n          override fun foo() {\n              super<B>.foo()\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveExplicitSuperQualifier",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitType",
                "shortDescription": {
                  "text": "明显的显式类型"
                },
                "fullDescription": {
                  "text": "报告局部变量的显式给定类型，这些类型显而易见且冗余，例如 'val f: Foo = Foo()'。 示例： 'class Point(val x: Int, val y: Int)\n\n  fun foo() {\n      val t: Boolean = true\n      val p: Point = Point(1, 2)\n      val i: Int = 42\n  }' 在应用快速修复后： 'class Point(val x: Int, val y: Int)\n\n  fun foo() {\n      val t = true\n      val p = Point(1, 2)\n      val i = 42\n  }'",
                  "markdown": "报告局部变量的显式给定类型，这些类型显而易见且冗余，例如 `val f: Foo = Foo()`。\n\n**示例：**\n\n\n      class Point(val x: Int, val y: Int)\n\n      fun foo() {\n          val t: Boolean = true\n          val p: Point = Point(1, 2)\n          val i: Int = 42\n      }\n\n在应用快速修复后：\n\n\n      class Point(val x: Int, val y: Int)\n\n      fun foo() {\n          val t = true\n          val p = Point(1, 2)\n          val i = 42\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedSymbol",
                "shortDescription": {
                  "text": "未使用的符号"
                },
                "fullDescription": {
                  "text": "报告入口点中未使用或不可到达的符号。",
                  "markdown": "报告入口点中未使用或不可到达的符号。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unused",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousVarProperty",
                "shortDescription": {
                  "text": "可疑的 'var' 属性: 它的 setter 不会影响其 getter 结果"
                },
                "fullDescription": {
                  "text": "报告具有默认 setter 和 getter 且未引用支持字段的 'var' 属性。 此类属性不影响调用其 setter；因此，将此类属性更改为 'val' 并删除初始值设定项将会更加清晰易懂。 更改为 val 并删除初始值设定项快速修复可用于自动修正代码。 示例： '// 此属性始终返回 '1'，属性为 'var' 并不重要\n  var foo: Int = 0\n      get() = 1'",
                  "markdown": "报告具有默认 setter 和 getter 且未引用支持字段的 `var` 属性。\n\n\n此类属性不影响调用其 setter；因此，将此类属性更改为 `val` 并删除初始值设定项将会更加清晰易懂。\n\n**更改为 val 并删除初始值设定项**快速修复可用于自动修正代码。\n\n示例：\n\n\n      // 此属性始终返回 '1'，属性为 'var' 并不重要\n      var foo: Int = 0\n          get() = 1\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousVarProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceCollectionCountWithSize",
                "shortDescription": {
                  "text": "集合计数可以转换为大小"
                },
                "fullDescription": {
                  "text": "报告对 'Collection<T>.count()' 的调用。 此函数调用可以替换为 '.size'。 '.size' 形式可以确保运算是 O(1) 并且不会分配额外的对象，而 'count()' 可能与 'Iterable<T>.count()' 混淆，后者是 O(n) 和分配。 示例： 'fun foo() {\n      var list = listOf(1,2,3)\n      list.count() // 可替换的 'count()'\n  }' 在应用快速修复后： 'fun foo() {\n      var list = listOf(1,2,3)\n      list.size\n  }'",
                  "markdown": "报告对 `Collection<T>.count()` 的调用。\n\n\n此函数调用可以替换为 `.size`。\n\n\n`.size` 形式可以确保运算是 O(1) 并且不会分配额外的对象，而 `count()` 可能与 `Iterable<T>.count()` 混淆，后者是 O(n) 和分配。\n\n\n**示例：**\n\n      fun foo() {\n          var list = listOf(1,2,3)\n          list.count() // 可替换的 'count()'\n      }\n\n在应用快速修复后：\n\n      fun foo() {\n          var list = listOf(1,2,3)\n          list.size\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceCollectionCountWithSize",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceArrayEqualityOpWithArraysEquals",
                "shortDescription": {
                  "text": "通过 '==' 和 '!=' 进行数组比较"
                },
                "fullDescription": {
                  "text": "报告 '==' 或 '!=' 运算符的用法，用于应替换为 'contentEquals()' 的数组。 '==' 和 '!=' 运算符比较数组引用而不是它们的内容。 示例： 'fun test() {\n      val a = arrayOf(1, 2, 3)\n      val b = arrayOf(1, 2, 3)\n      println(a == b) // 参考比较\n  }' 在应用快速修复后： 'fun test() {\n      val a = arrayOf(1, 2, 3)\n      val b = arrayOf(1, 2, 3)\n      println(a.contentEquals(b))\n  }'",
                  "markdown": "报告 `==` 或 `!=` 运算符的用法，用于应替换为 `contentEquals()` 的数组。\n\n\n`==` 和 `!=` 运算符比较数组引用而不是它们的内容。\n\n**示例：**\n\n      fun test() {\n          val a = arrayOf(1, 2, 3)\n          val b = arrayOf(1, 2, 3)\n          println(a == b) // 参考比较\n      }\n\n在应用快速修复后：\n\n      fun test() {\n          val a = arrayOf(1, 2, 3)\n          val b = arrayOf(1, 2, 3)\n          println(a.contentEquals(b))\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceArrayEqualityOpWithArraysEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaCollectionsStaticMethod",
                "shortDescription": {
                  "text": "Java 集合 static 方法调用可被替换为 Kotlin stdlib"
                },
                "fullDescription": {
                  "text": "报告可以替换为 Kotlin stdlib 的 Java 'Collections' static 方法调用。 示例： 'import java.util.Collections\n\n  fun test() {\n      val mutableList = mutableListOf(1, 2)\n      Collections.fill(mutableList, 3)\n  }' 该快速修复会将 Java 'Collections' static 方法调用替换为相应的 Kotlin stdlib 方法调用： 'import java.util.Collections\n\n  fun test() {\n      val mutableList = mutableListOf(1, 2)\n      mutableList.fill(3)\n  }'",
                  "markdown": "报告可以替换为 Kotlin stdlib 的 Java `Collections` static 方法调用。\n\n**示例：**\n\n\n      import java.util.Collections\n\n      fun test() {\n          val mutableList = mutableListOf(1, 2)\n          Collections.fill(mutableList, 3)\n      }\n\n该快速修复会将 Java `Collections` static 方法调用替换为相应的 Kotlin stdlib 方法调用：\n\n\n      import java.util.Collections\n\n      fun test() {\n          val mutableList = mutableListOf(1, 2)\n          mutableList.fill(3)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JavaCollectionsStaticMethod",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MoveVariableDeclarationIntoWhen",
                "shortDescription": {
                  "text": "变量声明可以在 'when' 中移动"
                },
                "fullDescription": {
                  "text": "报告可移动到 'when' 表达式中的变量声明。 示例： 'fun someCalc(x: Int) = x * 42\n\nfun foo(x: Int): Int {\n  val a = someCalc(x)\n  return when (a) {\n    1 -> a\n    2 -> 2 * a\n    else -> 24\n  }\n}' 在应用快速修复后： 'fun foo(x: Int): Int {\n  return when (val a = someCalc(x)) {\n    1 -> a\n    2 -> 2 * a\n    else -> 24\n  }\n}'",
                  "markdown": "报告可移动到 `when` 表达式中的变量声明。\n\n**示例：**\n\n\n    fun someCalc(x: Int) = x * 42\n\n    fun foo(x: Int): Int {\n      val a = someCalc(x)\n      return when (a) {\n        1 -> a\n        2 -> 2 * a\n        else -> 24\n      }\n    }\n\n在应用快速修复后：\n\n\n    fun foo(x: Int): Int {\n      return when (val a = someCalc(x)) {\n        1 -> a\n        2 -> 2 * a\n        else -> 24\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MoveVariableDeclarationIntoWhen",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedGradleDependency",
                "shortDescription": {
                  "text": "在 Gradle 中使用了弃用的库"
                },
                "fullDescription": {
                  "text": "报告 Gradle 构建脚本中已弃用的依赖项。 示例： 'dependencies {\n      compile \"org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0\"\n  }' 在应用快速修复后： 'dependencies {\n      compile \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.2.0\"\n  }'",
                  "markdown": "报告 Gradle 构建脚本中已弃用的依赖项。\n\n**示例：**\n\n\n      dependencies {\n          compile \"org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0\"\n      }\n\n在应用快速修复后：\n\n\n      dependencies {\n          compile \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.2.0\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedGradleDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastDueToProgressionResolutionChangeMigration",
                "shortDescription": {
                  "text": "自 1.9 起的进度分辨率更改"
                },
                "fullDescription": {
                  "text": "报告实参需要显式转换才能解析为正确声明的重载函数调用。 当前的编译器警告（从 Kotlin 1.6.20 开始提供）将成为 Kotlin 1.8 中的错误。 进度和范围类型 ('kotlin.ranges') 将在 1.9 及更高版本中开始实现 'Collection' 接口。 此更新将导致重载函数的解析发生变化。 例如，在下面的示例中，'test(1..5)' 调用将在 Kotlin 1.8 及更早版本中被解析为 'test(t: Any)'，而在 Kotlin 1.9 及更高版本中被解析为 'test(t: Collection<*>)'。 'fun test(t: Any) { }\n  fun test(t: Collection<*>) { }\n  fun invoke() {\n    test(1..5) // 在 1.9 版中 IntRange 会变成 Collection\n  }' 提供的快速修复会捕获 1.8 版及更早版本的编译器特有的行为： 'fun test(t: Any) { }\n  fun test(t: Collection<*>) { }\n\n  fun invoke() {\n    test(1..5) // 在 Kotlin 1.9 之前的版本中解析为 'test(t: T)'\n  }' 在应用快速修复后： 'fun test(t: Any) { }\n  fun test(t: Collection<*>) { }\n\n  fun invoke() {\n    test((1..5) as Iterable<Int>) // 在 Kotlin 1.9 版中解析为 'test(t: T)'\n  }' 从 1.6 版开始，可对 Kotlin 语言级别进行检查。",
                  "markdown": "报告实参需要显式转换才能解析为正确声明的重载函数调用。\n当前的编译器警告（从 Kotlin 1.6.20 开始提供）将成为 Kotlin 1.8 中的错误。\n\n\n进度和范围类型 (`kotlin.ranges`) 将在 1.9 及更高版本中开始实现 `Collection` 接口。 此更新将导致重载函数的解析发生变化。 例如，在下面的示例中，`test(1..5)` 调用将在 Kotlin 1.8 及更早版本中被解析为 `test(t: Any)`，而在 Kotlin 1.9 及更高版本中被解析为 `test(t: Collection<*>)`。\n\n\n      fun test(t: Any) { }\n      fun test(t: Collection<*>) { }\n      fun invoke() {\n        test(1..5) // 在 1.9 版中 IntRange 会变成 Collection\n      }\n\n提供的快速修复会捕获 1.8 版及更早版本的编译器特有的行为：\n\n\n      fun test(t: Any) { }\n      fun test(t: Collection<*>) { }\n\n      fun invoke() {\n        test(1..5) // 在 Kotlin 1.9 之前的版本中解析为 'test(t: T)'\n      }\n\n在应用快速修复后：\n\n\n      fun test(t: Any) { }\n      fun test(t: Collection<*>) { }\n\n      fun invoke() {\n        test((1..5) as Iterable<Int>) // 在 Kotlin 1.9 版中解析为 'test(t: T)'\n      }\n\n从 1.6 版开始，可对 Kotlin 语言级别进行检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastDueToProgressionResolutionChangeMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptyParenthesesFromAnnotationEntry",
                "shortDescription": {
                  "text": "移除不必要的圆括号"
                },
                "fullDescription": {
                  "text": "报告注解条目中的冗余空圆括号。 使用“移除不必要的圆括号”快速修复可清理代码。 示例： 'annotation class MyAnnotationA\n  annotation class MyAnnotationB(val x: Int)\n  annotation class MyAnnotationC(val x: Int = 10) // 存在默认值\n\n  @MyAnnotationA() // <== 圆括号冗余\n  fun testA() {\n  }\n\n  @MyAnnotationB() // <== 缺少实参，圆括号为必选项\n  fun testB() {\n  }\n\n  @MyAnnotationC() // <== 圆括号冗余\n  fun testC() {\n  }'",
                  "markdown": "报告注解条目中的冗余空圆括号。\n\n使用\"移除不必要的圆括号\"快速修复可清理代码。\n\n**示例：**\n\n\n      annotation class MyAnnotationA\n      annotation class MyAnnotationB(val x: Int)\n      annotation class MyAnnotationC(val x: Int = 10) // 存在默认值\n\n      @MyAnnotationA() // <== 圆括号冗余\n      fun testA() {\n      }\n\n      @MyAnnotationB() // <== 缺少实参，圆括号为必选项\n      fun testB() {\n      }\n\n      @MyAnnotationC() // <== 圆括号冗余\n      fun testC() {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptyParenthesesFromAnnotationEntry",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableCallChain",
                "shortDescription": {
                  "text": "可以简化集合类型上的调用链"
                },
                "fullDescription": {
                  "text": "报告可由单个调用替换的双调用链。 它可以帮助您避免冗余代码执行。 该快速修复会将调用链替换为单个调用。 示例： 'fun main() {\n      listOf(1, 2, 3).filter { it > 1 }.count()\n  }' 在应用快速修复后： 'fun main() {\n      listOf(1, 2, 3).count { it > 1 }\n  }'",
                  "markdown": "报告可由单个调用替换的双调用链。\n\n它可以帮助您避免冗余代码执行。\n\n该快速修复会将调用链替换为单个调用。\n\n**示例：**\n\n\n      fun main() {\n          listOf(1, 2, 3).filter { it > 1 }.count()\n      }\n\n在应用快速修复后：\n\n\n      fun main() {\n          listOf(1, 2, 3).count { it > 1 }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifiableCallChain",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertReferenceToLambda",
                "shortDescription": {
                  "text": "可被替换为 lambda"
                },
                "fullDescription": {
                  "text": "报告可以替换为函数文字 (lambda) 的函数引用表达式。 有时，传递 lambda 会更直接，并且与代码的其余部分更一致。 此外，如果需要将简单的调用替换为更复杂的调用，该修正可能很方便。 示例： 'fun Int.isEven() = this % 2 == 0\n\n  fun example() {\n      val numbers = listOf(1, 2, 4, 7, 9, 10)\n      val evenNumbers = numbers.filter(Int::isEven)\n  }' 在应用快速修复后： 'fun Int.isEven() = this % 2 == 0\n\n  fun example() {\n      val numbers = listOf(1, 2, 4, 7, 9, 10)\n      val evenNumbers = numbers.filter { it.isEven() }\n  }'",
                  "markdown": "报告可以替换为函数文字 (lambda) 的函数引用表达式。\n\n\n有时，传递 lambda 会更直接，并且与代码的其余部分更一致。\n此外，如果需要将简单的调用替换为更复杂的调用，该修正可能很方便。\n\n**示例：**\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter(Int::isEven)\n      }\n\n在应用快速修复后：\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter { it.isEven() }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertReferenceToLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceCallWithBinaryOperator",
                "shortDescription": {
                  "text": "可被替换为二元运算符"
                },
                "fullDescription": {
                  "text": "报告可以替换为二元运算符（特别是与比较相关的运算符）的函数调用。 示例： 'fun test(): Boolean {\n      return 2.compareTo(1) > 0 // 可替换的 'compareTo()'\n  }' 在应用快速修复后： 'fun test(): Boolean {\n      return 2 > 1\n  }'",
                  "markdown": "报告可以替换为二元运算符（特别是与比较相关的运算符）的函数调用。\n\n**示例：**\n\n      fun test(): Boolean {\n          return 2.compareTo(1) > 0 // 可替换的 'compareTo()'\n      }\n\n在应用快速修复后：\n\n      fun test(): Boolean {\n          return 2 > 1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceCallWithBinaryOperator",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplacePrintlnWithLogging",
                "shortDescription": {
                  "text": "对 'print()' 或 'println()' 的调用"
                },
                "fullDescription": {
                  "text": "报告 'print' 或 'printlnr' 的用法。 此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。",
                  "markdown": "报告 `print` 或 `printlnr` 的用法。\n\n此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplacePrintlnWithLogging",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnlabeledReturnInsideLambda",
                "shortDescription": {
                  "text": "lambda 中存在未标记的 return"
                },
                "fullDescription": {
                  "text": "报告内联 lambda 内未标记的 'return' 表达式。 此类表达式可能令人困惑，因为可能不清楚哪个范围属于 'return'。 更改为 return@… 快速修复可用于自动修正代码。 示例： 'fun test(list: List<Int>) {\n      list.forEach {\n          // 此返回表达式从函数测试返回\n          // 可以将其更改为 return@forEach 以更改范围\n          if (it == 10) return\n      }\n  }' 在应用快速修复后： 'fun test(list: List<Int>) {\n      list.forEach {\n          if (it == 10) return@test\n      }\n  }'",
                  "markdown": "报告内联 lambda 内未标记的 `return` 表达式。\n\n此类表达式可能令人困惑，因为可能不清楚哪个范围属于 `return`。\n\n**更改为 return@...** 快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun test(list: List<Int>) {\n          list.forEach {\n              // 此返回表达式从函数测试返回\n              // 可以将其更改为 return@forEach 以更改范围\n              if (it == 10) return\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun test(list: List<Int>) {\n          list.forEach {\n              if (it == 10) return@test\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnlabeledReturnInsideLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedUnaryOperator",
                "shortDescription": {
                  "text": "未使用的一元运算符"
                },
                "fullDescription": {
                  "text": "报告表达式上的未使用的数字类型一元运算符。 使用一元运算符时如果不带大括号，它们将会中断之前的表达式。 因此，跨越多行的数学表达式可能会产生误导。 示例： 'fun main() {\n      val result = 1 + 2 * 3\n                  + 3              // <== 请注意，'+ 3' 不属于 'result' 变量，它并未使用\n      println(\"Result = $result\")  // 结果为 '7'，而非预期的 '10'\n  }'",
                  "markdown": "报告表达式上的未使用的数字类型一元运算符。\n\n使用一元运算符时如果不带大括号，它们将会中断之前的表达式。\n因此，跨越多行的数学表达式可能会产生误导。\n\n示例：\n\n\n      fun main() {\n          val result = 1 + 2 * 3\n                      + 3              // <== 请注意，'+ 3' 不属于 'result' 变量，它并未使用\n          println(\"Result = $result\")  // 结果为 '7'，而非预期的 '10'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedUnaryOperator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AddConversionCallMigration",
                "shortDescription": {
                  "text": "自 1.9 起需要从 `Int` 显式转换"
                },
                "fullDescription": {
                  "text": "报告将为 'Int' 类型，从而在 Kotlin 1.9 及更高版本中导致编译错误的表达式。 示例： 'fun takeByte(x: Byte) {}\n\n  fun foo() {\n      takeByte(1 + 1) // 将在 1.9 版中解析为 Int\n  }' 在应用快速修复后： 'fun takeByte(x: Byte) {}\n\n  fun foo() {\n      takeByte((1 + 1).toByte()) // 将在 1.9 版中解析为 Int\n  }' 从 1.7 版开始，可对 Kotlin 语言级别进行检查。",
                  "markdown": "报告将为 `Int` 类型，从而在 Kotlin 1.9 及更高版本中导致编译错误的表达式。\n\n示例：\n\n\n      fun takeByte(x: Byte) {}\n\n      fun foo() {\n          takeByte(1 + 1) // 将在 1.9 版中解析为 Int\n      }\n\n在应用快速修复后：\n\n\n      fun takeByte(x: Byte) {}\n\n      fun foo() {\n          takeByte((1 + 1).toByte()) // 将在 1.9 版中解析为 Int\n      }\n\n从 1.7 版开始，可对 Kotlin 语言级别进行检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AddConversionCallMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LateinitVarOverridesLateinitVar",
                "shortDescription": {
                  "text": "'lateinit var' 属性重写 'lateinit var' 属性"
                },
                "fullDescription": {
                  "text": "报告重写其他 'lateinit var' 属性的 'lateinit var' 属性。 一个子类实例的单个属性会有两个字段，而来自超类的那个将保持不使用。 示例： 'open class BaseClass {\n      open lateinit var name: String\n    }\n\n    class RealClass : BaseClass() {\n      override lateinit var name: String\n    }'",
                  "markdown": "报告重写其他 `lateinit var` 属性的 `lateinit var` 属性。\n\n一个子类实例的单个属性会有两个字段，而来自超类的那个将保持不使用。\n\n**示例：**\n\n\n        open class BaseClass {\n          open lateinit var name: String\n        }\n\n        class RealClass : BaseClass() {\n          override lateinit var name: String\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LateinitVarOverridesLateinitVar",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VerboseNullabilityAndEmptiness",
                "shortDescription": {
                  "text": "详细的为 null 性和空性检查"
                },
                "fullDescription": {
                  "text": "报告可以简化为单个检查的 'null' 和空检查的组合。 该快速修复会将高亮显示的检查替换为组合的检查调用，例如 'isNullOrEmpty()'。 示例： 'fun test(list: List<Int>?) {\n      if (list == null || list.isEmpty()) {\n          println(\"List is empty!\")\n      } else {\n          println(list.joinToString())\n      }\n  }' 在应用快速修复后： 'fun test(list: List<Int>?) {\n      if (list.isNullOrEmpty()) {\n          println(\"List is empty!\")\n      } else {\n          println(list.joinToString())\n      }\n  }'",
                  "markdown": "报告可以简化为单个检查的 `null` 和空检查的组合。\n\n该快速修复会将高亮显示的检查替换为组合的检查调用，例如 `isNullOrEmpty()`。\n\n**示例：**\n\n\n      fun test(list: List<Int>?) {\n          if (list == null || list.isEmpty()) {\n              println(\"List is empty!\")\n          } else {\n              println(list.joinToString())\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun test(list: List<Int>?) {\n          if (list.isNullOrEmpty()) {\n              println(\"List is empty!\")\n          } else {\n              println(list.joinToString())\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "VerboseNullabilityAndEmptiness",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassName",
                "shortDescription": {
                  "text": "类命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循推荐命名约定的类名。 一致的命名会让阅读和理解代码变得更容易。 根据 Kotlin 官方样式指南，类名应以大写字母开头并使用驼峰拼写法。 可以通过更改“模式”正则表达式来引入其他命名规则。 示例： 'class user(val name: String)' 该快速修复会根据 Kotlin 命名约定重命名类： 'class User(val name: String)'",
                  "markdown": "报告不遵循推荐命名约定的类名。\n\n\n一致的命名会让阅读和理解代码变得更容易。\n根据 [Kotlin 官方样式指南](https://kotlinlang.org/docs/coding-conventions.html#naming-rules)，类名应以大写字母开头并使用驼峰拼写法。\n\n可以通过更改\"模式\"正则表达式来引入其他命名规则。\n\n**示例：**\n\n\n      class user(val name: String)\n\n该快速修复会根据 Kotlin 命名约定重命名类：\n\n\n      class User(val name: String)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ClassName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptyPrimaryConstructor",
                "shortDescription": {
                  "text": "冗余空主构造函数"
                },
                "fullDescription": {
                  "text": "当主构造函数隐式可用时，报告其中为空的主构造函数。 主构造函数冗余，当其没有任何注解或可见性修饰符时可以安全地省略。 使用“移除空主构造函数”快速修复可清理代码。 示例： 'class MyClassA constructor() //  冗余，可以替换为 'class MyClassA'\n\n  annotation class MyAnnotation\n  class MyClassB @MyAnnotation constructor() //  由于注解而必选\n\n  class MyClassC private constructor() // 由于可见性修饰符而必选'",
                  "markdown": "当主构造函数隐式可用时，报告其中为空的主构造函数。\n\n\n主构造函数冗余，当其没有任何注解或可见性修饰符时可以安全地省略。\n使用\"移除空主构造函数\"快速修复可清理代码。\n\n**示例：**\n\n\n      class MyClassA constructor() //  冗余，可以替换为 'class MyClassA'\n\n      annotation class MyAnnotation\n      class MyClassB @MyAnnotation constructor() //  由于注解而必选\n\n      class MyClassC private constructor() // 由于可见性修饰符而必选\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptyPrimaryConstructor",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptySecondaryConstructorBody",
                "shortDescription": {
                  "text": "冗余构造函数体"
                },
                "fullDescription": {
                  "text": "报告辅助构造函数的空主体。",
                  "markdown": "报告辅助构造函数的空主体。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptySecondaryConstructorBody",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FloatingPointLiteralPrecision",
                "shortDescription": {
                  "text": "浮点文字超出可用精度"
                },
                "fullDescription": {
                  "text": "报告无法使用 IEEE 754 以所需精度表示的浮点文字 'Float' 和 'Double' 类型。 例如，'1.9999999999999999999' 的有效数字太多，因此其作为 'Double' 的表示将舍入为 '2.0'。 指定多余的数字可能具有误导性，因为它掩盖了改用舍入值进行计算的事实。 该快速修复会将文字替换为与常量的实际表示相匹配的舍入值。 示例： 'val x: Float = 3.14159265359f' 在应用快速修复后： 'val x: Float = 3.1415927f'",
                  "markdown": "报告无法使用 [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) 以所需精度表示的浮点文字 `Float` 和 `Double` 类型。\n\n\n例如，`1.9999999999999999999` 的有效数字太多，因此其作为 `Double` 的表示将舍入为 `2.0`。\n指定多余的数字可能具有误导性，因为它掩盖了改用舍入值进行计算的事实。\n\n\n该快速修复会将文字替换为与常量的实际表示相匹配的舍入值。\n\n**示例：**\n\n\n      val x: Float = 3.14159265359f\n\n在应用快速修复后：\n\n\n      val x: Float = 3.1415927f\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FloatingPointLiteralPrecision",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DifferentKotlinGradleVersion",
                "shortDescription": {
                  "text": "Kotlin Gradle 和 IDE 插件版本不同"
                },
                "fullDescription": {
                  "text": "报告当前的 IDE 插件无法正确支持 Gradle 插件版本。 这可能会导致 IDE 和 Gradle 构建在错误报告或代码行为方面的不一致。 示例： 'dependencies {\n    classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:0.0.1\"\n  }' 要修正此问题，请更改 kotlin gradle 插件版本以匹配捆绑到 IDE 插件中的 kotlin 版本。",
                  "markdown": "报告当前的 IDE 插件无法正确支持 Gradle 插件版本。\n\n这可能会导致 IDE 和 Gradle 构建在错误报告或代码行为方面的不一致。\n\n**示例：**\n\n\n      dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:0.0.1\"\n      }\n\n要修正此问题，请更改 kotlin gradle 插件版本以匹配捆绑到 IDE 插件中的 kotlin 版本。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DifferentKotlinGradleVersion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertPairConstructorToToFunction",
                "shortDescription": {
                  "text": "将 Pair 构造函数转换为 'to' 函数"
                },
                "fullDescription": {
                  "text": "报告可替换为 'to()' 中缀函数调用的 'Pair' 构造函数调用。 显式构造函数调用可能会增添冗余，尤其是在多次使用时。 将构造函数调用替换为 'to()' 会使读取和维护代码变得更容易。 示例： 'val countries = mapOf(\n      Pair(\"France\", \"Paris\"),\n      Pair(\"Spain\", \"Madrid\"),\n      Pair(\"Germany\", \"Berlin\")\n  )' 在应用快速修复后： 'val countries = mapOf(\n      \"France\" to \"Paris\",\n      \"Spain\" to \"Madrid\",\n      \"Germany\" to \"Berlin\"\n  )'",
                  "markdown": "报告可替换为 `to()` 中缀函数调用的 `Pair` 构造函数调用。\n\n\n显式构造函数调用可能会增添冗余，尤其是在多次使用时。\n将构造函数调用替换为 `to()` 会使读取和维护代码变得更容易。\n\n**示例：**\n\n\n      val countries = mapOf(\n          Pair(\"France\", \"Paris\"),\n          Pair(\"Spain\", \"Madrid\"),\n          Pair(\"Germany\", \"Berlin\")\n      )\n\n在应用快速修复后：\n\n\n      val countries = mapOf(\n          \"France\" to \"Paris\",\n          \"Spain\" to \"Madrid\",\n          \"Germany\" to \"Berlin\"\n      )\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertPairConstructorToToFunction",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantGetter",
                "shortDescription": {
                  "text": "冗余属性 getter"
                },
                "fullDescription": {
                  "text": "报告冗余属性 getter。 示例： 'class Test {\n      val a = 1\n          get\n      val b = 1\n          get() = field\n  }' 在应用快速修复后： 'class Test {\n      val a = 1\n      val b = 1\n  }'",
                  "markdown": "报告冗余属性 getter。\n\n**示例：**\n\n\n      class Test {\n          val a = 1\n              get\n          val b = 1\n              get() = field\n      }\n\n在应用快速修复后：\n\n\n      class Test {\n          val a = 1\n          val b = 1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantGetter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantIf",
                "shortDescription": {
                  "text": "冗余的 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告可以简化为单个语句的 'if' 语句。 示例： 'fun test(): Boolean {\n      if (foo()) {\n         return true\n      } else {\n         return false\n      }\n  }' 在应用快速修复后： 'fun test(): Boolean {\n      return foo()\n  }'",
                  "markdown": "报告可以简化为单个语句的 `if` 语句。\n\n**示例：**\n\n\n      fun test(): Boolean {\n          if (foo()) {\n             return true\n          } else {\n             return false\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun test(): Boolean {\n          return foo()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantIf",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KDocMissingDocumentation",
                "shortDescription": {
                  "text": "public 声明缺少 KDoc 注释"
                },
                "fullDescription": {
                  "text": "报告没有 KDoc 注释的 public 声明。 示例： 'class A' 该快速修复会在声明上方生成注释块： '/**\n   *\n   */\n  class A'",
                  "markdown": "报告没有 KDoc 注释的 public 声明。\n\n**示例：**\n\n\n      class A\n\n该快速修复会在声明上方生成注释块：\n\n\n      /**\n       *\n       */\n      class A\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KDocMissingDocumentation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JoinDeclarationAndAssignment",
                "shortDescription": {
                  "text": "联接声明和赋值"
                },
                "fullDescription": {
                  "text": "报告可以与以下赋值联接的属性声明。 示例： 'val x: String\n  x = System.getProperty(\"\")' 该快速修复会将声明与赋值联接： 'val x = System.getProperty(\"\")' 配置检查： 您可以禁用报告成员属性的复杂初始化选项以跳过具有复杂初始化的属性。 这包括两种情况： 属性初始值设定项很复杂（它是一个多行或复合/控制流表达式） 首先对属性进行初始化，然后立即在后续代码中使用（例如，用来调用其他初始化方法）",
                  "markdown": "报告可以与以下赋值联接的属性声明。\n\n**示例：**\n\n\n      val x: String\n      x = System.getProperty(\"\")\n\n该快速修复会将声明与赋值联接：\n\n\n      val x = System.getProperty(\"\")\n\n配置检查：\n\n您可以禁用**报告成员属性的复杂初始化**选项以跳过具有复杂初始化的属性。 这包括两种情况：\n\n1. 属性初始值设定项很复杂（它是一个多行或复合/控制流表达式）\n2. 首先对属性进行初始化，然后立即在后续代码中使用（例如，用来调用其他初始化方法）"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JoinDeclarationAndAssignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinEqualsBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "'equals()' 位于不可转换类型的对象之间"
                },
                "fullDescription": {
                  "text": "报告对接收器和实参的基元、枚举或字符串类型不兼容的 'equals()' 的调用。 虽然此类调用理论上可能有用，但很可能是错误。 示例： '5.equals(\"\");'",
                  "markdown": "报告对接收器和实参的基元、枚举或字符串类型不兼容的 `equals()` 的调用。\n\n虽然此类调用理论上可能有用，但很可能是错误。\n\n**示例：**\n\n      5.equals(\"\");\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveExplicitTypeArguments",
                "shortDescription": {
                  "text": "不必要的类型实参"
                },
                "fullDescription": {
                  "text": "报告具有可自动推断的类型实参的函数调用。 这种类型实参是冗余的，可以安全地省略。 使用“移除显式类型实参”快速修复可清理代码。 示例： '// 在这里可以推断 'String' 类型\n  fun foo(): MutableList<String> = mutableListOf<String>()\n\n  // 在这里无法推断 'String'，类型实参为必选项。\n  fun bar() = mutableListOf<String>()' 在应用快速修复后： 'fun foo(): MutableList<String> = mutableListOf() <== 已更新\n\n  fun bar() = mutableListOf<String>()'",
                  "markdown": "报告具有可自动推断的类型实参的函数调用。 这种类型实参是冗余的，可以安全地省略。\n\n使用\"移除显式类型实参\"快速修复可清理代码。\n\n**示例：**\n\n\n      // 在这里可以推断 'String' 类型\n      fun foo(): MutableList<String> = mutableListOf<String>()\n\n      // 在这里无法推断 'String'，类型实参为必选项。\n      fun bar() = mutableListOf<String>()\n\n在应用快速修复后：\n\n\n      fun foo(): MutableList<String> = mutableListOf() <== 已更新\n\n      fun bar() = mutableListOf<String>()\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveExplicitTypeArguments",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HasPlatformType",
                "shortDescription": {
                  "text": "函数或属性具有平台类型"
                },
                "fullDescription": {
                  "text": "报告具有平台类型的函数和属性。 为防止意外错误，应显式声明类型。 示例： 'fun foo() = java.lang.String.valueOf(1)' 快速修复让您能够指定返回类型： 'fun foo(): String = java.lang.String.valueOf(1)'",
                  "markdown": "报告具有平台类型的函数和属性。\n\n为防止意外错误，应显式声明类型。\n\n**示例：**\n\n\n      fun foo() = java.lang.String.valueOf(1)\n\n快速修复让您能够指定返回类型：\n\n\n      fun foo(): String = java.lang.String.valueOf(1)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HasPlatformType",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 互操作问题",
                      "index": 67,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantVisibilityModifier",
                "shortDescription": {
                  "text": "冗余可见性修饰符"
                },
                "fullDescription": {
                  "text": "报告与元素的默认可见性匹配的可见性修饰符（对于大多数元素来说是 'public'，对于重写受保护成员的成员来说是 'protected'）。",
                  "markdown": "报告与元素的默认可见性匹配的可见性修饰符（对于大多数元素来说是 `public`，对于重写受保护成员的成员来说是 `protected`）。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantVisibilityModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumValuesSoftDeprecateInJava",
                "shortDescription": {
                  "text": "从 Kotlin 1.9 开始，建议将 'Enum.values()' 替换为 'Enum.getEntries()'"
                },
                "fullDescription": {
                  "text": "报告 Java 中对可被替换为 'getEntries()' 的 Kotlin 枚举类的 'values()' 方法的调用。 使用 'Enum.getEntries()' 可能会提高代码的性能。 更多详细信息：KT-48872 为 Enum.values() 提供现代且高效的替代",
                  "markdown": "报告 Java 中对可被替换为 `getEntries()` 的 Kotlin 枚举类的 `values()` 方法的调用。\n\n\n使用 `Enum.getEntries()` 可能会提高代码的性能。\n\n\n**更多详细信息** ：[KT-48872 为 Enum.values() 提供现代且高效的替代](https://youtrack.jetbrains.com/issue/KT-48872)"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumValuesSoftDeprecateInJava",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UsePropertyAccessSyntax",
                "shortDescription": {
                  "text": "可被替换为属性访问语法的访问器调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为 Kotlin 合成属性的 Java 'get' 和 'set' 方法调用。 使用属性访问语法快速修复可用于自动修正代码。 示例： '// Java:\n  public class JavaClassWithGetter {\n      private final String expr = \"result\";\n\n      // ...\n\n      public String getExpr() {\n          return expr;\n      }\n  }' '// Kotlin:\n  fun test(j: JavaClassWithGetter) {\n      // ...\n      j.getExpr() // <== 快速修复会将表达式简化为 'j.expr'\n  }'",
                  "markdown": "报告可以替换为 Kotlin 合成属性的 Java `get` 和 `set` 方法调用。\n\n**使用属性访问语法**快速修复可用于自动修正代码。\n\n示例：\n\n\n      // Java:\n      public class JavaClassWithGetter {\n          private final String expr = \"result\";\n\n          // ...\n\n          public String getExpr() {\n              return expr;\n          }\n      }\n\n\n      // Kotlin:\n      fun test(j: JavaClassWithGetter) {\n          // ...\n          j.getExpr() // <== 快速修复会将表达式简化为 'j.expr'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UsePropertyAccessSyntax",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseExpressionBody",
                "shortDescription": {
                  "text": "此处更适合表达式主体语法"
                },
                "fullDescription": {
                  "text": "返回可以替换为表达式主体语法的 'return' 表达式（一行代码或 'when'）。 表达式主体语法建议在样式指南中给出。 转换为表达式主体快速修复可用于自动修正代码。 示例： 'fun sign(x: Int): Int {\n      return when { // <== 可以简化\n          x < 0 -> -1\n          x > 0 -> 1\n          else -> 0\n      }\n  }' 在应用快速修复后： 'fun sign(x: Int): Int = when {\n      x < 0 -> -1\n      x > 0 -> 1\n      else -> 0\n  }'",
                  "markdown": "返回可以替换为表达式主体语法的 `return` 表达式（一行代码或 `when`）。\n\n表达式主体语法建议在[样式指南](https://kotlinlang.org/docs/coding-conventions.html#functions)中给出。\n\n**转换为表达式主体**快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun sign(x: Int): Int {\n          return when { // <== 可以简化\n              x < 0 -> -1\n              x > 0 -> 1\n              else -> 0\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun sign(x: Int): Int = when {\n          x < 0 -> -1\n          x > 0 -> 1\n          else -> 0\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UseExpressionBody",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DataClassPrivateConstructor",
                "shortDescription": {
                  "text": "private 数据类构造函数通过 'copy' 方法公开"
                },
                "fullDescription": {
                  "text": "报告数据类中的 'private' 主构造函数。 'data' 类拥有 'copy()' 工厂方法，可以像构造函数一样使用。 为了提供足够的安全性，构造函数不应被标记为 'private'。 示例： 'data class User private constructor(val name: String)' 该快速修复会将构造函数可见性修饰符更改为 'public'： 'data class User(val name: String)'",
                  "markdown": "报告数据类中的 `private` 主构造函数。\n\n\n`data` 类拥有 `copy()` 工厂方法，可以像构造函数一样使用。\n为了提供足够的安全性，构造函数不应被标记为 `private`。\n\n**示例：**\n\n\n      data class User private constructor(val name: String)\n\n该快速修复会将构造函数可见性修饰符更改为 `public`：\n\n\n      data class User(val name: String)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DataClassPrivateConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantInnerClassModifier",
                "shortDescription": {
                  "text": "冗余 'inner' 修饰符"
                },
                "fullDescription": {
                  "text": "如果类没有引用其外部类的成员，则将类上的 'inner' 修饰符报告为冗余。 示例： 'class Foo {\n      inner class InnerClass { // 冗余 `inner` 修饰符\n          fun hello() {\n              println(\"Hi!\")\n          }\n      }\n  }\n\n  class List {\n      val objects = Array<Any>(42) { Any() }\n\n      inner class Iterator { // 非冗余 `inner` 修饰符\n          fun next(): Any {\n              return objects[0]\n          }\n      }\n  }' 在应用快速修复后： 'class Foo {\n      class InnerClass { // 冗余 `inner` 修饰符\n          fun hello() {\n              println(\"Hi!\")\n          }\n      }\n  }\n\n  class List {\n      val objects = Array<Any>(42) { Any() }\n\n      inner class Iterator { // 非冗余 `inner` 修饰符\n          fun next(): Any {\n              return objects[0]\n          }\n      }\n  }'",
                  "markdown": "如果类没有引用其外部类的成员，则将类上的 `inner` 修饰符报告为冗余。\n\n**示例：**\n\n\n      class Foo {\n          inner class InnerClass { // 冗余 `inner` 修饰符\n              fun hello() {\n                  println(\"Hi!\")\n              }\n          }\n      }\n\n      class List {\n          val objects = Array<Any>(42) { Any() }\n\n          inner class Iterator { // 非冗余 `inner` 修饰符\n              fun next(): Any {\n                  return objects[0]\n              }\n          }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n          class InnerClass { // 冗余 `inner` 修饰符\n              fun hello() {\n                  println(\"Hi!\")\n              }\n          }\n      }\n\n      class List {\n          val objects = Array<Any>(42) { Any() }\n\n          inner class Iterator { // 非冗余 `inner` 修饰符\n              fun next(): Any {\n                  return objects[0]\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantInnerClassModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaCollectionsStaticMethodOnImmutableList",
                "shortDescription": {
                  "text": "在不可变的 Kotlin 集合上调用 Java 转变器方法"
                },
                "fullDescription": {
                  "text": "报告在不可变的 Kotlin 集合上对 Java 更改器方法的调用（如 'fill'、'reverse'、'shuffle'、'sort'）。 这可能会在运行时导致 'UnsupportedOperationException'。 示例： 'import java.util.Collections\n\n  fun test() {\n      val immutableList = listOf(1, 2)\n      Collections.reverse(immutableList)\n  }' 要修正此问题，请使列表可变。",
                  "markdown": "报告在不可变的 Kotlin 集合上对 Java 更改器方法的调用（如 `fill`、`reverse`、`shuffle`、`sort`）。\n\n这可能会在运行时导致 `UnsupportedOperationException`。\n\n**示例：**\n\n\n      import java.util.Collections\n\n      fun test() {\n          val immutableList = listOf(1, 2)\n          Collections.reverse(immutableList)\n      }\n\n要修正此问题，请使列表可变。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaCollectionsStaticMethodOnImmutableList",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 互操作问题",
                      "index": 67,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MapGetWithNotNullAssertionOperator",
                "shortDescription": {
                  "text": "包含非 null 断言运算符 (!!) 的 'map.get()'"
                },
                "fullDescription": {
                  "text": "报告可替换为 'map.getValue()'、'map.getOrElse()' 等的 'map.get()!!'。 示例： 'fun test(map: Map<Int, String>): String = map.get(0)!!' 在应用快速修复后： 'fun test(map: Map<Int, String>): String = map.getValue(0)'",
                  "markdown": "报告可替换为 `map.getValue()`、`map.getOrElse()` 等的 `map.get()!!`。\n\n**示例：**\n\n\n    fun test(map: Map<Int, String>): String = map.get(0)!!\n\n在应用快速修复后：\n\n\n    fun test(map: Map<Int, String>): String = map.getValue(0)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MapGetWithNotNullAssertionOperator",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SortModifiers",
                "shortDescription": {
                  "text": "非规范修饰符顺序"
                },
                "fullDescription": {
                  "text": "报告未遵循样式指南中所建议顺序的修饰符。 对修饰符排序快速修复可用于自动修正代码。 示例： 'private inline fun correctOrder(f: () -> Unit) {} // <== Ok\n\n  infix private fun Int.wrongOrder(expr: Int) {} // <== 顺序错误，快速修复会将修饰符修正为 \"private infix\"'",
                  "markdown": "报告未遵循[样式指南](https://kotlinlang.org/docs/coding-conventions.html#modifiers-order)中所建议顺序的修饰符。\n\n**对修饰符排序**快速修复可用于自动修正代码。\n\n示例：\n\n\n      private inline fun correctOrder(f: () -> Unit) {} // <== Ok\n\n      infix private fun Int.wrongOrder(expr: Int) {} // <== 顺序错误，快速修复会将修饰符修正为 \"private infix\"\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SortModifiers",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenCoroutinesDeprecation",
                "shortDescription": {
                  "text": "与 Maven 中的 Kotlin 1.3+ 一起使用的 kotlinx.coroutines 依赖项不兼容"
                },
                "fullDescription": {
                  "text": "报告为了与 Kotlin 1.3 及更高版本兼容而应更新的 Maven 中的 kotlinx.coroutines 库依赖项。",
                  "markdown": "报告为了与 Kotlin 1.3 及更高版本兼容而应更新的 Maven 中的 **kotlinx.coroutines** 库依赖项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MavenCoroutinesDeprecation",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin，迁移/Maven",
                      "index": 110,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullableBooleanElvis",
                "shortDescription": {
                  "text": "可以使用相等检查代替 elvis 进行可以为 null 布尔检查"
                },
                "fullDescription": {
                  "text": "报告应该使用相等检查而不是 elvis 运算符的情况。 示例： 'fun check(a: Boolean? == null) {\n    if (a ?: false) throw IllegalStateException()\n}' 在应用快速修复后： 'fun check(a: Boolean? == null) {\n    if (a == true) throw IllegalStateException()\n}'",
                  "markdown": "报告应该使用相等检查而不是 elvis 运算符的情况。\n\n**示例：**\n\n\n    fun check(a: Boolean? == null) {\n        if (a ?: false) throw IllegalStateException()\n    }\n\n在应用快速修复后：\n\n\n    fun check(a: Boolean? == null) {\n        if (a == true) throw IllegalStateException()\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NullableBooleanElvis",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedMavenDependency",
                "shortDescription": {
                  "text": "在 Maven 中使用了弃用的库"
                },
                "fullDescription": {
                  "text": "报告已弃用的 Maven 依赖项。 示例： '<dependencies>\n    <dependency>\n        <groupId>org.jetbrains.kotlin</groupId>\n        <artifactId>kotlin-stdlib-jre7</artifactId>\n        <version>${kotlin.version}</version>\n    </dependency>\n  </dependencies>' 该快速修复会将已弃用的依赖项更改为维护的依赖项： '<dependencies>\n    <dependency>\n        <groupId>org.jetbrains.kotlin</groupId>\n        <artifactId>kotlin-stdlib-jdk7</artifactId>\n        <version>${kotlin.version}</version>\n    </dependency>\n  </dependencies>'",
                  "markdown": "报告已弃用的 Maven 依赖项。\n\n**示例：**\n\n\n      <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-stdlib-jre7</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n      </dependencies>\n\n该快速修复会将已弃用的依赖项更改为维护的依赖项：\n\n\n       <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-stdlib-jdk7</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n      </dependencies>\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedMavenDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumEntryName",
                "shortDescription": {
                  "text": "枚举条目命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循推荐的命名约定的枚举条目名称。 示例： 'enum class Foo {\n    _Foo,\n    foo\n  }' 要修正此问题，请重命名枚举条目以匹配推荐的命名约定。",
                  "markdown": "报告不遵循推荐的命名约定的枚举条目名称。\n\n**示例：**\n\n\n      enum class Foo {\n        _Foo,\n        foo\n      }\n\n要修正此问题，请重命名枚举条目以匹配推荐的命名约定。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EnumEntryName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryVariable",
                "shortDescription": {
                  "text": "不必要的局部变量"
                },
                "fullDescription": {
                  "text": "报告仅恰好在下一条 'return' 语句或其他变量的确切副本中使用的局部变量。 可以安全地内联此类变量，以使代码更加清晰易懂。 示例： 'fun sum(a: Int, b: Int): Int {\n      val c = a + b\n      return c\n  }' 在应用快速修复后： 'fun sum(a: Int, b: Int): Int {\n      return a + b\n  }' 配置检查： 使用报告立即返回的变量选项可以报告立即返回的变量。 当给定描述性名称时，此类变量在某些情况下可能会提高代码的可读性，这就是默认情况下禁用此选项的原因。",
                  "markdown": "报告仅恰好在下一条 `return` 语句或其他变量的确切副本中使用的局部变量。\n\n可以安全地内联此类变量，以使代码更加清晰易懂。\n\n**示例：**\n\n\n      fun sum(a: Int, b: Int): Int {\n          val c = a + b\n          return c\n      }\n\n在应用快速修复后：\n\n\n      fun sum(a: Int, b: Int): Int {\n          return a + b\n      }\n\n配置检查：\n\n使用**报告立即返回的变量**选项可以报告立即返回的变量。\n当给定描述性名称时，此类变量在某些情况下可能会提高代码的可读性，这就是默认情况下禁用此选项的原因。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryVariable",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithDropLast",
                "shortDescription": {
                  "text": "'substring' 调用应被替换为 'dropLast' 调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为 's.dropLast(x)' 的 's.substring(0, s.length - x)' 等调用。 使用相应函数可使代码更简单。 该快速修复会将 'substring' 调用替换为 'dropLast'。 示例： 'fun foo(s: String) {\n      s.substring(0, s.length - 5)\n  }' 在应用快速修复后： 'fun foo(s: String) {\n      s.dropLast(5)\n  }'",
                  "markdown": "报告可以替换为 `s.dropLast(x)` 的 `s.substring(0, s.length - x)` 等调用。\n\n使用相应函数可使代码更简单。\n\n该快速修复会将 `substring` 调用替换为 `dropLast`。\n\n**示例：**\n\n\n      fun foo(s: String) {\n          s.substring(0, s.length - 5)\n      }\n\n在应用快速修复后：\n\n\n      fun foo(s: String) {\n          s.dropLast(5)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithDropLast",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SetterBackingFieldAssignment",
                "shortDescription": {
                  "text": "不包含赋值的现有支持字段"
                },
                "fullDescription": {
                  "text": "报告不更新支持字段的属性 setter。 该快速修复会向支持字段中添加赋值。 示例： 'class Test {\n      var foo: Int = 1\n          set(value) {\n          }\n  }' 在应用快速修复后： 'class Test {\n      var foo: Int = 1\n          set(value) {\n              field = value\n          }\n  }'",
                  "markdown": "报告不更新支持字段的属性 setter。\n\n该快速修复会向支持字段中添加赋值。\n\n**示例：**\n\n\n      class Test {\n          var foo: Int = 1\n              set(value) {\n              }\n      }\n\n在应用快速修复后：\n\n\n      class Test {\n          var foo: Int = 1\n              set(value) {\n                  field = value\n              }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SetterBackingFieldAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CopyWithoutNamedArguments",
                "shortDescription": {
                  "text": "数据类的 'copy' 方法在没有命名实参的情况下调用"
                },
                "fullDescription": {
                  "text": "报告对没有命名实参的数据类的 'copy()' 方法的调用。 由于 'copy()' 函数的所有实参都是可选的，因此可能很难理解修改了哪些属性。 显式提供形参名称使得代码容易理解，且无需导航到 'data class' 声明。 示例： 'data class User(val name: String, val age: Int)\n\n  fun copyUser(user: User): User {\n      return user.copy(\"John\")\n  }' 该快速修复程序会为所有的 'copy()' 实参提供形参名称： 'data class User(val name: String, val age: Int)\n\n  fun copyUser(user: User): User {\n      return user.copy(name = \"John\")\n  }'",
                  "markdown": "报告对没有命名实参的数据类的 `copy()` 方法的调用。\n\n\n由于 `copy()` 函数的所有实参都是可选的，因此可能很难理解修改了哪些属性。\n显式提供形参名称使得代码容易理解，且无需导航到 `data class` 声明。\n\n**示例：**\n\n\n      data class User(val name: String, val age: Int)\n\n      fun copyUser(user: User): User {\n          return user.copy(\"John\")\n      }\n\n该快速修复程序会为所有的 `copy()` 实参提供形参名称：\n\n\n      data class User(val name: String, val age: Int)\n\n      fun copyUser(user: User): User {\n          return user.copy(name = \"John\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CopyWithoutNamedArguments",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantConstructorKeyword",
                "shortDescription": {
                  "text": "冗余的 'constructor' 关键字"
                },
                "fullDescription": {
                  "text": "报告主构造函数上的冗余 'constructor' 关键字。 示例： 'class Foo constructor(x: Int, y: Int)' 在应用快速修复后： 'class Foo(x: Int, y: Int)'",
                  "markdown": "报告主构造函数上的冗余 'constructor' 关键字。\n\n**示例：**\n\n\n      class Foo constructor(x: Int, y: Int)\n\n在应用快速修复后：\n\n\n      class Foo(x: Int, y: Int)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantConstructorKeyword",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinDeprecation",
                "shortDescription": {
                  "text": "使用了冗余或弃用的语法或弃用的符号"
                },
                "fullDescription": {
                  "text": "在代码清理操作（代码 | 代码清理）期间报告过时的语言功能和不必要的冗长代码结构。 该快速修复会自动将过时的语言功能或不必要的冗长代码结构的用法替换为紧凑和最新的语法。 还会将弃用的符号替换为建议的替换项。",
                  "markdown": "在代码清理操作（**代码 \\| 代码清理** ）期间报告过时的语言功能和不必要的冗长代码结构。\n\n\n该快速修复会自动将过时的语言功能或不必要的冗长代码结构的用法替换为紧凑和最新的语法。\n\n\n还会将弃用的符号替换为建议的替换项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinDeprecation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEmptyInitializerBlock",
                "shortDescription": {
                  "text": "冗余空白初始值设定项块"
                },
                "fullDescription": {
                  "text": "报告冗余的空初始值设定项块。 示例： 'class Foo {\n      init {\n          // 空 init 块\n      }\n  }' 在应用快速修复后： 'class Foo {\n  }'",
                  "markdown": "报告冗余的空初始值设定项块。\n\n**示例：**\n\n\n      class Foo {\n          init {\n              // 空 init 块\n          }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantEmptyInitializerBlock",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithTake",
                "shortDescription": {
                  "text": "'substring' 调用应被替换为 'take' 调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为 's.take(x)' 的 's.substring(0, x)' 等调用。 使用 'take()' 可使代码更简单。 该快速修复会将 'substring' 调用替换为 'take()'。 示例： 'fun foo(s: String) {\n      s.substring(0, 10)\n  }' 在应用快速修复后： 'fun foo(s: String) {\n      s.take(10)\n  }'",
                  "markdown": "报告可以替换为 `s.take(x)` 的 `s.substring(0, x)` 等调用。\n\n使用 `take()` 可使代码更简单。\n\n该快速修复会将 `substring` 调用替换为 `take()`。\n\n**示例：**\n\n\n      fun foo(s: String) {\n          s.substring(0, 10)\n      }\n\n在应用快速修复后：\n\n\n      fun foo(s: String) {\n          s.take(10)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithTake",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceRangeToWithRangeUntil",
                "shortDescription": {
                  "text": "'rangeTo' 或 '..' 调用应被替换为 '..<'"
                },
                "fullDescription": {
                  "text": "报告对 'rangeTo' 或 '..' 运算符的调用，而非对 '..' 的调用。 使用相应函数可使代码更简单。 该快速修复会将 'rangeTo' 或 '..' 调用替换为 '..'。 示例： 'fun foo(a: Int) {\n      for (i in 0..a - 1) {\n\n      }\n  }' 在应用快速修复后： 'fun foo(a: Int) {\n      for (i in 0..<a) {\n\n      }\n  }'",
                  "markdown": "报告对 `rangeTo` 或 `..` 运算符的调用，而非对 `..` 的调用。\n\n使用相应函数可使代码更简单。\n\n该快速修复会将 `rangeTo` 或 `..` 调用替换为 `..`。\n\n**示例：**\n\n\n      fun foo(a: Int) {\n          for (i in 0..a - 1) {\n\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun foo(a: Int) {\n          for (i in 0..<a) {\n\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceRangeToWithRangeUntil",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertCallChainIntoSequence",
                "shortDescription": {
                  "text": "可以将集合上的调用链转换为 'Sequence' 来改善性能"
                },
                "fullDescription": {
                  "text": "报告应转换为 Sequence 的 'Collection' 上的调用链。 每个 'Collection' 转换函数（例如 'map()' 或 'filter()'）都会在后台创建一个新的 'Collection'（通常是 'List' 或 'Set'）。 多次后续调用以及 'Collection' 中存在大量条目的情况下，内存流量可能会很大。 这种情况下，最好使用 'Sequence'。 示例： 'class Entity(val key: String, val value: String)\n\n  fun getValues(lines: List<String>) = lines\n      .filter { it.isNotEmpty() }\n      .map { it.split(',', limit = 2) }\n      .filter { it.size == 2 }\n      .map { Entity(it[0], it[1]) }' 该快速修复会将调用链包装到 'asSequence()' 和 'toList()' 中： 'class Entity(val key: String, val value: String)\n\n  fun getValues(lines: List<String>) = lines\n      .asSequence()\n      .filter { it.isNotEmpty() }\n      .map { it.split(',', limit = 2) }\n      .filter { it.size == 2 }\n      .map { Entity(it[0], it[1]) }\n      .toList()'",
                  "markdown": "报告应转换为 **Sequence** 的 `Collection` 上的调用链。\n\n每个 `Collection` 转换函数（例如 `map()` 或 `filter()`）都会在后台创建一个新的\n`Collection`（通常是 `List` 或 `Set`）。\n多次后续调用以及 `Collection` 中存在大量条目的情况下，内存流量可能会很大。\n这种情况下，最好使用 `Sequence`。\n\n**示例：**\n\n\n      class Entity(val key: String, val value: String)\n\n      fun getValues(lines: List<String>) = lines\n          .filter { it.isNotEmpty() }\n          .map { it.split(',', limit = 2) }\n          .filter { it.size == 2 }\n          .map { Entity(it[0], it[1]) }\n\n该快速修复会将调用链包装到 `asSequence()` 和 `toList()` 中：\n\n\n      class Entity(val key: String, val value: String)\n\n      fun getValues(lines: List<String>) = lines\n          .asSequence()\n          .filter { it.isNotEmpty() }\n          .map { it.split(',', limit = 2) }\n          .filter { it.size == 2 }\n          .map { Entity(it[0], it[1]) }\n          .toList()\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertCallChainIntoSequence",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AddOperatorModifier",
                "shortDescription": {
                  "text": "函数应具有 'operator' 修饰符"
                },
                "fullDescription": {
                  "text": "报告与其中一个运算符约定匹配但缺少 'operator' 关键字的函数。 通过添加 'operator' 修饰符，您可以允许函数使用者编写惯用的 Kotlin 代码。 示例： 'class Complex(val real: Double, val imaginary: Double) {\n      fun plus(other: Complex) =\n          Complex(real + other.real, imaginary + other.imaginary)\n  }\n\n  fun usage(a: Complex, b: Complex) {\n      a.plus(b)\n  }' 该快速修复会添加 'operator' 修饰符关键字： 'class Complex(val real: Double, val imaginary: Double) {\n      operator fun plus(other: Complex) =\n          Complex(real + other.real, imaginary + other.imaginary)\n  }\n\n  fun usage(a: Complex, b: Complex) {\n      a + b\n  }'",
                  "markdown": "报告与其中一个运算符约定匹配但缺少 `operator` 关键字的函数。\n\n通过添加 `operator` 修饰符，您可以允许函数使用者编写惯用的 Kotlin 代码。\n\n**示例：**\n\n\n      class Complex(val real: Double, val imaginary: Double) {\n          fun plus(other: Complex) =\n              Complex(real + other.real, imaginary + other.imaginary)\n      }\n\n      fun usage(a: Complex, b: Complex) {\n          a.plus(b)\n      }\n\n该快速修复会添加 `operator` 修饰符关键字：\n\n\n      class Complex(val real: Double, val imaginary: Double) {\n          operator fun plus(other: Complex) =\n              Complex(real + other.real, imaginary + other.imaginary)\n      }\n\n      fun usage(a: Complex, b: Complex) {\n          a + b\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AddOperatorModifier",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLabeledReturnOnLastExpressionInLambda",
                "shortDescription": {
                  "text": "lambda 中最后一个表达式上带标签的冗余 return"
                },
                "fullDescription": {
                  "text": "报告在 lambdas 中的最后一个表达式上使用的带标签的 return。 此类 return 冗余，可以安全移除。 示例： 'fun foo() {\n  listOf(1,2,3).find {\n    return@find true\n  }\n}' 在应用快速修复后： 'fun foo() {\n  listOf(1,2,3).find {\n    true\n  }\n}'",
                  "markdown": "报告在 lambdas 中的最后一个表达式上使用的带标签的 return。\n\n此类 return 冗余，可以安全移除。\n\n**示例：**\n\n\n    fun foo() {\n      listOf(1,2,3).find {\n        return@find true\n      }\n    }\n\n在应用快速修复后：\n\n\n    fun foo() {\n      listOf(1,2,3).find {\n        true\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLabeledReturnOnLastExpressionInLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MayBeConstant",
                "shortDescription": {
                  "text": "可能为 'const'"
                },
                "fullDescription": {
                  "text": "报告为了获得更好的性能和 Java 互操作性而可能声明为 'const' 的对象中的顶级 'val' 属性。 示例： 'object A {\n      val foo = 1\n  }' 在应用快速修复后： 'object A {\n      const val foo = 1\n  }'",
                  "markdown": "报告为了获得更好的性能和 Java 互操作性而可能声明为 `const` 的对象中的顶级 `val` 属性。\n\n**示例：**\n\n\n      object A {\n          val foo = 1\n      }\n\n在应用快速修复后：\n\n\n      object A {\n          const val foo = 1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MayBeConstant",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GradleKotlinxCoroutinesDeprecation",
                "shortDescription": {
                  "text": "与 Gradle 中的 Kotlin 1.3+ 一起使用的 kotlinx.coroutines 依赖项不兼容"
                },
                "fullDescription": {
                  "text": "报告为了与 Kotlin 1.3+ 兼容而应更新的 Gradle 中的 'kotlinx.coroutines' 库依赖项。 示例： 'dependencies {\n      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.0.1'\n  }' 该快速修复会将 'kotlinx.coroutines' 库版本更改为与 Kotlin 1.3 兼容的版本： 'dependencies {\n      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.27.0-eap13'\n  }'",
                  "markdown": "报告为了与 Kotlin 1.3+ 兼容而应更新的 Gradle 中的 `kotlinx.coroutines` 库依赖项。\n\n**示例：**\n\n\n      dependencies {\n          implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.0.1'\n      }\n\n该快速修复会将 `kotlinx.coroutines` 库版本更改为与 Kotlin 1.3 兼容的版本：\n\n\n      dependencies {\n          implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.27.0-eap13'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "GradleKotlinxCoroutinesDeprecation",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin，迁移/Gradle",
                      "index": 117,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WarningOnMainUnusedParameterMigration",
                "shortDescription": {
                  "text": "从 1.4 起，'main' 上不再使用 'args'"
                },
                "fullDescription": {
                  "text": "报告带有单个未使用形参的 'main' 函数。 从 Kotlin 1.4 开始，可以使用不带形参的 'main' 函数作为 Kotlin 程序的入口点。 编译器会报告具有未使用形参的 'main' 函数的警告。",
                  "markdown": "报告带有单个未使用形参的 `main` 函数。\n\n从 Kotlin 1.4 开始，可以使用不带形参的 `main` 函数作为 Kotlin 程序的入口点。\n编译器会报告具有未使用形参的 `main` 函数的警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WarningOnMainUnusedParameterMigration",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantWith",
                "shortDescription": {
                  "text": "冗余 'with' 调用"
                },
                "fullDescription": {
                  "text": "报告不从接收器访问任何内容的冗余 'with' 函数调用。 示例： 'class MyClass {\n      fun f(): String = \"\"\n  }\n\n  fun testRedundant() {\n      with(c) { // <== 'with' 冗余，因为 'c' 未使用\n          println(\"1\")\n      }\n  }\n\n  fun testOk() {\n      val c = MyClass()\n      with(c) { // <== 可以，因为 'f()' 是有效的 'c.f()'\n          println(f())\n      }\n  }'",
                  "markdown": "报告不从接收器访问任何内容的冗余 `with` 函数调用。\n\n**示例：**\n\n\n      class MyClass {\n          fun f(): String = \"\"\n      }\n\n      fun testRedundant() {\n          with(c) { // <== 'with' 冗余，因为 'c' 未使用\n              println(\"1\")\n          }\n      }\n\n      fun testOk() {\n          val c = MyClass()\n          with(c) { // <== 可以，因为 'f()' 是有效的 'c.f()'\n              println(f())\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantWith",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceIsEmptyWithIfEmpty",
                "shortDescription": {
                  "text": "'if' 条件可被替换为 lambda 调用"
                },
                "fullDescription": {
                  "text": "报告 'if' 语句中的 'isEmpty'、'isBlank'、'isNotEmpty' 或 'isNotBlank' 调用以赋予默认值。 该快速修复会将 'if' 条件替换为 'ifEmpty' 或 'ifBlank' 调用。 示例： 'fun test(list: List<Int>): List<Int> {\n      return if (list.isEmpty()) {\n          println()\n          foo()\n      } else {\n          list\n      }\n  }' 在应用快速修复后： 'fun test(list: List<Int>): List<Int> {\n      return list.ifEmpty {\n          println()\n          foo()\n      }\n  }' 此检查仅报告项目或模块的 Kotlin 语言版本是否为 1.3 或更高版本。",
                  "markdown": "报告 `if` 语句中的 `isEmpty`、`isBlank`、`isNotEmpty` 或 `isNotBlank` 调用以赋予默认值。\n\n该快速修复会将 `if` 条件替换为 `ifEmpty` 或 `ifBlank` 调用。\n\n**示例：**\n\n\n      fun test(list: List<Int>): List<Int> {\n          return if (list.isEmpty()) {\n              println()\n              foo()\n          } else {\n              list\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun test(list: List<Int>): List<Int> {\n          return list.ifEmpty {\n              println()\n              foo()\n          }\n      }\n\n此检查仅报告项目或模块的 Kotlin 语言版本是否为 1.3 或更高版本。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceIsEmptyWithIfEmpty",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLabelMigration",
                "shortDescription": {
                  "text": "冗余标签"
                },
                "fullDescription": {
                  "text": "从 Kotlin 1.4 开始，报告导致编译错误的冗余标签。 从 Kotlin 1.0 开始，可以用标签标记任何语句： 'fun foo() {\n    L1@ val x = L2@bar()\n  }' 但是，这些标签仅能以有限的几种方式引用： 中断/继续循环 从内联 lambda 或内联匿名函数的非本地返回 sssss 从 Kotlin 1.4 开始禁止使用此类标签。 仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。",
                  "markdown": "从 Kotlin 1.4 开始，报告导致编译错误的冗余标签。\n\n从 Kotlin 1.0 开始，可以用标签标记任何语句：\n\n\n      fun foo() {\n        L1@ val x = L2@bar()\n      }\n\n但是，这些标签仅能以有限的几种方式引用：\n\n* 中断/继续循环\n* 从内联 lambda 或内联匿名函数的非本地返回\nsssss\n\n从 Kotlin 1.4 开始禁止使用此类标签。\n\n仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLabelMigration",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinRedundantDiagnosticSuppress",
                "shortDescription": {
                  "text": "冗余的诊断禁止"
                },
                "fullDescription": {
                  "text": "报告由于其影响的编译器诊断在此上下文中不再适用而可以安全移除的 '@Suppress' 注解。 示例： 'fun doSmth(@Suppress(\"UNUSED_PARAMETER\") used: Int) {\n    println(used)\n  }' 在应用快速修复后： 'fun doSmth(used: Int) {\n    println(used)\n  }'",
                  "markdown": "报告由于其影响的编译器诊断在此上下文中不再适用而可以安全移除的 `@Suppress` 注解。\n\n**示例：**\n\n\n      fun doSmth(@Suppress(\"UNUSED_PARAMETER\") used: Int) {\n        println(used)\n      }\n\n在应用快速修复后：\n\n\n      fun doSmth(used: Int) {\n        println(used)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinRedundantDiagnosticSuppress",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithImportAlias",
                "shortDescription": {
                  "text": "完全限定名称可被替换为现有的导入别名"
                },
                "fullDescription": {
                  "text": "报告可以替换为现有导入别名的完全限定名称。 示例： 'import foo.Foo as Bar\nfun main() {\n    foo.Foo()\n}' 在应用快速修复后： 'import foo.Foo as Bar\nfun main() {\n    Bar()\n}'",
                  "markdown": "报告可以替换为现有导入别名的完全限定名称。\n\n**示例：**\n\n\n    import foo.Foo as Bar\n    fun main() {\n        foo.Foo()\n    }\n\n在应用快速修复后：\n\n\n    import foo.Foo as Bar\n    fun main() {\n        Bar()\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceWithImportAlias",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceNegatedIsEmptyWithIsNotEmpty",
                "shortDescription": {
                  "text": "可以简化否定调用"
                },
                "fullDescription": {
                  "text": "报告集合与 'String' 的否定 'isEmpty()' 和 'isNotEmpty()'，或者 'String' 的 'isBlank()' 和 'isNotBlank()'。 使用相应函数可使代码更简单。 该快速修复会将否定调用替换为标准库中的相应调用。 示例： 'fun main() {\n      val list = listOf(1,2,3)\n      if (!list.isEmpty()) {\n          // 执行 smth\n      }\n  }' 在应用快速修复后： 'fun main() {\n      val list = listOf(1,2,3)\n      if (list.isNotEmpty()) {\n          // 执行 smth\n      }\n  }'",
                  "markdown": "报告集合与 `String` 的否定 `isEmpty()` 和 `isNotEmpty()`，或者 `String` 的 `isBlank()` 和 `isNotBlank()`。\n\n使用相应函数可使代码更简单。\n\n该快速修复会将否定调用替换为标准库中的相应调用。\n\n**示例：**\n\n\n      fun main() {\n          val list = listOf(1,2,3)\n          if (!list.isEmpty()) {\n              // 执行 smth\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun main() {\n          val list = listOf(1,2,3)\n          if (list.isNotEmpty()) {\n              // 执行 smth\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceNegatedIsEmptyWithIsNotEmpty",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DelegationToVarProperty",
                "shortDescription": {
                  "text": "正在委托给 'var' 属性"
                },
                "fullDescription": {
                  "text": "报告至 'var' 属性的接口委托 仅使用属性的初始值进行委托，任何后续的赋值都不会影响它。 示例： 'class Example(var text: CharSequence): CharSequence by text' 该快速修复会将属性替换为不可变的属性： 'class Example(val text: CharSequence): CharSequence by text' 如果您出于某种原因依赖可变性，则可使用另一种方法： 'class Example(text: CharSequence): CharSequence by text {\n      var text = text\n  }'",
                  "markdown": "报告至 `var` 属性的接口委托\n\n仅使用属性的初始值进行委托，任何后续的赋值都不会影响它。\n\n**示例：**\n\n\n      class Example(var text: CharSequence): CharSequence by text\n\n该快速修复会将属性替换为不可变的属性：\n\n\n      class Example(val text: CharSequence): CharSequence by text\n\n如果您出于某种原因依赖可变性，则可使用另一种方法：\n\n\n      class Example(text: CharSequence): CharSequence by text {\n          var text = text\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DelegationToVarProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantConditionIf",
                "shortDescription": {
                  "text": "'if' 表达式的条件为常量"
                },
                "fullDescription": {
                  "text": "报告具有 'true' 或 'false' 常量文字条件且可以简化的 'if' 表达式。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误或之前的重构所致。 示例： 'fun example() {\n      if (true) {\n          throw IllegalStateException(\"Unexpected state\")\n      }\n  }' 该快速修复会移除 'if' 条件： 'fun example() {\n      throw IllegalStateException(\"Unexpected state\")\n  }'",
                  "markdown": "报告具有 `true` 或 `false` 常量文字条件且可以简化的 `if` 表达式。\n\n虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误或之前的重构所致。\n\n**示例：**\n\n\n      fun example() {\n          if (true) {\n              throw IllegalStateException(\"Unexpected state\")\n          }\n      }\n\n该快速修复会移除 `if` 条件：\n\n\n      fun example() {\n          throw IllegalStateException(\"Unexpected state\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConstantConditionIf",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLambdaArrow",
                "shortDescription": {
                  "text": "冗余 lambda 箭头"
                },
                "fullDescription": {
                  "text": "报告没有形参的 lambda 中的冗余 lambda 箭头。 示例： 'fun foo(f: () -> Unit) = f()\n\n  fun bar() {\n      foo { -> println(\"Hi!\") }\n  }' 在应用快速修复后： 'fun foo(f: () -> Unit) = f()\n\n  fun bar() {\n      foo { println(\"Hi!\") }\n  }'",
                  "markdown": "报告没有形参的 lambda 中的冗余 lambda 箭头。\n\n**示例：**\n\n\n      fun foo(f: () -> Unit) = f()\n\n      fun bar() {\n          foo { -> println(\"Hi!\") }\n      }\n\n在应用快速修复后：\n\n\n      fun foo(f: () -> Unit) = f()\n\n      fun bar() {\n          foo { println(\"Hi!\") }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLambdaArrow",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinInternalInJava",
                "shortDescription": {
                  "text": "使用来自 Java 的 Kotlin 内部声明"
                },
                "fullDescription": {
                  "text": "报告位于不同模块中的 Java 代码中 Kotlin 'internal' 声明的用法。 'internal' 关键字旨在限制对其他模块的类、函数或属性的访问。 由于 JVM 限制，'internal' 类、函数和属性仍然可以从 Kotlin 外部访问，这可能会导致兼容性问题。",
                  "markdown": "报告位于不同模块中的 Java 代码中 Kotlin `internal` 声明的用法。\n\n\n`internal` 关键字旨在限制对其他模块的类、函数或属性的访问。\n由于 JVM 限制，`internal` 类、函数和属性仍然可以从 Kotlin 外部访问，这可能会导致兼容性问题。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "KotlinInternalInJava",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 互操作问题",
                      "index": 67,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyBooleanWithConstants",
                "shortDescription": {
                  "text": "可以简化布尔表达式"
                },
                "fullDescription": {
                  "text": "报告能够缩减为常量的布尔表达式。 该快速修复会简化条件。 示例： 'fun use(arg: Boolean) {\n      if (false == arg) {\n\n      }\n  }' 在应用快速修复后： 'fun use(arg: Boolean) {\n      if (!arg) {\n\n      }\n  }'",
                  "markdown": "报告能够缩减为常量的布尔表达式。\n\n该快速修复会简化条件。\n\n**示例：**\n\n\n      fun use(arg: Boolean) {\n          if (false == arg) {\n\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun use(arg: Boolean) {\n          if (!arg) {\n\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyBooleanWithConstants",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverrideDeprecatedMigration",
                "shortDescription": {
                  "text": "自 1.9 起不得通过重写传播方法描述"
                },
                "fullDescription": {
                  "text": "报告从 1.9 版开始会导致编译错误的由 '@Deprecated' 注解传播的声明。 动机类型： 出于实现设计/架构原因，需要对实现进行更改 设计中的不一致（在不同的上下文中存在不同的处理方式） 更多详细信息：KT-47902：不要通过重写传播方法弃用 该快速修复会复制父声明中的 '@Deprecated' 注解。 示例： 'open class Base {\n      @Deprecated(\"Don't use\")\n      open fun foo() {}\n  }\n\n  class Derived : Base() {\n      override fun foo() {}\n  }' 在应用快速修复后： 'open class Base {\n      @Deprecated(\"Don't use\")\n      open fun foo() {}\n  }\n\n  class Derived : Base() {\n      @Deprecated(\"Don't use\")\n      override fun foo() {}\n  }' 仅当项目或模块的 Kotlin 语言级别为 1.6 或更高时，此检查才会报告。",
                  "markdown": "报告从 1.9 版开始会导致编译错误的由 `@Deprecated` 注解传播的声明。\n\n动机类型：\n\n* 出于实现设计/架构原因，需要对实现进行更改\n* 设计中的不一致（在不同的上下文中存在不同的处理方式）\n\n**更多详细信息** ：[KT-47902：不要通过重写传播方法弃用](https://youtrack.jetbrains.com/issue/KT-47902)\n\n该快速修复会复制父声明中的 `@Deprecated` 注解。\n\n**示例：**\n\n\n      open class Base {\n          @Deprecated(\"Don't use\")\n          open fun foo() {}\n      }\n\n      class Derived : Base() {\n          override fun foo() {}\n      }\n\n在应用快速修复后：\n\n\n      open class Base {\n          @Deprecated(\"Don't use\")\n          open fun foo() {}\n      }\n\n      class Derived : Base() {\n          @Deprecated(\"Don't use\")\n          override fun foo() {}\n      }\n\n仅当项目或模块的 Kotlin 语言级别为 1.6 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "OverrideDeprecatedMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoConstructorMigration",
                "shortDescription": {
                  "text": "禁止的构造函数调用"
                },
                "fullDescription": {
                  "text": "报告从 1.9 版开始会导致编译错误的函数父类型上的构造函数调用。 动机类型： 该实现不遵守已发布的规范或文档 更多详细信息：KT-46344：在父类型列表中的函数接口上调用超类构造函数没有错误 该快速修复会移除构造函数调用。 示例： 'abstract class A : () -> Int()' 在应用快速修复后： 'abstract class A : () -> Int' 仅当项目或模块的 Kotlin 语言级别为 1.7 或更高时，此检查才会报告。",
                  "markdown": "报告从 1.9 版开始会导致编译错误的函数父类型上的构造函数调用。\n\n动机类型：\n\n* 该实现不遵守已发布的规范或文档\n\n**更多详细信息** ：[KT-46344：在父类型列表中的函数接口上调用超类构造函数没有错误](https://youtrack.jetbrains.com/issue/KT-46344)\n\n该快速修复会移除构造函数调用。\n\n**示例：**\n\n\n      abstract class A : () -> Int()\n\n在应用快速修复后：\n\n\n      abstract class A : () -> Int\n\n仅当项目或模块的 Kotlin 语言级别为 1.7 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "NoConstructorMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantValueArgument",
                "shortDescription": {
                  "text": "冗余值实参"
                },
                "fullDescription": {
                  "text": "报告等于相应形参的默认值的实参。 示例： 'fun foo(x: Int, y: Int = 2) {}\n\nfun bar() {\n    foo(1, 2)\n}' 在应用快速修复后： 'fun bar() {\n    foo(1)\n}'",
                  "markdown": "报告等于相应形参的默认值的实参。\n\n**示例：**\n\n\n    fun foo(x: Int, y: Int = 2) {}\n\n    fun bar() {\n        foo(1, 2)\n    }\n\n在应用快速修复后：\n\n\n    fun bar() {\n        foo(1)\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantValueArgument",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantModalityModifier",
                "shortDescription": {
                  "text": "冗余形式修饰符"
                },
                "fullDescription": {
                  "text": "报告与元素的默认模态匹配的模态修饰符（对于大多数元素来说是 'final'，对于具有 'override' 的成员来说是 'open'）。 示例： 'final class Foo\n\n  open class Bar : Comparable<Bar> {\n      open override fun compareTo(other: Bar): Int = 0\n  }' 在应用快速修复后： 'class Foo\n\n  open class Bar : Comparable<Bar> {\n      override fun compareTo(other: Bar): Int = 0\n  }'",
                  "markdown": "报告与元素的默认模态匹配的模态修饰符（对于大多数元素来说是 `final`，对于具有 `override` 的成员来说是 `open`）。\n\n**示例：**\n\n\n      final class Foo\n\n      open class Bar : Comparable<Bar> {\n          open override fun compareTo(other: Bar): Int = 0\n      }\n\n在应用快速修复后：\n\n\n      class Foo\n\n      open class Bar : Comparable<Bar> {\n          override fun compareTo(other: Bar): Int = 0\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantModalityModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseWithIndex",
                "shortDescription": {
                  "text": "手动递增的索引变量可被替换为使用 'withIndex()'"
                },
                "fullDescription": {
                  "text": "报告带有手动递增索引变量的 'for' 循环。 可以使用 'withIndex()' 函数简化带有手动递增索引变量的 'for' 循环。 使用 withIndex() 代替手动索引递增快速修复可用于自动修正代码。 示例： 'fun foo(list: List<String>): Int? {\n      var index = 0\n      for (s in list) { <== can be simplified\n          val x = s.length * index\n          index++\n          if (x > 0) return x\n      }\n      return null\n  }' 在应用快速修复后： 'fun foo(list: List<String>): Int? {\n      for ((index, s) in list.withIndex()) {\n          val x = s.length * index\n          if (x > 0) return x\n      }\n      return null\n  }'",
                  "markdown": "报告带有手动递增索引变量的 `for` 循环。\n\n可以使用 `withIndex()` 函数简化带有手动递增索引变量的 `for` 循环。\n\n**使用 withIndex() 代替手动索引递增**快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun foo(list: List<String>): Int? {\n          var index = 0\n          for (s in list) { <== can be simplified\n              val x = s.length * index\n              index++\n              if (x > 0) return x\n          }\n          return null\n      }\n\n在应用快速修复后：\n\n\n      fun foo(list: List<String>): Int? {\n          for ((index, s) in list.withIndex()) {\n              val x = s.length * index\n              if (x > 0) return x\n          }\n          return null\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UseWithIndex",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyAssertNotNull",
                "shortDescription": {
                  "text": "'assert' 调用可被替换为 '!!' 或 '?:'"
                },
                "fullDescription": {
                  "text": "报告检查已声明变量非 null 值的 'assert' 调用。 使用 '!!' or '?:' 可使代码更简单。 该快速修复会将变量初始值设定项中的 'assert' 替换为 '!!' 或 '?:' 运算符。 示例： 'fun foo(p: Array<String?>) {\n      val v = p[0]\n      assert(v != null, { \"Should be not null\" })\n  }' 在应用快速修复后： 'fun foo(p: Array<String?>) {\n      val v = p[0] ?: error(\"Should be not null\")\n  }'",
                  "markdown": "报告检查已声明变量非 null 值的 `assert` 调用。\n\n使用 `!!` or `?:` 可使代码更简单。\n\n该快速修复会将变量初始值设定项中的 `assert` 替换为 `!!` 或 `?:` 运算符。\n\n**示例：**\n\n\n      fun foo(p: Array<String?>) {\n          val v = p[0]\n          assert(v != null, { \"Should be not null\" })\n      }\n\n在应用快速修复后：\n\n\n      fun foo(p: Array<String?>) {\n          val v = p[0] ?: error(\"Should be not null\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyAssertNotNull",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertNaNEquality",
                "shortDescription": {
                  "text": "将带 'NaN' 的相等检查转换为 'isNaN' 调用"
                },
                "fullDescription": {
                  "text": "报告使用 'Float.NaN' 或 'Double.NaN' 的相等检查（应替换为 'isNaN()' 检查）。 根据 IEEE 754，对照 NaN 进行的相等检查始终返回 'false'，即便对 'NaN == NaN' 也如此。 因此，这种检查很可能是错误的。 该快速修复会将比较替换为使用不同比较技术的 'isNaN()' 检查，并能够正确处理 'NaN' 值。 示例： 'fun check(value: Double): Boolean {\n      return Double.NaN == value\n  }' 应用修正后： 'fun check(value: Double): Boolean {\n      return value.isNaN()\n  }'",
                  "markdown": "报告使用 `Float.NaN` 或 `Double.NaN` 的相等检查（应替换为 `isNaN()` 检查）。\n\n\n根据 IEEE 754，对照 NaN 进行的相等检查始终返回 `false`，即便对 `NaN == NaN` 也如此。\n因此，这种检查很可能是错误的。\n\n该快速修复会将比较替换为使用不同比较技术的 `isNaN()` 检查，并能够正确处理 `NaN` 值。\n\n**示例：**\n\n\n      fun check(value: Double): Boolean {\n          return Double.NaN == value\n      }\n\n应用修正后：\n\n\n      fun check(value: Double): Boolean {\n          return value.isNaN()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConvertNaNEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceManualRangeWithIndicesCalls",
                "shortDescription": {
                  "text": "范围可以转换为索引或迭代"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'Collection.indices' 或 'for' 循环内集合迭代的 'until' 和 'rangeTo' 运算符。 使用语法糖可使代码更简单。 该快速修复会将手动范围替换为相应的构造。 示例： 'fun main(args: Array<String>) {\n      for (index in 0..args.size - 1) {\n          println(args[index])\n      }\n  }' 在应用快速修复后： 'fun main(args: Array<String>) {\n      for (element in args) {\n          println(element)\n      }\n  }'",
                  "markdown": "报告可以替换为 `Collection.indices` 或 `for` 循环内集合迭代的 `until` 和 `rangeTo` 运算符。\n\n使用语法糖可使代码更简单。\n\n该快速修复会将手动范围替换为相应的构造。\n\n**示例：**\n\n\n      fun main(args: Array<String>) {\n          for (index in 0..args.size - 1) {\n              println(args[index])\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun main(args: Array<String>) {\n          for (element in args) {\n              println(element)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceManualRangeWithIndicesCalls",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinLoggerInitializedWithForeignClass",
                "shortDescription": {
                  "text": "使用外类初始化记录器"
                },
                "fullDescription": {
                  "text": "报告使用类文字初始化的 'Logger' 实例，而非使用 'Logger' 驻留的类。 当从另一个类复制粘贴时可能会发生这种情况。 这可能导致记录意外类别下的事件以及错误筛选。 使用检查选项可指定此检查识别的记录器工厂类和方法。 示例： 'class AnotherService\nclass MyService {\n    private val logger = LoggerFactory.getLogger(AnotherService::class.java)\n}' 在应用快速修复后： 'class MyService {\n    private val logger = LoggerFactory.getLogger(MyService::class.java)\n}'",
                  "markdown": "报告使用类文字初始化的 `Logger` 实例，而非使用 `Logger` 驻留的类。\n\n\n当从另一个类复制粘贴时可能会发生这种情况。\n这可能导致记录意外类别下的事件以及错误筛选。\n\n\n使用检查选项可指定此检查识别的记录器工厂类和方法。\n\n**示例：**\n\n\n    class AnotherService\n    class MyService {\n        private val logger = LoggerFactory.getLogger(AnotherService::class.java)\n    }\n\n在应用快速修复后：\n\n\n    class MyService {\n        private val logger = LoggerFactory.getLogger(MyService::class.java)\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinLoggerInitializedWithForeignClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/日志记录",
                      "index": 119,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitThis",
                "shortDescription": {
                  "text": "隐式 'this'"
                },
                "fullDescription": {
                  "text": "报告隐式 this 的使用情况。 示例： 'class Foo {\n      fun s() = \"\"\n\n      fun test() {\n          s()\n      }\n  }' 该快速修复会显式指定 this： 'class Foo {\n      fun s() = \"\"\n\n      fun test() {\n          this.s()\n      }\n  }'",
                  "markdown": "报告隐式 **this** 的使用情况。\n\n**示例：**\n\n\n      class Foo {\n          fun s() = \"\"\n\n          fun test() {\n              s()\n          }\n      }\n\n该快速修复会显式指定 **this**：\n\n\n      class Foo {\n          fun s() = \"\"\n\n          fun test() {\n              this.s()\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ImplicitThis",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantAsSequence",
                "shortDescription": {
                  "text": "冗余 'asSequence' 调用"
                },
                "fullDescription": {
                  "text": "报告永远不会产生积极的性能影响的冗余 'asSequence()' 调用。 'asSequence()' 会加速包含多个运算的集合处理，因为它会延迟执行运算并且不会创建中间集合。 但是，如果在 'asSequence()' 之后立即使用终端运算（例如 'toList()'），则不会带来任何积极的性能效果。 示例： 'fun test(list: List<String>) {\n      list.asSequence().last()\n  }' 在应用快速修复后： 'fun test(list: List<String>) {\n      list.last()\n  }'",
                  "markdown": "报告永远不会产生积极的性能影响的冗余 `asSequence()` 调用。\n\n\n`asSequence()` 会加速包含多个运算的集合处理，因为它会延迟执行运算并且不会创建中间集合。\n\n\n但是，如果在 `asSequence()` 之后立即使用终端运算（例如 `toList()`），则不会带来任何积极的性能效果。\n\n**示例：**\n\n\n      fun test(list: List<String>) {\n          list.asSequence().last()\n      }\n\n在应用快速修复后：\n\n\n      fun test(list: List<String>) {\n          list.last()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantAsSequence",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveToStringInStringTemplate",
                "shortDescription": {
                  "text": "字符串模板中的冗余 'toString()' 调用"
                },
                "fullDescription": {
                  "text": "报告对可以安全移除的字符串模板中的 'toString()' 的调用。 示例： 'fun foo(a: Int, b: Int) = a + b\n\n  fun test(): String {\n      return \"Foo: ${foo(0, 4).toString()}\" // 'toString()' 冗余\n  }' 在应用快速修复后： 'fun foo(a: Int, b: Int) = a + b\n\n  fun test(): String {\n      return \"Foo: ${foo(0, 4)}\"\n  }'",
                  "markdown": "报告对可以安全移除的字符串模板中的 `toString()` 的调用。\n\n**示例：**\n\n      fun foo(a: Int, b: Int) = a + b\n\n      fun test(): String {\n          return \"Foo: ${foo(0, 4).toString()}\" // 'toString()' 冗余\n      }\n\n在应用快速修复后：\n\n      fun foo(a: Int, b: Int) = a + b\n\n      fun test(): String {\n          return \"Foo: ${foo(0, 4)}\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveToStringInStringTemplate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinCatchMayIgnoreException",
                "shortDescription": {
                  "text": "'catch' 块可能会忽略异常"
                },
                "fullDescription": {
                  "text": "报告空的或可能忽略异常的 'catch' 块。 虽然偶尔是有意为之，但空的 'catch' 块可能导致调试复杂化。 此外，忽略 'catch' 形参可能是错误的。 该检查不会报告任何命名为 'ignore'、'ignored' 或 '_' 的 'catch' 形参。 您可以使用快速修复将异常名称更改为 '_'。 示例： 'try {\n    throwingMethod()\n  } catch (ex: IOException) {\n\n  }' 在应用快速修复后： 'try {\n    throwingMethod()\n  } catch (_: IOException) {\n\n  }' 使用当 'catch' 块包含注释时不发出警告选项可以忽略包含注释的 'catch' 块。",
                  "markdown": "报告空的或可能忽略异常的 `catch` 块。\n\n虽然偶尔是有意为之，但空的 `catch` 块可能导致调试复杂化。\n此外，忽略 `catch` 形参可能是错误的。\n\n\n该检查不会报告任何命名为 `ignore`、`ignored` 或 `_` 的 `catch` 形参。\n\n\n您可以使用快速修复将异常名称更改为 `_`。\n\n**示例：**\n\n\n      try {\n        throwingMethod()\n      } catch (ex: IOException) {\n\n      }\n\n在应用快速修复后：\n\n\n      try {\n        throwingMethod()\n      } catch (_: IOException) {\n\n      }\n\n使用**当 'catch' 块包含注释时不发出警告** 选项可以忽略包含注释的 `catch` 块。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CatchMayIgnoreException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DifferentStdlibGradleVersion",
                "shortDescription": {
                  "text": "Kotlin 库和 Gradle 插件版本不同"
                },
                "fullDescription": {
                  "text": "报告不同的 Kotlin stdlib 和编译器版本。 示例： 'dependencies {\n    classpath \"org.jetbrains.kotlin:kotlin-stdlib:0.0.1\"\n  }' 要修正此问题，请更改 kotlin stdlib 版本以匹配 kotlin 编译器版本。",
                  "markdown": "报告不同的 Kotlin stdlib 和编译器版本。\n\n**示例：**\n\n\n      dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-stdlib:0.0.1\"\n      }\n\n要修正此问题，请更改 kotlin stdlib 版本以匹配 kotlin 编译器版本。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DifferentStdlibGradleVersion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinUnusedImport",
                "shortDescription": {
                  "text": "未使用的 import 指令"
                },
                "fullDescription": {
                  "text": "报告冗余的 'import' 语句。 可以安全地移除默认和未使用的导入。 示例： 'import kotlin.*\n  import kotlin.collections.*\n  import kotlin.comparisons.*\n  import kotlin.io.*\n  import kotlin.ranges.*\n  import kotlin.sequences.*\n  import kotlin.text.*\n\n  // 特定于 jvm\n  import java.lang.*\n  import kotlin.jvm.*\n\n  // 特定于 js\n  import kotlin.js.*\n\n  import java.io.* // 此导入未使用，可以移除\n  import java.util.*\n\n  fun foo(list: ArrayList<String>) {\n      list.add(\"\")\n  }'",
                  "markdown": "报告冗余的 `import` 语句。\n\n可以安全地移除默认和未使用的导入。\n\n**示例：**\n\n\n      import kotlin.*\n      import kotlin.collections.*\n      import kotlin.comparisons.*\n      import kotlin.io.*\n      import kotlin.ranges.*\n      import kotlin.sequences.*\n      import kotlin.text.*\n\n      // 特定于 jvm\n      import java.lang.*\n      import kotlin.jvm.*\n\n      // 特定于 js\n      import kotlin.js.*\n\n      import java.io.* // 此导入未使用，可以移除\n      import java.util.*\n\n      fun foo(list: ArrayList<String>) {\n          list.add(\"\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanBePrimaryConstructorProperty",
                "shortDescription": {
                  "text": "属性已明确分配给构造函数形参"
                },
                "fullDescription": {
                  "text": "报告显式分配给主构造函数形参的属性。 可以直接在主构造函数中声明属性，从而减少代码量并提高代码可读性。 示例： 'class User(name: String) {\n      val name = name\n  }' 该快速修复会将形参和属性声明联接到主构造函数形参中： 'class User(val name: String) {\n  }'",
                  "markdown": "报告显式分配给主构造函数形参的属性。\n\n可以直接在主构造函数中声明属性，从而减少代码量并提高代码可读性。\n\n**示例：**\n\n\n      class User(name: String) {\n          val name = name\n      }\n\n该快速修复会将形参和属性声明联接到主构造函数形参中：\n\n\n      class User(val name: String) {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CanBePrimaryConstructorProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanBeVal",
                "shortDescription": {
                  "text": "本地 'var' 从未被修改，且可以声明为 'val'"
                },
                "fullDescription": {
                  "text": "报告使用 'var' 关键字声明但从未被修改的局部变量。 Kotlin 鼓励使用 'val' 关键字声明几乎不可变的变量，以确保它们的值永远不会改变。 示例： 'fun example() {\n      var primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n      var fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n      print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n  }' 该快速修复会将 'var' 关键字替换为 'val'： 'fun example() {\n      val primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n      val fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n      print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n  }'",
                  "markdown": "报告使用 `var` 关键字声明但从未被修改的局部变量。\n\nKotlin 鼓励使用 `val` 关键字声明几乎不可变的变量，以确保它们的值永远不会改变。\n\n**示例：**\n\n\n      fun example() {\n          var primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n          var fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n          print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n      }\n\n该快速修复会将 `var` 关键字替换为 `val`：\n\n\n      fun example() {\n          val primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n          val fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n          print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CanBeVal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaMapForEach",
                "shortDescription": {
                  "text": "Java Map.forEach 方法调用应被替换为 Kotlin 的 forEach"
                },
                "fullDescription": {
                  "text": "报告可以替换为 Kotlin 的 forEach 的 Java Map.'forEach' 方法调用。 示例： 'fun test(map: HashMap<Int, String>) {\n      map.forEach { key, value ->\n          foo(key, value)\n      }\n  }\n\n  fun foo(i: Int, s: String) {}' 该快速修复会添加圆括号： 'fun test(map: HashMap<Int, String>) {\n      map.forEach { (key, value) ->\n          foo(key, value)\n      }\n  }\n\n  fun foo(i: Int, s: String) {}'",
                  "markdown": "报告可以替换为 Kotlin 的 **forEach** 的 Java Map.`forEach` 方法调用。\n\n**示例：**\n\n\n      fun test(map: HashMap<Int, String>) {\n          map.forEach { key, value ->\n              foo(key, value)\n          }\n      }\n\n      fun foo(i: Int, s: String) {}\n\n该快速修复会添加圆括号：\n\n\n      fun test(map: HashMap<Int, String>) {\n          map.forEach { (key, value) ->\n              foo(key, value)\n          }\n      }\n\n      fun foo(i: Int, s: String) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JavaMapForEach",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantObjectTypeCheck",
                "shortDescription": {
                  "text": "对象的非惯用 'is' 类型检查"
                },
                "fullDescription": {
                  "text": "报告对象的非惯用 'is' 类型检查。 建议将此类检查替换为引用比较。 示例： 'object Foo\n\n  fun foo(arg: Any) = when {\n      arg is Foo -> ...\n      arg !is Foo -> ...\n  }' 在应用快速修复后： 'object Foo\n\n  fun foo(arg: Any) = when {\n      arg === Foo -> ...\n      arg !== Foo -> ...\n  }'",
                  "markdown": "报告对象的非惯用 `is` 类型检查。\n\n建议将此类检查替换为引用比较。\n\n**示例：**\n\n\n      object Foo\n\n      fun foo(arg: Any) = when {\n          arg is Foo -> ...\n          arg !is Foo -> ...\n      }\n\n在应用快速修复后：\n\n\n      object Foo\n\n      fun foo(arg: Any) = when {\n          arg === Foo -> ...\n          arg !== Foo -> ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantObjectTypeCheck",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspendFunctionOnCoroutineScope",
                "shortDescription": {
                  "text": "由于挂起函数的 CoroutineScope 接收器，coroutineContext 不明确"
                },
                "fullDescription": {
                  "text": "报告带有 'CoroutineScope' 接收器的 suspend 函数内 'CoroutineScope' 扩展或成员的调用和访问。 当函数为 'suspend' 且具有 'CoroutineScope' 接收器时，它通过 'kotlin.coroutines.coroutineContext' 和 'CoroutineScope.coroutineContext' 访问 'CoroutineContext' 的权限不明确，而且这两个上下文通常不同。 为了改善这种状况，可以将可疑的调用包装在 'coroutineScope { ... }' 中，或者去除 'CoroutineScope' 函数接收器。",
                  "markdown": "报告带有 `CoroutineScope` 接收器的 suspend 函数内 `CoroutineScope` 扩展或成员的调用和访问。\n\n当函数为 `suspend` 且具有 `CoroutineScope` 接收器时，它通过 `kotlin.coroutines.coroutineContext` 和 `CoroutineScope.coroutineContext` 访问 `CoroutineContext` 的权限不明确，而且这两个上下文通常不同。\n\n\n为了改善这种状况，可以将可疑的调用包装在 `coroutineScope { ... }` 中，或者去除 `CoroutineScope` 函数接收器。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspendFunctionOnCoroutineScope",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithIgnoreCaseEquals",
                "shortDescription": {
                  "text": "应替换为 'equals(..., ignoreCase = true)'"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'equals(..., ignoreCase = true)' 的不区分大小写的比较。 使用 'equals()'，无需分配具有 'toLowerCase()' 或 'toUpperCase()' 的额外字符串即可比较字符串。 该快速修复会将使用 'toLowerCase()' 或 'toUpperCase()' 的不区分大小写的比较替换为 'equals(..., ignoreCase = true)'。 注意：可能会更改某些区域设置的语义。 示例： 'fun main() {\n      val a = \"KoTliN\"\n      val b = \"KOTLIN\"\n      println(a.toLowerCase() == b.toLowerCase())\n  }' 在应用快速修复后： 'fun main() {\n      val a = \"KoTliN\"\n      val b = \"KOTLIN\"\n      println(a.equals(b, ignoreCase = true))\n  }'",
                  "markdown": "报告可以替换为 `equals(..., ignoreCase = true)` 的不区分大小写的比较。\n\n使用 `equals()`，无需分配具有 `toLowerCase()` 或 `toUpperCase()` 的额外字符串即可比较字符串。\n\n该快速修复会将使用 `toLowerCase()` 或 `toUpperCase()` 的不区分大小写的比较替换为 `equals(..., ignoreCase = true)`。\n\n**注意**：可能会更改某些区域设置的语义。\n\n**示例：**\n\n\n      fun main() {\n          val a = \"KoTliN\"\n          val b = \"KOTLIN\"\n          println(a.toLowerCase() == b.toLowerCase())\n      }\n\n在应用快速修复后：\n\n\n      fun main() {\n          val a = \"KoTliN\"\n          val b = \"KOTLIN\"\n          println(a.equals(b, ignoreCase = true))\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceWithIgnoreCaseEquals",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DifferentMavenStdlibVersion",
                "shortDescription": {
                  "text": "库和 Maven 插件版本不同"
                },
                "fullDescription": {
                  "text": "报告不同的 Kotlin stdlib 和编译器版本。 使用不同版本的 Kotlin 编译器和标准库会导致不可预测的运行时问题，应避免此情况。",
                  "markdown": "报告不同的 Kotlin stdlib 和编译器版本。\n\n使用不同版本的 Kotlin 编译器和标准库会导致不可预测的运行时问题，应避免此情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DifferentMavenStdlibVersion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithSubstringAfter",
                "shortDescription": {
                  "text": "'substring' 调用应被替换为 'substringAfter'"
                },
                "fullDescription": {
                  "text": "报告可以替换为 's.substringAfter(x)' 的 's.substring(s.indexOf(x))' 等调用。 使用 's.substringAfter(x)' 可使代码更简单。 该快速修复会将 'substring' 调用替换为 'substringAfter'。 示例： 'fun foo(s: String) {\n      s.substring(s.indexOf('x'))\n  }' 在应用快速修复后： 'fun foo(s: String) {\n      s.substringAfter('x')\n  }'",
                  "markdown": "报告可以替换为 `s.substringAfter(x)` 的 `s.substring(s.indexOf(x))` 等调用。\n\n使用 `s.substringAfter(x)` 可使代码更简单。\n\n该快速修复会将 `substring` 调用替换为 `substringAfter`。\n\n**示例：**\n\n\n      fun foo(s: String) {\n          s.substring(s.indexOf('x'))\n      }\n\n在应用快速修复后：\n\n\n      fun foo(s: String) {\n          s.substringAfter('x')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithSubstringAfter",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitNullableNothingType",
                "shortDescription": {
                  "text": "隐式 'Nothing?' 类型"
                },
                "fullDescription": {
                  "text": "报告具有隐式 Nothing? 类型的变量和函数。 示例： 'fun foo() = null' 该快速修复会显式指定返回类型： 'fun foo(): Nothing? = null'",
                  "markdown": "报告具有隐式 **Nothing?** 类型的变量和函数。\n\n**示例：**\n\n\n      fun foo() = null\n\n该快速修复会显式指定返回类型：\n\n\n      fun foo(): Nothing? = null\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ImplicitNullableNothingType",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCompanionReference",
                "shortDescription": {
                  "text": "冗余 'Companion' 引用"
                },
                "fullDescription": {
                  "text": "报告冗余的 'Companion' 引用。 示例： 'class A {\n      companion object {\n          fun create() = A()\n      }\n  }\n  fun test() {\n      val s = A.Companion.create()\n  }' 在应用快速修复后： 'class A {\n      companion object {\n          fun create() = A()\n      }\n  }\n  fun test() {\n      val s = A.create()\n  }'",
                  "markdown": "报告冗余的 `Companion` 引用。\n\n**示例：**\n\n\n      class A {\n          companion object {\n              fun create() = A()\n          }\n      }\n      fun test() {\n          val s = A.Companion.create()\n      }\n\n在应用快速修复后：\n\n\n      class A {\n          companion object {\n              fun create() = A()\n          }\n      }\n      fun test() {\n          val s = A.create()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCompanionReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAssociateFunction",
                "shortDescription": {
                  "text": "'associate' 可被替换为 'associateBy' 或 'associateWith'"
                },
                "fullDescription": {
                  "text": "报告对可以替换为 'associateBy()' 或 'associateWith()' 的 'associate()' 和 'associateTo()' 的调用。 两个函数都接受应用于给定序列或集合（作为接收器）的元素的转换器函数。 然后该对函数被用于构建结果 'Map'。 鉴于转换器引用 'it'，'associate[To]()' 调用可以替换为性能更高的 'associateBy()' 或 'associateWith()'。 示例： 'fun getKey(i: Int) = 1L\n  fun getValue(i: Int) = 1L\n\n  fun test() {\n      arrayOf(1).associate { getKey(it) to it }  // 可替换的 'associate()'\n      listOf(1).associate { it to getValue(it) } // 可替换的 'associate()'\n  }' 在应用快速修复后： 'fun getKey(i: Int) = 1L\n  fun getValue(i: Int) = 1L\n\n  fun test() {\n      arrayOf(1).associateBy { getKey(it) }\n      listOf(1).associateWith { getValue(it) }\n  }'",
                  "markdown": "报告对可以替换为 `associateBy()` 或 `associateWith()` 的 `associate()` 和 `associateTo()` 的调用。\n\n\n两个函数都接受应用于给定序列或集合（作为接收器）的元素的转换器函数。\n然后该对函数被用于构建结果 `Map`。\n\n\n鉴于转换器引用 `it`，`associate[To]()` 调用可以替换为性能更高的 `associateBy()` 或 `associateWith()`。\n\n**示例：**\n\n      fun getKey(i: Int) = 1L\n      fun getValue(i: Int) = 1L\n\n      fun test() {\n          arrayOf(1).associate { getKey(it) to it }  // 可替换的 'associate()'\n          listOf(1).associate { it to getValue(it) } // 可替换的 'associate()'\n      }\n\n在应用快速修复后：\n\n      fun getKey(i: Int) = 1L\n      fun getValue(i: Int) = 1L\n\n      fun test() {\n          arrayOf(1).associateBy { getKey(it) }\n          listOf(1).associateWith { getValue(it) }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceAssociateFunction",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KDocUnresolvedReference",
                "shortDescription": {
                  "text": "KDoc 中存在未解析的引用"
                },
                "fullDescription": {
                  "text": "报告 KDoc 注释中未解析的引用。 示例： '/**\n   * [unresolvedLink]\n   */\n  fun foo() {}' 要修正此问题，请使链接有效。",
                  "markdown": "报告 KDoc 注释中未解析的引用。\n\n**示例：**\n\n\n      /**\n       * [unresolvedLink]\n       */\n      fun foo() {}\n\n要修正此问题，请使链接有效。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KDocUnresolvedReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObsoleteExperimentalCoroutines",
                "shortDescription": {
                  "text": "从 1.3 起，实验性协程用法遭到废弃"
                },
                "fullDescription": {
                  "text": "报告使用实验性协程的代码。 此类用法与 Kotlin 1.3+ 不兼容，应更新。",
                  "markdown": "报告使用实验性协程的代码。\n\n此类用法与 Kotlin 1.3+ 不兼容，应更新。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ObsoleteExperimentalCoroutines",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LiftReturnOrAssignment",
                "shortDescription": {
                  "text": "可以提取 return 或赋值"
                },
                "fullDescription": {
                  "text": "报告可以通过提取 'return' 语句或赋值而转换为表达式的 'if'、'when' 和 'try' 语句。 示例： 'fun foo(arg: Int): String {\n      when (arg) {\n          0 -> return \"Zero\"\n          1 -> return \"One\"\n          else -> return \"Multiple\"\n      }\n  }' 在应用快速修复后： 'fun foo(arg: Int): String {\n      return when (arg) {\n          0 -> \"Zero\"\n          1 -> \"One\"\n          else -> \"Multiple\"\n      }\n  }' 如果您希望此检查高亮显示具有多语句分支的更复杂代码，请取消选中“仅在每个分支都是单条语句时报告”选项。",
                  "markdown": "报告可以通过提取 `return` 语句或赋值而转换为表达式的 `if`、`when` 和 `try` 语句。\n\n**示例：**\n\n\n      fun foo(arg: Int): String {\n          when (arg) {\n              0 -> return \"Zero\"\n              1 -> return \"One\"\n              else -> return \"Multiple\"\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun foo(arg: Int): String {\n          return when (arg) {\n              0 -> \"Zero\"\n              1 -> \"One\"\n              else -> \"Multiple\"\n          }\n      }\n\n如果您希望此检查高亮显示具有多语句分支的更复杂代码，请取消选中\"仅在每个分支都是单条语句时报告\"选项。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LiftReturnOrAssignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedLambdaShadowedImplicitParameter",
                "shortDescription": {
                  "text": "嵌套 lambda 具有隐藏的隐式形参"
                },
                "fullDescription": {
                  "text": "报告具有隐藏的隐式形参的嵌套 lambda。 示例： 'fun foo(listOfLists: List<List<String>>) {\n  listOfLists.forEach {\n    it.forEach {\n      println(it)\n    }\n  }\n}' 在应用快速修复后： 'fun foo(listOfLists: List<List<String>>) {\n  listOfLists.forEach {\n    it.forEach { it1 ->\n      println(it1)\n    }\n  }\n}'",
                  "markdown": "报告具有隐藏的隐式形参的嵌套 lambda。\n\n**示例：**\n\n\n    fun foo(listOfLists: List<List<String>>) {\n      listOfLists.forEach {\n        it.forEach {\n          println(it)\n        }\n      }\n    }\n\n在应用快速修复后：\n\n\n    fun foo(listOfLists: List<List<String>>) {\n      listOfLists.forEach {\n        it.forEach { it1 ->\n          println(it1)\n        }\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NestedLambdaShadowedImplicitParameter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyWhenWithBooleanConstantCondition",
                "shortDescription": {
                  "text": "可简化的 'when'"
                },
                "fullDescription": {
                  "text": "报告带有常量 'true' 或 'false' 分支的 'when' 表达式。 简化 \"when\" 快速修复可用于自动修正代码。 示例： 'fun redundant() {\n      when { // <== 冗余，快速修复会将 when 表达式简化为 \"println(\"true\")\"\n          true -> println(\"true\")\n          else -> println(\"false\")\n      }\n  }'",
                  "markdown": "报告带有常量 `true` 或 `false` 分支的 `when` 表达式。\n\n**简化 \"when\"** 快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun redundant() {\n          when { // <== 冗余，快速修复会将 when 表达式简化为 \"println(\"true\")\"\n              true -> println(\"true\")\n              else -> println(\"false\")\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyWhenWithBooleanConstantCondition",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSamConstructor",
                "shortDescription": {
                  "text": "冗余 SAM 构造函数"
                },
                "fullDescription": {
                  "text": "报告可以替换为 lambda 的 SAM（单一抽象方法）构造函数用法。 示例： 'fun main() {\n      foo(Runnable { println(\"Hi!\") })\n  }\n\n  fun foo(other: Runnable) {}' 在应用快速修复后： 'fun main() {\n      foo( { println(\"Hi!\") })\n  }\n\n  fun foo(other: Runnable) {}'",
                  "markdown": "报告可以替换为 lambda 的 SAM（单一抽象方法）构造函数用法。\n\n**示例：**\n\n\n      fun main() {\n          foo(Runnable { println(\"Hi!\") })\n      }\n\n      fun foo(other: Runnable) {}\n\n在应用快速修复后：\n\n\n      fun main() {\n          foo( { println(\"Hi!\") })\n      }\n\n      fun foo(other: Runnable) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSamConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinConstantConditions",
                "shortDescription": {
                  "text": "恒定条件"
                },
                "fullDescription": {
                  "text": "报告静态已知始终为 true、false、null 或零的非普通条件和值。 虽然有时会有意为之，但通常这是程序中存在逻辑错误的迹象。 此外，报告永远无法到达 'when' 分支和某些静态已知始终失败的表达式。 示例： 'fun process(x: Int?) {\n  val isNull = x == null\n  if (!isNull) {\n    if (x != null) {} // 条件始终为 true\n    require(x!! < 0 && x > 10) // 条件始终为 false\n  } else {\n    println(x!!) // !! operator will always fail\n  }\n}\nfun process(v: Any) {\n  when(v) {\n    is CharSequence -> println(v as Int) // 转换将始终失败\n    is String -> println(v) // 分支无法到达\n  }\n}' 取消选中“当常量存储在变量中时发出警告”选项，以避免报告具有不在条件中的常量值的变量。 2021.3 最新变化",
                  "markdown": "报告静态已知始终为 true、false、null 或零的非普通条件和值。 虽然有时会有意为之，但通常这是程序中存在逻辑错误的迹象。 此外，报告永远无法到达 `when` 分支和某些静态已知始终失败的表达式。\n\n示例：\n\n\n    fun process(x: Int?) {\n      val isNull = x == null\n      if (!isNull) {\n        if (x != null) {} // 条件始终为 true\n        require(x!! < 0 && x > 10) // 条件始终为 false\n      } else {\n        println(x!!) // !! operator will always fail\n      }\n    }\n    fun process(v: Any) {\n      when(v) {\n        is CharSequence -> println(v as Int) // 转换将始终失败\n        is String -> println(v) // 分支无法到达\n      }\n    }\n\n\n取消选中\"当常量存储在变量中时发出警告\"选项，以避免报告具有不在条件中的常量值的变量。\n\n2021.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinConstantConditions",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentCommentForJavaParameter",
                "shortDescription": {
                  "text": "Java 形参的注释不一致"
                },
                "fullDescription": {
                  "text": "报告在注释块中指定的 Java 方法调用的不一致形参名称。 示例： '// Java\n  public class JavaService {\n      public void invoke(String command) {}\n  }' '// Kotlin\n  fun main() {\n      JavaService().invoke(/* name = */ \"fix\")\n  }' 该快速修复会更正注释块中的形参名称： 'fun main() {\n      JavaService().invoke(/* command = */ \"fix\")\n  }'",
                  "markdown": "报告在注释块中指定的 **Java** 方法调用的不一致形参名称。\n\n**示例：**\n\n\n      // Java\n      public class JavaService {\n          public void invoke(String command) {}\n      }\n\n\n      // Kotlin\n      fun main() {\n          JavaService().invoke(/* name = */ \"fix\")\n      }\n\n该快速修复会更正注释块中的形参名称：\n\n\n      fun main() {\n          JavaService().invoke(/* command = */ \"fix\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentCommentForJavaParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForEachParameterNotUsed",
                "shortDescription": {
                  "text": "迭代元素不在 forEach 中使用"
                },
                "fullDescription": {
                  "text": "报告不使用可迭代值的 'forEach' 循环。 示例： 'listOf(1, 2, 3).forEach { }' 该快速修复会在 'forEach' 部分引入匿名形参： 'listOf(1, 2, 3).forEach { _ -> }'",
                  "markdown": "报告不使用可迭代值的 `forEach` 循环。\n\n**示例：**\n\n\n      listOf(1, 2, 3).forEach { }\n\n该快速修复会在 `forEach` 部分引入匿名形参：\n\n\n      listOf(1, 2, 3).forEach { _ -> }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ForEachParameterNotUsed",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LeakingThis",
                "shortDescription": {
                  "text": "在构造函数中泄漏 'this'"
                },
                "fullDescription": {
                  "text": "在对象构造期间使用 'this' 报告不安全的操作，包括： 在类初始化期间访问非 final 属性：从构造函数或属性初始化 在类初始化期间调用非 final 函数 在非 final 类的构造函数中使用 'this' 作为函数实参 如果其他类继承自给定的类，则在执行不安全操作时，可能无法完全初始化它们。 示例： 'abstract class Base {\n      val code = calculate()\n      abstract fun calculate(): Int\n  }\n\n  class Derived(private val x: Int) : Base() {\n      override fun calculate() = x\n  }\n\n  fun testIt() {\n      println(Derived(42).code) // 预期值：42，实际值：0\n  }'",
                  "markdown": "在对象构造期间使用 `this` 报告不安全的操作，包括：\n\n* 在类初始化期间访问非 final 属性：从构造函数或属性初始化\n* 在类初始化期间调用非 final 函数\n* 在非 final 类的构造函数中使用 `this` 作为函数实参\n\n\n如果其他类继承自给定的类，则在执行不安全操作时，可能无法完全初始化它们。\n\n**示例：**\n\n\n      abstract class Base {\n          val code = calculate()\n          abstract fun calculate(): Int\n      }\n\n      class Derived(private val x: Int) : Base() {\n          override fun calculate() = x\n      }\n\n      fun testIt() {\n          println(Derived(42).code) // 预期值：42，实际值：0\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LeakingThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveRedundantCallsOfConversionMethods",
                "shortDescription": {
                  "text": "转换方法的冗余调用"
                },
                "fullDescription": {
                  "text": "报告对转换方法的冗余调用（例如，'String' 上的 'toString()' 或 'Double' 上的 'toDouble()'）。 使用“移除转换方法的冗余调用”快速修复可清理代码。",
                  "markdown": "报告对转换方法的冗余调用（例如，`String` 上的 `toString()` 或 `Double` 上的 `toDouble()`）。\n\n使用\"移除转换方法的冗余调用\"快速修复可清理代码。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveRedundantCallsOfConversionMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AddVarianceModifier",
                "shortDescription": {
                  "text": "类型形参可以具有 'in' 或 'out' 差异"
                },
                "fullDescription": {
                  "text": "报告可以具有 'in' 或 'out' 差异的类型形参。 使用 'in' 和 'out' 差异可以在 Kotlin 中提供更精确的类型推断以及更清晰的代码语义。 示例： 'class Box<T>(val obj: T)\n\n  fun consumeString(box: Box<String>) {}\n  fun consumeCharSequence(box: Box<CharSequence>) {}\n\n  fun usage(box: Box<String>) {\n      consumeString(box)\n      consumeCharSequence(box) // 编译时错误\n  }' 该快速修复会添加匹配的差异修饰符： 'class Box<out T>(val obj: T)\n\n  fun consumeString(box: Box<String>) {}\n  fun consumeCharSequence(box: Box<CharSequence>) {}\n\n  fun usage(box: Box<String>) ++{\n      consumeString(box)\n      consumeCharSequence(box) // 可以\n  }'",
                  "markdown": "报告可以具有 `in` 或 `out` 差异的类型形参。\n\n使用 `in` 和 `out` 差异可以在 Kotlin 中提供更精确的类型推断以及更清晰的代码语义。\n\n**示例：**\n\n\n      class Box<T>(val obj: T)\n\n      fun consumeString(box: Box<String>) {}\n      fun consumeCharSequence(box: Box<CharSequence>) {}\n\n      fun usage(box: Box<String>) {\n          consumeString(box)\n          consumeCharSequence(box) // 编译时错误\n      }\n\n该快速修复会添加匹配的差异修饰符：\n\n\n      class Box<out T>(val obj: T)\n\n      fun consumeString(box: Box<String>) {}\n      fun consumeCharSequence(box: Box<CharSequence>) {}\n\n      fun usage(box: Box<String>) ++{\n          consumeString(box)\n          consumeCharSequence(box) // 可以\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AddVarianceModifier",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinThrowableNotThrown",
                "shortDescription": {
                  "text": "Throwable 未抛出"
                },
                "fullDescription": {
                  "text": "当创建的 'Throwable' 从未实际抛出时，报告 'Throwable' 或其子类的实例化。 报告的代码指出了测试中难以捕获的错误。 此外，当结果 'Throwable' 实例未抛出时，此检查会报告返回 'Throwable' 或其子类实例的方法调用。 示例： 'fun check(condition: Boolean) {\n      if (!condition) /* throw is missing here */ IllegalArgumentException(\"condition is not met\");\n  }\n\n  fun createError() = RuntimeException()\n\n  fun foo() {\n      /* throw is missing here */ createError()\n  }'",
                  "markdown": "当创建的 `Throwable` 从未实际抛出时，报告 `Throwable` 或其子类的实例化。\n\n报告的代码指出了测试中难以捕获的错误。\n\n\n此外，当结果 `Throwable` 实例未抛出时，此检查会报告返回 `Throwable` 或其子类实例的方法调用。\n\n**示例：**\n\n\n      fun check(condition: Boolean) {\n          if (!condition) /* throw is missing here */ IllegalArgumentException(\"condition is not met\");\n      }\n\n      fun createError() = RuntimeException()\n\n      fun foo() {\n          /* throw is missing here */ createError()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowableNotThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinSealedInheritorsInJava",
                "shortDescription": {
                  "text": "从 Java 继承 Kotlin 密封接口/类"
                },
                "fullDescription": {
                  "text": "报告从 Java 代码中的 Kotlin sealed 接口或类进行继承的尝试。 示例： '// Kotlin 文件：MathExpression.kt\n\nsealed class MathExpression\n\ndata class Const(val number: Double) : MathExpression()\ndata class Sum(val e1: MathExpression, val e2: MathExpression) : MathExpression()' '// Java 文件：NotANumber.java\n\npublic class NotANumber extends MathExpression {\n}'",
                  "markdown": "报告从 Java 代码中的 Kotlin sealed 接口或类进行继承的尝试。\n\n**示例：**\n\n\n    // Kotlin 文件：MathExpression.kt\n\n    sealed class MathExpression\n\n    data class Const(val number: Double) : MathExpression()\n    data class Sum(val e1: MathExpression, val e2: MathExpression) : MathExpression()\n\n\n    // Java 文件：NotANumber.java\n\n    public class NotANumber extends MathExpression {\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "KotlinSealedInheritorsInJava",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 互操作问题",
                      "index": 67,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyNegatedBinaryExpression",
                "shortDescription": {
                  "text": "可以简化求反布尔表达式"
                },
                "fullDescription": {
                  "text": "报告可以简化的求反布尔表达式。 该快速修复会简化布尔表达式。 示例： 'fun test(n: Int) {\n        !(0 == 1)\n    }' 在应用快速修复后： 'fun test(n: Int) {\n        0 != 1\n    }' 请注意，如果涉及 IEEE-754 NaN 值，此操作可能会更改代码语义： 'fun main() {\n        println(!(Double.NaN >= 0)) // true\n    }' 在应用快速修复后： 'fun main() {\n        println(Double.NaN < 0) // false\n    }'",
                  "markdown": "报告可以简化的求反布尔表达式。\n\n该快速修复会简化布尔表达式。\n\n**示例：**\n\n\n        fun test(n: Int) {\n            !(0 == 1)\n        }\n\n在应用快速修复后：\n\n\n        fun test(n: Int) {\n            0 != 1\n        }\n\n请注意，如果涉及 IEEE-754 NaN 值，此操作可能会更改代码语义：\n\n\n        fun main() {\n            println(!(Double.NaN >= 0)) // true\n        }\n\n在应用快速修复后：\n\n\n        fun main() {\n            println(Double.NaN < 0) // false\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyNegatedBinaryExpression",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MemberVisibilityCanBePrivate",
                "shortDescription": {
                  "text": "类成员可以具有 'private' 可见性"
                },
                "fullDescription": {
                  "text": "报告可以设为 'private' 以遵循封装原则的声明。 示例： 'class Service(val url: String) {\n    fun connect(): URLConnection = URL(url).openConnection()\n}' 应用快速修复后（考虑到 'Service' 类之外没有使用 'url' 的情况）： 'class Service(private val url: String) {\n    fun connect(): URLConnection = URL(url).openConnection()\n}'",
                  "markdown": "报告可以设为 `private` 以遵循封装原则的声明。\n\n**示例：**\n\n\n    class Service(val url: String) {\n        fun connect(): URLConnection = URL(url).openConnection()\n    }\n\n应用快速修复后（考虑到 `Service` 类之外没有使用 `url` 的情况）：\n\n\n    class Service(private val url: String) {\n        fun connect(): URLConnection = URL(url).openConnection()\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MemberVisibilityCanBePrivate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveForLoopIndices",
                "shortDescription": {
                  "text": "未使用的循环索引"
                },
                "fullDescription": {
                  "text": "报告使用 'withIndex()' 函数而非索引变量迭代集合的 'for' 循环。 使用“移除 'for' 循环中的索引”快速修复可清理代码。 示例： 'fun foo(bar: List<String>) {\n     for ((index : Int, value: String) in bar.withIndex()) { // <== 'index' 未使用\n         println(value)\n     }\n  }' 在应用快速修复后： 'fun foo(bar: List<String>) {\n      for (value: String in bar) { // <== '.withIndex()' 和 'index' 已被移除\n          println(value)\n      }\n  }'",
                  "markdown": "报告使用 `withIndex()` 函数而非索引变量迭代集合的 `for` 循环。\n\n使用\"移除 'for' 循环中的索引\"快速修复可清理代码。\n\n**示例：**\n\n\n      fun foo(bar: List<String>) {\n         for ((index : Int, value: String) in bar.withIndex()) { // <== 'index' 未使用\n             println(value)\n         }\n      }\n\n在应用快速修复后：\n\n\n      fun foo(bar: List<String>) {\n          for (value: String in bar) { // <== '.withIndex()' 和 'index' 已被移除\n              println(value)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveForLoopIndices",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSuspendModifier",
                "shortDescription": {
                  "text": "冗余 'suspend' 修饰符"
                },
                "fullDescription": {
                  "text": "如果内部没有调用其他挂起函数，报告 'suspend' 修饰符为冗余。",
                  "markdown": "如果内部没有调用其他挂起函数，报告 `suspend` 修饰符为冗余。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSuspendModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousAsDynamic",
                "shortDescription": {
                  "text": "可疑的 'asDynamic' 成员调用"
                },
                "fullDescription": {
                  "text": "报告动态类型接收器上的 'asDynamic' 函数用法。 'asDynamic' 函数对动态类型的表达式无影响。 动态类型接收器上的 'asDynamic' 函数会导致运行时问题，因为 'asDynamic' 将在 JavaScript 环境中执行，而且此类函数在运行时可能并不显示。 预期方式是在常用 Kotlin 类型上使用此函数。 移除 \"asDynamic\" 调用快速修复可用于自动修正代码。 示例： 'fun wrongUsage(d: Dynamic) {\n     d.asDynamic().foo() // <== 冗余，快速修复会将调用表达式简化为 \"d.foo()\"\n  }'",
                  "markdown": "报告动态类型接收器上的 `asDynamic` 函数用法。\n\n`asDynamic` 函数对动态类型的表达式无影响。\n\n动态类型接收器上的 `asDynamic` 函数会导致运行时问题，因为 `asDynamic` 将在 JavaScript 环境中执行，而且此类函数在运行时可能并不显示。\n预期方式是在常用 Kotlin 类型上使用此函数。\n\n**移除 \"asDynamic\" 调用**快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun wrongUsage(d: Dynamic) {\n         d.asDynamic().foo() // <== 冗余，快速修复会将调用表达式简化为 \"d.foo()\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SuspiciousAsDynamic",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FilterIsInstanceCallWithClassLiteralArgument",
                "shortDescription": {
                  "text": "带有类文字实参的 'filterIsInstance' 调用"
                },
                "fullDescription": {
                  "text": "报告对带有类文字实参的 Kotlin 标准库函数 'filterIsInstance' 的调用。 更习惯的做法是使用带有具体化类型形参的此函数版本，以避免使用 '::class.java' 语法。 注意：不报告对泛型类文字的检查，因为类型实参列表中的 'Class<*, *>' 语法可能不受欢迎。 示例： 'fun foo(list: List<*>) {\n      list.filterIsInstance(Int::class.java)\n  }' 在应用快速修复后： 'fun foo(list: List<*>) {\n      list.filterIsInstance<Int>()\n  }'",
                  "markdown": "报告对带有类文字实参的 Kotlin 标准库函数 `filterIsInstance` 的调用。 更习惯的做法是使用带有具体化类型形参的此函数版本，以避免使用 `::class.java` 语法。\n\n注意：不报告对泛型类文字的检查，因为类型实参列表中的 `Class<*, *>` 语法可能不受欢迎。\n\n示例：\n\n\n      fun foo(list: List<*>) {\n          list.filterIsInstance(Int::class.java)\n      }\n\n在应用快速修复后：\n\n\n      fun foo(list: List<*>) {\n          list.filterIsInstance<Int>()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FilterIsInstanceCallWithClassLiteralArgument",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FromClosedRangeMigration",
                "shortDescription": {
                  "text": "从 1.3 起，fromClosedRange() 中存在 MIN_VALUE 步骤"
                },
                "fullDescription": {
                  "text": "报告带 'MIN_VALUE' 步骤的 'IntProgression.fromClosedRange()' 和 'LongProgression.fromClosedRange()'。 禁止调用带有 'MIN_VALUE' 步骤的 'IntProgression.fromClosedRange()' 和 'LongProgression.fromClosedRange()'。 在迁移到 Kotlin 1.3+ 期间，应检查所有此类调用。 示例： 'IntProgression.fromClosedRange(12, 143, Int.MIN_VALUE)' 要修正此问题，请更改进程的步骤。",
                  "markdown": "报告带 `MIN_VALUE` 步骤的 `IntProgression.fromClosedRange()` 和 `LongProgression.fromClosedRange()`。\n\n\n禁止调用带有 `MIN_VALUE` 步骤的 `IntProgression.fromClosedRange()` 和 `LongProgression.fromClosedRange()`。 在迁移到 Kotlin 1.3+ 期间，应检查所有此类调用。\n\n**示例：**\n\n\n      IntProgression.fromClosedRange(12, 143, Int.MIN_VALUE)\n\n要修正此问题，请更改进程的步骤。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FromClosedRangeMigration",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveRedundantBackticks",
                "shortDescription": {
                  "text": "冗余反引号"
                },
                "fullDescription": {
                  "text": "报告引用中的冗余反引号。 一些 Kotlin 关键字在 Java 中是有效的标识符，例如：'in'、'object'、'is'。 如果 Java 库将 Kotlin 关键字用于方法，您仍然可以调用该方法并使用反引号字符 ('`') 对其进行转义，例如 'foo.`is`(bar)'。 有时这种转义是冗余的，可以安全地省略。 该检查会发现并报告此类情况，并与“移除冗余反引号”快速修复配对，允许您修改高亮显示的代码。 示例： 'fun `is`(x: String) {}\n  fun foo() {\n      `is`(\"bar\") // 'is' 是一个关键字，反引号为必选项\n  }\n\n  fun `test that smth works as designed`() {} // 可以，复杂标识符有助于改进可读性\n\n  val `a` = 1  // 不需要反引号'",
                  "markdown": "报告引用中的冗余反引号。\n\n\n一些 Kotlin 关键字在 Java 中是有效的标识符，例如：`in`、`object`、`is`。\n如果 Java 库将 Kotlin 关键字用于方法，您仍然可以调用该方法并使用反引号字符 (`````) 对其进行转义，例如 ``foo.`is`(bar)``。\n有时这种转义是冗余的，可以安全地省略。 该检查会发现并报告此类情况，并与\"移除冗余反引号\"快速修复配对，允许您修改高亮显示的代码。\n\n**示例：**\n\n\n      fun `is`(x: String) {}\n      fun foo() {\n          `is`(\"bar\") // 'is' 是一个关键字，反引号为必选项\n      }\n\n      fun `test that smth works as designed`() {} // 可以，复杂标识符有助于改进可读性\n\n      val `a` = 1  // 不需要反引号\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveRedundantBackticks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceReadLineWithReadln",
                "shortDescription": {
                  "text": "'readLine' 可被替换为 'readln' 或 'readlnOrNull'"
                },
                "fullDescription": {
                  "text": "报告对可被替换为 'readln()' 或 'readlnOrNull()' 的 'readLine()' 的调用。 使用相应函数可使代码更简单。 该快速修复会将 'readLine()!!' 替换为 'readln()'，并将 'readLine()' 替换为 'readlnOrNull()'。 示例： 'val x = readLine()!!\n    val y = readLine()?.length' 在应用快速修复后： 'val x = readln()\n    val y = readlnOrNull()?.length'",
                  "markdown": "报告对可被替换为 `readln()` 或 `readlnOrNull()` 的 `readLine()` 的调用。\n\n\n使用相应函数可使代码更简单。\n\n\n该快速修复会将 `readLine()!!` 替换为 `readln()`，并将 `readLine()` 替换为 `readlnOrNull()`。\n\n**示例：**\n\n\n        val x = readLine()!!\n        val y = readLine()?.length\n\n在应用快速修复后：\n\n\n        val x = readln()\n        val y = readlnOrNull()?.length\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceReadLineWithReadln",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SelfAssignment",
                "shortDescription": {
                  "text": "冗余赋值"
                },
                "fullDescription": {
                  "text": "报告变量对自身的赋值。 该快速修复会移除冗余赋值。 示例： 'fun test() {\n      var bar = 1\n      bar = bar\n  }' 在应用快速修复后： 'fun test() {\n      var bar = 1\n  }'",
                  "markdown": "报告变量对自身的赋值。\n\n该快速修复会移除冗余赋值。\n\n**示例：**\n\n\n      fun test() {\n          var bar = 1\n          bar = bar\n      }\n\n在应用快速修复后：\n\n\n      fun test() {\n          var bar = 1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SelfAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecursiveEqualsCall",
                "shortDescription": {
                  "text": "递归 equals 调用"
                },
                "fullDescription": {
                  "text": "报告递归 'equals'('==') 调用。 在 Kotlin 中，'==' 会通过在后台调用 'equals' 方法来比较对象值。 另一方面，'===' 则通过引用来比较对象。 '===' 通常用于 'equals' 方法实现。 但 '===' 可能会错误地与 '==' 混淆，从而导致无限递归。 示例： 'class X {\n      override fun equals(other: Any?): Boolean {\n          if (this == other) return true\n          return false\n      }\n  }' 在应用快速修复后： 'class X {\n      override fun equals(other: Any?): Boolean {\n          if (this === other) return true\n          return false\n      }\n  }'",
                  "markdown": "报告递归 `equals`(`==`) 调用。\n\n\n在 Kotlin 中，`==` 会通过在后台调用 `equals` 方法来比较对象值。\n另一方面，`===` 则通过引用来比较对象。\n\n\n`===` 通常用于 `equals` 方法实现。\n但 `===` 可能会错误地与 `==` 混淆，从而导致无限递归。\n\n**示例：**\n\n\n      class X {\n          override fun equals(other: Any?): Boolean {\n              if (this == other) return true\n              return false\n          }\n      }\n\n在应用快速修复后：\n\n\n      class X {\n          override fun equals(other: Any?): Boolean {\n              if (this === other) return true\n              return false\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RecursiveEqualsCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyNestedEachInScopeFunction",
                "shortDescription": {
                  "text": "嵌套 forEach 的作用域函数可以简化"
                },
                "fullDescription": {
                  "text": "报告 'also' 或 'apply' 等范围函数中可以简化的 'forEach' 函数。 将 forEach 调用转换为 onEach 快速修复可用于自动修正代码。 示例： 'fun test(list: List<Int>) {\n      val x = list.also { it.forEach { it + 4 } }.toString()\n      val y = list.apply { forEach { println(it) } }\n  }' 在应用快速修复后： 'fun test(list: List<Int>) {\n      val x = list.onEach { it + 4 }.toString()\n      val y = list.onEach { println(it) }\n  }'",
                  "markdown": "报告 `also` 或 `apply` 等范围函数中可以简化的 `forEach` 函数。\n\n**将 forEach 调用转换为 onEach** 快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun test(list: List<Int>) {\n          val x = list.also { it.forEach { it + 4 } }.toString()\n          val y = list.apply { forEach { println(it) } }\n      }\n\n在应用快速修复后：\n\n\n      fun test(list: List<Int>) {\n          val x = list.onEach { it + 4 }.toString()\n          val y = list.onEach { println(it) }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyNestedEachInScopeFunction",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsafeCastFromDynamic",
                "shortDescription": {
                  "text": "从动态类型的隐式(不安全)转换"
                },
                "fullDescription": {
                  "text": "报告指定检查范围内可隐式转换为其他类型的动态类型表达式。",
                  "markdown": "报告指定检查范围内可隐式转换为其他类型的动态类型表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnsafeCastFromDynamic",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicApiImplicitType",
                "shortDescription": {
                  "text": "具有隐式返回值类型的公共 API 声明"
                },
                "fullDescription": {
                  "text": "报告具有隐式返回类型的 'public' 和 'protected' 函数和属性。 出于 API 稳定性的原因，建议显式指定此种类型。 示例： 'fun publicFunctionWhichAbusesTypeInference() =\n      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()' 在应用快速修复后： 'fun publicFunctionWhichAbusesTypeInference(): Api =\n      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()'",
                  "markdown": "报告具有隐式返回类型的 `public` 和 `protected` 函数和属性。\n出于 API 稳定性的原因，建议显式指定此种类型。\n\n**示例：**\n\n\n      fun publicFunctionWhichAbusesTypeInference() =\n          otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()\n\n在应用快速修复后：\n\n\n      fun publicFunctionWhichAbusesTypeInference(): Api =\n          otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PublicApiImplicitType",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeclaringClassMigration",
                "shortDescription": {
                  "text": "已弃用的 'Enum.declaringClass' 属性"
                },
                "fullDescription": {
                  "text": "报告 Enum 上从 1.9 版开始会导致编译错误的 'declaringClass' 属性调用。 'Enum.getDeclaringClass' 是一种 \"hidden\" Java 函数，通常无法通过解析可见。 然而，它可通过合成属性可见，这是一个前端 bug。 更多详细信息：KT-49653 弃用并移除 Enum.declaringClass 合成属性 该快速修复会将调用替换为 'declaringJavaClass'。 示例： 'fun <E: Enum<E>> foo(values: Array<E>) {\n    EnumSet.noneOf(values.first().declaringClass)\n  }' 在应用快速修复后： 'fun <E: Enum<E>> foo(values: Array<E>) {\n    EnumSet.noneOf(values.first().declaringJavaClass)\n  }' 仅当项目或模块的 Kotlin 语言级别为 1.7 或更高时，此检查才会报告。",
                  "markdown": "报告 Enum 上从 1.9 版开始会导致编译错误的 'declaringClass' 属性调用。\n\n'Enum.getDeclaringClass' 是一种 \"hidden\" Java 函数，通常无法通过解析可见。 然而，它可通过合成属性可见，这是一个前端 bug。\n\n**更多详细信息** ：[KT-49653 弃用并移除 Enum.declaringClass 合成属性](https://youtrack.jetbrains.com/issue/KT-49653)\n\n该快速修复会将调用替换为 'declaringJavaClass'。\n\n**示例：**\n\n\n      fun <E: Enum<E>> foo(values: Array<E>) {\n        EnumSet.noneOf(values.first().declaringClass)\n      }\n\n在应用快速修复后：\n\n\n      fun <E: Enum<E>> foo(values: Array<E>) {\n        EnumSet.noneOf(values.first().declaringJavaClass)\n      }\n\n仅当项目或模块的 Kotlin 语言级别为 1.7 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeclaringClassMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceMapIndexedWithListGenerator",
                "shortDescription": {
                  "text": "将 'mapIndexed' 替换为 List 生成器"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'List' 生成器的 'mapIndexed' 调用。 示例： 'val a = listOf(1, 2, 3).mapIndexed { i, _ ->\n      i + 42\n  }' 在应用快速修复后： 'val a = List(listOf(1, 2, 3).size) { i ->\n          i + 42\n  }'",
                  "markdown": "报告可以替换为 `List` 生成器的 `mapIndexed` 调用。\n\n**示例：**\n\n\n      val a = listOf(1, 2, 3).mapIndexed { i, _ ->\n          i + 42\n      }\n\n在应用快速修复后：\n\n\n      val a = List(listOf(1, 2, 3).size) { i ->\n              i + 42\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceMapIndexedWithListGenerator",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ControlFlowWithEmptyBody",
                "shortDescription": {
                  "text": "带空体的控制流"
                },
                "fullDescription": {
                  "text": "报告语句体为空的 'if'、'while'、'do' 或 'for' 语句。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。 该快速修复会移除语句。 示例： 'if (a > b) {}'",
                  "markdown": "报告语句体为空的 `if`、`while`、`do` 或 `for` 语句。\n\n虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。\n\n该快速修复会移除语句。\n\n**示例：**\n\n\n      if (a > b) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ControlFlowWithEmptyBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitThis",
                "shortDescription": {
                  "text": "冗余显式 'this'"
                },
                "fullDescription": {
                  "text": "报告可以省略的显式 'this'。 示例： 'class C {\n      private val i = 1\n      fun f() = this.i\n  }' 该快速修复会移除冗余的 'this'： 'class C {\n      private val i = 1\n      fun f() = i\n  }'",
                  "markdown": "报告可以省略的显式 `this`。\n\n**示例：**\n\n\n      class C {\n          private val i = 1\n          fun f() = this.i\n      }\n\n该快速修复会移除冗余的 `this`：\n\n\n      class C {\n          private val i = 1\n          fun f() = i\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ExplicitThis",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullChecksToSafeCall",
                "shortDescription": {
                  "text": "null 检查可被替换为安全调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为安全调用的链式 null 检查。 示例： 'fun test(my: My?) {\n      if (my != null && my.foo() != null) {}\n  }' 在应用快速修复后： 'fun test(my: My?) {\n      if (my?.foo() != null) {}\n  }'",
                  "markdown": "报告可以替换为安全调用的链式 null 检查。\n\n**示例：**\n\n\n      fun test(my: My?) {\n          if (my != null && my.foo() != null) {}\n      }\n\n在应用快速修复后：\n\n\n      fun test(my: My?) {\n          if (my?.foo() != null) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NullChecksToSafeCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopToCallChain",
                "shortDescription": {
                  "text": "循环可被替换为 stdlib 运算"
                },
                "fullDescription": {
                  "text": "报告可替换为 stdlib 运算的序列（如 'map'、'filter' 等）的 'for' 循环。 示例： 'fun foo(list: List<String>): List<Int> {\n  val result = ArrayList<Int>()\n  for (s in list) {\n     if (s.length > 0)\n       result.add(s.hashCode())\n     }\n  return result\n}' 在应用快速修复后： 'fun foo(list: List<String>): List<Int> {\n  val result = list\n    .filter { it.length > 0 }\n    .map { it.hashCode() }\n  return result\n}'",
                  "markdown": "报告可替换为 stdlib 运算的序列（如 `map`、`filter` 等）的 `for` 循环。\n\n**示例：**\n\n\n    fun foo(list: List<String>): List<Int> {\n      val result = ArrayList<Int>()\n      for (s in list) {\n         if (s.length > 0)\n           result.add(s.hashCode())\n         }\n      return result\n    }\n\n在应用快速修复后：\n\n\n    fun foo(list: List<String>): List<Int> {\n      val result = list\n        .filter { it.length > 0 }\n        .map { it.hashCode() }\n      return result\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LoopToCallChain",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptyClassBody",
                "shortDescription": {
                  "text": "替换空类主体"
                },
                "fullDescription": {
                  "text": "报告具有空主体的类和对象的声明。 使用“移除冗余的空类主体”快速修复可清理代码。 示例： 'class EmptyA() {} // <== 空主体\n\n  class EmptyB {\n      companion object {} // <== 空主体\n  }\n\n  fun emptyC() {\n     object {} // <== 匿名对象，可以（未报告）\n  }' 在应用快速修复后： 'class EmptyA()\n\n  class EmptyB {\n      companion object\n  }\n\n  fun emptyC() {\n     object {}\n  }'",
                  "markdown": "报告具有空主体的类和对象的声明。\n\n使用\"移除冗余的空类主体\"快速修复可清理代码。\n\n**示例：**\n\n\n      class EmptyA() {} // <== 空主体\n\n      class EmptyB {\n          companion object {} // <== 空主体\n      }\n\n      fun emptyC() {\n         object {} // <== 匿名对象，可以（未报告）\n      }\n\n在应用快速修复后：\n\n\n      class EmptyA()\n\n      class EmptyB {\n          companion object\n      }\n\n      fun emptyC() {\n         object {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptyClassBody",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanBeParameter",
                "shortDescription": {
                  "text": "构造函数形参从未被用作属性"
                },
                "fullDescription": {
                  "text": "报告 'val' 或 'var' 可被移除的主构造函数形参。 在构造函数中声明的类属性会增加内存消耗。 如果形参值仅在构造函数中使用，则可以省略它们。 请注意，引用的对象可能是之前被垃圾回收。 示例： 'class Task(val name: String) {\n      init {\n          print(\"Task created: $name\")\n      }\n  }' 该快速修复会移除额外的 'val' 或 'var' 关键字： 'class Task(name: String) {\n      init {\n          print(\"Task created: $name\")\n      }\n  }'",
                  "markdown": "报告 `val` 或 `var` 可被移除的主构造函数形参。\n\n\n在构造函数中声明的类属性会增加内存消耗。\n如果形参值仅在构造函数中使用，则可以省略它们。\n\n请注意，引用的对象可能是之前被垃圾回收。\n\n**示例：**\n\n\n      class Task(val name: String) {\n          init {\n              print(\"Task created: $name\")\n          }\n      }\n\n该快速修复会移除额外的 `val` 或 `var` 关键字：\n\n\n      class Task(name: String) {\n          init {\n              print(\"Task created: $name\")\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CanBeParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantReturnLabel",
                "shortDescription": {
                  "text": "冗余 'return' 标签"
                },
                "fullDescription": {
                  "text": "报告 lambda 表达式之外的冗余返回标签。 示例： 'fun test() {\n      return@test\n  }' 在应用快速修复后： 'fun test() {\n      return\n  }'",
                  "markdown": "报告 lambda 表达式之外的冗余返回标签。\n\n**示例：**\n\n\n      fun test() {\n          return@test\n      }\n\n在应用快速修复后：\n\n\n      fun test() {\n          return\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantReturnLabel",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedMainParameter",
                "shortDescription": {
                  "text": "主形参不必要"
                },
                "fullDescription": {
                  "text": "报告带有单个未使用形参的 'main' 函数。",
                  "markdown": "报告带有单个未使用形参的 `main` 函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnusedMainParameter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionWithLambdaExpressionBody",
                "shortDescription": {
                  "text": "具有 '= { ... }' 和推断返回值类型的函数"
                },
                "fullDescription": {
                  "text": "报告具有 '= { ... }' 和推断返回类型的函数。 示例： 'fun sum(a: Int, b: Int) = { a + b } // 此函数的返回类型为 '() -> Int'。' 该快速修复会移除大括号： 'fun sum(a: Int, b: Int) = a + b'",
                  "markdown": "报告具有 `= { ... }` 和推断返回类型的函数。\n\n**示例：**\n\n\n      fun sum(a: Int, b: Int) = { a + b } // 此函数的返回类型为 '() -> Int'。\n\n该快速修复会移除大括号：\n\n\n      fun sum(a: Int, b: Int) = a + b\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FunctionWithLambdaExpressionBody",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageName",
                "shortDescription": {
                  "text": "软件包命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循命名约定的软件包名称。 您可以在检查选项中指定所需的模式。 建议的命名约定：软件包的名称始终小写，并且不应包含下划线。 示例： 'org.example.project' 通常不鼓励使用多词名称，但如果您确实需要使用多个词，则可以将它们串联在一起或使用驼峰拼写法 示例： 'org.example.myProject'",
                  "markdown": "报告不遵循命名约定的软件包名称。\n\n您可以在检查选项中指定所需的模式。\n\n[建议的命名约定](https://kotlinlang.org/docs/coding-conventions.html#naming-rules)：软件包的名称始终小写，并且不应包含下划线。\n\n**示例：**\n`org.example.project`\n\n通常不鼓励使用多词名称，但如果您确实需要使用多个词，则可以将它们串联在一起或使用驼峰拼写法\n\n**示例：**\n`org.example.myProject`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PackageName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayInDataClass",
                "shortDescription": {
                  "text": "数据类中的数组属性"
                },
                "fullDescription": {
                  "text": "报告 'data' 类中类型为 'Array' 但没有被重写的 'equals()' 或 'hashCode()' 的属性。 数组形参通过引用相等进行了比较，这可能是一种意外行为。 在此类情况下，强烈建议重写 'equals()' 和 'hashCode()'。 示例： 'data class Text(val lines: Array<String>)' 该快速修复会生成缺失的 'equals()' 和 'hashCode()' 实现： 'data class Text(val lines: Array<String>) {\n      override fun equals(other: Any?): Boolean {\n          if (this === other) return true\n          if (javaClass != other?.javaClass) return false\n\n          other as Text\n\n          if (!lines.contentEquals(other.lines)) return false\n\n          return true\n      }\n\n      override fun hashCode(): Int {\n          return lines.contentHashCode()\n      }\n  }'",
                  "markdown": "报告 `data` 类中类型为 `Array` 但没有被重写的 `equals()` 或 `hashCode()` 的属性。\n\n\n数组形参通过引用相等进行了比较，这可能是一种意外行为。\n在此类情况下，强烈建议重写 `equals()` 和 `hashCode()`。\n\n**示例：**\n\n\n      data class Text(val lines: Array<String>)\n\n该快速修复会生成缺失的 `equals()` 和 `hashCode()` 实现：\n\n\n      data class Text(val lines: Array<String>) {\n          override fun equals(other: Any?): Boolean {\n              if (this === other) return true\n              if (javaClass != other?.javaClass) return false\n\n              other as Text\n\n              if (!lines.contentEquals(other.lines)) return false\n\n              return true\n          }\n\n          override fun hashCode(): Int {\n              return lines.contentHashCode()\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ArrayInDataClass",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProhibitUseSiteTargetAnnotationsOnSuperTypesMigration",
                "shortDescription": {
                  "text": "超类上的无意义注解目标"
                },
                "fullDescription": {
                  "text": "从 Kotlin 1.4 开始，报告超类的无意义注解目标。 诸如 '@get:' 之类的注解目标在超类中毫无意义并且被禁止。 示例： 'interface Foo\n\n  annotation class Ann\n\n  class E : @field:Ann @get:Ann @set:Ann @setparam:Ann Foo' 在应用快速修复后： 'interface Foo\n\n  annotation class Ann\n\n  class E : Foo' 仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。",
                  "markdown": "从 Kotlin 1.4 开始，报告超类的无意义注解目标。\n\n诸如 `@get:` 之类的注解目标在超类中毫无意义并且被禁止。\n\n**示例：**\n\n\n      interface Foo\n\n      annotation class Ann\n\n      class E : @field:Ann @get:Ann @set:Ann @setparam:Ann Foo\n\n在应用快速修复后：\n\n\n      interface Foo\n\n      annotation class Ann\n\n      class E : Foo\n\n仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ProhibitUseSiteTargetAnnotationsOnSuperTypesMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertTwoComparisonsToRangeCheck",
                "shortDescription": {
                  "text": "两个比较应转换为范围检查"
                },
                "fullDescription": {
                  "text": "报告可转换为范围检查的两个连续比较。 通过移除测试主体重复，针对范围进行检查使代码更简单。 示例： 'fun checkMonth(month: Int): Boolean {\n      return month >= 1 && month <= 12\n  }' 该快速修复会将基于比较的检查替换为针对范围的检查： 'fun checkMonth(month: Int): Boolean {\n      return month in 1..12\n  }'",
                  "markdown": "报告可转换为范围检查的两个连续比较。\n\n通过移除测试主体重复，针对范围进行检查使代码更简单。\n\n**示例：**\n\n\n      fun checkMonth(month: Int): Boolean {\n          return month >= 1 && month <= 12\n      }\n\n该快速修复会将基于比较的检查替换为针对范围的检查：\n\n\n      fun checkMonth(month: Int): Boolean {\n          return month in 1..12\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertTwoComparisonsToRangeCheck",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithEnumMap",
                "shortDescription": {
                  "text": "'HashMap' 可被替换为 'EnumMap'"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'EnumMap' 构造函数调用的 'hashMapOf' 函数或 'HashMap' 构造函数调用。 使用 'EnumMap' 构造函数可使代码更简单。 该快速修复会将函数调用替换为 'EnumMap' 构造函数调用。 示例： 'enum class E {\n      A, B\n  }\n\n  fun getMap(): Map<E, String> = hashMapOf()' 在应用快速修复后： 'enum class E {\n      A, B\n  }\n\n  fun getMap(): Map<E, String> = EnumMap(E::class.java)'",
                  "markdown": "报告可以替换为 `EnumMap` 构造函数调用的 `hashMapOf` 函数或 `HashMap` 构造函数调用。\n\n使用 `EnumMap` 构造函数可使代码更简单。\n\n该快速修复会将函数调用替换为 `EnumMap` 构造函数调用。\n\n**示例：**\n\n\n      enum class E {\n          A, B\n      }\n\n      fun getMap(): Map<E, String> = hashMapOf()\n\n在应用快速修复后：\n\n\n      enum class E {\n          A, B\n      }\n\n      fun getMap(): Map<E, String> = EnumMap(E::class.java)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceWithEnumMap",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalVariableName",
                "shortDescription": {
                  "text": "局部变量命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循命名约定的局部变量。 您可以在检查选项中指定所需的模式。 建议的命名约定：必须以小写字母开头，使用驼峰拼写法并且没有下划线。 示例： 'fun fibonacciNumber(index: Int): Long = when(index) {\n      0 -> 0\n      else -> {\n          // 未遵循命名约定：包含下划线符号 (`_`)\n          var number_one: Long = 0\n          // 未遵循命名约定：以大写字母开头\n          var NUMBER_TWO: Long = 1\n          // 遵循命名约定：以小写字母开头，使用驼峰拼写法并且没有下划线。\n          var numberThree: Long = number_one + NUMBER_TWO\n\n          for(currentIndex in 2..index) {\n              numberThree = number_one + NUMBER_TWO\n              number_one = NUMBER_TWO\n              NUMBER_TWO = numberThree\n          }\n          numberThree\n      }\n  }'",
                  "markdown": "报告不遵循命名约定的局部变量。\n\n您可以在检查选项中指定所需的模式。\n\n[建议的命名约定](https://kotlinlang.org/docs/coding-conventions.html#function-names)：必须以小写字母开头，使用驼峰拼写法并且没有下划线。\n\n**示例：**\n\n\n      fun fibonacciNumber(index: Int): Long = when(index) {\n          0 -> 0\n          else -> {\n              // 未遵循命名约定：包含下划线符号 (`_`)\n              var number_one: Long = 0\n              // 未遵循命名约定：以大写字母开头\n              var NUMBER_TWO: Long = 1\n              // 遵循命名约定：以小写字母开头，使用驼峰拼写法并且没有下划线。\n              var numberThree: Long = number_one + NUMBER_TWO\n\n              for(currentIndex in 2..index) {\n                  numberThree = number_one + NUMBER_TWO\n                  number_one = NUMBER_TWO\n                  NUMBER_TWO = numberThree\n              }\n              numberThree\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LocalVariableName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceUntilWithRangeUntil",
                "shortDescription": {
                  "text": "将 'until' 替换为 '..<' 运算符"
                },
                "fullDescription": {
                  "text": "报告可被替换为 '..<' 运算符的 'until'。 每个 'until' 到 '..<' 替换都不会以任何方式更改语义。 用户体验研究表明，与 'until' 相比，开发者在阅读包含 '..<' 的代码时的错误减少了约 20-30%。 示例： 'fun main(args: Array<String>) {\n      for (index in 0 until args.size) {\n          println(index)\n      }\n  }' 在应用快速修复后： 'fun main(args: Array<String>) {\n      for (index in 0..<args.size) {\n          println(index)\n      }\n  }' 仅当项目或模块的 Kotlin 语言级别为 1.7 或更高时，此检查才会报告。",
                  "markdown": "报告可被替换为 `..<` 运算符的 `until`。\n\n每个 `until` 到 `..<` 替换都不会以任何方式更改语义。\n\n用户体验研究表明，与 `until` 相比，开发者在阅读包含 `..<` 的代码时的错误减少了约 20-30%。\n\n**示例：**\n\n\n      fun main(args: Array<String>) {\n          for (index in 0 until args.size) {\n              println(index)\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun main(args: Array<String>) {\n          for (index in 0..<args.size) {\n              println(index)\n          }\n      }\n\n仅当项目或模块的 Kotlin 语言级别为 1.7 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceUntilWithRangeUntil",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumValuesSoftDeprecate",
                "shortDescription": {
                  "text": "从 1.9 开始，建议将 'Enum.values()' 替换为 'Enum.entries'"
                },
                "fullDescription": {
                  "text": "报告从 Kotlin 对可被替换为 'entries' 属性读取的枚举类中 'values()' 方法的调用。 使用 'Enum.entries' 可能会提高代码的性能。 该快速修复会将 'values()' 替换为 'entries'。 更多详细信息：KT-48872 为 Enum.values() 提供现代且高效的替代 注意：'entries' 属性类型与 'values()' 方法的返回值类型不同（'EnumEntries<T>' 继承自 'List<T>'，而不是 'Array<T>'）。 因此，在某些情况下，快速修复会插入额外的 '.toTypedArray()' 转换，以避免破坏代码，但在大多数情况下，将在没有该转换的情况下完成（例如，在 'for' 循环中）。 示例： 'enum class Version {\n        V1, V2\n    }\n\n    Version.values().forEach { /* .. */ }\n    val firstVersion = Version.values()[0]\n    functionExpectingArray(Version.values())' 在应用快速修复后： 'enum class Version {\n        V1, V2\n    }\n\n    Version.entries.forEach { /* .. */ }\n    val firstVersion = Version.entries[0]\n    functionExpectingArray(Version.entries.toTypedArray())'",
                  "markdown": "报告从 Kotlin 对可被替换为 `entries` 属性读取的枚举类中 `values()` 方法的调用。\n\n\n使用 `Enum.entries` 可能会提高代码的性能。\n\n\n该快速修复会将 `values()` 替换为 `entries`。\n\n\n**更多详细信息** ：[KT-48872 为 Enum.values() 提供现代且高效的替代](https://youtrack.jetbrains.com/issue/KT-48872)\n\n\n**注意** ：`entries` 属性类型与 `values()` 方法的返回值类型不同（`EnumEntries<T>` 继承自 `List<T>`，而不是 `Array<T>`）。\n因此，在某些情况下，快速修复会插入额外的 `.toTypedArray()` 转换，以避免破坏代码，但在大多数情况下，将在没有该转换的情况下完成（例如，在 `for` 循环中）。\n\n**示例：**\n\n\n        enum class Version {\n            V1, V2\n        }\n\n        Version.values().forEach { /* .. */ }\n        val firstVersion = Version.values()[0]\n        functionExpectingArray(Version.values())\n\n在应用快速修复后：\n\n\n        enum class Version {\n            V1, V2\n        }\n\n        Version.entries.forEach { /* .. */ }\n        val firstVersion = Version.entries[0]\n        functionExpectingArray(Version.entries.toTypedArray())\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumValuesSoftDeprecate",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveRedundantQualifierName",
                "shortDescription": {
                  "text": "冗余限定符名称"
                },
                "fullDescription": {
                  "text": "报告关于类名、函数和属性的冗余限定符（或其部分）。 完全限定名称是一种明确的标识符，用于指定调用所引用的对象、函数或属性。 在可以缩短名称的上下文中，检查会告知机会，关联的“移除冗余限定符名称”快速修复可以修改代码。 示例： 'package my.simple.name\n  import kotlin.Int.Companion.MAX_VALUE\n\n  class Foo\n\n  fun main() {\n      val a = my.simple.name.Foo()    // 'Foo' 位于声明的 'my.simple.name' 软件包中，限定符冗余\n      val b = kotlin.Int.MAX_VALUE    // 可以替换为 'MAX_VALUE'，因为它已被导入\n      val c = kotlin.Double.MAX_VALUE // 可以替换为 'Double.MAX_VALUE'，因为内置类型会被自动导入\n  }' 在应用快速修复后： 'package my.simple.name\n  import kotlin.Int.Companion.MAX_VALUE\n\n  class Foo\n\n  fun main() {\n      val a = Foo()\n      val b = MAX_VALUE\n      val c = Double.MAX_VALUE\n  }'",
                  "markdown": "报告关于类名、函数和属性的冗余限定符（或其部分）。\n\n\n完全限定名称是一种明确的标识符，用于指定调用所引用的对象、函数或属性。\n在可以缩短名称的上下文中，检查会告知机会，关联的\"移除冗余限定符名称\"快速修复可以修改代码。\n\n**示例：**\n\n\n      package my.simple.name\n      import kotlin.Int.Companion.MAX_VALUE\n\n      class Foo\n\n      fun main() {\n          val a = my.simple.name.Foo()    // 'Foo' 位于声明的 'my.simple.name' 软件包中，限定符冗余\n          val b = kotlin.Int.MAX_VALUE    // 可以替换为 'MAX_VALUE'，因为它已被导入\n          val c = kotlin.Double.MAX_VALUE // 可以替换为 'Double.MAX_VALUE'，因为内置类型会被自动导入\n      }\n\n在应用快速修复后：\n\n\n      package my.simple.name\n      import kotlin.Int.Companion.MAX_VALUE\n\n      class Foo\n\n      fun main() {\n          val a = Foo()\n          val b = MAX_VALUE\n          val c = Double.MAX_VALUE\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveRedundantQualifierName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveCurlyBracesFromTemplate",
                "shortDescription": {
                  "text": "字符串模板中的冗余大括号"
                },
                "fullDescription": {
                  "text": "报告字符串模板中用于括简单标识符的大括号的用法。 使用“移除大括号”快速修复可移除冗余的大括号。 示例： 'fun redundant() {\n     val x = 4\n     val y = \"${x}\" // <== 冗余\n  }\n\n  fun correctUsage() {\n      val x = \"x\"\n      val y = \"${x.length}\" // <== 可以\n  }' 在应用快速修复后： 'fun redundant() {\n     val x = 4\n     val y = \"$x\"\n  }\n\n  fun correctUsage() {\n      val x = \"x\" <== 已更新\n      val y = \"${x.length}\"\n  }'",
                  "markdown": "报告字符串模板中用于括简单标识符的大括号的用法。\n\n使用\"移除大括号\"快速修复可移除冗余的大括号。\n\n**示例：**\n\n\n      fun redundant() {\n         val x = 4\n         val y = \"${x}\" // <== 冗余\n      }\n\n      fun correctUsage() {\n          val x = \"x\"\n          val y = \"${x.length}\" // <== 可以\n      }\n\n在应用快速修复后：\n\n\n      fun redundant() {\n         val x = 4\n         val y = \"$x\"\n      }\n\n      fun correctUsage() {\n          val x = \"x\" <== 已更新\n          val y = \"${x.length}\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveCurlyBracesFromTemplate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithIndexingOperation",
                "shortDescription": {
                  "text": "'substring' 调用应被替换为索引运算符"
                },
                "fullDescription": {
                  "text": "报告可以替换为 '\"abc\"[0]' 的 '\"abc\".substring(0, 1)' 等调用。 按索引获取元素可使代码更简单。 该快速修复会将 'substring' 调用替换为索引运算符。 示例： 'fun foo() {\n      \"abc\".substring(0, 1)\n  }' 在应用快速修复后： 'fun foo() {\n      \"abc\"[0]\n  }'",
                  "markdown": "报告可以替换为 `\"abc\"[0]` 的 `\"abc\".substring(0, 1)` 等调用。\n\n按索引获取元素可使代码更简单。\n\n该快速修复会将 `substring` 调用替换为索引运算符。\n\n**示例：**\n\n\n      fun foo() {\n          \"abc\".substring(0, 1)\n      }\n\n在应用快速修复后：\n\n\n      fun foo() {\n          \"abc\"[0]\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithIndexingOperation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousCollectionReassignment",
                "shortDescription": {
                  "text": "增强赋值在后台创建新集合"
                },
                "fullDescription": {
                  "text": "报告只读 'Collection' 上的增强型赋值 ('+=') 表达式。 只读 'Collection' 上的增强型赋值 ('+=') 表达式临时分配新集合，这可能会影响性能。 将类型更改为可变快速修复可用于自动修正代码。 示例： 'fun test() {\n      var list = listOf(0)\n      list += 42 // 此处分配了一个新列表，相当于 list = list + 42\n  }' 在应用快速修复后： 'fun test() {\n      val list = mutableListOf(0)\n      list += 42\n  }'",
                  "markdown": "报告只读 `Collection` 上的增强型赋值 (`+=`) 表达式。\n\n只读 `Collection` 上的增强型赋值 (`+=`) 表达式临时分配新集合，这可能会影响性能。\n\n**将类型更改为可变**快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun test() {\n          var list = listOf(0)\n          list += 42 // 此处分配了一个新列表，相当于 list = list + 42\n      }\n\n在应用快速修复后：\n\n\n      fun test() {\n          val list = mutableListOf(0)\n          list += 42\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SuspiciousCollectionReassignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MoveLambdaOutsideParentheses",
                "shortDescription": {
                  "text": "圆括号内的 lambda 实参"
                },
                "fullDescription": {
                  "text": "报告圆括号中可以移到外部的 lambda 表达式。 示例： 'fun square(a: Int, b: (Int) -> Int) {\n  b(a * a)\n}\n\nfun foo() {\n  square(2, { it })\n}' 在应用快速修复后： 'fun foo() {\n  square(2){ it }\n}'",
                  "markdown": "报告圆括号中可以移到外部的 lambda 表达式。\n\n**示例：**\n\n\n    fun square(a: Int, b: (Int) -> Int) {\n      b(a * a)\n    }\n\n    fun foo() {\n      square(2, { it })\n    }\n\n在应用快速修复后：\n\n\n    fun foo() {\n      square(2){ it }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MoveLambdaOutsideParentheses",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantNotNullExtensionReceiverOfInline",
                "shortDescription": {
                  "text": "'inline fun' 扩展接收器在 Kotlin 1.2 及更低版本中可以显式设为可为 null"
                },
                "fullDescription": {
                  "text": "报告带有不可为 null 的扩展接收器的内联函数，这些函数不使用扩展接收器不可为 null 的事实。 在 Kotlin 1.2 之前，使用灵活的可 null 扩展接收器（具有未知可 null 性的平台类型）对 'inline fun' 的调用不包括字节码中的可 null 性检查。 自 Kotlin 1.2 起，字节码中包含可 null 性检查（请参阅 KT-12899）。 因此，在 Kotlin 1.2 之前的版本中，不使用扩展接收器不可为 null 这一事实的函数是危险的，建议使此类函数具有可为 null 的接收器。 示例： 'inline fun String.greet() {\n      println(\"Hello, $this!\")\n  }\n\n  fun main() {\n      // `System.getProperty` 返回不可表示的 `String!` 类型\n      val user = System.getProperty(\"user.name\")\n      user.greet()\n  }' 在应用快速修复后： 'inline fun String.greet() {\n      println(\"Hello, $this!\")\n  }\n\n  fun main() {\n      // `System.getProperty` 返回不可表示的 `String!` 类型\n      val user = System.getProperty(\"user.name\")\n      user.greet()\n  }' 仅当项目或模块的 Kotlin 语言级别低于 1.2 时，此检查才会报告。",
                  "markdown": "报告带有不可为 null 的扩展接收器的内联函数，这些函数不使用扩展接收器不可为 null 的事实。\n\n\n在 Kotlin 1.2 之前，使用灵活的可 null 扩展接收器（具有未知可 null 性的平台类型）对 `inline fun` 的调用不包括字节码中的可 null 性检查。 自 Kotlin 1.2 起，字节码中包含可 null 性检查（请参阅 [KT-12899](https://youtrack.jetbrains.com/issue/KT-12899)）。\n\n\n因此，在 Kotlin 1.2 之前的版本中，不使用扩展接收器不可为 null 这一事实的函数是危险的，建议使此类函数具有可为 null 的接收器。\n\n**示例：**\n\n\n      inline fun String.greet() {\n          println(\"Hello, $this!\")\n      }\n\n      fun main() {\n          // `System.getProperty` 返回不可表示的 `String!` 类型\n          val user = System.getProperty(\"user.name\")\n          user.greet()\n      }\n\n在应用快速修复后：\n\n\n      inline fun String.greet() {\n          println(\"Hello, $this!\")\n      }\n\n      fun main() {\n          // `System.getProperty` 返回不可表示的 `String!` 类型\n          val user = System.getProperty(\"user.name\")\n          user.greet()\n      }\n\n仅当项目或模块的 Kotlin 语言级别低于 1.2 时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantNotNullExtensionReceiverOfInline",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 互操作问题",
                      "index": 67,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantElvisReturnNull",
                "shortDescription": {
                  "text": "冗余 '?: return null'"
                },
                "fullDescription": {
                  "text": "报告冗余的 '?: return null' 示例： 'fun foo(): Int? {\n      ...\n  }\n\n  fun test() : Int? {\n      return foo() ?: return null\n  }' 在应用快速修复后： 'fun foo(): Int? {\n      ...\n  }\n\n  fun test() : Int? {\n      return foo()\n  }'",
                  "markdown": "报告冗余的 `?: return null`\n\n**示例：**\n\n\n      fun foo(): Int? {\n          ...\n      }\n\n      fun test() : Int? {\n          return foo() ?: return null\n      }\n\n在应用快速修复后：\n\n\n      fun foo(): Int? {\n          ...\n      }\n\n      fun test() : Int? {\n          return foo()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantElvisReturnNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProhibitTypeParametersForLocalVariablesMigration",
                "shortDescription": {
                  "text": "带类型形参的局部变量"
                },
                "fullDescription": {
                  "text": "报告带有类型形参的局部变量。 局部变量的类型形参没有意义，因为它不能被专门化。 示例： 'fun main() {\n      val <T> x = \"\"\n  }' 在应用快速修复后： 'fun main() {\n      val x = \"\"\n  }' 仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。",
                  "markdown": "报告带有类型形参的局部变量。\n\n局部变量的类型形参没有意义，因为它不能被专门化。\n\n**示例：**\n\n\n      fun main() {\n          val <T> x = \"\"\n      }\n\n在应用快速修复后：\n\n\n      fun main() {\n          val x = \"\"\n      }\n\n仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ProhibitTypeParametersForLocalVariablesMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PrivatePropertyName",
                "shortDescription": {
                  "text": "private 属性命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循推荐命名约定的 private 属性名称。 一致的命名会让阅读和理解代码变得更容易。 根据 Kotlin 官方样式指南，private 属性名称应以小写字母开头并使用驼峰拼写法。 或者，允许使用下划线前缀，但仅限于 private 属性。 可以通过更改“模式”正则表达式来引入其他命名规则。 示例： 'val _My_Cool_Property = \"\"' 该快速修复会根据 Kotlin 命名约定重命名类： 'val _myCoolProperty = \"\"'",
                  "markdown": "报告不遵循推荐命名约定的 private 属性名称。\n\n\n一致的命名会让阅读和理解代码变得更容易。\n根据 [Kotlin 官方样式指南](https://kotlinlang.org/docs/coding-conventions.html#naming-rules)，private 属性名称应以小写字母开头并使用驼峰拼写法。\n或者，允许使用下划线前缀，但仅限于 **private** 属性。\n\n可以通过更改\"模式\"正则表达式来引入其他命名规则。\n\n**示例：**\n\n\n      val _My_Cool_Property = \"\"\n\n该快速修复会根据 Kotlin 命名约定重命名类：\n\n\n      val _myCoolProperty = \"\"\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PrivatePropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinJvmAnnotationInJava",
                "shortDescription": {
                  "text": "Java 中的 Kotlin JVM 注解"
                },
                "fullDescription": {
                  "text": "报告 Java 代码中的无用 Kotlin JVM 注解。 示例： 'import kotlin.jvm.Volatile;\n\n  public class Test {\n      @Volatile\n      public int i;\n  }'",
                  "markdown": "报告 Java 代码中的无用 Kotlin JVM 注解。\n\n**示例：**\n\n\n      import kotlin.jvm.Volatile;\n\n      public class Test {\n          @Volatile\n          public int i;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinJvmAnnotationInJava",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 互操作问题",
                      "index": 67,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObsoleteKotlinJsPackages",
                "shortDescription": {
                  "text": "'kotlin.browser' 和 'kotlin.dom' 软件包自 1.4 起已弃用"
                },
                "fullDescription": {
                  "text": "报告 'kotlin.dom' 和 'kotlin.browser' 软件包的用法。 在 Kotlin 1.4+ 中，这些软件包分别移至 'kotlinx.dom' 和 'kotlinx.browser'。",
                  "markdown": "报告 `kotlin.dom` 和 `kotlin.browser` 软件包的用法。\n\n在 Kotlin 1.4+ 中，这些软件包分别移至 `kotlinx.dom` 和 `kotlinx.browser`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ObsoleteKotlinJsPackages",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CascadeIf",
                "shortDescription": {
                  "text": "级联 'if' 可被替换为 'when'"
                },
                "fullDescription": {
                  "text": "报告有三个以上分支并且可以替换为 'when' 表达式的 'if' 语句。 示例： 'fun checkIdentifier(id: String) {\n      fun Char.isIdentifierStart() = this in 'A'..'z'\n      fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n      if (id.isEmpty()) {\n          print(\"Identifier is empty\")\n      } else if (!id.first().isIdentifierStart()) {\n          print(\"Identifier should start with a letter\")\n      } else if (!id.subSequence(1, id.length).all(Char::isIdentifierPart)) {\n          print(\"Identifier should contain only letters and numbers\")\n      }\n  }' 该快速修复会将 'if' 表达式转换为 'when'： 'fun checkIdentifier(id: String) {\n      fun Char.isIdentifierStart() = this in 'A'..'z'\n      fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n      when {\n          id.isEmpty() -> {\n              print(\"Identifier is empty\")\n          }\n          !id.first().isIdentifierStart() -> {\n              print(\"Identifier should start with a letter\")\n          }\n          !id.subSequence(1, id.length).all(Char::isIdentifierPart) -> {\n              print(\"Identifier should contain only letters and numbers\")\n          }\n      }\n  }'",
                  "markdown": "报告有三个以上分支并且可以替换为 `when` 表达式的 `if` 语句。\n\n**示例：**\n\n\n      fun checkIdentifier(id: String) {\n          fun Char.isIdentifierStart() = this in 'A'..'z'\n          fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n          if (id.isEmpty()) {\n              print(\"Identifier is empty\")\n          } else if (!id.first().isIdentifierStart()) {\n              print(\"Identifier should start with a letter\")\n          } else if (!id.subSequence(1, id.length).all(Char::isIdentifierPart)) {\n              print(\"Identifier should contain only letters and numbers\")\n          }\n      }\n\n该快速修复会将 `if` 表达式转换为 `when`：\n\n\n      fun checkIdentifier(id: String) {\n          fun Char.isIdentifierStart() = this in 'A'..'z'\n          fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n          when {\n              id.isEmpty() -> {\n                  print(\"Identifier is empty\")\n              }\n              !id.first().isIdentifierStart() -> {\n                  print(\"Identifier should start with a letter\")\n              }\n              !id.subSequence(1, id.length).all(Char::isIdentifierPart) -> {\n                  print(\"Identifier should contain only letters and numbers\")\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CascadeIf",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyRange",
                "shortDescription": {
                  "text": "start 大于 endInclusive 的范围为空"
                },
                "fullDescription": {
                  "text": "报告由于 'start' 值大于 'endInclusive' 值而为空的范围。 示例： 'val range = 2..1' 该快速修复会将 '..' 运算符更改为 'downTo'： 'val range = 2 downTo 1'",
                  "markdown": "报告由于 `start` 值大于 `endInclusive` 值而为空的范围。\n\n**示例：**\n\n\n      val range = 2..1\n\n该快速修复会将 `..` 运算符更改为 `downTo`：\n\n\n      val range = 2 downTo 1\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyRange",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestFunctionName",
                "shortDescription": {
                  "text": "测试函数命名约定"
                },
                "fullDescription": {
                  "text": "报告未遵循建议的命名约定的测试函数名称。",
                  "markdown": "报告未遵循[建议的命名约定](https://kotlinlang.org/docs/coding-conventions.html#names-for-test-methods)的测试函数名称。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TestFunctionName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecursivePropertyAccessor",
                "shortDescription": {
                  "text": "递归属性访问器"
                },
                "fullDescription": {
                  "text": "报告能够以 'StackOverflowError' 结束的递归属性访问器调用。 此类调用经常与支持字段访问混淆。 示例： 'var counter: Int = 0\n      set(value) {\n          counter = if (value < 0) 0 else value\n      }' 在应用快速修复后： 'var counter: Int = 0\n      set(value) {\n          field = if (value < 0) 0 else value\n      }'",
                  "markdown": "报告能够以 `StackOverflowError` 结束的递归属性访问器调用。\n此类调用经常与支持字段访问混淆。\n\n**示例：**\n\n\n      var counter: Int = 0\n          set(value) {\n              counter = if (value < 0) 0 else value\n          }\n\n在应用快速修复后：\n\n\n      var counter: Int = 0\n          set(value) {\n              field = if (value < 0) 0 else value\n          }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RecursivePropertyAccessor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExternalClassifierExtendingStateOrProps",
                "shortDescription": {
                  "text": "扩展 State 或 Props 的非外部分类器"
                },
                "fullDescription": {
                  "text": "报告扩展 State 或 Props 的非外部分类器。 在迁移指南中阅读更多信息。",
                  "markdown": "报告扩展 State 或 Props 的非外部分类器。 在[迁移指南](https://kotlinlang.org/docs/js-ir-migration.html#convert-js-and-react-related-classes-and-interfaces-to-external-interfaces)中阅读更多信息。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExternalClassifierExtendingStateOrProps",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/React/可能的 bug",
                      "index": 128,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalExpectation",
                "shortDescription": {
                  "text": "可选预期注解没有实际注解"
                },
                "fullDescription": {
                  "text": "报告某些平台模块中没有实际注解的可选预期注解。 示例： '// 通用代码\n@OptionalExpectation\nexpect annotation class JvmName(val name: String)\n\n@JvmName(name = \"JvmFoo\")\nfun foo() { }\n\n// jvm 代码\nactual annotation class JvmName(val name: String)' 该检查还会报告对非 JVM 平台（例如 Native）省略 'actual annotation class JvmName' 的情况。",
                  "markdown": "报告某些平台模块中没有实际注解的可选预期注解。\n\n**示例：**\n\n    // 通用代码\n    @OptionalExpectation\n    expect annotation class JvmName(val name: String)\n\n    @JvmName(name = \"JvmFoo\")\n    fun foo() { }\n\n    // jvm 代码\n    actual annotation class JvmName(val name: String)\n\n该检查还会报告对非 JVM 平台（例如 Native）省略 `actual annotation class JvmName` 的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "OptionalExpectation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DestructuringWrongName",
                "shortDescription": {
                  "text": "析构声明中的变量使用错误数据类属性的名称"
                },
                "fullDescription": {
                  "text": "报告与析构数据类的不同属性名称匹配的析构声明条目。 示例： 'data class Foo(val a: String, val b: Int, val c: String)\n\n  fun bar(f: Foo) {\n      val (a, c) = f\n  }' 该快速修复会更改变量的名称以匹配相应类字段的名称： 'data class Foo(val a: String, val b: Int, val c: String)\n\n  fun bar(f: Foo) {\n      val (a, b) = f\n  }'",
                  "markdown": "报告与析构数据类的不同属性名称匹配的析构声明条目。\n\n**示例：**\n\n\n      data class Foo(val a: String, val b: Int, val c: String)\n\n      fun bar(f: Foo) {\n          val (a, c) = f\n      }\n\n该快速修复会更改变量的名称以匹配相应类字段的名称：\n\n\n      data class Foo(val a: String, val b: Int, val c: String)\n\n      fun bar(f: Foo) {\n          val (a, b) = f\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DestructuringWrongName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfThenToSafeAccess",
                "shortDescription": {
                  "text": "If-Then 可折叠为 '?.'"
                },
                "fullDescription": {
                  "text": "报告可以折叠到安全访问 ('?.') 表达式中的 'if-then' 表达式。 示例： 'fun bar(x: String) = \"\"\n\n  fun foo(a: String?) {\n     if (a != null) bar(a) else null\n  }' 该快速修复会将 'if-then' 表达式转换为安全访问 ('?.') 表达式： 'fun bar(x: String) = \"\"\n\n  fun foo(a: String?) {\n     a?.let { bar(it) }\n  }'",
                  "markdown": "报告可以折叠到安全访问 (`?.`) 表达式中的 `if-then` 表达式。\n\n**示例：**\n\n\n      fun bar(x: String) = \"\"\n\n      fun foo(a: String?) {\n         if (a != null) bar(a) else null\n      }\n\n该快速修复会将 `if-then` 表达式转换为安全访问 (`?.`) 表达式：\n\n\n      fun bar(x: String) = \"\"\n\n      fun foo(a: String?) {\n         a?.let { bar(it) }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfThenToSafeAccess",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RestrictReturnStatementTargetMigration",
                "shortDescription": {
                  "text": "从 1.4 起，目标标签不表示函数"
                },
                "fullDescription": {
                  "text": "报告未指向函数的标签。 禁止声明不表示函数的目标标签。 该快速修复会移除标签。 示例： 'fun testValLabelInReturn() {\n      L@ val fn = { return@L }\n      fn()\n  }' 在应用快速修复后： 'fun testValLabelInReturn() {\n      L@ val fn = { return }\n      fn()\n  }' 仅当项目或模块的语言级别为 1.4 或更高时，此检查才会报告。",
                  "markdown": "报告未指向函数的标签。\n\n禁止声明不表示函数的目标标签。\n\n该快速修复会移除标签。\n\n**示例：**\n\n\n      fun testValLabelInReturn() {\n          L@ val fn = { return@L }\n          fn()\n      }\n\n在应用快速修复后：\n\n\n      fun testValLabelInReturn() {\n          L@ val fn = { return }\n          fn()\n      }\n\n仅当项目或模块的语言级别为 1.4 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "RestrictReturnStatementTargetMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantUnitExpression",
                "shortDescription": {
                  "text": "冗余 'Unit'"
                },
                "fullDescription": {
                  "text": "报告冗余的 'Unit' 表达式。 Kotlin 中的 'Unit' 可以用作不返回任何有意义的函数的返回类型。 'Unit' 类型只有一个可能的值，即 'Unit' 对象。 示例： 'fun redundantA(): Unit {\n      return Unit // 冗余，'Unit' 默认返回并与预期返回类型匹配\n  }\n\n  fun requiredA(condition: Boolean): Any {\n      if (condition) return \"hello\"\n      return Unit // 显式 'Unit' 为必选项，因为预期类型为 'Any'\n  }\n\n  fun redundantB(condition: Boolean): Any = if (condition) {\n      fun ancillary(): Int = 1\n      println(\"${ancillary()}\")\n      Unit // 冗余，因为上一个表达式已经为 'Unit' 类型\n  } else {\n      println(\"else\")\n  }\n\n  fun requiredB(condition: Boolean): Any = if (condition) {\n      1024\n      Unit // 必选项，否则 '1024' (Int) 将为返回值\n  } else {\n      println(\"else\")\n  }'",
                  "markdown": "报告冗余的 `Unit` 表达式。\n\n\nKotlin 中的 `Unit` 可以用作不返回任何有意义的函数的返回类型。\n`Unit` 类型只有一个可能的值，即 `Unit` 对象。\n\n**示例：**\n\n\n      fun redundantA(): Unit {\n          return Unit // 冗余，'Unit' 默认返回并与预期返回类型匹配\n      }\n\n      fun requiredA(condition: Boolean): Any {\n          if (condition) return \"hello\"\n          return Unit // 显式 'Unit' 为必选项，因为预期类型为 'Any'\n      }\n\n      fun redundantB(condition: Boolean): Any = if (condition) {\n          fun ancillary(): Int = 1\n          println(\"${ancillary()}\")\n          Unit // 冗余，因为上一个表达式已经为 'Unit' 类型\n      } else {\n          println(\"else\")\n      }\n\n      fun requiredB(condition: Boolean): Any = if (condition) {\n          1024\n          Unit // 必选项，否则 '1024' (Int) 将为返回值\n      } else {\n          println(\"else\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantUnitExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PlatformExtensionReceiverOfInline",
                "shortDescription": {
                  "text": "在 Kotlin 1.2 及更低版本中包含可为 null 的接收器的 'inline fun'"
                },
                "fullDescription": {
                  "text": "报告使用灵活可 null 的扩展接收器（具有未知可 null 性的平台类型）对内联函数的潜在不安全调用。 在 Kotlin 1.2 之前，使用灵活的可 null 扩展接收器（具有未知可 null 性的平台类型）对 'inline fun' 的调用不包括字节码中的可 null 性检查。 自 Kotlin 1.2 起，字节码中包含可 null 性检查（请参阅 KT-12899）。 建议添加要抛出异常的显式 '!!'，或者考虑将函数的接收器类型更改为可 null（如果它能够无异常地运行）。 示例： 'inline fun String.removePrefix(prefix: String): String {\n      return this.substring(prefix.length)\n  }\n\n  fun main() {\n      // `System.getProperty` 返回不可表示的 `String!` 类型\n      val property = System.getProperty(\"user.dir\")\n      println(property.removePrefix(\"/home\"))\n  }' 在应用快速修复后： 'inline fun String.removePrefix(prefix: String): String {\n      return this.substring(prefix.length)\n  }\n\n  fun main() {\n      // `System.getProperty` 返回不可表示的 `String!` 类型\n      val property = System.getProperty(\"user.dir\")\n      println(property!!.removePrefix(\"/home\"))\n  }' 仅当项目或模块的 Kotlin 语言级别低于 1.2 时，此检查才会报告。",
                  "markdown": "报告使用灵活可 null 的扩展接收器（具有未知可 null 性的平台类型）对内联函数的潜在不安全调用。\n\n\n在 Kotlin 1.2 之前，使用灵活的可 null 扩展接收器（具有未知可 null 性的平台类型）对 `inline fun` 的调用不包括字节码中的可 null 性检查。 自 Kotlin 1.2 起，字节码中包含可 null 性检查（请参阅 [KT-12899](https://youtrack.jetbrains.com/issue/KT-12899)）。\n\n\n建议添加要抛出异常的显式 `!!`，或者考虑将函数的接收器类型更改为可 null（如果它能够无异常地运行）。\n\n**示例：**\n\n\n      inline fun String.removePrefix(prefix: String): String {\n          return this.substring(prefix.length)\n      }\n\n      fun main() {\n          // `System.getProperty` 返回不可表示的 `String!` 类型\n          val property = System.getProperty(\"user.dir\")\n          println(property.removePrefix(\"/home\"))\n      }\n\n在应用快速修复后：\n\n\n      inline fun String.removePrefix(prefix: String): String {\n          return this.substring(prefix.length)\n      }\n\n      fun main() {\n          // `System.getProperty` 返回不可表示的 `String!` 类型\n          val property = System.getProperty(\"user.dir\")\n          println(property!!.removePrefix(\"/home\"))\n      }\n\n仅当项目或模块的 Kotlin 语言级别低于 1.2 时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PlatformExtensionReceiverOfInline",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 互操作问题",
                      "index": 67,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousEqualsCombination",
                "shortDescription": {
                  "text": "可疑的 == 与 === 组合"
                },
                "fullDescription": {
                  "text": "报告在单个表达式内的同一变量上使用的 '==' 和 '===' 比较。 由于相似性，'==' 和 '===' 可能会在无通知的情况下混用，需要仔细检查使用的是 '==' 而非 '===' 示例： 'if (type === FIELD || type == METHOD || type == ANNOTATION_METHOD || // 请注意，\"==\" 使用错误\n      type === LAMBDA_EXPRESSION) return'",
                  "markdown": "报告在单个表达式内的同一变量上使用的 `==` 和 `===` 比较。\n\n由于相似性，`==` 和 `===` 可能会在无通知的情况下混用，需要仔细检查使用的是 `==` 而非 `===`\n\n示例：\n\n\n      if (type === FIELD || type == METHOD || type == ANNOTATION_METHOD || // 请注意，\"==\" 使用错误\n          type === LAMBDA_EXPRESSION) return\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SuspiciousEqualsCombination",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MigrateDiagnosticSuppression",
                "shortDescription": {
                  "text": "应替换诊断名称"
                },
                "fullDescription": {
                  "text": "报告带有旧诊断名称的禁止，例如 '@Suppress(\"HEADER_WITHOUT_IMPLEMENTATION\")'。 来自 Kotlin 1.2 及更早版本的一些诊断现在已经过时，从而使这样的禁止变得冗余。 示例： '@Suppress(\"HEADER_DECLARATION_WITH_BODY\")\nexpect fun connection() {\n  // ...\n}' 在应用快速修复后： '@Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\nexpect fun connection() {\n  // ...\n}'",
                  "markdown": "报告带有旧诊断名称的禁止，例如 `@Suppress(\"HEADER_WITHOUT_IMPLEMENTATION\")`。\n\n\n来自 Kotlin 1.2 及更早版本的一些诊断现在已经过时，从而使这样的禁止变得冗余。\n\n**示例：**\n\n\n    @Suppress(\"HEADER_DECLARATION_WITH_BODY\")\n    expect fun connection() {\n      // ...\n    }\n\n在应用快速修复后：\n\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    expect fun connection() {\n      // ...\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MigrateDiagnosticSuppression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/其他问题",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedDataClassCopyResult",
                "shortDescription": {
                  "text": "数据类复制的未使用结果"
                },
                "fullDescription": {
                  "text": "报告未使用其结果的数据类 'copy' 函数调用。",
                  "markdown": "报告未使用其结果的数据类 `copy` 函数调用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedDataClassCopyResult",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonNullableBooleanPropertyInExternalInterface",
                "shortDescription": {
                  "text": "external 接口包含不可为 null 的布尔属性"
                },
                "fullDescription": {
                  "text": "报告外部接口中不可为 null 的布尔属性。 在迁移指南中阅读更多信息。",
                  "markdown": "报告外部接口中不可为 null 的布尔属性。 在[迁移指南](https://kotlinlang.org/docs/js-ir-migration.html#make-boolean-properties-nullable-in-external-interfaces)中阅读更多信息。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonNullableBooleanPropertyInExternalInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeferredResultUnused",
                "shortDescription": {
                  "text": "'@Deferred' 结果未被使用"
                },
                "fullDescription": {
                  "text": "如果未使用返回值，则报告具有 'Deferred' 结果类型的函数调用。 如果未使用 'Deferred' 返回值，则调用站点不会等待补全此函数。 示例： 'fun calcEverythingAsync() = CompletableDeferred(42)\n\n  fun usage() {\n      calcEverythingAsync()\n  }' 该快速修复会提供具有 'Deferred' 初始值设定项的变量： 'fun calcEverythingAsync() = CompletableDeferred(42)\n\n  fun usage() {\n      val answer = calcEverythingAsync()\n  }'",
                  "markdown": "如果未使用返回值，则报告具有 `Deferred` 结果类型的函数调用。\n\n如果未使用 `Deferred` 返回值，则调用站点不会等待补全此函数。\n\n**示例：**\n\n\n      fun calcEverythingAsync() = CompletableDeferred(42)\n\n      fun usage() {\n          calcEverythingAsync()\n      }\n\n该快速修复会提供具有 `Deferred` 初始值设定项的变量：\n\n\n      fun calcEverythingAsync() = CompletableDeferred(42)\n\n      fun usage() {\n          val answer = calcEverythingAsync()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeferredResultUnused",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantElseInIf",
                "shortDescription": {
                  "text": "'if' 中冗余的 'else'"
                },
                "fullDescription": {
                  "text": "报告 'if' 中具有 'return' 的冗余 'if' 示例： 'fun foo(arg: Boolean): Int {\n      if (arg) return 0\n      else { // 此 else 冗余，大括号中的代码正好可以向左移动\n          someCode()\n      }\n  }' 在应用快速修复后： 'fun foo(arg: Boolean): Int {\n      if (arg) return 0\n      someCode()\n  }'",
                  "markdown": "报告 `if` 中具有 `return` 的冗余 `if`\n\n**示例：**\n\n\n      fun foo(arg: Boolean): Int {\n          if (arg) return 0\n          else { // 此 else 冗余，大括号中的代码正好可以向左移动\n              someCode()\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun foo(arg: Boolean): Int {\n          if (arg) return 0\n          someCode()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantElseInIf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SelfReferenceConstructorParameter",
                "shortDescription": {
                  "text": "构造函数永远无法补全"
                },
                "fullDescription": {
                  "text": "报告具有非 null 自引用形参的构造函数。 此类构造函数从不实例化类。 该快速修复会将形参类型转换为可 null。 示例： 'class SelfRef(val ref: SelfRef)' 在应用快速修复后： 'class SelfRef(val ref: SelfRef?)'",
                  "markdown": "报告具有非 null 自引用形参的构造函数。\n\n此类构造函数从不实例化类。\n\n该快速修复会将形参类型转换为可 null。\n\n**示例：**\n\n\n      class SelfRef(val ref: SelfRef)\n\n在应用快速修复后：\n\n\n      class SelfRef(val ref: SelfRef?)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SelfReferenceConstructorParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaIoSerializableObjectMustHaveReadResolve",
                "shortDescription": {
                  "text": "Serializable 对象必须实现 'readResolve'"
                },
                "fullDescription": {
                  "text": "报告实现 'java.io.Serializable' 但不实现 readResolve 的 'object'（包括 'data object'） 示例： 'import java.io.Serializable\n\n  object Foo : Serializable' 快速修复会实现 'readResolve' 方法： 'import java.io.Serializable\n\n  object Foo : Serializable {\n      private fun readResolve() = Foo\n  }'",
                  "markdown": "报告实现 `java.io.Serializable` 但不实现 [readResolve](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method) 的 `object`（包括 `data object`）\n\n**示例：**\n\n\n      import java.io.Serializable\n\n      object Foo : Serializable\n\n快速修复会实现 `readResolve` 方法：\n\n\n      import java.io.Serializable\n\n      object Foo : Serializable {\n          private fun readResolve() = Foo\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaIoSerializableObjectMustHaveReadResolve",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplacePutWithAssignment",
                "shortDescription": {
                  "text": "'map.put()' 可以转换为赋值"
                },
                "fullDescription": {
                  "text": "报告可以替换为索引运算符 ('[]') 的 'map.put' 函数调用。 使用语法糖可使代码更简单。 该快速修复会将 'put' 调用替换为赋值。 示例： 'fun foo(map: MutableMap<Int, String>) {\n      map.put(42, \"foo\")\n  }' 在应用快速修复后： 'fun foo(map: MutableMap<Int, String>) {\n      map[42] = \"foo\"\n  }'",
                  "markdown": "报告可以替换为索引运算符 (`[]`) 的 `map.put` 函数调用。\n\n使用语法糖可使代码更简单。\n\n该快速修复会将 `put` 调用替换为赋值。\n\n**示例：**\n\n\n      fun foo(map: MutableMap<Int, String>) {\n          map.put(42, \"foo\")\n      }\n\n在应用快速修复后：\n\n\n      fun foo(map: MutableMap<Int, String>) {\n          map[42] = \"foo\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplacePutWithAssignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MainFunctionReturnUnit",
                "shortDescription": {
                  "text": "main 函数应返回 'Unit'"
                },
                "fullDescription": {
                  "text": "当 main 函数没有 'Unit' 的返回值类型值时报告。 示例： 'fun main() = \"Hello world!\"'",
                  "markdown": "当 main 函数没有 `Unit` 的返回值类型值时报告。\n\n**示例：**\n`fun main() = \"Hello world!\"`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MainFunctionReturnUnit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousCallableReferenceInLambda",
                "shortDescription": {
                  "text": "可疑的可调用引用用作 lambda 结果"
                },
                "fullDescription": {
                  "text": "报告具有一个可调用引用的 lambda 表达式。 将 lambda 替换为可调用引用而不将大括号更改为圆括号是常见错误。 示例： 'listOf(1,2,3).map { it::toString }' 在应用快速修复后： 'listOf(1,2,3).map(Int::toString)'",
                  "markdown": "报告具有一个可调用引用的 lambda 表达式。\n\n将 lambda 替换为可调用引用而不将大括号更改为圆括号是常见错误。\n\n**示例：**\n\n      listOf(1,2,3).map { it::toString }\n\n在应用快速修复后：\n\n      listOf(1,2,3).map(Int::toString)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SuspiciousCallableReferenceInLambda",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinDoubleNegation",
                "shortDescription": {
                  "text": "冗余双重求反"
                },
                "fullDescription": {
                  "text": "报告冗余双重否定。 示例： 'val truth = !!true'",
                  "markdown": "报告冗余双重否定。\n\n**示例：**\n\n      val truth = !!true\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DoubleNegation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionName",
                "shortDescription": {
                  "text": "函数命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循推荐命名约定的函数名称。 示例： 'fun Foo() {}' 要修正此问题，请更改函数名称以匹配推荐的命名约定。",
                  "markdown": "报告不遵循推荐命名约定的函数名称。\n\n**示例：**\n\n\n      fun Foo() {}\n\n要修正此问题，请更改函数名称以匹配推荐的命名约定。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FunctionName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertSecondaryConstructorToPrimary",
                "shortDescription": {
                  "text": "转换为主构造函数"
                },
                "fullDescription": {
                  "text": "报告可以替换为更简洁的主构造函数的辅助构造函数。 示例： 'class User {\n      val name: String\n\n      constructor(name: String) {\n          this.name = name\n      }\n  }' 该快速修复会自动转换代码： 'class User(val name: String) {\n  }'",
                  "markdown": "报告可以替换为更简洁的主构造函数的辅助构造函数。\n\n**示例：**\n\n\n      class User {\n          val name: String\n\n          constructor(name: String) {\n              this.name = name\n          }\n      }\n\n该快速修复会自动转换代码：\n\n\n      class User(val name: String) {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConvertSecondaryConstructorToPrimary",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DifferentKotlinMavenVersion",
                "shortDescription": {
                  "text": "Maven 和 IDE 插件版本不同"
                },
                "fullDescription": {
                  "text": "报告当前的 IDE 插件无法正确支持 Maven 插件版本。 这种不一致可能导致 IDE 和编译器出现不同的错误报告行为。",
                  "markdown": "报告当前的 IDE 插件无法正确支持 Maven 插件版本。\n\n这种不一致可能导致 IDE 和编译器出现不同的错误报告行为。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DifferentKotlinMavenVersion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceGetOrSet",
                "shortDescription": {
                  "text": "显式 'get' 或 'set' 调用"
                },
                "fullDescription": {
                  "text": "报告对可通过索引运算符 '[]' 替换的 'get' 或 'set' 函数的显式调用。 Kotlin 允许对类型的预定义运算符集进行自定义实现。 要重载运算符，您可以使用 'operator' 修饰符标记相应的函数： 'operator fun get(index: Int) {}\n  operator fun set(index: Int, value: Int) {}' 以上函数对应于索引运算符。 示例： 'class Test {\n      operator fun get(i: Int): Int = 0\n  }\n\n  fun test() {\n      Test().get(0) // 可替换的 'get()'\n  }' 在应用快速修复后： 'class Test {\n      operator fun get(i: Int): Int = 0\n  }\n\n  fun test() {\n      Test()[0]\n  }'",
                  "markdown": "报告对可通过索引运算符 `[]` 替换的 `get` 或 `set` 函数的显式调用。\n\n\nKotlin 允许对类型的预定义运算符集进行自定义实现。\n要重载运算符，您可以使用 `operator` 修饰符标记相应的函数：\n\n\n      operator fun get(index: Int) {}\n      operator fun set(index: Int, value: Int) {}\n        \n以上函数对应于索引运算符。\n\n**示例：**\n\n      class Test {\n          operator fun get(i: Int): Int = 0\n      }\n\n      fun test() {\n          Test().get(0) // 可替换的 'get()'\n      }\n\n在应用快速修复后：\n\n      class Test {\n          operator fun get(i: Int): Int = 0\n      }\n\n      fun test() {\n          Test()[0]\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceGetOrSet",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProhibitRepeatedUseSiteTargetAnnotationsMigration",
                "shortDescription": {
                  "text": "未被标记为 '@Repeatable' 的重复注解"
                },
                "fullDescription": {
                  "text": "报告在属性访问器上重复使用非 '@Repeatable' 注解的情况。 由于多次使用非 '@Repeatable' 注解，这两种注解的使用都会出现在字节码中，从而导致反射调用中的歧义。 从 Kotlin 1.4 开始，必须将注解标记为 '@Repeatable' 或不重复注解，否则会导致编译错误。 示例： 'annotation class Foo(val x: Int)\n\n  @get:Foo(10)\n  val a: String\n      @Foo(20) get() = \"foo\" // 注解重复两次，但未被标记为 @Repeatable' 仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。",
                  "markdown": "报告在属性访问器上重复使用非 `@Repeatable` 注解的情况。\n\n\n由于多次使用非 `@Repeatable` 注解，这两种注解的使用都会出现在字节码中，从而导致反射调用中的歧义。\n\n\n从 Kotlin 1.4 开始，必须将注解标记为 `@Repeatable` 或不重复注解，否则会导致编译错误。\n\n**示例：**\n\n\n      annotation class Foo(val x: Int)\n\n      @get:Foo(10)\n      val a: String\n          @Foo(20) get() = \"foo\" // 注解重复两次，但未被标记为 @Repeatable\n\n仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ProhibitRepeatedUseSiteTargetAnnotationsMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/迁移",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantUnitReturnType",
                "shortDescription": {
                  "text": "冗余 'Unit' 返回值类型"
                },
                "fullDescription": {
                  "text": "报告可以省略的冗余 'Unit' 返回类型。",
                  "markdown": "报告可以省略的冗余 `Unit` 返回类型。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantUnitReturnType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Destructure",
                "shortDescription": {
                  "text": "使用析构声明"
                },
                "fullDescription": {
                  "text": "报告可以析构的声明。 示例： 'data class My(val first: String, val second: Int, val third: Boolean)\n\n  fun foo(list: List<My>) {\n      list.forEach { my ->\n          println(my.second)\n          println(my.third)\n      }\n  }' 该快速修复会析构声明并引入具有来自相应类的名称的新变量： 'data class My(val first: String, val second: Int, val third: Boolean)\n\n  fun foo(list: List<My>) {\n      list.forEach { (_, second, third) ->\n          println(second)\n          println(third)\n      }\n  }'",
                  "markdown": "报告可以析构的声明。\n\n**示例：**\n\n\n      data class My(val first: String, val second: Int, val third: Boolean)\n\n      fun foo(list: List<My>) {\n          list.forEach { my ->\n              println(my.second)\n              println(my.third)\n          }\n      }\n\n该快速修复会析构声明并引入具有来自相应类的名称的新变量：\n\n\n      data class My(val first: String, val second: Int, val third: Boolean)\n\n      fun foo(list: List<My>) {\n          list.forEach { (_, second, third) ->\n              println(second)\n              println(third)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Destructure",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedReceiverParameter",
                "shortDescription": {
                  "text": "未使用的接收器形参"
                },
                "fullDescription": {
                  "text": "报告扩展函数和属性的未使用接收器形参。 移除冗余的接收器形参可用于自动修正代码。",
                  "markdown": "报告扩展函数和属性的未使用接收器形参。\n\n**移除冗余的接收器形参**可用于自动修正代码。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedReceiverParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertTryFinallyToUseCall",
                "shortDescription": {
                  "text": "将 try / finally 转换为 use() 调用"
                },
                "fullDescription": {
                  "text": "报告 'finally' 中带有 'resource.close()' 并可转换为 'resource.use()' 调用的 'try-finally' 块。 'use()' 更容易读取，且不易出错，因为无需显式 'close()' 调用。 示例： 'fun example() {\n      val reader = File(\"file.txt\").bufferedReader()\n      try {\n          reader.lineSequence().forEach(::print)\n      } finally {\n          reader.close()\n      }\n  }' 在应用快速修复后： 'fun example() {\n      File(\"file.txt\").bufferedReader().use { reader ->\n          reader.lineSequence().forEach(::print)\n      }\n  }'",
                  "markdown": "报告 `finally` 中带有 `resource.close()` 并可转换为 `resource.use()` 调用的 `try-finally` 块。\n\n`use()` 更容易读取，且不易出错，因为无需显式 `close()` 调用。\n\n**示例：**\n\n\n      fun example() {\n          val reader = File(\"file.txt\").bufferedReader()\n          try {\n              reader.lineSequence().forEach(::print)\n          } finally {\n              reader.close()\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun example() {\n          File(\"file.txt\").bufferedReader().use { reader ->\n              reader.lineSequence().forEach(::print)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertTryFinallyToUseCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinRedundantOverride",
                "shortDescription": {
                  "text": "冗余重写方法"
                },
                "fullDescription": {
                  "text": "报告冗余重写声明。 如果重写不修改继承的签名语义，则可以省略重写，例如，通过更改可见性。 示例： 'open class Foo {\n      open fun singleExpression() {\n      }\n  }\n\n  class Bar : Foo() {\n      override fun singleExpression() = super.singleExpression()\n  }' 在应用快速修复后： 'class Bar : Foo() {\n  }'",
                  "markdown": "报告冗余重写声明。\n\n\n如果重写不修改继承的签名语义，则可以省略重写，例如，通过更改可见性。\n\n**示例：**\n\n\n      open class Foo {\n          open fun singleExpression() {\n          }\n      }\n\n      class Bar : Foo() {\n          override fun singleExpression() = super.singleExpression()\n      }\n\n在应用快速修复后：\n\n\n      class Bar : Foo() {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantOverride",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RunBlocking",
                "shortDescription": {
                  "text": "协程中的 RunBlocking"
                },
                "fullDescription": {
                  "text": "报告可从协程到达的 runBlocking 构建器。 协程共享用于执行的线程。 当从协程调用 runBlocking 构建器时，它会阻塞底层线程，并阻止其他协程使用此资源。 这可能会导致性能问题，在糟糕的情况下还会导致线程饥饿。 它提供了从协程基元（挂起函数或构建器）到 runBlocking 构建器的潜在调用栈。 示例： 'suspend fun main() {\n      foo() \n   }\n\n  fun foo() {\n      runBlocking { suspendFunction() }\n  }' 潜在解决方案： 'suspend fun main() {\n      foo() \n   }\n\n  suspend fun foo() {\n      suspendFunction()\n  }' 使用浏览具有重写的函数选项可以配置虚拟函数的分析： 使用否选项可跳过对具有重写的函数的分析。 使用是，排除重写选项可以仅浏览定义的被调用者类型中的函数。 使用是，包括重写选项可以浏览函数和所有重写。",
                  "markdown": "报告可从协程到达的 runBlocking 构建器。\n\n协程共享用于执行的线程。 当从协程调用 runBlocking 构建器时，它会阻塞底层线程，并阻止其他协程使用此资源。 这可能会导致性能问题，在糟糕的情况下还会导致线程饥饿。\n\n它提供了从协程基元（挂起函数或构建器）到 runBlocking 构建器的潜在调用栈。\n\n示例：\n\n\n      suspend fun main() {\n          foo() \n       }\n\n      fun foo() {\n          runBlocking { suspendFunction() }\n      }\n\n潜在解决方案：\n\n\n      suspend fun main() {\n          foo() \n       }\n\n      suspend fun foo() {\n          suspendFunction()\n      }\n\n使用**浏览具有重写的函数**选项可以配置虚拟函数的分析：\n\n* 使用**否**选项可跳过对具有重写的函数的分析。\n* 使用**是，排除重写**选项可以仅浏览定义的被调用者类型中的函数。\n* 使用**是，包括重写**选项可以浏览函数和所有重写。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RunBlocking",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/协程检查",
                      "index": 131,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceArrayOfWithLiteral",
                "shortDescription": {
                  "text": "'arrayOf' 调用可被替换为数组文字 […]"
                },
                "fullDescription": {
                  "text": "报告可以替换为数组文字 '[...]' 的 'arrayOf' 调用。 示例： 'annotation class MyAnnotation(val strings: Array<String>)\n\n  @MyAnnotation(arrayOf(\"alpha\", \"beta\", \"omega\")) // 可替换的 'arrayOf()'\n  class MyClass' 在应用快速修复后： 'annotation class MyAnnotation(val strings: Array<String>)\n\n  @MyAnnotation([\"alpha\", \"beta\", \"omega\"])\n  class MyClass'",
                  "markdown": "报告可以替换为数组文字 `[...]` 的 `arrayOf` 调用。\n\n**示例：**\n\n      annotation class MyAnnotation(val strings: Array<String>)\n\n      @MyAnnotation(arrayOf(\"alpha\", \"beta\", \"omega\")) // 可替换的 'arrayOf()'\n      class MyClass\n\n在应用快速修复后：\n\n      annotation class MyAnnotation(val strings: Array<String>)\n\n      @MyAnnotation([\"alpha\", \"beta\", \"omega\"])\n      class MyClass\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceArrayOfWithLiteral",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceRangeToWithUntil",
                "shortDescription": {
                  "text": "'rangeTo' 或 '..' 调用应被替换为 'until'"
                },
                "fullDescription": {
                  "text": "报告对 'rangeTo' 或 '..' 运算符的调用，而非对 'until' 的调用。 使用相应函数可使代码更简单。 该快速修复会将 'rangeTo' 或 '..' 调用替换为 'until'。 示例： 'fun foo(a: Int) {\n      for (i in 0..a - 1) {\n\n      }\n  }' 在应用快速修复后： 'fun foo(a: Int) {\n      for (i in 0 until a) {\n\n      }\n  }'",
                  "markdown": "报告对 `rangeTo` 或 `..` 运算符的调用，而非对 `until` 的调用。\n\n使用相应函数可使代码更简单。\n\n该快速修复会将 `rangeTo` 或 `..` 调用替换为 `until`。\n\n**示例：**\n\n\n      fun foo(a: Int) {\n          for (i in 0..a - 1) {\n\n          }\n      }\n\n在应用快速修复后：\n\n\n      fun foo(a: Int) {\n          for (i in 0 until a) {\n\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceRangeToWithUntil",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceToWithInfixForm",
                "shortDescription": {
                  "text": "'to' 调用应被替换为中缀形式"
                },
                "fullDescription": {
                  "text": "报告可以替换为中缀形式的 'to' 函数调用。 使用中缀形式可使代码更简单。 该快速修复会将 'to' 替换为中缀形式。 示例： 'fun foo(a: Int, b: Int) {\n      val pair = a.to(b)\n  }' 在应用快速修复后： 'fun foo(a: Int, b: Int) {\n      val pair = a to b\n  }'",
                  "markdown": "报告可以替换为中缀形式的 `to` 函数调用。\n\n使用中缀形式可使代码更简单。\n\n该快速修复会将 `to` 替换为中缀形式。\n\n**示例：**\n\n\n      fun foo(a: Int, b: Int) {\n          val pair = a.to(b)\n      }\n\n在应用快速修复后：\n\n\n      fun foo(a: Int, b: Int) {\n          val pair = a to b\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceToWithInfixForm",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedEquals",
                "shortDescription": {
                  "text": "未使用的 equals 表达式"
                },
                "fullDescription": {
                  "text": "报告未使用的 'equals'('==') 表达式。",
                  "markdown": "报告未使用的 `equals`(`==`) 表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstPropertyName",
                "shortDescription": {
                  "text": "const 属性命名约定"
                },
                "fullDescription": {
                  "text": "报告不遵循推荐命名约定的 'const' 属性名称。 一致的命名会让阅读和理解代码变得更容易。 根据 Kotlin 官方样式指南，'const' 属性应使用大写下划线分隔的名称。 示例： 'const val Planck: Double = 6.62607015E-34' 该快速修复会重命名属性： 'const val PLANCK: Double = 6.62607015E-34'",
                  "markdown": "报告不遵循推荐命名约定的 `const` 属性名称。\n\n\n一致的命名会让阅读和理解代码变得更容易。\n根据 [Kotlin 官方样式指南](https://kotlinlang.org/docs/coding-conventions.html#property-names)，`const` 属性应使用大写下划线分隔的名称。\n\n**示例：**\n\n\n      const val Planck: Double = 6.62607015E-34\n\n该快速修复会重命名属性：\n\n\n      const val PLANCK: Double = 6.62607015E-34\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConstPropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名约定",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantNullableReturnType",
                "shortDescription": {
                  "text": "冗余可 null 返回值类型"
                },
                "fullDescription": {
                  "text": "报告具有可为 null 的返回类型的函数和变量，这些函数和变量永远不会返回或变为 'null'。 示例： 'fun greeting(user: String): String? = \"Hello, $user!\"' 在应用快速修复后： 'fun greeting(user: String): String = \"Hello, $user!\"'",
                  "markdown": "报告具有可为 null 的返回类型的函数和变量，这些函数和变量永远不会返回或变为 `null`。\n\n**示例：**\n\n\n      fun greeting(user: String): String? = \"Hello, $user!\"\n\n在应用快速修复后：\n\n\n      fun greeting(user: String): String = \"Hello, $user!\"\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantNullableReturnType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗余结构",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnclearPrecedenceOfBinaryExpression",
                "shortDescription": {
                  "text": "具有不同优先级的多个运算符"
                },
                "fullDescription": {
                  "text": "报告包含不同运算符且无圆括号的二进制表达式。 此类表达式可能由于不同的运算符优先级规则而可读性不佳。 示例：   fun foo(b: Boolean?, i: Int?) {\n      val x = b ?: i == null // 评估为 `(b ?: i) == null`\n      val y = i ?: 0 + 1 // 评估为 `i ?: (0 + 1)`\n  }",
                  "markdown": "报告包含不同运算符且无圆括号的二进制表达式。\n\n此类表达式可能由于不同的运算符[优先级规则](https://kotlinlang.org/docs/reference/grammar.html#expressions)而可读性不佳。\n\n示例：\n\n```\n  fun foo(b: Boolean?, i: Int?) {\n      val x = b ?: i == null // 评估为 `(b ?: i) == null`\n      val y = i ?: 0 + 1 // 评估为 `i ?: (0 + 1)`\n  }\n```"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnclearPrecedenceOfBinaryExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/样式问题",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UselessCallOnNotNull",
                "shortDescription": {
                  "text": "对非 null 类型的无用调用"
                },
                "fullDescription": {
                  "text": "报告非 null 接收器上仅对可 null 接收器有意义的调用。 只有在可 null 类型的接收器上调用时，标准库中 'orEmpty()' 或 'isNullOrEmpty' 之类的几个函数才有意义。 在其他情况下，可以忽略它们，因为结果将相同。 移除冗余调用和将调用更改为 … 快速修复可用于自动修正代码。 示例： 'fun test(s: String) {\n      val x = s.orEmpty() // 快速修复会简化为 's'\n      val y = s.isNullOrEmpty() // 快速修复会简化为 's.isEmpty()'\n  }'",
                  "markdown": "报告非 null 接收器上仅对可 null 接收器有意义的调用。\n\n只有在可 null 类型的接收器上调用时，标准库中 `orEmpty()` 或 `isNullOrEmpty` 之类的几个函数才有意义。 在其他情况下，可以忽略它们，因为结果将相同。\n\n**移除冗余调用** 和**将调用更改为 ...** 快速修复可用于自动修正代码。\n\n示例：\n\n\n      fun test(s: String) {\n          val x = s.orEmpty() // 快速修复会简化为 's'\n          val y = s.isNullOrEmpty() // 快速修复会简化为 's.isEmpty()'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UselessCallOnNotNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedLambdaExpressionBody",
                "shortDescription": {
                  "text": "包含 lambda 表达式主体的函数未使用的返回值"
                },
                "fullDescription": {
                  "text": "报告调用的函数从表达式主体返回 lambda 时返回值并未使用的调用。 如果函数头和主体块之间存在 '='，则不会评估函数中的代码，这可能导致不正确的行为。 从函数声明中移除 = 令牌可用于自动修正代码。 示例： 'fun printHello() = { println(\"Hello\") }\n\n  fun main() {\n      printHello() // 此函数不打印任何内容\n  }' 在应用快速修复后： 'fun printHello() { println(\"Hello\") }\n\n  fun main() {\n      printHello()\n  }'",
                  "markdown": "报告调用的函数从表达式主体返回 lambda 时返回值并未使用的调用。\n\n\n如果函数头和主体块之间存在 `=`，则不会评估函数中的代码，这可能导致不正确的行为。\n\n**从函数声明中移除 = 令牌**可用于自动修正代码。\n\n示例：\n\n\n      fun printHello() = { println(\"Hello\") }\n\n      fun main() {\n          printHello() // 此函数不打印任何内容\n      }\n\n在应用快速修复后：\n\n\n      fun printHello() { println(\"Hello\") }\n\n      fun main() {\n          printHello()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedLambdaExpressionBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsOrHashCode",
                "shortDescription": {
                  "text": "'equals()' 和 'hashCode()' 未配对"
                },
                "fullDescription": {
                  "text": "报告重写 'equals()' 但不重写 'hashCode()'（或者相反操作）的类。 同时还报告重写 'equals()' 或 'hashCode()' 的对象声明。 这可能会导致在将类添加到 'Collection' 时产生不良行为 示例： 'class C1 {\n      override fun equals(other: Any?) = true\n  }\n\n  class C2 {\n      override fun hashCode() = 0\n  }\n\n  object O1 {\n      override fun equals(other: Any?) = true\n  }\n\n  object O2 {\n      override fun hashCode() = 0\n  }' 该快速修复会为类重写 'equals()' 或 'hashCode()' 方法并为对象删除这些方法： 'class C1 {\n       override fun equals(other: Any?) = true\n       override fun hashCode(): Int {\n           return javaClass.hashCode()\n       }\n   }\n\n   class C2 {\n       override fun hashCode() = 0\n       override fun equals(other: Any?): Boolean {\n           if (this === other) return true\n           if (javaClass != other?.javaClass) return false\n           return true\n       }\n   }\n\n   object O1 {\n   }\n\n   object O2 {\n   }'",
                  "markdown": "报告重写 `equals()` 但不重写 `hashCode()`（或者相反操作）的类。 同时还报告重写 `equals()` 或 `hashCode()` 的对象声明。\n\n这可能会导致在将类添加到 `Collection` 时产生不良行为\n\n**示例：**\n\n\n      class C1 {\n          override fun equals(other: Any?) = true\n      }\n\n      class C2 {\n          override fun hashCode() = 0\n      }\n\n      object O1 {\n          override fun equals(other: Any?) = true\n      }\n\n      object O2 {\n          override fun hashCode() = 0\n      }\n\n该快速修复会为类重写 `equals()` 或 `hashCode()` 方法并为对象删除这些方法：\n\n\n       class C1 {\n           override fun equals(other: Any?) = true\n           override fun hashCode(): Int {\n               return javaClass.hashCode()\n           }\n       }\n\n       class C2 {\n           override fun hashCode() = 0\n           override fun equals(other: Any?): Boolean {\n               if (this === other) return true\n               if (javaClass != other?.javaClass) return false\n               return true\n           }\n       }\n\n       object O1 {\n       }\n\n       object O2 {\n       }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsOrHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/可能的 bug",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.jetbrains.sh",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "ShellCheck",
                "shortDescription": {
                  "text": "ShellCheck"
                },
                "fullDescription": {
                  "text": "报告由集成的 ShellCheck 静态分析工具检测到的 shell 脚本错误。",
                  "markdown": "报告由集成的 [ShellCheck](https://github.com/koalaman/shellcheck) 静态分析工具检测到的 shell 脚本错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ShellCheck",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Shell 脚本",
                      "index": 17,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.intellij.groovy",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "GroovyListSetCanBeKeyedAccess",
                "shortDescription": {
                  "text": "对 List.set 的调用可以是键控访问"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.List.set()' 方法的调用。 此类调用可由更简短明确的键控访问形式替代。 示例： 'def list = [\"foo\"]\nlist.set(0, \"bar\") // list.set(0, \"bar\") 可以替换为 list[0] = \"bar\"'\n 在应用快速修复后： 'def list = [\"foo\"]\nlist[0] = \"bar\"'",
                  "markdown": "报告对 `java.util.List.set()` 方法的调用。 此类调用可由更简短明确的键控访问形式替代。\n\n**示例：**\n\n\n    def list = [\"foo\"]\n    list.set(0, \"bar\") // list.set(0, \"bar\") 可以替换为 list[0] = \"bar\"\n\n在应用快速修复后：\n\n\n    def list = [\"foo\"]\n    list[0] = \"bar\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyListSetCanBeKeyedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/GPath",
                      "index": 22,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConstantNamingConvention",
                "shortDescription": {
                  "text": "常量命名约定"
                },
                "fullDescription": {
                  "text": "报告名称与指定约定不相符的常量。 常量是使用 'static' 和 'final' 修饰符声明的不可变类型的字段。 报告名称太短、太长或不遵循指定正则表达式模式的常量。 配置检查： 使用模式字段可指定常量名称预期与其相符的 'java.util.regex.Pattern'。 使用最小长度字段可指定常量名称的最小长度。 使用最大长度字段可指定常量名称的最大长度。",
                  "markdown": "报告名称与指定约定不相符的常量。\n\n常量是使用 `static` 和 `final` 修饰符声明的不可变类型的字段。\n报告名称太短、太长或不遵循指定正则表达式模式的常量。\n\n配置检查：\n\n* 使用**模式** 字段可指定常量名称预期与其相符的 `java.util.regex.Pattern`。\n* 使用**最小长度**字段可指定常量名称的最小长度。\n* 使用**最大长度**字段可指定常量名称的最大长度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConstantNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名约定",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyThreadStopSuspendResume",
                "shortDescription": {
                  "text": "Thread.stop()、Thread.suspend() 或 Thread.resume() 调用"
                },
                "fullDescription": {
                  "text": "报告对 'Thread.stop()'、'Thread.suspend()' 或 'Thread.resume()' 的调用。 这些调用在本质上容易导致数据损坏和死锁，因此强烈建议不使用。",
                  "markdown": "报告对 `Thread.stop()`、`Thread.suspend()` 或 `Thread.resume()` 的调用。\n\n\n这些调用在本质上容易导致数据损坏和死锁，因此强烈建议不使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyThreadStopSuspendResume",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyContinueOrBreakFromFinallyBlock",
                "shortDescription": {
                  "text": "'finally' 块中的 'continue' 或 'break'"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'break' 和 'continue' 语句。 虽然偶尔是有意为之，但此类语句非常令人困惑，可能会掩盖抛出的异常，并导致调试变得极其复杂。",
                  "markdown": "报告 `finally` 块中的 `break` 和 `continue` 语句。\n\n虽然偶尔是有意为之，但此类语句非常令人困惑，可能会掩盖抛出的异常，并导致调试变得极其复杂。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyContinueOrBreakFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/错误处理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInArgumentCheck",
                "shortDescription": {
                  "text": "不兼容的 'in' 实参类型"
                },
                "fullDescription": {
                  "text": "报告具有不兼容类型的条目和容器的成员运算符 'in' 的用法。 示例： 'def list = [1, 2]\nif (\"foo\" in list) {} // 整数列表不能包含字符串'",
                  "markdown": "报告具有不兼容类型的条目和容器的成员运算符 `in` 的用法。\n\n**示例：**\n\n\n    def list = [1, 2]\n    if (\"foo\" in list) {} // 整数列表不能包含字符串\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInArgumentCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMapPutCanBeKeyedAccess",
                "shortDescription": {
                  "text": "对 Map.put 的调用可以是键控访问"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Map.put()' 方法的调用。 此类调用可由更简短明确的键控访问形式替代。 示例： 'def map = [\"foo\": \"bar\"]\nmap.put(\"foo\", \"baz\") // map.put(\"foo\", \"baz\") 可以替换为 map[\"foo\"] = \"baz\"'\n 在应用快速修复后： 'def map = [\"foo\": \"bar\"]\nmap[\"foo\"] = \"baz\"'",
                  "markdown": "报告对 `java.util.Map.put()` 方法的调用。 此类调用可由更简短明确的键控访问形式替代。\n\n**示例：**\n\n\n    def map = [\"foo\": \"bar\"]\n    map.put(\"foo\", \"baz\") // map.put(\"foo\", \"baz\") 可以替换为 map[\"foo\"] = \"baz\"\n\n在应用快速修复后：\n\n\n    def map = [\"foo\": \"bar\"]\n    map[\"foo\"] = \"baz\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMapPutCanBeKeyedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/GPath",
                      "index": 22,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAssignmentToMethodParameter",
                "shortDescription": {
                  "text": "赋值给方法形参"
                },
                "fullDescription": {
                  "text": "报告方法形参的赋值。 虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由拼写错误所致。 示例： 'def m(a, b, c) {\n      a = [] // 警告\n  }'",
                  "markdown": "报告方法形参的赋值。\n\n虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由拼写错误所致。\n\n**示例：**\n\n\n      def m(a, b, c) {\n          a = [] // 警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAssignmentToMethodParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyStaticMethodNamingConvention",
                "shortDescription": {
                  "text": "static 方法命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的 static 方法。 使用下面提供的字段可指定 static 方法名称的预期最小长度、最大长度和正则表达式。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的 static 方法。\n\n\n使用下面提供的字段可指定 static 方法名称的预期最小长度、最大长度和正则表达式。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyStaticMethodNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名约定",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyTrivialIf",
                "shortDescription": {
                  "text": "冗余的 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告可以简化为单个赋值或 'return' 语句的 'if' 语句。 示例： 'if (foo())\n    return true;\n  else\n    return false;' 在应用快速修复后： 'return foo();'",
                  "markdown": "报告可以简化为单个赋值或 `return` 语句的 `if` 语句。\n\n**示例：**\n\n\n      if (foo())\n        return true;\n      else\n        return false;\n\n在应用快速修复后：\n\n\n      return foo();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyTrivialIf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyPointlessArithmetic",
                "shortDescription": {
                  "text": "无意义的算术表达式"
                },
                "fullDescription": {
                  "text": "报告无意义的算术表达式。 此类表达式包括加 0 或减 0、乘以 0 或 1、除以 1 以及 0 移位。 此类表达式可能是未完全完成的自动重构所致，在任何情况下都不太可能是开发人员有意为之。 示例： 'a + 0' 在应用快速修复后： 'a'",
                  "markdown": "报告无意义的算术表达式。\n\n\n此类表达式包括加 0 或减 0、乘以 0 或 1、除以 1 以及 0 移位。 此类表达式可能是未完全完成的自动重构所致，在任何情况下都不太可能是开发人员有意为之。\n\n**示例：**\n\n\n      a + 0\n\n在应用快速修复后：\n\n\n      a\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyPointlessArithmetic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAccessibility",
                "shortDescription": {
                  "text": "不可访问的元素"
                },
                "fullDescription": {
                  "text": "报告超出访问权限的引用。 对 private 成员的访问会破坏封装。",
                  "markdown": "报告超出访问权限的引用。\n\n对 private 成员的访问会破坏封装。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAccessibility",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDoubleCheckedLocking",
                "shortDescription": {
                  "text": "双重检查锁定"
                },
                "fullDescription": {
                  "text": "报告双重检查锁定。 双重检查锁定会尝试以线程安全的方式按需初始化字段，同时避免同步的开销。 遗憾的是，在未被声明为 'volatile' 的字段上使用时，它不具备线程安全。 在使用 Java 1.4 或更早的版本时，双重检查锁定即便对 'volatile' 字段也不起作用。 阅读上面的链接文章，了解该问题的详细说明。 示例： 'class Foo {\n      private Helper helper = null\n\n      Helper getHelper() {\n          if (helper == null)\n              synchronized(this) {\n                  if (helper == null) {\n                      helper = new Helper()\n                  }\n              }\n          }\n          return helper;\n      }\n  }'",
                  "markdown": "报告[双重检查锁定](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)。\n\n\n双重检查锁定会尝试以线程安全的方式按需初始化字段，同时避免同步的开销。\n遗憾的是，在未被声明为 `volatile` 的字段上使用时，它不具备线程安全。\n在使用 Java 1.4 或更早的版本时，双重检查锁定即便对 `volatile` 字段也不起作用。\n阅读上面的链接文章，了解该问题的详细说明。\n\n**示例：**\n\n\n      class Foo {\n          private Helper helper = null\n\n          Helper getHelper() {\n              if (helper == null)\n                  synchronized(this) {\n                      if (helper == null) {\n                          helper = new Helper()\n                      }\n                  }\n              }\n              return helper;\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyDoubleCheckedLocking",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyFallthrough",
                "shortDescription": {
                  "text": "'switch' 语句中的直落"
                },
                "fullDescription": {
                  "text": "报告 switch 语句中的 fallthrough。 虽然偶尔有用，但直落通常是无意为之，并且可能导致意外的错误。 示例： 'switch(n) {\n  case 1:\n    print 1\n  case 2: // \"case 1\" 直落到 \"case 2\"。 从 \"case 2\" 开始的语句将在执行 \"case 1\" 后立即执行。\n    print 2\n    break\n  default:\n    print \"Default\"\n}'",
                  "markdown": "报告 switch 语句中的 *fallthrough* 。 虽然偶尔有用，但直落通常是无意为之，并且可能导致意外的错误。\n\n**示例：**\n\n\n    switch(n) {\n      case 1:\n        print 1\n      case 2: // \"case 1\" 直落到 \"case 2\"。 从 \"case 2\" 开始的语句将在执行 \"case 1\" 后立即执行。\n        print 2\n        break\n      default:\n        print \"Default\"\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyFallthrough",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyLocalVariableNamingConvention",
                "shortDescription": {
                  "text": "局部变量命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的局部变量。 使用下面提供的字段可指定局部变量名称的预期最小长度、最大长度和正则表达式。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的局部变量。\n\n\n使用下面提供的字段可指定局部变量名称的预期最小长度、最大长度和正则表达式。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyLocalVariableNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名约定",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyIfStatementWithIdenticalBranches",
                "shortDescription": {
                  "text": "具有相同分支的 if 语句"
                },
                "fullDescription": {
                  "text": "报告具有相同的 \"then\" 和 'else' 分支的 'if' 语句。 此类语句几乎肯定表明程序员出现错误。 示例： 'if (condition) {\n  print \"foo\"\n} else {\n  print \"foo\"\n}'\n 在应用快速修复后： 'print \"foo\"'",
                  "markdown": "报告具有相同的 \"then\" 和 `else` 分支的 `if` 语句。 此类语句几乎肯定表明程序员出现错误。\n\n**示例：**\n\n\n    if (condition) {\n      print \"foo\"\n    } else {\n      print \"foo\"\n    }\n\n在应用快速修复后：\n\n\n    print \"foo\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyIfStatementWithIdenticalBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUncheckedAssignmentOfMemberOfRawType",
                "shortDescription": {
                  "text": "原始类型成员中的未检查的赋值"
                },
                "fullDescription": {
                  "text": "报告原始类型成员中的未检查的赋值。 示例： 'List list = new ArrayList()\n  List&ltString> a = list.get(0)'",
                  "markdown": "报告原始类型成员中的未检查的赋值。\n\n**示例：**\n\n\n      List list = new ArrayList()\n      List&ltString> a = list.get(0)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUncheckedAssignmentOfMemberOfRawType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNonShortCircuitBoolean",
                "shortDescription": {
                  "text": "非短路布尔"
                },
                "fullDescription": {
                  "text": "报告布尔运算符 'and' 和 'or' 的非短路形式（'&' 和 '|'）。 非短路版本偶尔有用，但是，它们通常是由非短路形式（'&&' 和 '||'）拼写错误导致的，并且可能产生难以捉摸的错误。 示例： 'if (a & b) {}' 在应用快速修复后： 'if (a && b) {}'",
                  "markdown": "报告布尔运算符 'and' 和 'or' 的非短路形式（`&` 和 `|`）。\n\n\n非短路版本偶尔有用，但是，它们通常是由非短路形式（`&&`\n和 `||`）拼写错误导致的，并且可能产生难以捉摸的错误。\n\n**示例：**\n\n\n    if (a & b) {}\n\n在应用快速修复后：\n\n\n    if (a && b) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNonShortCircuitBoolean",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrMethodMayBeStatic",
                "shortDescription": {
                  "text": "方法可以为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以安全设置为 'static' 的方法。 如果方法未 'synchronized'，未引用它的类的任何实例方法和实例字段，并且未在子类中被重写，则可能是 'static' 方法。",
                  "markdown": "报告可以安全设置为 `static` 的方法。\n\n\n如果方法未 `synchronized`，未引用它的类的任何实例方法和实例字段，并且未在子类中被重写，则可能是 `static` 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrMethodMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/其他",
                      "index": 78,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDivideByZero",
                "shortDescription": {
                  "text": "除以零"
                },
                "fullDescription": {
                  "text": "报告除以 0 或对 0 取余。 示例： 'def a = 42\n  a / 0 // 警告\n  a % 0.0 // 警告'",
                  "markdown": "报告除以 0 或对 0 取余。\n\n**示例：**\n\n\n      def a = 42\n      a / 0 // 警告\n      a % 0.0 // 警告\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyDivideByZero",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaStylePropertiesInvocation",
                "shortDescription": {
                  "text": "Java 风格的属性访问"
                },
                "fullDescription": {
                  "text": "报告通过方法调用访问的属性。 示例： 'class Foo {\n      int foo\n  }\n\n  def bar = new Foo()\n  print(bar.getFoo())' 在应用快速修复后： 'class Foo {\n      int foo\n  }\n\n  def bar = new Foo()\n  print(bar.foo)'",
                  "markdown": "报告通过方法调用访问的属性。\n\n**示例：**\n\n\n      class Foo {\n          int foo\n      }\n\n      def bar = new Foo()\n      print(bar.getFoo())\n\n在应用快速修复后：\n\n\n      class Foo {\n          int foo\n      }\n\n      def bar = new Foo()\n      print(bar.foo)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JavaStylePropertiesInvocation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyTrivialConditional",
                "shortDescription": {
                  "text": "冗余条件表达式"
                },
                "fullDescription": {
                  "text": "报告 'x ? true : false' 或类似形式并且可以大大简化的三元条件运算符。 示例： 'foo() ? true : false' 在应用快速修复后： 'foo()'",
                  "markdown": "报告 `x ? true : false` 或类似形式并且可以大大简化的三元条件运算符。\n\n**示例：**\n\n\n      foo() ? true : false\n\n在应用快速修复后：\n\n\n    foo()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyTrivialConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessarySemicolon",
                "shortDescription": {
                  "text": "不必要的分号"
                },
                "fullDescription": {
                  "text": "报告不必要的分号。 示例： 'print 2; print 3 // 分号是必要的\n  print 2; // 分号不必要'",
                  "markdown": "报告不必要的分号。\n\n**示例：**\n\n\n      print 2; print 3 // 分号是必要的\n      print 2; // 分号不必要\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessarySemicolon",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrFinalVariableAccess",
                "shortDescription": {
                  "text": "final 变量访问"
                },
                "fullDescription": {
                  "text": "报告未初始化的 final 字段，以及 final 变量、形参和字段的无效赋值。",
                  "markdown": "报告未初始化的 final 字段，以及 final 变量、形参和字段的无效赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrFinalVariableAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryQualifiedReference",
                "shortDescription": {
                  "text": "不必要的限定参考"
                },
                "fullDescription": {
                  "text": "报告可以替换为 import 的完全限定引用。 示例： 'def swingBuilder = new groovy.swing.SwingBuilder()' 在应用快速修复后： 'import groovy.swing.SwingBuilder\n \n  def swingBuilder = new SwingBuilder()'",
                  "markdown": "报告可以替换为 import 的完全限定引用。\n\n**示例：**\n\n\n      def swingBuilder = new groovy.swing.SwingBuilder()\n\n在应用快速修复后：\n\n\n      import groovy.swing.SwingBuilder\n     \n      def swingBuilder = new SwingBuilder()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryQualifiedReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChangeToMethod",
                "shortDescription": {
                  "text": "运算符调用可被替换为方法调用"
                },
                "fullDescription": {
                  "text": "报告可替换为方法调用的运算符调用。 示例： 'a + b' 在应用快速修复后： 'a.plus(b)'",
                  "markdown": "报告可替换为方法调用的运算符调用。\n\n**示例：**\n\n\n      a + b\n\n在应用快速修复后：\n\n\n      a.plus(b)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ChangeToMethod",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyBreak",
                "shortDescription": {
                  "text": "'break' 语句"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句外的 'break' 语句。",
                  "markdown": "报告 `switch` 语句外的 `break` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyBreak",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DelegatesTo",
                "shortDescription": {
                  "text": "@DelegatesTo"
                },
                "fullDescription": {
                  "text": "报告未使用的 '@DelegatesTo.Target' 注解和未解析的 '@DelegatedTo.target' 注解特性值。 示例： '// 未使用的目标 't1' 和未解析的目标 't2'\n  def m(\n      @DelegatesTo.Target('t1') target,\n      @DelegatesTo(target = 't2') Closure c\n  ) {}'",
                  "markdown": "报告未使用的 `@DelegatesTo.Target` 注解和未解析的 `@DelegatedTo.target` 注解特性值。\n\n**示例：**\n\n\n      // 未使用的目标 't1' 和未解析的目标 't2'\n      def m(\n          @DelegatesTo.Target('t1') target,\n          @DelegatesTo(target = 't2') Closure c\n      ) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DelegatesTo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注解",
                      "index": 89,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConstantConditional",
                "shortDescription": {
                  "text": "常量条件表达式"
                },
                "fullDescription": {
                  "text": "报告将布尔常量作为条件的条件表达式。 示例： 'true ? result1 : result2\n  false ? result1 : result2'",
                  "markdown": "报告将布尔常量作为条件的条件表达式。\n\n**示例：**\n\n\n      true ? result1 : result2\n      false ? result1 : result2\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConstantConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyComplexArithmeticExpression",
                "shortDescription": {
                  "text": "过于复杂的算术表达式"
                },
                "fullDescription": {
                  "text": "报告包含太多项的算术表达式。 此类表达方式可能令人困惑，并且容易出错。 使用最大项数字段可指定算数表达式中允许的最大项数。",
                  "markdown": "报告包含太多项的算术表达式。\n\n\n此类表达方式可能令人困惑，并且容易出错。\n\n\n使用**最大项数**字段可指定算数表达式中允许的最大项数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyComplexArithmeticExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrSwitchExhaustivenessCheck",
                "shortDescription": {
                  "text": "switch 表达式的详尽性检查"
                },
                "fullDescription": {
                  "text": "报告未覆盖匹配表达式的所有可能结果的 switch 表达式。 Groovy 不要求 switch 表达式必须详尽。 它的作用就像插入了隐式 'default -> null' 分支。 如果开发者忘记插入必要的 'case' 分支，可能会导致意外的 null。 示例： 'enum A { X, Y }\n\n  def foo(A a) {\n    def x = switch (a) { // reports switch\n      case A.X -> ...\n    }\n  }'",
                  "markdown": "报告未覆盖匹配表达式的所有可能结果的 switch 表达式。\n\nGroovy 不要求 switch 表达式必须详尽。 它的作用就像插入了隐式 `default -> null` 分支。\n如果开发者忘记插入必要的 `case` 分支，可能会导致意外的 null。\n\n**示例：**\n\n\n      enum A { X, Y }\n\n      def foo(A a) {\n        def x = switch (a) { // reports switch\n          case A.X -> ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrSwitchExhaustivenessCheck",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyThrowFromFinallyBlock",
                "shortDescription": {
                  "text": "'throw' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'throw' 语句。 虽然偶尔是有意为之，但此类 'throw' 语句可能会掩盖抛出的异常，并导致调试变得极其复杂。",
                  "markdown": "报告 `finally` 块中的 `throw` 语句。\n\n\n虽然偶尔是有意为之，但此类 `throw` 语句可能会掩盖抛出的异常，并导致调试变得极其复杂。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyThrowFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/错误处理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAssignabilityCheck",
                "shortDescription": {
                  "text": "不兼容的类型赋值"
                },
                "fullDescription": {
                  "text": "报告具有不兼容类型的赋值。 此类赋值可能导致各种运行时异常。 示例： 'class A {}\n  class B {}\n\n  // 不兼容的赋值\n  A a = new B()'",
                  "markdown": "报告具有不兼容类型的赋值。\n\n此类赋值可能导致各种运行时异常。\n\n**示例：**\n\n\n      class A {}\n      class B {}\n\n      // 不兼容的赋值\n      A a = new B()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAssignabilityCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChangeToOperator",
                "shortDescription": {
                  "text": "方法调用可被替换为运算符调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为运算符调用的方法调用。 示例： 'a.plus(b)' 在应用快速修复后： 'a + b'",
                  "markdown": "报告可以替换为运算符调用的方法调用。\n\n**示例：**\n\n\n      a.plus(b)\n\n在应用快速修复后：\n\n\n      a + b\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ChangeToOperator",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMapGetCanBeKeyedAccess",
                "shortDescription": {
                  "text": "对 Map.get 的调用可以是键控访问"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Map.get()' 方法的调用。 此类调用可由更简短明确的键控访问形式替代。 示例： 'def map = [\"foo\": \"bar\"]\ndef str = map.get(\"foo\") // map.get(\"foo\") 可以替换为 map[\"foo\"]'\n 在应用快速修复后： 'def map = [\"foo\": \"bar\"]\ndef str = map[\"foo\"]'",
                  "markdown": "报告对 `java.util.Map.get()` 方法的调用。 此类调用可由更简短明确的键控访问形式替代。\n\n**示例：**\n\n\n    def map = [\"foo\": \"bar\"]\n    def str = map.get(\"foo\") // map.get(\"foo\") 可以替换为 map[\"foo\"]\n\n在应用快速修复后：\n\n\n    def map = [\"foo\": \"bar\"]\n    def str = map[\"foo\"]\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMapGetCanBeKeyedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/GPath",
                      "index": 22,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUntypedAccess",
                "shortDescription": {
                  "text": "无类型引用表达式"
                },
                "fullDescription": {
                  "text": "报告无法确定类型的引用表达式。",
                  "markdown": "报告无法确定类型的引用表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUntypedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyResultOfAssignmentUsed",
                "shortDescription": {
                  "text": "使用的赋值的结果"
                },
                "fullDescription": {
                  "text": "报告嵌套在其他表达式中以立即使用所赋值的赋值表达式。 此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。",
                  "markdown": "报告嵌套在其他表达式中以立即使用所赋值的赋值表达式。\n\n\n此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyResultOfAssignmentUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyResultOfObjectAllocationIgnored",
                "shortDescription": {
                  "text": "被忽略的对象分配结果"
                },
                "fullDescription": {
                  "text": "报告忽略运算结果的对象分配。 此类分配表达式虽然在 Groovy 中合法，但通常要么是无意为之，要么表明存在复杂的对象初始化策略。",
                  "markdown": "报告忽略运算结果的对象分配。\n\n\n此类分配表达式虽然在 Groovy 中合法，但通常要么是无意为之，要么表明存在复杂的对象初始化策略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyResultOfObjectAllocationIgnored",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNestedAssignment",
                "shortDescription": {
                  "text": "嵌套赋值"
                },
                "fullDescription": {
                  "text": "报告嵌套在其他表达式中的赋值表达式。 虽然极其简洁，但此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。 示例： 'a = b = 1'",
                  "markdown": "报告嵌套在其他表达式中的赋值表达式。 虽然极其简洁，但此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。\n\n**示例：**\n\n\n    a = b = 1\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNestedAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDocCheck",
                "shortDescription": {
                  "text": "未解析的 GroovyDoc 引用"
                },
                "fullDescription": {
                  "text": "报告 GroovyDoc 注释的中未解析引用。",
                  "markdown": "报告 GroovyDoc 注释的中未解析引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "GroovyDocCheck",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnusedCatchParameter",
                "shortDescription": {
                  "text": "未使用的 'catch' 形参"
                },
                "fullDescription": {
                  "text": "报告未在相应的块中使用的 catch 形参。 此检查不会报告任何命名为 \"ignore\"或 \"ignored\" 的 catch 形参。 示例： 'try {\n      def arr = new int[3]\n      arr[5] = 5\n  } catch(Exception ex) {\n      println('Catching the exception')\n  }' 此处的形参 ex 永远不会在 catch 块中使用。 在应用快速修复后： 'try {\n      def arr = new int[3]\n      arr[5] = 5\n  } catch(Exception ignored) {\n      println('Catching the exception')\n  }'",
                  "markdown": "报告未在相应的块中使用的 **catch** 形参。 此检查不会报告任何命名为 \"ignore\"或 \"ignored\" 的 **catch** 形参。\n\n**示例：**\n\n\n      try {\n          def arr = new int[3]\n          arr[5] = 5\n      } catch(Exception ex) {\n          println('Catching the exception')\n      }\n\n此处的形参 **ex** 永远不会在 **catch** 块中使用。\n\n在应用快速修复后：\n\n\n      try {\n          def arr = new int[3]\n          arr[5] = 5\n      } catch(Exception ignored) {\n          println('Catching the exception')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnusedCatchParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/错误处理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInstanceMethodNamingConvention",
                "shortDescription": {
                  "text": "实例方法命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的实例方法。 此检查将忽略重写库方法的实例方法。 使用下面提供的字段可指定实例方法名称的预期最小长度、最大长度和正则表达式。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的实例方法。 此检查将忽略重写库方法的实例方法。\n\n\n使用下面提供的字段可指定实例方法名称的预期最小长度、最大长度和正则表达式。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInstanceMethodNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名约定",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySynchronizedMethod",
                "shortDescription": {
                  "text": "synchronized 方法"
                },
                "fullDescription": {
                  "text": "报告方法上的 'synchronized' 修饰符。 某些编码标准禁止使用 'synchronized' 修饰符，而是支持 'synchronized' 语句。",
                  "markdown": "报告方法上的 `synchronized` 修饰符。\n\n\n某些编码标准禁止使用 `synchronized` 修饰符，而是支持 `synchronized` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnconditionalWait",
                "shortDescription": {
                  "text": "无条件的 'wait' 调用"
                },
                "fullDescription": {
                  "text": "报告在同步上下文中无条件调用的 wait()。 通常，wait() 用于在某个条件为 true 前阻塞线程。 如果是无条件调用 wait()，则通常表示已在获取锁定之前检查条件。 在这种情况下，如果条件在检查的时间与获得锁定的时间之间变为 true，则可能会发生数据竞争。 虽然此检查发现的结构未必不正确，但肯定值得检查。",
                  "markdown": "报告在同步上下文中无条件调用的 **wait()** 。\n通常，**wait()** 用于在某个条件为 true 前阻塞线程。 如果是无条件调用 **wait()**，则通常表示已在获取锁定之前检查条件。 在这种情况下，如果条件在检查的时间与获得锁定的时间之间变为 true，则可能会发生数据竞争。 虽然此检查发现的结构未必不正确，但肯定值得检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnconditionalWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyContinue",
                "shortDescription": {
                  "text": "'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告 'continue' 语句。",
                  "markdown": "报告 `continue` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyContinue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnsynchronizedMethodOverridesSynchronizedMethod",
                "shortDescription": {
                  "text": "未同步方法重写 synchronized 方法"
                },
                "fullDescription": {
                  "text": "报告重写 synchronized 方法的非 synchronized 方法。 示例： 'abstract class Base {\n      synchronized void foo() {\n          // ...\n      }\n  }\n  class Derived extends Base {\n      @Override\n      void foo() {\n          super.foo()\n            // ...\n        }\n    }' 在这里，类 'Bar' 中的非 synchronized 方法 'foo()' 会重写 synchronized 方法。",
                  "markdown": "报告重写 **synchronized** 方法的非 **synchronized** 方法。\n\n**示例：**\n\n\n      abstract class Base {\n          synchronized void foo() {\n              // ...\n          }\n      }\n      class Derived extends Base {\n          @Override\n          void foo() {\n              super.foo()\n                // ...\n            }\n        }\n\n在这里，类 `Bar` 中的非 synchronized 方法 `foo()` 会重写 synchronized 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnsynchronizedMethodOverridesSynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNegatedIf",
                "shortDescription": {
                  "text": "否定 if 条件表达式"
                },
                "fullDescription": {
                  "text": "报告包含 'else' 分支且条件被否定的 'if' 语句。 翻转 'if' 和 'else' 分支的顺序通常会改进此类语句的清晰度。 示例： 'if (!condition) {\n  return \"1\"\n} else {\n  return \"2\"\n}'",
                  "markdown": "报告包含 `else` 分支且条件被否定的 `if` 语句。 翻转 `if` 和 `else` 分支的顺序通常会改进此类语句的清晰度。\n\n**示例：**\n\n\n    if (!condition) {\n      return \"1\"\n    } else {\n      return \"2\"\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNegatedIf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewGroovyClassNamingConvention",
                "shortDescription": {
                  "text": "类命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的类。 对于类的每种类型，请使用所提供的输入字段指定类名应有的最小长度、最大长度和正则表达式。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的类。\n\n对于类的每种类型，请使用所提供的输入字段指定类名应有的最小长度、最大长度和正则表达式。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewGroovyClassNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名约定",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClashingGetters",
                "shortDescription": {
                  "text": "冲突的 getter"
                },
                "fullDescription": {
                  "text": "报告可通过同一属性名称访问的布尔方法。 访问此类属性可能产生意外的结果。 示例： 'class X {\n      boolean isFoo() { true }\n      boolean getFoo() { false }\n  }\n\n  // 将调用 getFoo()\n  new X().foo'",
                  "markdown": "报告可通过同一属性名称访问的布尔方法。\n\n访问此类属性可能产生意外的结果。\n\n**示例：**\n\n\n      class X {\n          boolean isFoo() { true }\n          boolean getFoo() { false }\n      }\n\n      // 将调用 getFoo()\n      new X().foo\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClashingGetters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySwitchStatementWithNoDefault",
                "shortDescription": {
                  "text": "没有 default case 的 switch 语句"
                },
                "fullDescription": {
                  "text": "报告不包含 'default' 标签的 'switch' 语句。 某些编码实践可能会坚持将此标签添加到所有 'switch' 语句。",
                  "markdown": "报告不包含 `default` 标签的 `switch` 语句。\n\n\n某些编码实践可能会坚持将此标签添加到所有 `switch` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySwitchStatementWithNoDefault",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDuplicateSwitchBranch",
                "shortDescription": {
                  "text": "重复 switch case"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句的 'case' 标签中的重复表达式。 示例： 'switch (n) {\n  case 1: //重复\n    break\n  case 1: //重复\n    System.out.println(\"2\")\n    break\n  default:\n    System.out.println(\"default\");\n}'",
                  "markdown": "报告 `switch` 语句的 `case` 标签中的重复表达式。\n\n**示例：**\n\n\n    switch (n) {\n      case 1: //重复\n        break\n      case 1: //重复\n        System.out.println(\"2\")\n        break\n      default:\n        System.out.println(\"default\");\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyDuplicateSwitchBranch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/有效性问题",
                      "index": 103,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyListGetCanBeKeyedAccess",
                "shortDescription": {
                  "text": "对 List.get 的调用可以是键控访问"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.List.get()' 方法的调用。 此类调用可由更简短明确的键控访问形式替代。 示例： 'def list = [\"foo\"]\ndef str = list.get(0) // list.get(0) 可以替换为 list[0]'\n 在应用快速修复后： 'def list = [\"foo\"]\ndef str = list[0]'",
                  "markdown": "报告对 `java.util.List.get()` 方法的调用。 此类调用可由更简短明确的键控访问形式替代。\n\n**示例：**\n\n\n    def list = [\"foo\"]\n    def str = list.get(0) // list.get(0) 可以替换为 list[0]\n\n在应用快速修复后：\n\n\n    def list = [\"foo\"]\n    def str = list[0]\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyListGetCanBeKeyedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/GPath",
                      "index": 22,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySynchronizationOnThis",
                "shortDescription": {
                  "text": "在 'this' 上同步"
                },
                "fullDescription": {
                  "text": "报告使用 'this' 作为其锁定表达式的同步。 报告的结构包括锁定 'this' 的 'synchronized' 块，以及对以 'wait()' 为目标的 'wait()' 'notify()' 或 'notifyAll()' 的调用。 此类结构（如 synchronized 方法）会导致难以跟踪给定对象上锁定的对象，并且可能导致对象遭到“拒绝服务”攻击。 替代做法是考虑在 private 实例变量上锁定，从而完全控制对该对象的访问。",
                  "markdown": "报告使用 `this` 作为其锁定表达式的同步。\n\n\n报告的结构包括锁定 `this` 的 `synchronized` 块，以及对以 `wait()` 为目标的 `wait()` `notify()` 或 `notifyAll()` 的调用。\n此类结构（如 synchronized 方法）会导致难以跟踪给定对象上锁定的对象，并且可能导致对象遭到\"拒绝服务\"攻击。 替代做法是考虑在 private 实例变量上锁定，从而完全控制对该对象的访问。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySynchronizationOnThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNestedSynchronizedStatement",
                "shortDescription": {
                  "text": "嵌套 'synchronized' 语句"
                },
                "fullDescription": {
                  "text": "报告嵌套的 'synchronized' 语句。 嵌套的 'synchronized' 语句要么冗余（如果锁定对象相同），要么容易导致死锁。",
                  "markdown": "报告嵌套的 `synchronized` 语句。\n\n\n嵌套的 `synchronized` 语句要么冗余（如果锁定对象相同），要么容易导致死锁。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNestedSynchronizedStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyGStringKey",
                "shortDescription": {
                  "text": "GString 映射键"
                },
                "fullDescription": {
                  "text": "报告将 'groovy.lang.GString' 对象用作映射键的语句。 通常，'GString' 对象是可变的，可能不应用作键。 此外，使用具有相同值的 'java.lang.String' 对象无法访问 'GString' 条目。 示例： 'def map = [:]\ndef key = 'foo'\nmap << [\"${key}\": 'bar']\nassert map[key] == null // 令人困惑的比较 'true' 结果'\n 2017.1 最新变化",
                  "markdown": "报告将 `groovy.lang.GString` 对象用作映射键的语句。 通常，`GString` 对象是可变的，可能不应用作键。 此外，使用具有相同值的 `java.lang.String` 对象无法访问 `GString` 条目。\n\n**示例：**\n\n\n    def map = [:]\n    def key = 'foo'\n    map << [\"${key}\": 'bar']\n    assert map[key] == null // 令人困惑的比较 'true' 结果\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyGStringKey",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewInstanceOfSingleton",
                "shortDescription": {
                  "text": "使用 @groovy.lang.Singleton 注解的类的新实例"
                },
                "fullDescription": {
                  "text": "报告使用 '@groovy.lang.Singleton' 注解的类的新实例创建。 此类构造可能导致运行时异常无法实例化单例。 示例： '@Singleton\n  class Foo{\n  }\n  \n  Foo foo = new Foo()' 在应用快速修复后： '@Singleton\n  class Foo{\n  }\n  \n  Foo foo = Foo.instance'",
                  "markdown": "报告使用 `@groovy.lang.Singleton` 注解的类的新实例创建。\n此类构造可能导致运行时异常**无法实例化单例**。\n\n**示例：**\n\n\n      @Singleton\n      class Foo{\n      }\n      \n      Foo foo = new Foo()\n\n在应用快速修复后：\n\n\n      @Singleton\n      class Foo{\n      }\n      \n      Foo foo = Foo.instance\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewInstanceOfSingleton",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyVariableCanBeFinal",
                "shortDescription": {
                  "text": "变量可以为 final"
                },
                "fullDescription": {
                  "text": "报告可能添加了 final 修饰符的形参或局部变量。 示例： 'def list = [1,2,3]\n  return list' 在应用快速修复后： 'final def list = [1,2,3]\n  return list' 有关更多信息，请参阅 Java 中的相同检查。",
                  "markdown": "报告可能添加了 final 修饰符的形参或局部变量。\n\n**示例：**\n\n\n      def list = [1,2,3]\n      return list\n\n在应用快速修复后：\n\n\n      final def list = [1,2,3]\n      return list\n\n有关更多信息，请参阅 Java 中的相同检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyVariableCanBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/数据流",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyWaitCallNotInLoop",
                "shortDescription": {
                  "text": "'wait()' 不在循环中"
                },
                "fullDescription": {
                  "text": "报告不是在循环中进行的 'wait()' 调用。 'wait()' 通常用于挂起线程，直到某个条件变成 true 为止，并且应在 'wait()' 返回后检查该条件。 使用循环很容易做到这一点。",
                  "markdown": "报告不是在循环中进行的 `wait()` 调用。\n\n`wait()` 通常用于挂起线程，直到某个条件变成 true 为止，并且应在 `wait()` 返回后检查该条件。 使用循环很容易做到这一点。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyWaitCallNotInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnnecessaryReturn",
                "shortDescription": {
                  "text": "不必要的 'return' 语句"
                },
                "fullDescription": {
                  "text": "报告返回 'void' 的构造函数和方法结尾的 'return' 语句。 此类调用不必要，并且可以安全移除。 示例： 'void foo (String s){\n      print(s)\n      return\n  }' 在应用快速修复后： 'void foo (String s){\n      print(s)\n  }' 有关更多信息，请参阅 Java 中的相同检查。",
                  "markdown": "报告返回 `void` 的构造函数和方法结尾的 `return` 语句。 此类调用不必要，并且可以安全移除。\n\n**示例：**\n\n\n      void foo (String s){\n          print(s)\n          return\n      }\n\n在应用快速修复后：\n\n\n      void foo (String s){\n          print(s)\n      }\n\n有关更多信息，请参阅 Java 中的相同检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnnecessaryReturn",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrReassignedInClosureLocalVar",
                "shortDescription": {
                  "text": "在闭包类或匿名类中重新分配局部变量"
                },
                "fullDescription": {
                  "text": "报告在闭包或匿名类中分配给不同类型的表达式的局部变量。 示例： 'int sum = 0\n  [1, 2, 3].each { sum += 'as' }\n  println(sum)' 因此，'integer' 变量 sum 会被重新赋值给 'String' 表达式。",
                  "markdown": "报告在闭包或匿名类中分配给不同类型的表达式的局部变量。\n\n**示例：**\n\n\n      int sum = 0\n      [1, 2, 3].each { sum += 'as' }\n      println(sum)\n\n因此，`integer` 变量 **sum** 会被重新赋值给 `String` 表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrReassignedInClosureLocalVar",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMethodParameterCount",
                "shortDescription": {
                  "text": "形参过多的方法"
                },
                "fullDescription": {
                  "text": "报告形参过多的方法。 方法的形参过多可能表明有必要重构。 此检查会忽略从库类继承签名的方法。 使用最大形参数量: 字段可指定方法的最大可接受形参数量。",
                  "markdown": "报告形参过多的方法。 方法的形参过多可能表明有必要重构。 此检查会忽略从库类继承签名的方法。\n\n\n使用**最大形参数量:** 字段可指定方法的最大可接受形参数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMethodParameterCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/方法指标",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConditional",
                "shortDescription": {
                  "text": "三元表达式"
                },
                "fullDescription": {
                  "text": "报告三元表达式。 某些编码标准禁止使用条件运算符，而是支持 'if' 语句。",
                  "markdown": "报告三元表达式。\n\n某些编码标准禁止使用条件运算符，而是支持 `if` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAccessToStaticFieldLockedOnInstance",
                "shortDescription": {
                  "text": "访问实例数据上锁定的 static 字段"
                },
                "fullDescription": {
                  "text": "报告对在 'this' 或 'this' 的实例字段上锁定的非常量 static 字段的访问。 在实例数据上锁定 static 字段并不能防止其他实例修改该字段，因此可能会导致意外的竞争条件。 示例： 'static String s;\n  def foo() {\n      synchronized (this) {\n          System.out.println(s); // 警告\n      }\n  }'",
                  "markdown": "报告对在 `this` 或 `this` 的实例字段上锁定的非常量 static 字段的访问。\n\n\n在实例数据上锁定 static 字段并不能防止其他实例修改该字段，因此可能会导致意外的竞争条件。\n\n**示例：**\n\n\n      static String s;\n      def foo() {\n          synchronized (this) {\n              System.out.println(s); // 警告\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAccessToStaticFieldLockedOnInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNestedConditional",
                "shortDescription": {
                  "text": "嵌套条件表达式"
                },
                "fullDescription": {
                  "text": "报告嵌套在其他条件表达式中的三元条件表达式。 此类嵌套条件可能非常令人困惑。 出于此检查的目的，\"Elvis\" 表达式将算作条件表达式。 示例： 'return (condition ? \"result\" : null) ?: \"fail\"'",
                  "markdown": "报告嵌套在其他条件表达式中的三元条件表达式。 此类嵌套条件可能非常令人困惑。 出于此检查的目的，\"Elvis\" 表达式将算作条件表达式。\n\n**示例：**\n\n\n    return (condition ? \"result\" : null) ?: \"fail\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNestedConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyLabeledStatement",
                "shortDescription": {
                  "text": "标签化语句检查"
                },
                "fullDescription": {
                  "text": "报告已在父工作流中使用的标签。 示例： 'def list = [\"foo\"]\ncycle:\nfor (element in list) {\n  cycle: // 令人困惑的标签重复\n  element.chars().forEach {\n  }\n}'",
                  "markdown": "报告已在父工作流中使用的标签。\n\n**示例：**\n\n\n    def list = [\"foo\"]\n    cycle:\n    for (element in list) {\n      cycle: // 令人困惑的标签重复\n      element.chars().forEach {\n      }\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyLabeledStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptyStatementBody",
                "shortDescription": {
                  "text": "带空体的语句"
                },
                "fullDescription": {
                  "text": "报告语句体为空的 'if'、'while'、'do' 或 'for' 语句。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。 示例： 'if (condition) {}\nwhile(true){}'",
                  "markdown": "报告语句体为空的 `if`、`while`、`do` 或 `for` 语句。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。\n\n**示例：**\n\n\n    if (condition) {}\n    while(true){}\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptyStatementBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAssignmentToForLoopParameter",
                "shortDescription": {
                  "text": "赋值给 'for' 循环形参"
                },
                "fullDescription": {
                  "text": "报告对 for 循环体中的 for 循环形参的赋值。 虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由拼写错误所致。 示例： 'for (value in [1, 2, 3]) {\n      value = 4 // 警告\n  }'",
                  "markdown": "报告对 **for** 循环体中的 **for** 循环形参的赋值。\n\n虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由拼写错误所致。\n\n**示例：**\n\n\n      for (value in [1, 2, 3]) {\n          value = 4 // 警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAssignmentToForLoopParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryAlias",
                "shortDescription": {
                  "text": "不必要的导入别名"
                },
                "fullDescription": {
                  "text": "报告不必要的导入别名。 示例： 'import com.foo.Bar as Bar' 在应用快速修复后： 'import com.foo.Bar'",
                  "markdown": "报告不必要的导入别名。\n\n**示例：**\n\n\n      import com.foo.Bar as Bar\n\n在应用快速修复后：\n\n\n      import com.foo.Bar\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryAlias",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAssignmentCanBeOperatorAssignment",
                "shortDescription": {
                  "text": "赋值可被替换为运算符赋值"
                },
                "fullDescription": {
                  "text": "报告可替换为运算符赋值的赋值。 示例： 'a = a + b' 在应用快速修复后： 'a += b' 配置检查： 使用忽略条件运算符选项可忽略 '&&' 和 '||' 运算符。 使用忽略模糊运算符选项可忽略 '^' 和 '%' 运算符。",
                  "markdown": "报告可替换为运算符赋值的赋值。\n\n**示例：**\n\n\n      a = a + b\n\n在应用快速修复后：\n\n\n      a += b\n\n配置检查：\n\n* 使用**忽略条件运算符** 选项可忽略 `&&` 和 `||` 运算符。\n* 使用**忽略模糊运算符** 选项可忽略 `^` 和 `%` 运算符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GroovyAssignmentCanBeOperatorAssignment",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyImplicitNullArgumentCall",
                "shortDescription": {
                  "text": "隐式 null 实参"
                },
                "fullDescription": {
                  "text": "报告对只有一个形参的方法的无实参调用。 这等效于使用 'null' 进行调用，但这种行为通常令人困惑并且是无意为之。 示例： 'def foo(String s){}\nfoo() // 此调用实际上为 'foo(null)' 调用'",
                  "markdown": "报告对只有一个形参的方法的无实参调用。 这等效于使用 `null` 进行调用，但这种行为通常令人困惑并且是无意为之。\n\n**示例：**\n\n\n    def foo(String s){}\n    foo() // 此调用实际上为 'foo(null)' 调用\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GroovyImplicitNullArgumentCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyReturnFromFinallyBlock",
                "shortDescription": {
                  "text": "'return' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'return' 语句。 虽然偶尔是有意为之，但此类 'return' 语句可能会掩盖抛出的异常，并导致调试复杂化。",
                  "markdown": "报告 `finally` 块中的 `return` 语句。\n\n\n虽然偶尔是有意为之，但此类 `return` 语句可能会掩盖抛出的异常，并导致调试复杂化。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyReturnFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/错误处理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConstructorNamedArguments",
                "shortDescription": {
                  "text": "构造函数调用的命名实参"
                },
                "fullDescription": {
                  "text": "报告与此类的属性不对应的默认类构造函数调用的命名实参。 示例： 'class Person {\n      def name\n      def age\n  }\n\n  // 'firstName' 属性不存在\n  new Person(firstName: \"John\")'",
                  "markdown": "报告与此类的属性不对应的默认类构造函数调用的命名实参。\n\n**示例：**\n\n\n      class Person {\n          def name\n          def age\n      }\n\n      // 'firstName' 属性不存在\n      new Person(firstName: \"John\")\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConstructorNamedArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConditionalWithIdenticalBranches",
                "shortDescription": {
                  "text": "分支相同的三元表达式"
                },
                "fullDescription": {
                  "text": "报告包含相同 \"then\" 和 \"else\" 分支的三元表达式。 此类表达式几乎肯定表明程序员出现错误。 该快速修复会将替换表达式替换为其 \"then\" 分支。 示例： 'condition ? a.foo() : a.foo()' 在应用快速修复后： 'a.foo()'",
                  "markdown": "报告包含相同 \"then\" 和 \"else\" 分支的三元表达式。 此类表达式几乎肯定表明程序员出现错误。\n\n该快速修复会将替换表达式替换为其 \"then\" 分支。\n\n**示例：**\n\n\n      condition ? a.foo() : a.foo()\n\n在应用快速修复后：\n\n\n      a.foo()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConditionalWithIdenticalBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryNonSealedModifier",
                "shortDescription": {
                  "text": "不必要的 'non-sealed' 修饰符"
                },
                "fullDescription": {
                  "text": "报告在方法、字段或变量上使用的不必要的 'non-sealed' 修饰符。 此修饰符仅对类、接口和特征有效。 示例： 'non-sealed boolean foo() {} // 修饰符不必要\n  non-sealed Object bar // 修饰符不必要\n\n  // 修饰符为必选项，因此未高亮显示\n  non-sealed class A {}'",
                  "markdown": "报告在方法、字段或变量上使用的不必要的 `non-sealed` 修饰符。\n\n此修饰符仅对类、接口和特征有效。\n\n**示例：**\n\n\n      non-sealed boolean foo() {} // 修饰符不必要\n      non-sealed Object bar // 修饰符不必要\n\n      // 修饰符为必选项，因此未高亮显示\n      non-sealed class A {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryNonSealedModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrAnnotationReferencingUnknownIdentifiers",
                "shortDescription": {
                  "text": "@TupleConstructor 和 @MapConstructor"
                },
                "fullDescription": {
                  "text": "报告 '@TupleConstructor' 和 '@MapConstructor' 'includes' 和 'excludes' 注解特性值中的未解析标识符。 示例： '// 未解析的 'c'\n  @TupleConstructor(includes = ['a', 'b', 'c'])\n  class X {\n      def a\n      def b\n  }'",
                  "markdown": "报告 `@TupleConstructor` 和 `@MapConstructor` `includes` 和 `excludes` 注解特性值中的未解析标识符。\n\n**示例：**\n\n\n      // 未解析的 'c'\n      @TupleConstructor(includes = ['a', 'b', 'c'])\n      class X {\n          def a\n          def b\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrAnnotationReferencingUnknownIdentifiers",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注解",
                      "index": 89,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryDefModifier",
                "shortDescription": {
                  "text": "不必要的 'def'"
                },
                "fullDescription": {
                  "text": "报告与显式类型声明一起使用时不必要的 'def' 修饰符。 示例： 'def boolean foo() {} // 修饰符不必要\n  def Object bar // 修饰符不必要\n\n  // 修饰符是必要的，因此未高亮显示\n  def (int a, String b) = []'",
                  "markdown": "报告与显式类型声明一起使用时不必要的 `def` 修饰符。\n\n**示例：**\n\n\n      def boolean foo() {} // 修饰符不必要\n      def Object bar // 修饰符不必要\n\n      // 修饰符是必要的，因此未高亮显示\n      def (int a, String b) = []\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryDefModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnresolvedAccess",
                "shortDescription": {
                  "text": "未解析的引用表达式"
                },
                "fullDescription": {
                  "text": "报告无法解析的引用表达式。",
                  "markdown": "报告无法解析的引用表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrUnresolvedAccess",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrPOJO",
                "shortDescription": {
                  "text": "无 @CompileStatic 的 @POJO"
                },
                "fullDescription": {
                  "text": "报表注解 '@groovy.transform.stc.POJO' 在没有'@groovy.transform.CompileStatic' 的情况下的应用。 注解 '@POJO' 会将 Groovy 类的编译过程更改为字节码。 如果没有显式启用的静态编译（通过 '@CompileStatic' 注解完成），它就不起作用。 示例： '@POJO // 报告 @POJO\n  class A {}'",
                  "markdown": "报表注解 `@groovy.transform.stc.POJO` 在没有`@groovy.transform.CompileStatic` 的情况下的应用。\n\n注解 `@POJO` 会将 Groovy 类的编译过程更改为字节码。 如果没有显式启用的静态编译（通过 `@CompileStatic` 注解完成），它就不起作用。\n\n**示例：**\n\n\n      @POJO // 报告 @POJO\n      class A {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrPOJO",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注解",
                      "index": 89,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyWaitWhileNotSynchronized",
                "shortDescription": {
                  "text": "未同步时使用 'wait()'"
                },
                "fullDescription": {
                  "text": "报告不是在相应的 synchronized 语句或 synchronized 方法中进行的 'wait()' 调用。 在没有持有锁定的对象上调用 'wait()' 会导致抛出 'IllegalMonitorStateException'。 此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。",
                  "markdown": "报告不是在相应的 synchronized 语句或 synchronized 方法中进行的 `wait()` 调用。\n\n在没有持有锁定的对象上调用 `wait()` 会导致抛出 `IllegalMonitorStateException`。\n此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyWaitWhileNotSynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMultipleReturnPointsPerMethod",
                "shortDescription": {
                  "text": "具有多个返回点的方法"
                },
                "fullDescription": {
                  "text": "报告返回点过多的方法。 返回点过多的方法可能令人困惑且难以重构。 示例： 'int foo(int a) {\n    if (a > 0) {\n      return a\n    }\n    if (a < 0) return -a\n    return 0\n  }'\n 使用下面提供的字段可指定方法的最大可接受返回点数量。",
                  "markdown": "报告返回点过多的方法。 返回点过多的方法可能令人困惑且难以重构。\n\n**示例：**\n\n\n      int foo(int a) {\n        if (a > 0) {\n          return a\n        }\n        if (a < 0) return -a\n        return 0\n      }\n\n\n使用下面提供的字段可指定方法的最大可接受返回点数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMultipleReturnPointsPerMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/方法指标",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConditionalCanBeElvis",
                "shortDescription": {
                  "text": "三元表达式可被替换为 elvis 表达式"
                },
                "fullDescription": {
                  "text": "报告可以使用 elvis 表达式替换的三元表达式。 示例： 'def notNull(o, defaultValue) {\n      o != null ? o : defaultValue\n  }' 在应用快速修复后： 'def notNull(o, defaultValue) {\n      o ?: defaultValue\n  }'",
                  "markdown": "报告可以使用 elvis 表达式替换的三元表达式。\n\n**示例：**\n\n\n      def notNull(o, defaultValue) {\n          o != null ? o : defaultValue\n      }\n\n在应用快速修复后：\n\n\n      def notNull(o, defaultValue) {\n          o ?: defaultValue\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GroovyConditionalCanBeElvis",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryFinalModifier",
                "shortDescription": {
                  "text": "不必要的 'final'"
                },
                "fullDescription": {
                  "text": "报告与记录定义一起使用时不必要的 'final' 修饰符。 示例： 'final record R(int a) {} // 不需要修饰符'",
                  "markdown": "报告与记录定义一起使用时不必要的 `final` 修饰符。\n\n**示例：**\n\n\n      final record R(int a) {} // 不需要修饰符\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryFinalModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyLongMethod",
                "shortDescription": {
                  "text": "过长的方法"
                },
                "fullDescription": {
                  "text": "报告过长的方法。 过长的方法可能令人困惑，并且表明可能有必要重构。 使用每个方法的最大语句数字段可指定方法的最大可接受非注释源代码语句数量。",
                  "markdown": "报告过长的方法。\n\n\n过长的方法可能令人困惑，并且表明可能有必要重构。\n\n\n使用**每个方法的最大语句数**字段可指定方法的最大可接受非注释源代码语句数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyLongMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/方法指标",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SecondUnsafeCall",
                "shortDescription": {
                  "text": "第二次不安全的调用"
                },
                "fullDescription": {
                  "text": "报告链方法或属性调用过程中可能产生的 NullPointerException。 示例： 'domain?.getZone().getName()' 在应用快速修复后： 'domain?.getZone()?.getName()'",
                  "markdown": "报告链方法或属性调用过程中可能产生的 **NullPointerException**。\n\n**示例：**\n\n\n      domain?.getZone().getName()\n\n在应用快速修复后：\n\n\n      domain?.getZone()?.getName()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SecondUnsafeCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrPackage",
                "shortDescription": {
                  "text": "软件包不匹配"
                },
                "fullDescription": {
                  "text": "报告包含与预期软件包不相符的声明软件包的文件。 此外，如果类不是直接位于源根目录中，则报告不包含 'package' 语句的文件。",
                  "markdown": "报告包含与预期软件包不相符的声明软件包的文件。 此外，如果类不是直接位于源根目录中，则报告不包含 `package` 语句的文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyComplexBooleanExpression",
                "shortDescription": {
                  "text": "过于复杂的布尔表达式"
                },
                "fullDescription": {
                  "text": "报告包含太多项的布尔表达式。 此类表达方式可能令人困惑，并且容易出错。 使用最大项数字段可以指定布尔表达式中允许的最大项数。",
                  "markdown": "报告包含太多项的布尔表达式。\n\n\n此类表达方式可能令人困惑，并且容易出错。\n\n\n使用**最大项数**字段可以指定布尔表达式中允许的最大项数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyComplexBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnreachableStatement",
                "shortDescription": {
                  "text": "不可到达的语句"
                },
                "fullDescription": {
                  "text": "报告无法到达的语句。 如果该语句位于无线循环、'return'、'break' 或 'continue' 语句后，则可能发生这种情况。 示例： 'void foo (int n) {\n      if (n < 1) {\n          return\n          print('This statement is unreachable')\n      }\n      while (true){\n          print ('Hello, world!')\n      }\n      print('This statement is unreachable too')\n  }'",
                  "markdown": "报告无法到达的语句。 如果该语句位于无线循环、`return`、`break` 或 `continue` 语句后，则可能发生这种情况。\n\n**示例：**\n\n\n      void foo (int n) {\n          if (n < 1) {\n              return\n              print('This statement is unreachable')\n          }\n          while (true){\n              print ('Hello, world!')\n          }\n          print('This statement is unreachable too')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnreachableStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/有效性问题",
                      "index": 103,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySystemRunFinalizersOnExit",
                "shortDescription": {
                  "text": "System.runFinalizersOnExit() 调用"
                },
                "fullDescription": {
                  "text": "报告对 'System.runFinalizersOnExit()' 的调用。 此调用是 Java 语言中最危险的调用之一。 它本质上为非线程安全，可能导致数据损坏、死锁，并可能影响远离调用点的程序部分。 已弃用，强烈建议不要使用。",
                  "markdown": "报告对 `System.runFinalizersOnExit()` 的调用。\n\n\n此调用是 Java 语言中最危险的调用之一。 它本质上为非线程安全，可能导致数据损坏、死锁，并可能影响远离调用点的程序部分。\n已弃用，强烈建议不要使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySystemRunFinalizersOnExit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInstanceVariableNamingConvention",
                "shortDescription": {
                  "text": "实例变量命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的实例变量。 使用下面提供的字段可指定实例变量名称的预期最小长度、最大长度和正则表达式。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的实例变量。\n\n\n使用下面提供的字段可指定实例变量名称的预期最小长度、最大长度和正则表达式。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInstanceVariableNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名约定",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConstantIfStatement",
                "shortDescription": {
                  "text": "常量 if 语句"
                },
                "fullDescription": {
                  "text": "报告将布尔常量作为条件的 'if' 语句。 示例： 'if (true) {\n      // ...\n  }\n  if (false) {\n      // ...\n  }'",
                  "markdown": "报告将布尔常量作为条件的 `if` 语句。\n\n**示例：**\n\n\n      if (true) {\n          // ...\n      }\n      if (false) {\n          // ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConstantIfStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyParameterNamingConvention",
                "shortDescription": {
                  "text": "方法形参命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的方法形参。 使用下面提供的字段可指定方法形参名称的预期最小长度、最大长度和正则表达式。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的方法形参。\n\n\n使用下面提供的字段可指定方法形参名称的预期最小长度、最大长度和正则表达式。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyParameterNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名约定",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryPublicModifier",
                "shortDescription": {
                  "text": "不必要的 'public'"
                },
                "fullDescription": {
                  "text": "报告不必要的 'public' 修饰符，因为 Groovy 类和方法默认为 'public'。 示例： 'public class Foo{\n      public void bar(){\n      }\n  }' 在应用快速修复后： 'class Foo{\n      void bar(){\n      }\n  }'",
                  "markdown": "报告不必要的 `public` 修饰符，因为 Groovy 类和方法默认为 `public`。\n\n**示例：**\n\n\n      public class Foo{\n          public void bar(){\n          }\n      }\n\n在应用快速修复后：\n\n\n      class Foo{\n          void bar(){\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryPublicModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrStringStyleViolation",
                "shortDescription": {
                  "text": "字符串样式违规"
                },
                "fullDescription": {
                  "text": "报告具有不符合代码样式的引号的字符串。 示例： 'def hw = \"Hello, world!\"' 在应用快速修复后： 'def hw = 'Hello, world!'' 使用下面提供的字段可为不同种类的字符串指定代码样式。",
                  "markdown": "报告具有不符合代码样式的引号的字符串。\n\n**示例：**\n\n\n      def hw = \"Hello, world!\"\n\n在应用快速修复后：\n\n\n      def hw = 'Hello, world!'\n\n使用下面提供的字段可为不同种类的字符串指定代码样式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrStringStyleViolation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyPointlessBoolean",
                "shortDescription": {
                  "text": "无意义的布尔表达式"
                },
                "fullDescription": {
                  "text": "报告无意义或复杂的无意义布尔表达式。 此类表达式包括与 true 的合取、与 false 的析取、与布尔文字的相等比较或布尔文字求反。 此类表达式可能是未完全完成的自动重构所致，在任何情况下都不太可能是开发人员有意为之。 示例： 'if (someBool && true) {}' 在应用快速修复后： 'if (someBool) {}'",
                  "markdown": "报告无意义或复杂的无意义布尔表达式。\n\n\n此类表达式包括与 true 的合取、与 false 的析取、与布尔文字的相等比较或布尔文字求反。 此类表达式可能是未完全完成的自动重构所致，在任何情况下都不太可能是开发人员有意为之。\n\n**示例：**\n\n\n      if (someBool && true) {}\n\n在应用快速修复后：\n\n\n      if (someBool) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyPointlessBoolean",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingletonConstructor",
                "shortDescription": {
                  "text": "@Singleton 构造函数"
                },
                "fullDescription": {
                  "text": "除非被声明为非 strict，否则报告使用 '@Singleton' 注解的类的构造函数。 示例： '@Singleton\n  class Foo{\n      Foo(){\n      }\n  }' 有两种可能的快速修复方法：移除该构造函数，或者将 '@Singleton' 声明为非 strict。 在应用快速修复后： '@Singleton\n  class Foo{\n  }' 或： '@Singleton(strict = false)\n  class Foo{\n      Foo(){\n      }\n  }'",
                  "markdown": "除非被声明为非 strict，否则报告使用 `@Singleton` 注解的类的构造函数。\n\n**示例：**\n\n\n      @Singleton\n      class Foo{\n          Foo(){\n          }\n      }\n\n有两种可能的快速修复方法：移除该构造函数，或者将 `@Singleton` 声明为非 strict。\n\n在应用快速修复后：\n\n\n      @Singleton\n      class Foo{\n      }\n\n或：\n\n\n      @Singleton(strict = false)\n      class Foo{\n          Foo(){\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "SingletonConstructor",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注解",
                      "index": 89,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyStaticVariableNamingConvention",
                "shortDescription": {
                  "text": "static 变量命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的 'static' 变量。 此检查不会检查常量（即被声明为 'static final' 的不可变类型的变量）。 使用下面提供的字段可指定 static 变量名称的预期最小长度、最大长度和正则表达式。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的 `static` 变量。\n\n\n此检查不会检查常量（即被声明为 `static final` 的不可变类型的变量）。\n\n\n使用下面提供的字段可指定 static 变量名称的预期最小长度、最大长度和正则表达式。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyStaticVariableNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名约定",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInfiniteLoopStatement",
                "shortDescription": {
                  "text": "无限循环语句"
                },
                "fullDescription": {
                  "text": "报告只能通过抛出异常来退出的 'for'、 'while' 或 'do' 语句。 虽然此类语句可能是正确的，但它们通常是由错误所致。 示例： 'while(true) {\n  Thread.sleep(1000)\n}'",
                  "markdown": "报告只能通过抛出异常来退出的 `for`、 `while` 或 `do` 语句。 虽然此类语句可能是正确的，但它们通常是由错误所致。\n\n**示例：**\n\n\n    while(true) {\n      Thread.sleep(1000)\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInfiniteLoopStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptyTryBlock",
                "shortDescription": {
                  "text": "空 'try' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'try' 块。 空的 'try' 块通常表明存在编码错误。 示例： 'try {\n}\nfinally {\n  close()\n}'",
                  "markdown": "报告空的 `try` 块。 空的 `try` 块通常表明存在编码错误。\n\n**示例：**\n\n\n    try {\n    }\n    finally {\n      close()\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptyTryBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/错误处理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrPermitsClause",
                "shortDescription": {
                  "text": "不可扩展的允许的子类"
                },
                "fullDescription": {
                  "text": "报告不扩展 sealed 基类的允许类。 Groovy 不要求所有的允许类都应在编译时可用并与基类一起编译。 编译器不会在处理非扩展允许子类时警告用户，但这与 sealed 类的性质相矛盾。 示例： 'class A permits B {} // 报告 B\n  class B {}'",
                  "markdown": "报告不扩展 sealed 基类的允许类。\n\nGroovy 不要求所有的允许类都应在编译时可用并与基类一起编译。 编译器不会在处理非扩展允许子类时警告用户，但这与 sealed 类的性质相矛盾。\n\n**示例：**\n\n\n      class A permits B {} // 报告 B\n      class B {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "GrPermitsClause",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnusedIncOrDec",
                "shortDescription": {
                  "text": "未使用的递增或递减"
                },
                "fullDescription": {
                  "text": "报告未使用的增量和减量表达式。",
                  "markdown": "报告未使用的增量和减量表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnusedIncOrDec",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/数据流",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptyCatchBlock",
                "shortDescription": {
                  "text": "空 'catch' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'catch' 块。 虽然偶尔是有意为之，但空的 'catch' 块可能导致调试变得极其困难。 示例： 'try {\n  throw new Exception()\n}\ncatch (Exception e) {\n}'\n 在应用快速修复后： 'try {\n  throw new Exception()\n}\ncatch (Exception ignored) {\n}'",
                  "markdown": "报告空的 `catch` 块。 虽然偶尔是有意为之，但空的 `catch` 块可能导致调试变得极其困难。\n\n**示例：**\n\n\n    try {\n      throw new Exception()\n    }\n    catch (Exception e) {\n    }\n\n在应用快速修复后：\n\n\n    try {\n      throw new Exception()\n    }\n    catch (Exception ignored) {\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptyCatchBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/错误处理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClashingTraitMethods",
                "shortDescription": {
                  "text": "冲突的特征方法"
                },
                "fullDescription": {
                  "text": "报告实现两个或多个特征（包含具有相同签名的方法）的类。 调用此类方法可能产生意外的结果。 该快速修复会添加显式重写方法。 示例： 'trait T1 {\n      def foo() {}\n  }\n\n  trait T2 {\n      def foo() {}\n  }\n\n  class X implements T1, T2 {}\n\n  // 将调用 T2.foo()\n  new X().foo()' 在应用快速修复后： 'class X implements T1, T2 {\n      @Override\n      Object foo() {\n          return T2.super.foo()\n      }\n  }'",
                  "markdown": "报告实现两个或多个特征（包含具有相同签名的方法）的类。\n\n调用此类方法可能产生意外的结果。\n\n该快速修复会添加显式重写方法。\n\n**示例：**\n\n\n      trait T1 {\n          def foo() {}\n      }\n\n      trait T2 {\n          def foo() {}\n      }\n\n      class X implements T1, T2 {}\n\n      // 将调用 T2.foo()\n      new X().foo()\n\n在应用快速修复后：\n\n\n      class X implements T1, T2 {\n          @Override\n          Object foo() {\n              return T2.super.foo()\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClashingTraitMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyComplexMethod",
                "shortDescription": {
                  "text": "过于复杂的方法"
                },
                "fullDescription": {
                  "text": "报告具有过高循环复杂度的方法。 循环复杂度基本上是方法中分支点数量的度量。 循环复杂度过高的方法可能令人困惑且难以测试。 使用方法复杂度限制字段可指定方法的最大可接受循环复杂度。",
                  "markdown": "报告具有过高循环复杂度的方法。\n\n\n循环复杂度基本上是方法中分支点数量的度量。 循环复杂度过高的方法可能令人困惑且难以测试。\n\n\n使用**方法复杂度限制**字段可指定方法的最大可接受循环复杂度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyComplexMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/方法指标",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeCustomizer",
                "shortDescription": {
                  "text": "类型自定义工具检查"
                },
                "fullDescription": {
                  "text": "报告可作为自定义类型检查器且未添加到编译器资源的文件。",
                  "markdown": "报告可作为自定义类型检查器且未添加到编译器资源的文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeCustomizer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/其他",
                      "index": 78,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyNestedMethod",
                "shortDescription": {
                  "text": "过度嵌套的方法"
                },
                "fullDescription": {
                  "text": "报告方法体嵌套过深的方法。 语句嵌套过深的方法可能令人困惑，并且表明可能有必要重构。 使用最大嵌套深度字段可指定方法的最大可接受嵌套深度。",
                  "markdown": "报告方法体嵌套过深的方法。\n\n\n语句嵌套过深的方法可能令人困惑，并且表明可能有必要重构。\n\n\n使用**最大嵌套深度**字段可指定方法的最大可接受嵌套深度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyNestedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/方法指标",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyVariableNotAssigned",
                "shortDescription": {
                  "text": "未分配变量"
                },
                "fullDescription": {
                  "text": "报告可能未初始化的变量。",
                  "markdown": "报告可能未初始化的变量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyVariableNotAssigned",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/数据流",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMethodWithMoreThanThreeNegations",
                "shortDescription": {
                  "text": "具有三个以上否定的方法"
                },
                "fullDescription": {
                  "text": "报告具有三个或更多求反运算（'!' 或 '!='）的方法。 此类方法可能造成不必要的困惑。",
                  "markdown": "报告具有三个或更多求反运算（`!` 或 `!=`）的方法。 此类方法可能造成不必要的困惑。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMethodWithMoreThanThreeNegations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/方法指标",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDoubleNegation",
                "shortDescription": {
                  "text": "双重求反"
                },
                "fullDescription": {
                  "text": "报告可以简化的双重否定。 示例： 'if (!!functionCall()) {} // 双重否定\nif (!(a != b)) {} // 双重否定'\n 在应用快速修复后： 'if (functionCall()) {}\nif (a == b) {}'",
                  "markdown": "报告可以简化的双重否定。\n\n**示例：**\n\n\n    if (!!functionCall()) {} // 双重否定\n    if (!(a != b)) {} // 双重否定\n\n在应用快速修复后：\n\n\n    if (functionCall()) {}\n    if (a == b) {}\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyDoubleNegation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrNamedVariantLabels",
                "shortDescription": {
                  "text": "@NamedVariant/@NamedParam/@NamedDelegate 未解析标签"
                },
                "fullDescription": {
                  "text": "报告通过 '@NamedVariant'/'@NamedParam'/'@NamedDelegate' 注解的方法调用中未解析的实参标签。 示例： '@groovy.transform.NamedVariant\n  def foo(a, b) {}\n\n  // 未解析的标签 'c'\n  foo(a: 1, b: 2, c: 3)'",
                  "markdown": "报告通过 `@NamedVariant`/`@NamedParam`/`@NamedDelegate` 注解的方法调用中未解析的实参标签。\n\n**示例：**\n\n\n      @groovy.transform.NamedVariant\n      def foo(a, b) {}\n\n      // 未解析的标签 'c'\n      foo(a: 1, b: 2, c: 3)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrNamedVariantLabels",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注解",
                      "index": 89,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyIfStatementWithTooManyBranches",
                "shortDescription": {
                  "text": "具有过多分支的 if 语句"
                },
                "fullDescription": {
                  "text": "报告分支太多的 'if' 语句。 此类语句可能令人困惑，并且通常表明设计抽象度不足。 示例： 'if (a) {\n  print \"foo\"\n} else if (b) {\n  print \"bar\"\n} else if (c) {\n  print \"baz\"\n} else if (d) {\n  print \"Too many branches\"\n}'\n 使用最大分支数字段可指定预期的最大分支数量。",
                  "markdown": "报告分支太多的 `if` 语句。 此类语句可能令人困惑，并且通常表明设计抽象度不足。\n\n**示例：**\n\n\n    if (a) {\n      print \"foo\"\n    } else if (b) {\n      print \"bar\"\n    } else if (c) {\n      print \"baz\"\n    } else if (d) {\n      print \"Too many branches\"\n    }\n\n\n使用**最大分支数**字段可指定预期的最大分支数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyIfStatementWithTooManyBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNegatedConditional",
                "shortDescription": {
                  "text": "否定条件表达式"
                },
                "fullDescription": {
                  "text": "报告条件被否定的条件表达式。 翻转条件表达式分支的顺序通常会增加此类语句的清晰度。 示例： '~condition ? \"1\" : \"2\"'",
                  "markdown": "报告条件被否定的条件表达式。 翻转条件表达式分支的顺序通常会增加此类语句的清晰度。\n\n**示例：**\n\n\n    ~condition ? \"1\" : \"2\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNegatedConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyWhileLoopSpinsOnField",
                "shortDescription": {
                  "text": "While 循环在字段上自旋"
                },
                "fullDescription": {
                  "text": "报告在非 'volatile' 字段值上自旋，等待它被另一个线程更改的 'while' 循环。 除了在循环内完成少量工作时可能会非常耗费 CPU 之外，此类循环很可能具有与预期不同的语义。 即便另一个线程改变了该字段的值，Java 内存模型也允许该循环永不完成。 示例： 'class SpinsOnField {\n      boolean ready = false;\n\n      void run() {\n          // 即使在从其他线程调用 markAsReady 后，\n          // 该循环也可能永不完成\n          while (!ready) {\n          }\n          // 执行某些工作\n      }\n\n      void markAsReady() {\n          ready = true;\n      }\n  }' 此外，自 Java 9 起，建议在 'volatile' 字段的自旋循环中调用 'Thread.onSpinWait()'，这可能会显著提高在某些硬件上的性能。 使用下面的复选框可使此检查仅报告空 'while' 循环。",
                  "markdown": "报告在非 `volatile` 字段值上自旋，等待它被另一个线程更改的 `while` 循环。\n\n\n除了在循环内完成少量工作时可能会非常耗费 CPU 之外，此类循环很可能具有与预期不同的语义。 即便另一个线程改变了该字段的值，Java 内存模型也允许该循环永不完成。\n\n**示例：**\n\n\n      class SpinsOnField {\n          boolean ready = false;\n\n          void run() {\n              // 即使在从其他线程调用 markAsReady 后，\n              // 该循环也可能永不完成\n              while (!ready) {\n              }\n              // 执行某些工作\n          }\n\n          void markAsReady() {\n              ready = true;\n          }\n      }\n\n\n此外，自 Java 9 起，建议在 `volatile` 字段的自旋循环中调用 `Thread.onSpinWait()`，这可能会显著提高在某些硬件上的性能。\n\n\n使用下面的复选框可使此检查仅报告空 `while` 循环。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyWhileLoopSpinsOnField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrEqualsBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "'equals()' 位于不可转换类型的对象之间"
                },
                "fullDescription": {
                  "text": "报告对目标和实参的类型不兼容的 'equals()' 的调用。 虽然此类调用理论上可能有用，但很可能是错误。 示例： 'new HashSet<String>() == new TreeSet<Integer>())'",
                  "markdown": "报告对目标和实参的类型不兼容的 `equals()` 的调用。\n\n虽然此类调用理论上可能有用，但很可能是错误。\n\n**示例：**\n\n\n        new HashSet<String>() == new TreeSet<Integer>())\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrEqualsBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptySyncBlock",
                "shortDescription": {
                  "text": "空 'synchronized' 块"
                },
                "fullDescription": {
                  "text": "报告语句体为空的 'synchronized' 语句。 虽然在理论上这种语义可能是有意为之，但此构造令人困惑，并且通常是由拼写错误所致。 示例： 'synchronized(lock) {\n}'",
                  "markdown": "报告语句体为空的 `synchronized` 语句。 虽然在理论上这种语义可能是有意为之，但此构造令人困惑，并且通常是由拼写错误所致。\n\n**示例：**\n\n\n    synchronized(lock) {\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptySyncBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySillyAssignment",
                "shortDescription": {
                  "text": "不实用的赋值"
                },
                "fullDescription": {
                  "text": "报告变量对自身的赋值。",
                  "markdown": "报告变量对自身的赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySillyAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConditionalCanBeConditionalCall",
                "shortDescription": {
                  "text": "三元表达式可被替换为安全调用"
                },
                "fullDescription": {
                  "text": "报告可以使用安全调用替换的三元表达式。 示例： 'def charArray(String s) {\n      s == null ? null : s.toCharArray()\n  }' 在应用快速修复后： 'def charArray(String s) {\n      s?.toCharArray()\n  }'",
                  "markdown": "报告可以使用安全调用替换的三元表达式。\n\n**示例：**\n\n\n      def charArray(String s) {\n          s == null ? null : s.toCharArray()\n      }\n\n在应用快速修复后：\n\n\n      def charArray(String s) {\n          s?.toCharArray()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GroovyConditionalCanBeConditionalCall",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInfiniteRecursion",
                "shortDescription": {
                  "text": "无限递归"
                },
                "fullDescription": {
                  "text": "报告肯定会无限递归或抛出异常的方法。 此检查报告的方法无法正确结束。 示例： '// 此函数会使循环越来越深\ndef fibonacci(int n) {\n  return fibonacci(n-1) + fibonacci(n-2)\n}'",
                  "markdown": "报告肯定会无限递归或抛出异常的方法。 此检查报告的方法无法正确结束。\n\n**示例：**\n\n\n    // 此函数会使循环越来越深\n    def fibonacci(int n) {\n      return fibonacci(n-1) + fibonacci(n-2)\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInfiniteRecursion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNestedSwitch",
                "shortDescription": {
                  "text": "嵌套 switch 语句"
                },
                "fullDescription": {
                  "text": "报告嵌套在其他 'switch' 语句中的 'switch' 语句。 此类嵌套 switch 语句令人困惑，并且可能导致意外行为。 示例： 'switch (outer) {\n  case 1:\n    switch (inner) {\n      case 1:\n        print \"inner 1\"\n        break\n      default:\n        print \"inner default\"\n    }\n    break\n  default:\n    print \"default\"\n}'",
                  "markdown": "报告嵌套在其他 `switch` 语句中的 `switch` 语句。 此类嵌套 switch 语句令人困惑，并且可能导致意外行为。\n\n**示例：**\n\n\n    switch (outer) {\n      case 1:\n        switch (inner) {\n          case 1:\n            print \"inner 1\"\n            break\n          default:\n            print \"inner default\"\n        }\n        break\n      default:\n        print \"default\"\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNestedSwitch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyRangeTypeCheck",
                "shortDescription": {
                  "text": "不正确的范围实参"
                },
                "fullDescription": {
                  "text": "报告在没有 'next()' 或 'previous()' 方法 或者在没有实现 'java.lang.Comparable' 接口的范围中使用的类型。",
                  "markdown": "报告在没有 `next()` 或 `previous()` 方法 或者在没有实现 `java.lang.Comparable` 接口的范围中使用的类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyRangeTypeCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能的 bug",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessarySealedModifier",
                "shortDescription": {
                  "text": "不必要的 'sealed' 修饰符"
                },
                "fullDescription": {
                  "text": "报告在方法、字段或变量上使用的不必要的 'sealed' 修饰符。 此修饰符仅对类、接口和特征有效。 示例： 'sealed boolean foo() {} // 修饰符不必要\n  sealed Object bar // 修饰符不必要\n\n  // 修饰符为必选项，因此未高亮显示\n  sealed class A {}'",
                  "markdown": "报告在方法、字段或变量上使用的不必要的 `sealed` 修饰符。\n\n此修饰符仅对类、接口和特征有效。\n\n**示例：**\n\n\n      sealed boolean foo() {} // 修饰符不必要\n      sealed Object bar // 修饰符不必要\n\n      // 修饰符为必选项，因此未高亮显示\n      sealed class A {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessarySealedModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/样式",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrDeprecatedAPIUsage",
                "shortDescription": {
                  "text": "弃用的 API 用法"
                },
                "fullDescription": {
                  "text": "报告对已弃用类、字段和方法的引用。",
                  "markdown": "报告对已弃用类、字段和方法的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrDeprecatedAPIUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMissingReturnStatement",
                "shortDescription": {
                  "text": "缺少 return 语句"
                },
                "fullDescription": {
                  "text": "报告具有非 void 返回类型的方法结尾缺少 'return' 语句。 方法的执行流应该可以执行到方法结尾。 示例： 'String foo(int a) {\n  if (a > 0) {\n    return \"more than zero\"\n  }\n} // foo(-1) 将返回 'null'\n\nint bar(int a) {\n  if (a > 0) {\n    return a\n  }\n} // bar(-1) 将失败并引发运行时异常'",
                  "markdown": "报告具有非 **void** 返回类型的方法结尾缺少 `return` 语句。 方法的执行流应该可以执行到方法结尾。\n\n**示例：**\n\n\n    String foo(int a) {\n      if (a > 0) {\n        return \"more than zero\"\n      }\n    } // foo(-1) 将返回 'null'\n\n    int bar(int a) {\n      if (a > 0) {\n        return a\n      }\n    } // bar(-1) 将失败并引发运行时异常\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMissingReturnStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/数据流",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyPublicFieldAccessedInSynchronizedContext",
                "shortDescription": {
                  "text": "在同步上下文中访问的非 private 字段"
                },
                "fullDescription": {
                  "text": "报告在同步上下文中访问的非 'final'、非 'private' 字段。 不能保证始终以同步方式访问非 private 字段，此类“部分同步的”访问可能意外导致不一致的数据结构。 出于此检查的目的，将忽略构造函数和初始值设定项中的访问。",
                  "markdown": "报告在同步上下文中访问的非 `final`、非 `private` 字段。\n\n\n不能保证始终以同步方式访问非 private 字段，此类\"部分同步的\"访问可能意外导致不一致的数据结构。 出于此检查的目的，将忽略构造函数和初始值设定项中的访问。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyPublicFieldAccessedInSynchronizedContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnnecessaryContinue",
                "shortDescription": {
                  "text": "不必要的 'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告循环中最后能够到达的 'continue' 语句。 这些 'continue' 语句是不必要的语句，可以安全移除。 示例： 'for(int i in array) {\n      println(i)\n      continue\n  }' 在应用快速修复后： 'for(int i in array) {\n      println(i)\n  }' 有关更多信息，请参阅 Java 中的相同检查。",
                  "markdown": "报告循环中最后能够到达的 `continue` 语句。\n这些 `continue` 语句是不必要的语句，可以安全移除。\n\n**示例：**\n\n\n      for(int i in array) {\n          println(i)\n          continue\n      }\n\n在应用快速修复后：\n\n\n      for(int i in array) {\n          println(i)\n      }\n\n有关更多信息，请参阅 Java 中的相同检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnnecessaryContinue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnusedAssignment",
                "shortDescription": {
                  "text": "未使用的赋值"
                },
                "fullDescription": {
                  "text": "报告赋值后因值从未使用而导致变量冗余的情况。 如果变量未使用，建议将其移除，以缩短代码并避免冗余分配。 将报告以下情况： 该变量赋值后从未读取 在读取下一个变量之前，该值始终被另一个赋值重写 变量初始值设定项冗余（由于以上两种原因之一） 有关更多信息，请参阅 Java 中的相同检查。",
                  "markdown": "报告赋值后因值从未使用而导致变量冗余的情况。\n\n如果变量未使用，建议将其移除，以缩短代码并避免冗余分配。\n\n将报告以下情况：\n\n* 该变量赋值后从未读取\n* 在读取下一个变量之前，该值始终被另一个赋值重写\n* 变量初始值设定项冗余（由于以上两种原因之一）\n\n有关更多信息，请参阅 Java 中的相同检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnusedAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/数据流",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNotifyWhileNotSynchronized",
                "shortDescription": {
                  "text": "未同步时使用 'notify()' 或 'notifyAll()'"
                },
                "fullDescription": {
                  "text": "报告不是在相应的 synchronized 语句或 synchronized 方法中进行的 'notify()' 和 'notifyAll()' 调用。 在没有持有锁定的对象上调用这些方法会导致抛出 'IllegalMonitorStateException'。 此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。",
                  "markdown": "报告不是在相应的 synchronized 语句或 synchronized 方法中进行的 `notify()` 和 `notifyAll()` 调用。\n\n\n在没有持有锁定的对象上调用这些方法会导致抛出 `IllegalMonitorStateException`。\n此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNotifyWhileNotSynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyBusyWait",
                "shortDescription": {
                  "text": "繁忙等待"
                },
                "fullDescription": {
                  "text": "报告在循环内发生的对 'java.lang.Thread.sleep()' 的调用。 此类调用表示“繁忙-等待”。 忙等待通常效率低下，并且可能导致意外死锁，因为忙等待线程不会释放锁定的资源。",
                  "markdown": "报告在循环内发生的对 `java.lang.Thread.sleep()` 的调用。\n\n\n此类调用表示\"繁忙-等待\"。 忙等待通常效率低下，并且可能导致意外死锁，因为忙等待线程不会释放锁定的资源。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyBusyWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOctalInteger",
                "shortDescription": {
                  "text": "八进制整数"
                },
                "fullDescription": {
                  "text": "报告八进制整数文字。 某些编码标准禁止使用八进制文字，因为它们可能容易与十进制文字混淆。",
                  "markdown": "报告八进制整数文字。\n\n\n某些编码标准禁止使用八进制文字，因为它们可能容易与十进制文字混淆。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOctalInteger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptyFinallyBlock",
                "shortDescription": {
                  "text": "空 'finally' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'finally' 块。 空的 'finally' 块通常表明存在编码错误。 示例： 'try {\n  throw new Exception()\n}\nfinally {\n}'",
                  "markdown": "报告空的 `finally` 块。 空的 `finally` 块通常表明存在编码错误。\n\n**示例：**\n\n\n    try {\n      throw new Exception()\n    }\n    finally {\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptyFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/错误处理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySynchronizationOnVariableInitializedWithLiteral",
                "shortDescription": {
                  "text": "在使用文字初始化的变量上同步"
                },
                "fullDescription": {
                  "text": "报告在使用文字初始化的对象上锁定的 synchronized 块。 字符串文字是暂存的，'Number' 文字可以从缓存中分配。 正因为如此，可能系统的其他某些部分（使用通过相同文字初始化的对象）实际上会包含对完全相同的对象的引用。 如果字符串被认为是 private 对象，这可能会产生意外的死锁情况。",
                  "markdown": "报告在使用文字初始化的对象上锁定的 synchronized 块。\n\n\n字符串文字是暂存的，`Number` 文字可以从缓存中分配。 正因为如此，可能系统的其他某些部分（使用通过相同文字初始化的对象）实际上会包含对完全相同的对象的引用。 如果字符串被认为是 private 对象，这可能会产生意外的死锁情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySynchronizationOnVariableInitializedWithLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnusedDeclaration",
                "shortDescription": {
                  "text": "未使用的声明"
                },
                "fullDescription": {
                  "text": "报告未使用的类、方法和字段。 示例： 'public class Department {\n      private Organization myOrganization;\n  }' 在这里，'Department' 显式引用 'Organization'，但如果 'Department' 类未使用，则此检查将报告这两个类。 该检查还会报告其方法、所有方法实现/重写器未使用的形参，以及已声明但未使用的局部变量。 有关更多信息，请参阅 Java 中的相同检查。",
                  "markdown": "报告未使用的类、方法和字段。\n\n**示例：**\n\n\n      public class Department {\n          private Organization myOrganization;\n      }\n\n在这里，`Department` 显式引用 `Organization`，但如果 `Department` 类未使用，则此检查将报告这两个类。\n\n\n该检查还会报告其方法、所有方法实现/重写器未使用的形参，以及已声明但未使用的局部变量。\n\n有关更多信息，请参阅 Java 中的相同检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnusedDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/声明冗余",
                      "index": 132,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyLoopStatementThatDoesntLoop",
                "shortDescription": {
                  "text": "不循环的循环语句"
                },
                "fullDescription": {
                  "text": "报告语句体保证最多执行一次的 'for' 或 'while' 语句。 虽然可以有意编写此类语句，但它们通常表明存在错误。 示例： 'for (int i in 0..<10) {\n    return\n  }'",
                  "markdown": "报告语句体保证最多执行一次的 `for` 或 `while` 语句。 虽然可以有意编写此类语句，但它们通常表明存在错误。\n\n**示例：**\n\n\n      for (int i in 0..<10) {\n        return\n      }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyLoopStatementThatDoesntLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyResultOfIncrementOrDecrementUsed",
                "shortDescription": {
                  "text": "使用增量或减量的结果"
                },
                "fullDescription": {
                  "text": "报告嵌套在其他表达式中的增量或减量表达式。 此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。",
                  "markdown": "报告嵌套在其他表达式中的增量或减量表达式。\n\n\n此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyResultOfIncrementOrDecrementUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/可能引起混淆的代码结构",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyReturnFromClosureCanBeImplicit",
                "shortDescription": {
                  "text": "'return' 语句可以是隐式语句"
                },
                "fullDescription": {
                  "text": "报告闭包末尾可以设置为隐式的返回声明。 Groovy 闭包隐式返回其中最后一条语句的值。 示例： 'def foo = {\n    return 1\n  }' 在应用快速修复后： 'def foo = {\n    1\n  }'",
                  "markdown": "报告闭包末尾可以设置为隐式的返回声明。\n\n\nGroovy 闭包隐式返回其中最后一条语句的值。\n\n**示例：**\n\n\n      def foo = {\n        return 1\n      }\n\n在应用快速修复后：\n\n\n      def foo = {\n        1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyReturnFromClosureCanBeImplicit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/控制流问题",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySynchronizationOnNonFinalField",
                "shortDescription": {
                  "text": "在非 final 字段上同步"
                },
                "fullDescription": {
                  "text": "报告其中的锁定表达式为非 'final' 字段的 'synchronized' 语句。 此类语句不太可能包含有用的语义，因为不同的线程即便在对同一对象操作时也可能在不同的对象上锁定。",
                  "markdown": "报告其中的锁定表达式为非 `final` 字段的 `synchronized` 语句。\n\n\n此类语句不太可能包含有用的语义，因为不同的线程即便在对同一对象操作时也可能在不同的对象上锁定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySynchronizationOnNonFinalField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/线程问题",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "HtmlUnknownBooleanAttribute",
                "shortDescription": {
                  "text": "不正确的布尔特性"
                },
                "fullDescription": {
                  "text": "报告不含值的 HTML 非布尔特性。 建议配置不应报告的特性。",
                  "markdown": "报告不含值的 HTML 非布尔特性。 建议配置不应报告的特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownBooleanAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentLineSeparators",
                "shortDescription": {
                  "text": "行分隔符不一致"
                },
                "fullDescription": {
                  "text": "报告包含的行分隔符与项目设置中指定的行分隔符不同的文件。 例如，如果在设置 | 编辑器 | 代码样式 | 行分隔符中将行分隔符设置为 '\\n'，而您正在编辑的文件使用 '\\r\\n' 作为行分隔符，就会触发该检查。 该检查还会警告留意文件中的混合行分隔符。",
                  "markdown": "报告包含的行分隔符与项目设置中指定的行分隔符不同的文件。\n\n例如，如果在[设置 \\| 编辑器 \\| 代码样式 \\| 行分隔符](settings://preferences.sourceCode?Line%20separator)中将行分隔符设置为 `\\n`，而您正在编辑的文件使用 `\\r\\n` 作为行分隔符，就会触发该检查。\n\n该检查还会警告留意文件中的混合行分隔符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentLineSeparators",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSuppression",
                "shortDescription": {
                  "text": "冗余禁止"
                },
                "fullDescription": {
                  "text": "报告由于它们所影响的检查在此上下文中不再适用而可以安全移除的下列元素： '@SuppressWarning' 注解或 '// noinspection' 行注释，或 '/** noinspection */' JavaDoc 注释 示例： 'public class C {\n // 符号已经为 private，\n // 但周围仍有注解\n  @SuppressWarnings({\"WeakerAccess\"})\n private boolean CONST = true;\n void f() {\n    CONST = false;\n  }\n}'",
                  "markdown": "报告由于它们所影响的检查在此上下文中不再适用而可以安全移除的下列元素：\n\n* `@SuppressWarning` 注解或\n* `// noinspection` 行注释，或\n* `/** noinspection */` JavaDoc 注释\n\n示例：\n\n\n    public class C {\n     // 符号已经为 private，\n     // 但周围仍有注解\n      @SuppressWarnings({\"WeakerAccess\"})\n     private boolean CONST = true;\n     void f() {\n        CONST = false;\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSuppression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProblematicWhitespace",
                "shortDescription": {
                  "text": "有问题的空格"
                },
                "fullDescription": {
                  "text": "报告以下问题： 当代码样式配置为只使用空格时使用制表符进行缩进。 当代码样式配置为只使用制表符时使用空格进行缩进。 当代码样式配置为使用智能制表符时，使用空格进行缩进，以及使用制表符进行对齐。",
                  "markdown": "报告以下问题：\n\n* 当代码样式配置为只使用空格时使用制表符进行缩进。\n* 当代码样式配置为只使用制表符时使用空格进行缩进。\n* 当代码样式配置为使用智能制表符时，使用空格进行缩进，以及使用制表符进行对齐。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProblematicWhitespace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownTarget",
                "shortDescription": {
                  "text": "链接中未解析的文件"
                },
                "fullDescription": {
                  "text": "报告链接中未解析的文件。",
                  "markdown": "报告链接中未解析的文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownTarget",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LongLine",
                "shortDescription": {
                  "text": "行长度超出代码样式的允许范围"
                },
                "fullDescription": {
                  "text": "报告比在设置 | 编辑器 | 代码样式 | 常规中指定的强制换行位置参数长的行。",
                  "markdown": "报告比在[设置 \\| 编辑器 \\| 代码样式 \\| 常规](settings://preferences.sourceCode?Hard%20wrap%20at)中指定的**强制换行位置**参数长的行。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LongLine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlWrongRootElement",
                "shortDescription": {
                  "text": "错误的根元素"
                },
                "fullDescription": {
                  "text": "报告与 '<doctype>' 标记中指定的名称不同的根标记名称。",
                  "markdown": "报告与 `<doctype>` 标记中指定的名称不同的根标记名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlWrongRootElement",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownAttribute",
                "shortDescription": {
                  "text": "未知特性"
                },
                "fullDescription": {
                  "text": "报告未知的 HTML 特性。 建议配置不应报告的特性。",
                  "markdown": "报告未知的 HTML 特性。 建议配置不应报告的特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRedundantEscape",
                "shortDescription": {
                  "text": "冗余字符转义"
                },
                "fullDescription": {
                  "text": "报告可以替换为保留其含义的非转义字符的冗余字符转义序列。 许多在字符类外部必需的转义序列在字符类的方括号 '[]' 内部冗余。 尽管某些方言（JavaScript、Python 等）允许在字符类外部使用未转义的左大括号 '{'，但这样可能会导致混乱并降低模式的可移植性，因为某些方言要求将大括号作为字符进行转义。 因此，该检查不会报告转义的左大括号。 示例： '\\-\\;[\\.]' 在应用快速修复后： '-;[.]' 忽略转义的右括号 '}' 和 ']' 选项可以指定当 RegExp 方言允许在字符类外部使用未转义的 '\\}' 和 '\\]' 时是否报告它们。 2017.3 最新变化",
                  "markdown": "报告可以替换为保留其含义的非转义字符的冗余字符转义序列。 许多在字符类外部必需的转义序列在字符类的方括号 `[]` 内部冗余。\n\n\n尽管某些方言（JavaScript、Python 等）允许在字符类外部使用未转义的左大括号 `{`，但这样可能会导致混乱并降低模式的可移植性，因为某些方言要求将大括号作为字符进行转义。\n因此，该检查不会报告转义的左大括号。\n\n**示例：**\n\n\n      \\-\\;[\\.]\n\n在应用快速修复后：\n\n\n      -;[.]\n\n\n**忽略转义的右括号 '}' 和 '\\]'** 选项可以指定当 RegExp 方言允许在字符类外部使用未转义的 `\\}` 和 `\\]` 时是否报告它们。\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpRedundantEscape",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CustomRegExpInspection",
                "shortDescription": {
                  "text": "自定义正则表达式检查"
                },
                "fullDescription": {
                  "text": "自定义正则表达式检查",
                  "markdown": "自定义正则表达式检查"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CustomRegExpInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectFormatting",
                "shortDescription": {
                  "text": "格式设置不正确"
                },
                "fullDescription": {
                  "text": "报告代码不遵循项目代码样式设置时出现的格式问题。 此检查与需要第三方格式化程序进行代码格式设置的语言（例如启用了 CLangFormat 的 Go 或 C 语言）不兼容。",
                  "markdown": "报告代码不遵循项目代码样式设置时出现的格式问题。\n\n\n此检查与需要第三方格式化程序进行代码格式设置的语言（例如启用了 CLangFormat 的 Go 或 C 语言）不兼容。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IncorrectFormatting",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlExtraClosingTag",
                "shortDescription": {
                  "text": "冗余结束标记"
                },
                "fullDescription": {
                  "text": "报告空元素的冗余结束标记，例如 'img' 或 'br'。 示例： '<html>\n    <body>\n      <br></br>\n    </body>\n  </html>' 在应用快速修复后： '<html>\n    <body>\n      <br>\n    </body>\n  </html>'",
                  "markdown": "报告空元素的冗余结束标记，例如 `img` 或 `br`。\n\n**示例：**\n\n\n      <html>\n        <body>\n          <br></br>\n        </body>\n      </html>\n\n在应用快速修复后：\n\n\n      <html>\n        <body>\n          <br>\n        </body>\n      </html>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlExtraClosingTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpUnexpectedAnchor",
                "shortDescription": {
                  "text": "起始或结束定位点在意外位置"
                },
                "fullDescription": {
                  "text": "报告不在模式开头的 '^' 或 '\\A' 定位标记以及不在模式末尾的 '$'、'\\Z' 或 '\\z' 定位标记。 如果这些正则表达式定位标记位于错误的位置，则会阻止模式与任何对象匹配。 对于 '^' 和 '$' 定位标记，则很可能是指文字字符，并且忘记了转义。 示例： '(Price $10)' 2018.1 最新变化",
                  "markdown": "报告不在模式开头的 `^` 或 `\\A` 定位标记以及不在模式末尾的 `$`、`\\Z` 或 `\\z` 定位标记。 如果这些正则表达式定位标记位于错误的位置，则会阻止模式与任何对象匹配。 对于 `^` 和 `$` 定位标记，则很可能是指文字字符，并且忘记了转义。\n\n**示例：**\n\n\n      (Price $10)\n\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpUnexpectedAnchor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SpellCheckingInspection",
                "shortDescription": {
                  "text": "拼写错误"
                },
                "fullDescription": {
                  "text": "报告代码、注释和文字中的拼写错误并一键修正。",
                  "markdown": "报告代码、注释和文字中的拼写错误并一键修正。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SpellCheckingInspection",
                    "ideaSeverity": "TYPO",
                    "qodanaSeverity": "Low"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "校对",
                      "index": 90,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckXmlFileWithXercesValidator",
                "shortDescription": {
                  "text": "外部验证失败"
                },
                "fullDescription": {
                  "text": "报告 Xerces 验证程序检测到的 XML 文件和指定 DTD 或架构的差异。",
                  "markdown": "报告 Xerces 验证程序检测到的 XML 文件和指定 DTD 或架构的差异。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CheckXmlFileWithXercesValidator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownTag",
                "shortDescription": {
                  "text": "未知标记"
                },
                "fullDescription": {
                  "text": "报告未知的 HTML 标记。 建议配置不应报告的标记。",
                  "markdown": "报告未知的 HTML 标记。 建议配置不应报告的标记。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpEscapedMetaCharacter",
                "shortDescription": {
                  "text": "转义元字符"
                },
                "fullDescription": {
                  "text": "报告转义元字符。 某些正则表达式代码样式指定应将元字符放在字符类中，从而使正则表达式更易于理解。 此检查不会警告元字符 '[', ']' 和 '^'，因为这些字符可能需要在字符类中进行额外的转义。 示例： '\\d+\\.\\d+' 在应用快速修复后： '\\d+[.]\\d+' 2017.1 最新变化",
                  "markdown": "报告转义元字符。 某些正则表达式代码样式指定应将元字符放在字符类中，从而使正则表达式更易于理解。 此检查不会警告元字符 `[`, `]` 和 `^`，因为这些字符可能需要在字符类中进行额外的转义。\n\n**示例：**\n\n\n      \\d+\\.\\d+\n\n在应用快速修复后：\n\n\n      \\d+[.]\\d+\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpEscapedMetaCharacter",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlHighlighting",
                "shortDescription": {
                  "text": "XML 高亮显示"
                },
                "fullDescription": {
                  "text": "报告批量代码检查结果中的 XML 验证问题。",
                  "markdown": "报告批量代码检查结果中的 XML 验证问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlHighlighting",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlDuplicatedId",
                "shortDescription": {
                  "text": "重复 'id' 特性"
                },
                "fullDescription": {
                  "text": "报告 XML 中重复的 'id' 特性。",
                  "markdown": "报告 XML 中重复的 `id` 特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlDuplicatedId",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpDuplicateCharacterInClass",
                "shortDescription": {
                  "text": "字符类中存在重复字符"
                },
                "fullDescription": {
                  "text": "报告正则表达式字符类中的重复字符。 重复字符是多余的，可将其移除而不改变正则表达式的语义。 示例： '[aabc]' 在应用快速修复后： '[abc]'",
                  "markdown": "报告正则表达式字符类中的重复字符。 重复字符是多余的，可将其移除而不改变正则表达式的语义。\n\n**示例：**\n\n\n      [aabc]\n\n在应用快速修复后：\n\n\n      [abc]\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpDuplicateCharacterInClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlUnboundNsPrefix",
                "shortDescription": {
                  "text": "未绑定的命名空间前缀"
                },
                "fullDescription": {
                  "text": "报告 XML 中未绑定的命名空间前缀。",
                  "markdown": "报告 XML 中未绑定的命名空间前缀。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlUnboundNsPrefix",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RequiredAttributes",
                "shortDescription": {
                  "text": "缺少必要的特性"
                },
                "fullDescription": {
                  "text": "报告 XML/HTML 标记中缺少的强制特性。 建议配置不应报告的特性。",
                  "markdown": "报告 XML/HTML 标记中缺少的强制特性。 建议配置不应报告的特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RequiredAttributes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlUnusedNamespaceDeclaration",
                "shortDescription": {
                  "text": "未使用的架构声明"
                },
                "fullDescription": {
                  "text": "报告 XML 中未使用的命名空间声明或位置提示。",
                  "markdown": "报告 XML 中未使用的命名空间声明或位置提示。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlUnusedNamespaceDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRedundantClassElement",
                "shortDescription": {
                  "text": "冗余的 '\\d', '[:digit:]'，或 '\\D' 类元素"
                },
                "fullDescription": {
                  "text": "报告在同一个类中与 '\\w' 或 '[:word:]'（带 '\\W' 的 '\\D'）一起使用且可移除的冗余 '\\d' 或 '[:digit:]'。 示例： '[\\w\\d]' 在应用快速修复后： '[\\w]' 2022.2 最新变化",
                  "markdown": "报告在同一个类中与 `\\w` 或 `[:word:]`（带 `\\W` 的 `\\D`）一起使用且可移除的冗余 `\\d` 或 `[:digit:]`。\n\n**示例：**\n\n\n      [\\w\\d]\n\n在应用快速修复后：\n\n\n      [\\w]\n\n2022.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpRedundantClassElement",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpSimplifiable",
                "shortDescription": {
                  "text": "正则表达式可以简化"
                },
                "fullDescription": {
                  "text": "报告可以简化的正则表达式。 示例： '[a] xx* [ah-hz]' 在应用快速修复后： 'a x+ [ahz]' 2022.1 最新变化",
                  "markdown": "报告可以简化的正则表达式。\n\n**示例：**\n\n\n      [a] xx* [ah-hz]\n\n在应用快速修复后：\n\n\n      a x+ [ahz]\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpSimplifiable",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpEmptyAlternationBranch",
                "shortDescription": {
                  "text": "替代项中存在空分支"
                },
                "fullDescription": {
                  "text": "报告正则表达式替换中的空分支。 空分支只能匹配空字符串，在大多数情况下，这并不是我们的目的。 此检查不会报告位于替换开头或末尾的单个空分支。 示例： '(alpha||bravo)' 在应用快速修复后： '(alpha|bravo)' 2017.2 最新变化",
                  "markdown": "报告正则表达式替换中的空分支。 空分支只能匹配空字符串，在大多数情况下，这并不是我们的目的。 此检查不会报告位于替换开头或末尾的单个空分支。\n\n**示例：**\n\n\n      (alpha||bravo)\n\n在应用快速修复后：\n\n\n      (alpha|bravo)\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpEmptyAlternationBranch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlPathReference",
                "shortDescription": {
                  "text": "未解析的文件引用"
                },
                "fullDescription": {
                  "text": "报告 XML 中未解析的文件引用。",
                  "markdown": "报告 XML 中未解析的文件引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlPathReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpUnnecessaryNonCapturingGroup",
                "shortDescription": {
                  "text": "不必要的非捕获组"
                },
                "fullDescription": {
                  "text": "报告不必要的非捕获组（对匹配结果无影响）。 示例： 'Everybody be cool, (?:this) is a robbery!' 在应用快速修复后： 'Everybody be cool, this is a robbery!' 2021.1 最新变化",
                  "markdown": "报告不必要的非捕获组（对匹配结果无影响）。\n\n**示例：**\n\n\n      Everybody be cool, (?:this) is a robbery!\n\n在应用快速修复后：\n\n\n      Everybody be cool, this is a robbery!\n\n2021.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpUnnecessaryNonCapturingGroup",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TodoComment",
                "shortDescription": {
                  "text": "TODO 注释"
                },
                "fullDescription": {
                  "text": "报告代码中的 TODO 注释。 您可以在设置 | 编辑器 | TODO 中配置 TODO 注释的格式。 启用只对没有任何详细信息的 TODO 注释发出警告选项，以仅对不提供有关应完成任务的任何描述的空 TODO 注释发出警告。 禁用可报告所有 TODO 注释。",
                  "markdown": "报告代码中的 **TODO** 注释。\n\n您可以在[设置 \\| 编辑器 \\| TODO](settings://preferences.toDoOptions) 中配置 **TODO** 注释的格式。\n\n启用**只对没有任何详细信息的 TODO 注释发出警告**选项，以仅对不提供有关应完成任务的任何描述的空 TODO 注释发出警告。 禁用可报告所有 TODO 注释。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TodoComment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Json5StandardCompliance",
                "shortDescription": {
                  "text": "符合 JSON5 标准"
                },
                "fullDescription": {
                  "text": "报告 JSON5 文件中语言规范不一致的情况。",
                  "markdown": "报告 JSON5 文件中[语言规范](http://json5.org)不一致的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Json5StandardCompliance",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlWrongAttributeValue",
                "shortDescription": {
                  "text": "特性值错误"
                },
                "fullDescription": {
                  "text": "报告不正确的 HTML 特性值。",
                  "markdown": "报告不正确的 HTML 特性值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlWrongAttributeValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlDefaultAttributeValue",
                "shortDescription": {
                  "text": "包含默认值的冗余特性"
                },
                "fullDescription": {
                  "text": "报告对 XML 特性默认值的冗余赋值。",
                  "markdown": "报告对 XML 特性默认值的冗余赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlDefaultAttributeValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonSchemaCompliance",
                "shortDescription": {
                  "text": "符合 JSON 架构"
                },
                "fullDescription": {
                  "text": "报告 JSON 文件与分配给它的 JSON 模式之间的不一致。",
                  "markdown": "报告 JSON 文件与分配给它的 [JSON 模式](https://json-schema.org)之间的不一致。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JsonSchemaCompliance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyDirectory",
                "shortDescription": {
                  "text": "空目录"
                },
                "fullDescription": {
                  "text": "报告空目录。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用仅报告位于源文件夹下的空目录选项可以仅报告源根下的目录。",
                  "markdown": "报告空目录。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**仅报告位于源文件夹下的空目录**选项可以仅报告源根下的目录。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyDirectory",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckDtdRefs",
                "shortDescription": {
                  "text": "未解析的 DTD 引用"
                },
                "fullDescription": {
                  "text": "报告特定于 DTD 的引用（例如，对 XML 实体或 DTD 元素声明的引用）中的不一致。 适用于 DTD 和 XML 文件。",
                  "markdown": "报告特定于 DTD 的引用（例如，对 XML 实体或 DTD 元素声明的引用）中的不一致。 适用于 DTD 和 XML 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CheckDtdRefs",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonAsciiCharacters",
                "shortDescription": {
                  "text": "非 ASCII 字符"
                },
                "fullDescription": {
                  "text": "报告在异常上下文中使用非 ASCII 符号的代码元素。 示例： 标识符、字符串或注释中使用的非 ASCII 字符。 使用不同语言编写的标识符，例如带有使用西里尔文编写的字母 'C' 的 'myСollection'。 包含 Unicode 符号（如长划线和箭头）的注释或字符串。",
                  "markdown": "报告在异常上下文中使用非 ASCII 符号的代码元素。\n\n示例：\n\n* 标识符、字符串或注释中使用的非 ASCII 字符。\n* 使用不同语言编写的标识符，例如带有使用西里尔文编写的字母 **C** 的 `my`**С**`ollection`。\n* 包含 Unicode 符号（如长划线和箭头）的注释或字符串。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonAsciiCharacters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "国际化",
                      "index": 111,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LossyEncoding",
                "shortDescription": {
                  "text": "有损编码"
                },
                "fullDescription": {
                  "text": "报告由于当前文档编码而无法显示的字符。 示例： 如果在带有 US-ASCII 字符集的文档中键入国际字符，保存时会丢失某些字符。 如果加载使用 ISO-8859-1 一字节字符集的 UTF-8 编码文件，某些字符将无法正确显示。 要解决此问题，可以直接在文件中指定编码来更改文件编码，例如编辑 XML 文件的 XML prolog 中的 'encoding=' 特性，或者在设置 | 编辑器 | 文件编码中更改相应选项。",
                  "markdown": "报告由于当前文档编码而无法显示的字符。\n\n示例：\n\n* 如果在带有 **US-ASCII** 字符集的文档中键入国际字符，保存时会丢失某些字符。\n* 如果加载使用 **ISO-8859-1** 一字节字符集的 **UTF-8** 编码文件，某些字符将无法正确显示。\n\n要解决此问题，可以直接在文件中指定编码来更改文件编码，例如编辑 XML 文件的 XML prolog 中的 `encoding=` 特性，或者在**设置 \\| 编辑器 \\| 文件编码**中更改相应选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LossyEncoding",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "国际化",
                      "index": 111,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IgnoreFileDuplicateEntry",
                "shortDescription": {
                  "text": "忽略文件重复项"
                },
                "fullDescription": {
                  "text": "报告忽略文件（例如 .gitignore、.hgignore）中的重复条目（模式）。 这些文件中的重复条目冗余，可以移除。 示例： '# 输出目录\n    /out/\n    /target/\n    /out/'",
                  "markdown": "报告忽略文件（例如 .gitignore、.hgignore）中的重复条目（模式）。 这些文件中的重复条目冗余，可以移除。\n\n示例：\n\n\n        # 输出目录\n        /out/\n        /target/\n        /out/\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IgnoreFileDuplicateEntry",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "版本控制",
                      "index": 116,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonStandardCompliance",
                "shortDescription": {
                  "text": "符合 JSON 标准"
                },
                "fullDescription": {
                  "text": "报告 JSON 文件与语言规范的以下差异： 行或块注释（可配置）。 多个顶层值（用于 JSON Lines 文件，可针对其他文件配置）。 对象或数组中的尾随逗号（可配置）。 用单引号引用的字符串。 属性键不是由双引号引用的字符串。 用 NaN 或正无穷大/负无穷大数值作为浮点文字（可配置）。",
                  "markdown": "报告 JSON 文件与[语言规范](https://tools.ietf.org/html/rfc7159)的以下差异：\n\n* 行或块注释（可配置）。\n* 多个顶层值（用于 JSON Lines 文件，可针对其他文件配置）。\n* 对象或数组中的尾随逗号（可配置）。\n* 用单引号引用的字符串。\n* 属性键不是由双引号引用的字符串。\n* 用 NaN 或正无穷大/负无穷大数值作为浮点文字（可配置）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JsonStandardCompliance",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonSchemaDeprecation",
                "shortDescription": {
                  "text": "弃用的 JSON 属性"
                },
                "fullDescription": {
                  "text": "报告 JSON 文件中弃用的属性。 请注意，JSON 架构规范中尚未定义弃用机制， 并且该检查使用了非标准的扩展 'deprecationMessage'。",
                  "markdown": "报告 JSON 文件中弃用的属性。  \n请注意，JSON 架构规范中尚未定义弃用机制， 并且该检查使用了非标准的扩展 'deprecationMessage'。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JsonSchemaDeprecation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonSchemaRefReference",
                "shortDescription": {
                  "text": "未解析的 '$ref' 和 '$schema' 引用"
                },
                "fullDescription": {
                  "text": "报告 JSON 架构中未解析的 '$ref' 或 '$schema' 路径。",
                  "markdown": "报告 JSON 架构中未解析的 `$ref` 或 `$schema` 路径。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JsonSchemaRefReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SSBasedInspection",
                "shortDescription": {
                  "text": "结构搜索检查"
                },
                "fullDescription": {
                  "text": "允许配置可以应用于您正在编辑的文件的结构搜索/结构替换模板。 所有匹配项都将高亮显示并使用您配置的模板名称标记。 如果您还配置了结构替换模式，相应的替换选项将作为快速修复提供。",
                  "markdown": "允许配置可以应用于您正在编辑的文件的**结构搜索/结构替换**模板。\n\n所有匹配项都将高亮显示并使用您配置的模板名称标记。\n如果您还配置了**结构替换**模式，相应的替换选项将作为快速修复提供。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SSBasedInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "结构搜索",
                      "index": 120,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckValidXmlInScriptTagBody",
                "shortDescription": {
                  "text": "'script' 标记的内容格式错误"
                },
                "fullDescription": {
                  "text": "报告是无效 XML 的 'script' 标记的内容。 示例： '<script type=\"text/javascript\">\n    console.log('<');\n  </script>' 在应用快速修复后： '<script type=\"text/javascript\">\n    console.log('&lt;');\n  </script>'",
                  "markdown": "报告是无效 XML 的 `script` 标记的内容。  \n\n**示例：**\n\n\n      <script type=\"text/javascript\">\n        console.log('<');\n      </script>\n\n在应用快速修复后：\n\n\n      <script type=\"text/javascript\">\n        console.log('&lt;');\n      </script>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CheckValidXmlInScriptTagBody",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpSuspiciousBackref",
                "shortDescription": {
                  "text": "可疑的反向引用"
                },
                "fullDescription": {
                  "text": "报告在运行时无法解析的反向引用。 这意味着反向引用永远无法匹配任何内容。 如果组是在反向引用之后定义的，或者组是在替代项的不同分支中定义的，则反向引用将不可解析。 在其反向引用之后定义的组的示例： '\\1(abc)' 不同分支中的组和反向引用的示例： 'a(b)c|(xy)\\1z' 2022.1 最新变化",
                  "markdown": "报告在运行时无法解析的反向引用。 这意味着反向引用永远无法匹配任何内容。 如果组是在反向引用之后定义的，或者组是在替代项的不同分支中定义的，则反向引用将不可解析。\n\n**在其反向引用之后定义的组的示例：**\n\n\n      \\1(abc)\n\n**不同分支中的组和反向引用的示例：**\n\n\n      a(b)c|(xy)\\1z\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpSuspiciousBackref",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpSingleCharAlternation",
                "shortDescription": {
                  "text": "单字符替代项"
                },
                "fullDescription": {
                  "text": "报告正则表达式中的单一字符替换。 改用一个字符类更简单。 这还可能提高匹配性能。 示例： 'a|b|c|d' 在应用快速修复后： '[abcd]' 2017.1 最新变化",
                  "markdown": "报告正则表达式中的单一字符替换。 改用一个字符类更简单。 这还可能提高匹配性能。\n\n**示例：**\n\n\n      a|b|c|d\n\n在应用快速修复后：\n\n\n      [abcd]\n\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpSingleCharAlternation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckTagEmptyBody",
                "shortDescription": {
                  "text": "空元素内容"
                },
                "fullDescription": {
                  "text": "报告没有内容的 XML 元素。 示例： '<user>\n    <name></name>\n  </user>' 在应用快速修复后： '<user>\n    <name/>\n  </user>'",
                  "markdown": "报告没有内容的 XML 元素。\n\n**示例：**\n\n\n      <user>\n        <name></name>\n      </user>\n\n在应用快速修复后：\n\n\n      <user>\n        <name/>\n      </user>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckTagEmptyBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnresolvedReference",
                "shortDescription": {
                  "text": "未解析的引用"
                },
                "fullDescription": {
                  "text": "报告使用 XML 语法的 RELAX-NG 文件中对命名模式 ('define') 的未解析引用。 建议创建引用的 'define' 元素。",
                  "markdown": "报告使用 XML 语法的 RELAX-NG 文件中对命名模式 (`define`) 的未解析引用。 建议创建引用的 `define` 元素。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "UnresolvedReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "RELAX NG",
                      "index": 123,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlMissingClosingTag",
                "shortDescription": {
                  "text": "缺少结束标记"
                },
                "fullDescription": {
                  "text": "报告不含结束标记的 HTML 元素。 即便在可选的情况下，有些编码样式也要求 HTML 元素包含结束标记。 示例： '<html>\n    <body>\n      <p>Behold!\n    </body>\n  </html>' 在应用快速修复后： '<html>\n    <body>\n      <p>Behold!</p>\n    </body>\n  </html>'",
                  "markdown": "报告不含结束标记的 HTML 元素。 即便在可选的情况下，有些编码样式也要求 HTML 元素包含结束标记。\n\n**示例：**\n\n\n      <html>\n        <body>\n          <p>Behold!\n        </body>\n      </html>\n\n在应用快速修复后：\n\n\n      <html>\n        <body>\n          <p>Behold!</p>\n        </body>\n      </html>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HtmlMissingClosingTag",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownAnchorTarget",
                "shortDescription": {
                  "text": "链接中未解析的片段"
                },
                "fullDescription": {
                  "text": "报告 '#' 符号后面的 URL 中未解析的最后部分。",
                  "markdown": "报告 `#` 符号后面的 URL 中未解析的最后部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownAnchorTarget",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlInvalidId",
                "shortDescription": {
                  "text": "未解析的 'id' 引用"
                },
                "fullDescription": {
                  "text": "报告 XML 中未解析的 'id' 引用。",
                  "markdown": "报告 XML 中未解析的 `id` 引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlInvalidId",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReassignedToPlainText",
                "shortDescription": {
                  "text": "重新分配为纯文本"
                },
                "fullDescription": {
                  "text": "报告被显式重新分配为纯文本文件类型的文件。 这种关联是不必要的，因为平台会根据内容自动检测文本文件。 您可以通过在设置 | 编辑器 | 文件类型 | 文本中移除文件类型关联来关闭此警告。",
                  "markdown": "报告被显式重新分配为纯文本文件类型的文件。 这种关联是不必要的，因为平台会根据内容自动检测文本文件。\n\n您可以通过在**设置 \\| 编辑器 \\| 文件类型 \\| 文本**中移除文件类型关联来关闭此警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReassignedToPlainText",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Annotator",
                "shortDescription": {
                  "text": "注解器"
                },
                "fullDescription": {
                  "text": "报告批处理代码检查运行结果中对此文件至关重要的问题（例如，语法错误）。 与检查不同，这些问题通常会在编辑器中高亮显示，并且无法配置。 这些选项控制此检查所执行检查的作用域： 选项报告语法错误：报告解析器相关问题。 选项报告来自语言特定注解器的问题：报告由为相关语言配置的注解器发现的问题 请参阅自定义语言支持：注解器以了解详情。 选项报告其他高亮显示问题：报告特定于当前文件语言的问题（例如，类型不匹配或未报告的异常）。 请参阅自定义语言支持：高亮显示以了解详情。",
                  "markdown": "报告批处理代码检查运行结果中对此文件至关重要的问题（例如，语法错误）。 与检查不同，这些问题通常会在编辑器中高亮显示，并且无法配置。 这些选项控制此检查所执行检查的作用域：\n\n* 选项**报告语法错误**：报告解析器相关问题。\n* 选项**报告来自语言特定注解器的问题** ：报告由为相关语言配置的注解器发现的问题 请参阅[自定义语言支持：注解器](https://plugins.jetbrains.com/docs/intellij/annotator.html)以了解详情。\n* 选项**报告其他高亮显示问题** ：报告特定于当前文件语言的问题（例如，类型不匹配或未报告的异常）。 请参阅[自定义语言支持：高亮显示](https://plugins.jetbrains.com/docs/intellij/syntax-highlighting-and-error-highlighting.html#semantic-highlighting)以了解详情。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Annotator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonDuplicatePropertyKeys",
                "shortDescription": {
                  "text": "对象文字中的重复键"
                },
                "fullDescription": {
                  "text": "报告对象文字中重复的键。",
                  "markdown": "报告对象文字中重复的键。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JsonDuplicatePropertyKeys",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlDeprecatedElement",
                "shortDescription": {
                  "text": "弃用的符号"
                },
                "fullDescription": {
                  "text": "报告弃用的 XML 元素或特性。 可以通过 XML 注释或带有 'deprecated' 文本的文档标记来标记符号。",
                  "markdown": "报告弃用的 XML 元素或特性。\n\n可以通过 XML 注释或带有 'deprecated' 文本的文档标记来标记符号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlDeprecatedElement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRedundantNestedCharacterClass",
                "shortDescription": {
                  "text": "冗余嵌套字符类"
                },
                "fullDescription": {
                  "text": "报告非必要的嵌套字符类。 示例： '[a-c[x-z]]' 在应用快速修复后： '[a-cx-z]' 2020.2 最新变化",
                  "markdown": "报告非必要的嵌套字符类。\n\n**示例：**\n\n\n      [a-c[x-z]]\n\n在应用快速修复后：\n\n\n      [a-cx-z]\n\n2020.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpRedundantNestedCharacterClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpOctalEscape",
                "shortDescription": {
                  "text": "八进制转义"
                },
                "fullDescription": {
                  "text": "报告八进制转义（容易与反向引用混淆）。 使用十六进制转义可避免混淆。 示例： '\\07' 在应用快速修复后： '\\x07' 2017.1 最新变化",
                  "markdown": "报告八进制转义（容易与反向引用混淆）。 使用十六进制转义可避免混淆。\n\n**示例：**\n\n\n      \\07\n\n在应用快速修复后：\n\n\n      \\x07\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpOctalEscape",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedDefine",
                "shortDescription": {
                  "text": "未使用的定义"
                },
                "fullDescription": {
                  "text": "报告 RELAX-NG 文件 (XML 或 Compact 语法) 中未使用的命名模式 ('define')。 通过另一个文件中的 include 使用的 'define' 元素将被忽略。",
                  "markdown": "报告 RELAX-NG 文件 (XML 或 Compact 语法) 中未使用的命名模式 (`define`)。 通过另一个文件中的 include 使用的 `define` 元素将被忽略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedDefine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "RELAX NG",
                      "index": 123,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpAnonymousGroup",
                "shortDescription": {
                  "text": "匿名捕获组或数字反向引用"
                },
                "fullDescription": {
                  "text": "报告正则表达式中的匿名捕获组和数字反向引用。 只有正则表达式方言支持命名组和命名组引用，才支持这些用法。 命名组和命名反向引用可改进代码可读性，建议改用。 无需捕获时，使用非捕获组，即使用 '(?:xxx)' 而不是 '(xxx)'，可以提高匹配效率和减少需要使用的内存。 示例： '(\\d\\d\\d\\d)\\1' 更好的正则表达式模式如下： '(?<quad>\\d\\d\\d\\d)\\k<quad>' 2017.2 最新变化",
                  "markdown": "报告正则表达式中的匿名捕获组和数字反向引用。 只有正则表达式方言支持命名组和命名组引用，才支持这些用法。 命名组和命名反向引用可改进代码可读性，建议改用。 无需捕获时，使用非捕获组，即使用 `(?:xxx)` 而不是 `(xxx)`，可以提高匹配效率和减少需要使用的内存。\n\n**示例：**\n\n\n      (\\d\\d\\d\\d)\\1\n\n更好的正则表达式模式如下：\n\n\n      (?<quad>\\d\\d\\d\\d)\\k<quad>\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpAnonymousGroup",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlUnresolvedReference",
                "shortDescription": {
                  "text": "未解析的引用"
                },
                "fullDescription": {
                  "text": "报告 XML 中的未解析引用。",
                  "markdown": "报告 XML 中的未解析引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlUnresolvedReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRepeatedSpace",
                "shortDescription": {
                  "text": "连续空格"
                },
                "fullDescription": {
                  "text": "报告正则表达式中的多个连续空格。 由于空格默认不可见，因此，很难了解需要的空格数量。 使用单个空格和计数量词来替换连续空格可以让正则表达式更清晰易懂。 示例： '(     )' 在应用快速修复后： '( {5})' 2017.1 最新变化",
                  "markdown": "报告正则表达式中的多个连续空格。 由于空格默认不可见，因此，很难了解需要的空格数量。 使用单个空格和计数量词来替换连续空格可以让正则表达式更清晰易懂。\n\n**示例：**\n\n\n      (     )\n\n在应用快速修复后：\n\n\n      ( {5})\n\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpRepeatedSpace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpDuplicateAlternationBranch",
                "shortDescription": {
                  "text": "替代项中存在重复分支"
                },
                "fullDescription": {
                  "text": "报告正则表达式替换中的重复分支。 重复分支会降低匹配速度并导致表达式意图不明。 示例： '(alpha|bravo|charlie|alpha)' 在应用快速修复后： '(alpha|bravo|charlie)' 2017.1 最新变化",
                  "markdown": "报告正则表达式替换中的重复分支。 重复分支会降低匹配速度并导致表达式意图不明。\n\n**示例：**\n\n\n      (alpha|bravo|charlie|alpha)\n\n在应用快速修复后：\n\n\n      (alpha|bravo|charlie)\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpDuplicateAlternationBranch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckEmptyScriptTag",
                "shortDescription": {
                  "text": "空标记"
                },
                "fullDescription": {
                  "text": "报告在某些浏览器中无法正常运行的空标记。 示例： '<html>\n    <script/>\n  </html>' 在应用快速修复后： '<html>\n    <script></script>\n  </html>'",
                  "markdown": "报告在某些浏览器中无法正常运行的空标记。\n\n**示例：**\n\n\n      <html>\n        <script/>\n      </html>\n\n在应用快速修复后：\n\n\n      <html>\n        <script></script>\n      </html>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckEmptyScriptTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.editorconfig.editorconfigjetbrains",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "EditorConfigRootDeclarationUniqueness",
                "shortDescription": {
                  "text": "额外顶层声明"
                },
                "fullDescription": {
                  "text": "报告多个顶层声明。 EditorConfig 文件中只能有一个可选的 “root=true” 顶级声明。 不允许使用多个顶级声明。",
                  "markdown": "报告多个顶层声明。 EditorConfig 文件中只能有一个可选的 \"root=true\" 顶级声明。 不允许使用多个顶级声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigRootDeclarationUniqueness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigNumerousWildcards",
                "shortDescription": {
                  "text": "过多通配符"
                },
                "fullDescription": {
                  "text": "报告包含过多通配符的部分。 使用大量通配符可能会导致性能问题。",
                  "markdown": "报告包含过多通配符的部分。 使用大量通配符可能会导致性能问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EditorConfigNumerousWildcards",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigKeyCorrectness",
                "shortDescription": {
                  "text": "未知属性"
                },
                "fullDescription": {
                  "text": "报告 IDE 不支持的属性。 注意：一些 “ij” 域属性可能需要特定的语言插件。",
                  "markdown": "报告 IDE 不支持的属性。 注意：一些 \"ij\" 域属性可能需要特定的语言插件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigKeyCorrectness",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigEncoding",
                "shortDescription": {
                  "text": "文件编码与 EditorConfig 字符集不匹配"
                },
                "fullDescription": {
                  "text": "检查当前文件编码是否与 .editorconfig 文件 \"charset\" 属性中定义的编码匹配。",
                  "markdown": "检查当前文件编码是否与 .editorconfig 文件 \"charset\" 属性中定义的编码匹配。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigEncoding",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigRootDeclarationCorrectness",
                "shortDescription": {
                  "text": "意外的顶层声明"
                },
                "fullDescription": {
                  "text": "报告非预期的顶层声明。 EditorConfig 文件中不允许使用除 “root=true” 之外的顶级声明。",
                  "markdown": "报告非预期的顶层声明。 EditorConfig 文件中不允许使用除 \"root=true\" 之外的顶级声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigRootDeclarationCorrectness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPatternRedundancy",
                "shortDescription": {
                  "text": "重复或冗余模式"
                },
                "fullDescription": {
                  "text": "报告已经有另一个模式定义了具有相同或更广泛文件范围的冗余的文件模式。 例如，在 '[{*.java,*}]' 中，第一个 '*.java' 模式定义了比 '*' 更窄的范围。 这使得第一个模式变得多余并且可以被移除。",
                  "markdown": "报告已经有另一个模式定义了具有相同或更广泛文件范围的冗余的文件模式。 例如，在 `[{*.java,*}]` 中，第一个 `*.java` 模式定义了比 `*` 更窄的范围。 这使得第一个模式变得多余并且可以被移除。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigPatternRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigDeprecatedDescriptor",
                "shortDescription": {
                  "text": "弃用的属性"
                },
                "fullDescription": {
                  "text": "报告不再支持的 EditorConfig 属性。",
                  "markdown": "报告不再支持的 EditorConfig 属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigDeprecatedDescriptor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigShadowedOption",
                "shortDescription": {
                  "text": "被重写的属性"
                },
                "fullDescription": {
                  "text": "报告已在其他部分中定义的属性。 示例： '[*.java]\nindent_size=4\n[{*.java,*.js}]\nindent_size=2' 第二部分也包括所有 '*.java' 文件，但它也重新定义了 indent_size。 因此，值 \"2\" 将用于匹配 '*.java' 的文件。",
                  "markdown": "报告已在其他部分中定义的属性。\n\n示例：\n\n\n    [*.java]\n    indent_size=4\n    [{*.java,*.js}]\n    indent_size=2\n\n第二部分也包括所有 `*.java` 文件，但它也重新定义了 indent_size。 因此，值 \"2\" 将用于匹配 `*.java` 的文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigShadowedOption",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigEmptyHeader",
                "shortDescription": {
                  "text": "空标头"
                },
                "fullDescription": {
                  "text": "报告带有空标题的部分。 部分标题必须包含格式类似于 'gitignore' 支持的格式的文件路径 glob。",
                  "markdown": "报告带有空标题的部分。 部分标题必须包含格式类似于 `gitignore` 支持的格式的文件路径 glob。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigEmptyHeader",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigValueUniqueness",
                "shortDescription": {
                  "text": "非唯一列表值"
                },
                "fullDescription": {
                  "text": "报告值列表中的重复项。",
                  "markdown": "报告值列表中的重复项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigValueUniqueness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigMissingRequiredDeclaration",
                "shortDescription": {
                  "text": "缺少必需声明"
                },
                "fullDescription": {
                  "text": "报告缺少所需声明的属性。 有关更多信息，请参阅文档。",
                  "markdown": "报告缺少所需声明的属性。 有关更多信息，请参阅文档。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigMissingRequiredDeclaration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigSpaceInHeader",
                "shortDescription": {
                  "text": "文件模式中的空格"
                },
                "fullDescription": {
                  "text": "报告影响模式匹配的通配符模式中的空格字符。 如果这些字符不是故意的，则应将其删除。",
                  "markdown": "报告影响模式匹配的通配符模式中的空格字符。 如果这些字符不是故意的，则应将其删除。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EditorConfigSpaceInHeader",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigOptionRedundancy",
                "shortDescription": {
                  "text": "冗余属性"
                },
                "fullDescription": {
                  "text": "报告另一个适用的部分已经包含相同的属性和值的冗余的属性。 示例： '[*]\nindent_size=4\n[*.java]\nindent_size=4' 都适用于 '*.java' 文件并定义相同的 'indent_size' 值。",
                  "markdown": "报告另一个适用的部分已经包含相同的属性和值的冗余的属性。\n\n\n示例：\n\n\n    [*]\n    indent_size=4\n    [*.java]\n    indent_size=4\n\n都适用于 `*.java` 文件并定义相同的 `indent_size` 值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigOptionRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigUnexpectedComma",
                "shortDescription": {
                  "text": "意外逗号"
                },
                "fullDescription": {
                  "text": "报告不能在当前上下文中使用的逗号。 逗号只能用作分隔符来分隔列表中的值。",
                  "markdown": "报告不能在当前上下文中使用的逗号。 逗号只能用作分隔符来分隔列表中的值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigUnexpectedComma",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigCharClassRedundancy",
                "shortDescription": {
                  "text": "不必要的字符类"
                },
                "fullDescription": {
                  "text": "报告由单个字符组成的字符类。 这种类可以简化为一个字符，例如 '[a]'→'a'。",
                  "markdown": "报告由单个字符组成的字符类。 这种类可以简化为一个字符，例如 `[a]`→`a`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigCharClassRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPartialOverride",
                "shortDescription": {
                  "text": "重叠的部分"
                },
                "fullDescription": {
                  "text": "报告当前部分中指定的文件子集与其他部分中的其他子集重叠。 例如：'[{foo,bar}]' 和 '[{foo,bas}]' 都包含 “foo”。",
                  "markdown": "报告当前部分中指定的文件子集与其他部分中的其他子集重叠。 例如：`[{foo,bar}]` 和 `[{foo,bas}]` 都包含 \"foo\"。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EditorConfigPartialOverride",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigEmptySection",
                "shortDescription": {
                  "text": "空部分"
                },
                "fullDescription": {
                  "text": "报告不包含任何 EditorConfig 属性的部分。",
                  "markdown": "报告不包含任何 EditorConfig 属性的部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigEmptySection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigShadowingOption",
                "shortDescription": {
                  "text": "重写属性"
                },
                "fullDescription": {
                  "text": "报告覆盖文件中先前定义的相同属性的属性。 示例： '[*.java]\nindent_size=4\n[{*.java,*.js}]\nindent_size=2' 第二部分同样包含 '[*.java]' 文件，但还将 indent_size 设置为值 2。 因此第一个声明 'indent_size=4' 将被忽略。",
                  "markdown": "报告覆盖文件中先前定义的相同属性的属性。\n\n示例：\n\n\n    [*.java]\n    indent_size=4\n    [{*.java,*.js}]\n    indent_size=2\n\n第二部分同样包含 `[*.java]` 文件，但还将 indent_size 设置为值 2。 因此第一个声明 `indent_size=4` 将被忽略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigShadowingOption",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigListAcceptability",
                "shortDescription": {
                  "text": "意外的值列表"
                },
                "fullDescription": {
                  "text": "报告在不支持列表的属性中使用的值列表。 在这种情况下，只能指定一个值。",
                  "markdown": "报告在不支持列表的属性中使用的值列表。 在这种情况下，只能指定一个值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigListAcceptability",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPatternEnumerationRedundancy",
                "shortDescription": {
                  "text": "不必要的大括号"
                },
                "fullDescription": {
                  "text": "报告要么为空 '{}'，要么只包含一个模式（例如 '{foo}'）而非包含多个模式的列表（例如 '{foo,bar}'）的模式列表。 在这种情况下，大括号会被作为名称的一部分进行处理。 例如，模式 '*.{a}' 将匹配 'my.{a}' 文件而非 'my.a' 文件。",
                  "markdown": "报告要么为空 `{}`，要么只包含一个模式（例如 `{foo}`）而非包含多个模式的列表（例如 `{foo,bar}`）的模式列表。 在这种情况下，大括号会被作为名称的一部分进行处理。 例如，模式 `*.{a}` 将匹配 `my.{a}` 文件而非 `my.a` 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigPatternEnumerationRedundancy",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigReferenceCorrectness",
                "shortDescription": {
                  "text": "无效引用"
                },
                "fullDescription": {
                  "text": "报告未知或类型错误的标识符。",
                  "markdown": "报告未知或类型错误的标识符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigReferenceCorrectness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPairAcceptability",
                "shortDescription": {
                  "text": "意外的键值对"
                },
                "fullDescription": {
                  "text": "报告当前上下文中不允许的键值对。",
                  "markdown": "报告当前上下文中不允许的键值对。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigPairAcceptability",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigNoMatchingFiles",
                "shortDescription": {
                  "text": "无匹配文件"
                },
                "fullDescription": {
                  "text": "报告通配符模式与 '.editorconfig' 文件所在目录下的任何文件都不匹配的部分。",
                  "markdown": "报告通配符模式与 `.editorconfig` 文件所在目录下的任何文件都不匹配的部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigNoMatchingFiles",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigWildcardRedundancy",
                "shortDescription": {
                  "text": "冗余通配符"
                },
                "fullDescription": {
                  "text": "报告在同一部分中使用 “**” 通配符时变得冗余的通配符。 “**” 通配符定义了比其他通配符更广泛的文件集。 因此，同一部分中使用的任何其他通配符都是无效的，可以删除。",
                  "markdown": "报告在同一部分中使用 \"\\*\\*\" 通配符时变得冗余的通配符。\n\n\n\"\\*\\*\" 通配符定义了比其他通配符更广泛的文件集。\n因此，同一部分中使用的任何其他通配符都是无效的，可以删除。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigWildcardRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigHeaderUniqueness",
                "shortDescription": {
                  "text": "EditorConfig 部分不唯一"
                },
                "fullDescription": {
                  "text": "报告定义与其他部分相同的文件模式的部分。",
                  "markdown": "报告定义与其他部分相同的文件模式的部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigHeaderUniqueness",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigValueCorrectness",
                "shortDescription": {
                  "text": "无效属性值"
                },
                "fullDescription": {
                  "text": "报告不符合值限制的属性值。 例如，某些属性可能只能为 “true” 或 “false”、其他属性仅包含整数等。 如果一个值的变体集合有限，请使用代码完成来查看所有变体。",
                  "markdown": "报告不符合值限制的属性值。 例如，某些属性可能只能为 \"true\" 或 \"false\"、其他属性仅包含整数等。 如果一个值的变体集合有限，请使用代码完成来查看所有变体。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigValueCorrectness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigVerifyByCore",
                "shortDescription": {
                  "text": "无效的 .editorconfig 文件"
                },
                "fullDescription": {
                  "text": "使用备份 EditorConfig 核心库验证整个文件，并报告任何失败。 任何此类失败都会阻止 EditorConfig 属性的正确应用。",
                  "markdown": "使用备份 EditorConfig 核心库验证整个文件，并报告任何失败。 任何此类失败都会阻止 EditorConfig 属性的正确应用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigVerifyByCore",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigCharClassLetterRedundancy",
                "shortDescription": {
                  "text": "重复的字符类字母"
                },
                "fullDescription": {
                  "text": "报告 EditorConfig 部分中在字符类中包含重复字符的通配符模式，例如 '[aa]'。",
                  "markdown": "报告 EditorConfig 部分中在字符类中包含重复字符的通配符模式，例如 `[aa]`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigCharClassLetterRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigUnusedDeclaration",
                "shortDescription": {
                  "text": "未使用的声明"
                },
                "fullDescription": {
                  "text": "报告未使用的声明。 可以删除此类声明。",
                  "markdown": "报告未使用的声明。 可以删除此类声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigUnusedDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.java-i18n",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "UnusedMessageFormatParameter",
                "shortDescription": {
                  "text": "缺少消息格式形参"
                },
                "fullDescription": {
                  "text": "报告类似于 'java.text.MessageFormat' 格式字符串但不使用某些 '{xx}' 类型形参的属性值。 示例： '#未使用形参 {0}\nerror.message=第 {1} 行有问题'",
                  "markdown": "报告类似于 `java.text.MessageFormat` 格式字符串但不使用某些 `{xx}` 类型形参的属性值。\n\n示例：\n\n\n    #未使用形参 {0}\n    error.message=第 {1} 行有问题\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedMessageFormatParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertToBasicLatin",
                "shortDescription": {
                  "text": "非基本拉丁字符"
                },
                "fullDescription": {
                  "text": "报告文字中的非基本拉丁字符，并建议将它们替换为 unicode 实体。 示例： '// © 2021\n  char c = '©';\n  String s = \"Áî\";'\n 在应用快速修复后： '// &copy; 2021\n  char c = '\\u00a9';\n  String s = \"\\u00c1\\u00ee\";'",
                  "markdown": "报告文字中的非基本拉丁字符，并建议将它们替换为 unicode 实体。\n\n示例：\n\n\n      // © 2021\n      char c = '©';\n      String s = \"Áî\";\n\n在应用快速修复后：\n\n\n      // &copy; 2021\n      char c = '\\u00a9';\n      String s = \"\\u00c1\\u00ee\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertToBasicLatin",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentResourceBundle",
                "shortDescription": {
                  "text": "不一致的资源包"
                },
                "fullDescription": {
                  "text": "报告资源包中包含的属性文件中的问题。 报告缺失的翻译 使用此选项可以报告在父属性文件中包含但在继承属性中缺失的属性（除非它是语言方言）。 示例： '# messages.properties\n    abc=xxx\n\n    # messages_fr.properties\n    # 空文件' 空属性 'abc' 将被报告为未翻译。 报告不一致的属性 使用此选项可以报告在继承属性文件中包含但在父属性（如果没有父属性，则在同级属性）中缺失的属性。 示例： '# messages.properties\n    # 空文件\n\n    # messages_fr.properties\n    abc=xxx' 此处的属性 'abc' 翻译不适用于法语以外的任何语言，因此，将在（默认）属性文件 'messages.properties' 中报告为缺失。 报告使用相同值重写的属性 使用此选项可以报告逐字复制粘贴到多个属性文件中的属性。 示例： '# messages.properties\n    abc=xxx\n\n    # messages_fr.properties\n    abc=xxx' 属性 'abc' 将在文件 'messages_fr.properties' 中报告为不必要地继承。 报告使用不同的占位符重写的属性 使用此选项可以检查被重写的属性中的占位符一致性。 示例： '# messages.properties\n    qwe={0}xxx{1}\n    abc={0}yyy{1}\n\n    # messages_fr.properties\n    qwe={0}xxx{0}xxx{1}\n    abc={0}yyy' 属性 'abc' 将被报告为包含消息格式占位符的属性，与 'messages.properties' 不对应。 报告使用不同值结尾重写的属性 使用此选项可以检查被重写的属性中的结尾一致性。 示例： '# messages.properties\n    abc=xxxzzz\n\n    # messages_fr.properties\n    abc=xxx;' 属性 'abc' 将被报告为以特殊符号 ('!' / '?' / '.' / ':' / ';') 结尾，而 'messages.properties' 中的父值则不会。",
                  "markdown": "报告资源包中包含的属性文件中的问题。\n\n* **报告缺失的翻译**   \n\n  使用此选项可以报告在父属性文件中包含但在继承属性中缺失的属性（除非它是语言方言）。   \n\n  示例：\n\n\n          # messages.properties\n          abc=xxx\n\n          # messages_fr.properties\n          # 空文件\n        \n  空属性 `abc` 将被报告为未翻译。   \n\n* **报告不一致的属性**   \n\n  使用此选项可以报告在继承属性文件中包含但在父属性（如果没有父属性，则在同级属性）中缺失的属性。   \n\n  示例：\n\n\n          # messages.properties\n          # 空文件\n\n          # messages_fr.properties\n          abc=xxx\n        \n  此处的属性 `abc` 翻译不适用于法语以外的任何语言，因此，将在（默认）属性文件 `messages.properties` 中报告为缺失。   \n\n* **报告使用相同值重写的属性**   \n\n  使用此选项可以报告逐字复制粘贴到多个属性文件中的属性。  \n\n  示例：\n\n\n          # messages.properties\n          abc=xxx\n\n          # messages_fr.properties\n          abc=xxx\n        \n  属性 `abc` 将在文件 `messages_fr.properties` 中报告为不必要地继承。   \n\n* **报告使用不同的占位符重写的属性**   \n\n  使用此选项可以检查被重写的属性中的占位符一致性。   \n\n  示例：\n\n\n          # messages.properties\n          qwe={0}xxx{1}\n          abc={0}yyy{1}\n\n          # messages_fr.properties\n          qwe={0}xxx{0}xxx{1}\n          abc={0}yyy\n        \n  属性 `abc` 将被报告为包含消息格式占位符的属性，与 `messages.properties` 不对应。   \n\n* **报告使用不同值结尾重写的属性**   \n\n  使用此选项可以检查被重写的属性中的结尾一致性。   \n\n  示例：\n\n\n          # messages.properties\n          abc=xxxzzz\n\n          # messages_fr.properties\n          abc=xxx;\n        \n  属性 `abc` 将被报告为以特殊符号 (`!` / `?` / `.` / `:` / `;`) 结尾，而 `messages.properties` 中的父值则不会。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "InconsistentResourceBundle",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HardCodedStringLiteral",
                "shortDescription": {
                  "text": "硬编码字符串"
                },
                "fullDescription": {
                  "text": "报告硬编码 'String' 文字的任何实例。 硬编码的 'String' 文字在国际化环境中可能是错误的。 此检查不会报告空字符串和仅包含空格的字符串。 可以使用快速修复将字符串文字转换为 'java.util.ResourceBundle.getString()' 方法调用。",
                  "markdown": "报告硬编码 `String` 文字的任何实例。\n\n硬编码的 `String` 文字在国际化环境中可能是错误的。 此检查不会报告空字符串和仅包含空格的字符串。 可以使用快速修复将字符串文字转换为 `java.util.ResourceBundle.getString()` 方法调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HardCodedStringLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DialogTitleCapitalization",
                "shortDescription": {
                  "text": "错误的字符串大小写"
                },
                "fullDescription": {
                  "text": "报告方法形参中的字符串和使用 '@Nls' 注解的返回值，并将形参大写以符合大多数平台 UI 指南中的大写规则。 示例： 'void setTitle(@NlsContexts.DialogTitle String title) {}\n  setTitle(\"This is sentence capitalization but should be title\");' 在应用快速修复后： 'setTitle(\"This Is Sentence Capitalization but Should Be Title\");'",
                  "markdown": "报告方法形参中的字符串和使用 `@Nls` 注解的返回值，并将形参大写以符合大多数平台 UI 指南中的大写规则。\n\n**示例：**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\n在应用快速修复后：\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DialogTitleCapitalization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnresolvedPropertyKey",
                "shortDescription": {
                  "text": "无效属性健"
                },
                "fullDescription": {
                  "text": "报告传递给形参注解为 '@PropertyKey' 的方法的无效实参。 这些实参应为相应属性文件中的有效属性键。 此外，该检查还将验证 '@PropertyKey' 注解的 'resourceBundle' 实参是否为现有的资源包。 使用该快速修复可以创建新属性或选择现有属性。 示例： '@PropertyKey(resourceBundle = \"myBundle\") String value = \"invalid.key\";'",
                  "markdown": "报告传递给形参注解为 `@PropertyKey` 的方法的无效实参。\n\n这些实参应为相应属性文件中的有效属性键。\n此外，该检查还将验证 `@PropertyKey` 注解的 `resourceBundle` 实参是否为现有的资源包。\n\n\n使用该快速修复可以创建新属性或选择现有属性。\n\n示例：\n\n\n      @PropertyKey(resourceBundle = \"myBundle\") String value = \"invalid.key\";\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "UnresolvedPropertyKey",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/属性文件",
                      "index": 124,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousLocalesLanguages",
                "shortDescription": {
                  "text": "可疑的资源包区域设置语言"
                },
                "fullDescription": {
                  "text": "报告语言代码不受 Java 支持的区域设置。",
                  "markdown": "报告语言代码不受 Java 支持的区域设置。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousLocalesLanguages",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateStringLiteralInspection",
                "shortDescription": {
                  "text": "复制字符串文字"
                },
                "fullDescription": {
                  "text": "报告整个项目中在不更改的情况下复制的字符串文字。 提供了两个快速修复。 一个是为重复的字符串引入一个常量并在整个项目中使用它，另一个是显示特定字符串文字的所有重复项的位置。 示例： 'class C1 { String CONST1 = \"duplicate string\"; }\n  class C2 { String CONST2 = \"duplicate string\"; }' 配置检查： 使用最小字符串长度字段设置检测重复项所需的最小字符串长度。 使用忽略@PropertyKey 表达式选项可忽略作为实参传递给使用 'org.jetbrains.annotations.PropertyKey' 注解的方法的字符串。",
                  "markdown": "报告整个项目中在不更改的情况下复制的字符串文字。 提供了两个快速修复。 一个是为重复的字符串引入一个常量并在整个项目中使用它，另一个是显示特定字符串文字的所有重复项的位置。\n\n示例：\n\n\n      class C1 { String CONST1 = \"duplicate string\"; }\n      class C2 { String CONST2 = \"duplicate string\"; }\n\n配置检查：\n\n* 使用**最小字符串长度**字段设置检测重复项所需的最小字符串长度。\n* 使用**忽略@PropertyKey 表达式** 选项可忽略作为实参传递给使用 ` org.jetbrains.annotations.PropertyKey ` 注解的方法的字符串。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateStringLiteralInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.gradle",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "ForeignDelegate",
                "shortDescription": {
                  "text": "可能错误地调用了 Gradle 方法"
                },
                "fullDescription": {
                  "text": "检测可能位置错误的 Gradle 方法调用。 Gradle buildscripts 包含许多嵌套闭包，使得代码结构类似于标记语言。 由于 DSL 语言的行为，可以在外部闭包中编写的方法也可以在内部闭包中使用。 此类方法在其范围之外编写时可能没有任何意义。 有时可能很难发现这种情况。 此检查的目的就是发现此类方法。 示例： 'repositories {\n  // 'repositories' 的委托具有方法 'exclusiveContent'，可在此处编写\n  maven {\n    // 'maven' 的委托具有方法 'content'，可在此处编写\n    // 但也可使用 'exclusiveContent'\n    exclusiveContent {} // 报告 'exclusiveContent'\n  }\n}'",
                  "markdown": "检测可能位置错误的 Gradle 方法调用。\nGradle buildscripts 包含许多嵌套闭包，使得代码结构类似于标记语言。 由于 DSL 语言的行为，可以在外部闭包中编写的方法也可以在内部闭包中使用。 此类方法在其范围之外编写时可能没有任何意义。   \n有时可能很难发现这种情况。 此检查的目的就是发现此类方法。\n\n**示例：**\n\n\n    repositories {\n      // 'repositories' 的委托具有方法 'exclusiveContent'，可在此处编写\n      maven {\n        // 'maven' 的委托具有方法 'content'，可在此处编写\n        // 但也可使用 'exclusiveContent'\n        exclusiveContent {} // 报告 'exclusiveContent'\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ForeignDelegate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/可能的 bug",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectPluginDslStructure",
                "shortDescription": {
                  "text": "插件 DSL 结构"
                },
                "fullDescription": {
                  "text": "检测 'plugins {}' 块前不允许的语句。 由于 Gradle 插件 DSL 的限制，在 ''plugins {}'' 块前只有一组受限的 Groovy 语句可用。 唯一的选项是 ''buildscript {}''、''pluginManagement {}'' 和其他 ''plugins {}''。 请参阅 Gradle 文档 示例： 'import foo.bar.Baz\nplugins {} // 报告 'plugins'\nplugins {\n  foo() // 报告 'foo'\n  id 'java'\n}'",
                  "markdown": "检测 'plugins {}' 块前不允许的语句。\n由于 Gradle 插件 DSL 的限制，在 '`plugins {}`' 块前只有一组受限的 Groovy 语句可用。 唯一的选项是 '`buildscript {}`'、'`pluginManagement {}`' 和其他 '`plugins {}`'。   \n[请参阅 Gradle 文档](https://docs.gradle.org/current/userguide/plugins.html#plugins_dsl_limitations)\n\n**示例：**\n\n\n    import foo.bar.Baz\n    plugins {} // 报告 'plugins'\n    plugins {\n      foo() // 报告 'foo'\n      id 'java'\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "IncorrectPluginDslStructure",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/有效性问题",
                      "index": 48,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BintrayPublishingPlugin",
                "shortDescription": {
                  "text": "Bintray 发布插件可能会在 2021 年 5 月 1 日停止工作"
                },
                "fullDescription": {
                  "text": "检测 Gradle 插件 'com.jfrog.bintray' 的用法。 该插件用于将构建结果发布到 Bintray。 发布到 Bintray 服务已禁用。",
                  "markdown": "检测 Gradle 插件 `com.jfrog.bintray` 的用法。\n该插件用于将构建结果发布到 Bintray。\n发布到 [Bintray](https://www.jfrog.com/confluence/display/BT/Welcome+to+JFrog+Bintray) 服务已禁用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BintrayPublishingPlugin",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/可能的 bug",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DependencyNotationArgument",
                "shortDescription": {
                  "text": "无法识别的依赖关系表示法"
                },
                "fullDescription": {
                  "text": "检测不正确的依赖项表示法。 Gradle 支持以下类型/格式： 'Dependency' 的实例； 'String' 或 'CharSequence' 值，例如 ''org.gradle:gradle-core:1.0''； 映射，例如 '[group: 'org.gradle', name: 'gradle-core', version: '1.0']'； FileCollection，例如 'files('some.jar', 'someOther.jar')'； 项目，例如 'project(':some:project:path')'； 'ClassPathNotation'，例如 'gradleApi()'； 依赖项表示法列表，例如 '['org.gradle:gradle-core:1.0']'； (Gradle 7.0+) 版本目录访问器，例如 'libs.groovy.core'。 请参阅 Gradle 文档 示例： 'dependencies {\n  implementation(1) // reports '1'\n}'",
                  "markdown": "检测不正确的依赖项表示法。\nGradle 支持以下类型/格式：\n\n* `Dependency` 的实例；\n* `String` 或 `CharSequence` 值，例如 `'org.gradle:gradle-core:1.0'`；\n* 映射，例如 `[group: 'org.gradle', name: 'gradle-core', version: '1.0']`；\n* FileCollection，例如 `files('some.jar', 'someOther.jar')`；\n* 项目，例如 `project(':some:project:path')`；\n* `ClassPathNotation`，例如 `gradleApi()`；\n* 依赖项表示法列表，例如 `['org.gradle:gradle-core:1.0']`；\n* (Gradle 7.0+) [版本目录访问器](https://docs.gradle.org/current/userguide/platforms.html)，例如 `libs.groovy.core`。\n\n[请参阅 Gradle 文档](https://docs.gradle.org/current/userguide/declaring_dependencies.html#sec:dependency-types)\n\n**示例：**\n\n\n    dependencies {\n      implementation(1) // reports '1'\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DependencyNotationArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/可能的 bug",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedConfigurations",
                "shortDescription": {
                  "text": "已弃用的配置"
                },
                "fullDescription": {
                  "text": "检测已弃用的配置方法的用法。 配置方法可能因为以下两个可能的原因之一而被弃用： Gradle API 已经发展，因此应该避免选择旧方法； 某款插件提供了已弃用配置方法的更好版本。 最有可能的是，将会有替代已弃用方法的替代方法。 示例： 'plugins {\n  id 'java'\n}\n\ndependencies {\n  archive 'org.gradle.api:gradle:1.0' // reports 'archive'\n}'",
                  "markdown": "检测已弃用的配置方法的用法。\n配置方法可能因为以下两个可能的原因之一而被弃用：\n\n* Gradle API 已经发展，因此应该避免选择旧方法；\n* 某款插件提供了已弃用配置方法的更好版本。\n\n最有可能的是，将会有替代已弃用方法的替代方法。\n\n**示例：**\n\n\n    plugins {\n      id 'java'\n    }\n\n    dependencies {\n      archive 'org.gradle.api:gradle:1.0' // reports 'archive'\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedConfigurations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/有效性问题",
                      "index": 48,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedVersionCatalogEntry",
                "shortDescription": {
                  "text": "未使用的版本目录条目"
                },
                "fullDescription": {
                  "text": "检测版本目录的 TOML 描述符中的未使用键。 示例： '// build.gradle\ndependencies {\n  implementation libs.foo.bar\n}' '# libs.versions.toml\n[libraries]\nfoo-bar = \"com.gradle:example:1.0.0\"\nbar-baz = \"com.gradle:example:2.0.0\" # 高亮显示 bar-baz'",
                  "markdown": "检测版本目录的 TOML 描述符中的未使用键。\n\n**示例：**\n\n\n    // build.gradle\n    dependencies {\n      implementation libs.foo.bar\n    }\n\n\n    # libs.versions.toml\n    [libraries]\n    foo-bar = \"com.gradle:example:1.0.0\"\n    bar-baz = \"com.gradle:example:2.0.0\" # 高亮显示 bar-baz\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedVersionCatalogEntry",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/样式",
                      "index": 121,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleRepositoryUrls",
                "shortDescription": {
                  "text": "多个仓库 URL"
                },
                "fullDescription": {
                  "text": "报告每个存储库块（Maven 或 Ivy）使用多个 URL 的情况。 问题在于只能为存储库选择一个 URL，而其他 URL 将被忽略。",
                  "markdown": "报告每个存储库块（Maven 或 Ivy）使用多个 URL 的情况。 问题在于只能为存储库选择一个 URL，而其他 URL 将被忽略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultipleRepositoryUrls",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/可能的 bug",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JCenterRepository",
                "shortDescription": {
                  "text": "2022 年 2 月 1 日后，构建不能再解析 JCenter 中的工件"
                },
                "fullDescription": {
                  "text": "检测 JCenter 存储库的用法以解决依赖关系。 2022 年 2 月 1 日后，构建不能再解析 JCenter 中的工件。",
                  "markdown": "检测 JCenter 存储库的用法以解决依赖关系。 2022 年 2 月 1 日后，构建不能再解析 JCenter 中的工件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JCenterRepository",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/可能的 bug",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfigurationAvoidance",
                "shortDescription": {
                  "text": "配置避免"
                },
                "fullDescription": {
                  "text": "(Gradle 4.9+) 检测预先与任务交互的 API 的用法。 与任务预先交互意味着很多困难： 用户应该手动设置任务之间的所有依赖关系； 在配置阶段，所有通过预先 API 访问的任务都会被配置，即使它们没有在之后执行。 这会导致性能下降。 最终， 预先 API 将被弃用，取而代之的是延迟 API。 有关迁移指南，请参阅 Gradle 文档。 示例： 'task foo { // 报告 'task'，建议将其替换为 'task.register'\n  // ...\n}'",
                  "markdown": "(Gradle 4.9+) 检测预先与任务交互的 API 的用法。\n\n与任务预先交互意味着很多困难：\n\n* 用户应该手动设置任务之间的所有依赖关系；\n* 在[配置阶段](https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases)，所有通过预先 API 访问的任务都会被配置，即使它们没有在之后执行。 这会导致性能下降。\n\n最终， 预先 API 将被弃用，取而代之的是延迟 API。\n\n有关迁移指南，请参阅 [Gradle 文档](https://docs.gradle.org/current/userguide/task_configuration_avoidance.html)。\n\n**示例：**\n\n    task foo { // 报告 'task'，建议将其替换为 'task.register'\n      // ...\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfigurationAvoidance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/最佳做法",
                      "index": 130,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "HtmlTools",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "HtmlRequiredAltAttribute",
                "shortDescription": {
                  "text": "缺少所需的 'alt' 特性"
                },
                "fullDescription": {
                  "text": "报告 'img' 或 'applet' 标记或图像映射的 'area' 元素中缺少的 'alt' 特性。 建议添加含标签内容替代文本的必要特性。 基于 WCAG 2.0：H24、H35、H36、H37。",
                  "markdown": "报告 `img` 或 `applet` 标记或图像映射的 `area` 元素中缺少的 `alt` 特性。 建议添加含标签内容替代文本的必要特性。 基于 WCAG 2.0：[H24](https://www.w3.org/TR/WCAG20-TECHS/H24.html)、[H35](https://www.w3.org/TR/WCAG20-TECHS/H35.html)、[H36](https://www.w3.org/TR/WCAG20-TECHS/H36.html)、[H37](https://www.w3.org/TR/WCAG20-TECHS/H37.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredAltAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/可访问性",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlDeprecatedTag",
                "shortDescription": {
                  "text": "废弃的标记"
                },
                "fullDescription": {
                  "text": "报告过时的 HTML5 标记。 建议将过时的标记替换为 CSS 或其他标记。",
                  "markdown": "报告过时的 HTML5 标记。 建议将过时的标记替换为 CSS 或其他标记。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlDeprecatedTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckImageSize",
                "shortDescription": {
                  "text": "不匹配的图像大小"
                },
                "fullDescription": {
                  "text": "报告与所引用图像的实际宽度和高度不同的 'img' 标记的 'width' 和 'height' 特性值。",
                  "markdown": "报告与所引用图像的实际宽度和高度不同的 `img` 标记的 `width` 和 `height` 特性值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckImageSize",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlRequiredSummaryAttribute",
                "shortDescription": {
                  "text": "缺少所需的 'summary' 特性"
                },
                "fullDescription": {
                  "text": "报告 'table' 标记中缺少的 'summary' 特性。 建议添加 'summary' 特性。 基于 WCAG 2.0：H73。",
                  "markdown": "报告 `table` 标记中缺少的 `summary` 特性。 建议添加 `summary` 特性。 基于 WCAG 2.0：[H73](https://www.w3.org/TR/WCAG20-TECHS/H73.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredSummaryAttribute",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/可访问性",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlNonExistentInternetResource",
                "shortDescription": {
                  "text": "未解析的 Web 链接"
                },
                "fullDescription": {
                  "text": "报告未解析的 Web 链接。 通过在后台发出网络请求来发挥作用。",
                  "markdown": "报告未解析的 Web 链接。 通过在后台发出网络请求来发挥作用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlNonExistentInternetResource",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlFormInputWithoutLabel",
                "shortDescription": {
                  "text": "表单输入没有相关的label"
                },
                "fullDescription": {
                  "text": "报告没有关联标签的表单元素 ('input'、'textarea' 或 'select')。 建议创建新标签。 基于 WCAG 2.0：H44。",
                  "markdown": "报告没有关联标签的表单元素 (`input`、`textarea` 或 `select`)。 建议创建新标签。 基于 WCAG 2.0：[H44](https://www.w3.org/TR/WCAG20-TECHS/H44.html)。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlFormInputWithoutLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/可访问性",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlRequiredTitleAttribute",
                "shortDescription": {
                  "text": "缺少所需的 'title' 特性"
                },
                "fullDescription": {
                  "text": "报告缺少的标题特性 'frame'、'iframe'、'dl' 和 'a' 标记。 建议添加标题特性。 基于 WCAG 2.0：H33、H40 和 H64。",
                  "markdown": "报告缺少的标题特性 `frame`、`iframe`、`dl` 和 `a` 标记。 建议添加标题特性。 基于 WCAG 2.0：[H33](https://www.w3.org/TR/WCAG20-TECHS/H33.html)、[H40](https://www.w3.org/TR/WCAG20-TECHS/H40.html) 和 [H64](https://www.w3.org/TR/WCAG20-TECHS/H64.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredTitleAttribute",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/可访问性",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlRequiredLangAttribute",
                "shortDescription": {
                  "text": "缺少所需的 'lang' 特性"
                },
                "fullDescription": {
                  "text": "报告 'html' 标记中缺少的 'lang'（或 'xml:lang'）特性。 建议添加一项必备特性来声明文档的默认语言。 基于 WCAG 2.0：H57。",
                  "markdown": "报告 `html` 标记中缺少的 `lang`（或 `xml:lang`）特性。 建议添加一项必备特性来声明文档的默认语言。 基于 WCAG 2.0：[H57](https://www.w3.org/TR/WCAG20-TECHS/H57.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredLangAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/可访问性",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlRequiredTitleElement",
                "shortDescription": {
                  "text": "缺少所需的 'title' 元素"
                },
                "fullDescription": {
                  "text": "报告 'head' 部分中缺少的 'title' 元素。 建议添加 'title' 元素。 标题应能说明文档。 基于 WCAG 2.0：H25。",
                  "markdown": "报告 `head` 部分中缺少的 `title` 元素。 建议添加 `title` 元素。 标题应能说明文档。 基于 WCAG 2.0：[H25](https://www.w3.org/TR/WCAG20-TECHS/H25.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredTitleElement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/可访问性",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlDeprecatedAttribute",
                "shortDescription": {
                  "text": "废弃的特性"
                },
                "fullDescription": {
                  "text": "报告过时的 HTML5 特性。",
                  "markdown": "报告过时的 HTML5 特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlDeprecatedAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlPresentationalElement",
                "shortDescription": {
                  "text": "演示标记"
                },
                "fullDescription": {
                  "text": "报告 HTML 表示标记。 建议将表示标记替换为 CSS 或其他标记。",
                  "markdown": "报告 HTML 表示标记。 建议将表示标记替换为 CSS 或其他标记。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HtmlPresentationalElement",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.yaml",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "YAMLSchemaValidation",
                "shortDescription": {
                  "text": "由 JSON 架构验证"
                },
                "fullDescription": {
                  "text": "如果指定了架构，则报告 YAML 文件和 JSON 架构之间的不一致。 方案示例： '{\n    \"properties\": {\n      \"SomeNumberProperty\": {\n        \"type\": \"number\"\n      }\n    }\n  }' 以下是带有相应警告的示例： 'SomeNumberProperty: hello world'",
                  "markdown": "如果指定了架构，则报告 YAML 文件和 JSON 架构之间的不一致。\n\n**方案示例：**\n\n\n      {\n        \"properties\": {\n          \"SomeNumberProperty\": {\n            \"type\": \"number\"\n          }\n        }\n      }\n\n**以下是带有相应警告的示例：**\n\n\n      SomeNumberProperty: hello world\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "YAMLSchemaValidation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLUnresolvedAlias",
                "shortDescription": {
                  "text": "未解析的别名"
                },
                "fullDescription": {
                  "text": "报告 YAML 文件中的未解析别名。 示例： 'some_key: *unknown_alias'",
                  "markdown": "报告 YAML 文件中的未解析别名。\n\n**示例：**\n\n\n      some_key: *unknown_alias\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "YAMLUnresolvedAlias",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLSchemaDeprecation",
                "shortDescription": {
                  "text": "弃用的 YAML 键"
                },
                "fullDescription": {
                  "text": "报告 YAML 文件中已弃用的键。 仅当存在与相应 YAML 文件关联的 JSON 架构时，才会检查是否弃用。 请注意，JSON 架构规范中尚未定义弃用机制，并且此检查使用非标准的 'deprecationMessage' 扩展。 方案弃用示例： '{\n    \"properties\": {\n      \"SomeDeprecatedProperty\": {\n        \"deprecationMessage\": \"Baz\",\n        \"description\": \"Foo bar\"\n      }\n    }\n  }' 以下是带有相应警告的示例： 'SomeDeprecatedProperty: some value'",
                  "markdown": "报告 YAML 文件中已弃用的键。\n\n仅当存在与相应 YAML 文件关联的 JSON 架构时，才会检查是否弃用。\n\n请注意，JSON 架构规范中尚未定义弃用机制，并且此检查使用非标准的 `deprecationMessage` 扩展。\n\n**方案弃用示例：**\n\n\n      {\n        \"properties\": {\n          \"SomeDeprecatedProperty\": {\n            \"deprecationMessage\": \"Baz\",\n            \"description\": \"Foo bar\"\n          }\n        }\n      }\n\n**以下是带有相应警告的示例：**\n\n\n      SomeDeprecatedProperty: some value\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "YAMLSchemaDeprecation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLIncompatibleTypes",
                "shortDescription": {
                  "text": "可疑的类型不匹配"
                },
                "fullDescription": {
                  "text": "报告 YAML 文件中的标量值类型与相似位置中的值类型不匹配。 示例： 'myElements:\n  - value1\n  - value2\n  - false # <- 已报告，因为它是布尔值，而其他值是字符串'",
                  "markdown": "报告 YAML 文件中的标量值类型与相似位置中的值类型不匹配。\n\n**示例：**\n\n\n    myElements:\n      - value1\n      - value2\n      - false # <- 已报告，因为它是布尔值，而其他值是字符串\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "YAMLIncompatibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLRecursiveAlias",
                "shortDescription": {
                  "text": "递归别名"
                },
                "fullDescription": {
                  "text": "报告 YAML 别名中的递归。 别名不能递归并在相应定位标记引用的数据中使用。 示例： 'some_key: &some_anchor\n    sub_key1: value1\n    sub_key2: *some_anchor'",
                  "markdown": "报告 YAML 别名中的递归。\n\n别名不能递归并在相应定位标记引用的数据中使用。\n\n**示例：**\n\n\n      some_key: &some_anchor\n        sub_key1: value1\n        sub_key2: *some_anchor\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "YAMLRecursiveAlias",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLDuplicatedKeys",
                "shortDescription": {
                  "text": "重复的 YAML 键"
                },
                "fullDescription": {
                  "text": "报告 YAML 文件中的重复键。 示例： 'same_key: some value\n  same_key: another value'",
                  "markdown": "报告 YAML 文件中的重复键。\n\n**示例：**\n\n\n      same_key: some value\n      same_key: another value\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "YAMLDuplicatedKeys",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLUnusedAnchor",
                "shortDescription": {
                  "text": "未使用的定位标记"
                },
                "fullDescription": {
                  "text": "报告未使用的定位标记。 示例： 'some_key: &some_anchor\n    key1: value1'",
                  "markdown": "报告未使用的定位标记。\n\n**示例：**\n\n\n      some_key: &some_anchor\n        key1: value1\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "YAMLUnusedAnchor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "TestNG-J",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "groupsTestNG",
                "shortDescription": {
                  "text": "未定义的组名"
                },
                "fullDescription": {
                  "text": "报告传递给 '@Test' 注解中的 'dependsOnGroups' 或 'groups' 特性的未定义组名称。 快速修复将未定义的名称添加到已知组列表中。 使用 定义的组 字段定义现有组的逗号分隔列表。",
                  "markdown": "报告传递给 `@Test` 注解中的 `dependsOnGroups` 或 `groups` 特性的未定义组名称。\n\n快速修复将未定义的名称添加到已知组列表中。\n\n使用 **定义的组** 字段定义现有组的逗号分隔列表。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "groupsTestNG",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnitTestNG",
                "shortDescription": {
                  "text": "JUnit 测试可以转换为 TestNG"
                },
                "fullDescription": {
                  "text": "报告可以转换为基于 TestNG 的单元测试的任何基于 JUnit 的测试类。 示例： 'import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ExampleTest {\n  @Test\n  public void testExample(){\n    assertEquals(2 + 2, 4);\n  }\n}' 在应用快速修复后： 'import org.testng.Assert;\nimport org.testng.annotations.Test;\n\npublic class ExampleTest {\n  @Test\n  public void testExample(){\n    Assert.assertEquals(4, 2 + 2);\n  }\n}'",
                  "markdown": "报告可以转换为基于 TestNG 的单元测试的任何基于 JUnit 的测试类。\n\n示例：\n\n\n    import org.junit.Test;\n    import static org.junit.Assert.*;\n\n    public class ExampleTest {\n      @Test\n      public void testExample(){\n        assertEquals(2 + 2, 4);\n      }\n    }\n\n在应用快速修复后：\n\n\n    import org.testng.Assert;\n    import org.testng.annotations.Test;\n\n    public class ExampleTest {\n      @Test\n      public void testExample(){\n        Assert.assertEquals(4, 2 + 2);\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitTestNG",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertJavadoc",
                "shortDescription": {
                  "text": "TestNG Javadoc 可以转换为注解"
                },
                "fullDescription": {
                  "text": "使用 Javadoc 注解断言您的 TestNG 测试并将它们转换为 JDK 注解。 示例： '/**\n    * @testng.before-test\n  */\n  public void sample() {}' 在应用快速修复后： '@BeforeTest\n  public void sample() {}'",
                  "markdown": "使用 Javadoc 注解断言您的 TestNG 测试并将它们转换为 JDK 注解。\n\n示例：\n\n\n      /**\n        * @testng.before-test\n      */\n      public void sample() {}\n\n在应用快速修复后：\n\n\n      @BeforeTest\n      public void sample() {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConvertJavadoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DataProviderReturnType",
                "shortDescription": {
                  "text": "数据提供程序返回值类型无效"
                },
                "fullDescription": {
                  "text": "报告不返回 'Object[][]' 或 'Iterator<Object>' 的用 '@DataProvider' 注解标记的方法。 如果返回另一种类型，TestNG 将抛出异常。 示例： 'public class TestNgTest {\n  @DataProvider(name = \"Languages\")\n  List<String> getData() {\n    return List.of(\"Java\", \"Kotlin\");\n  }\n\n  @Test(dataProvider = \"Languages\")\n  public void testData(String language) {\n    System.out.println(language);\n  }\n}'",
                  "markdown": "报告不返回 `Object[][]` 或 `Iterator<Object>` 的用 `@DataProvider` 注解标记的方法。 如果返回另一种类型，TestNG 将抛出异常。\n\n示例：\n\n\n    public class TestNgTest {\n      @DataProvider(name = \"Languages\")\n      List<String> getData() {\n        return List.of(\"Java\", \"Kotlin\");\n      }\n\n      @Test(dataProvider = \"Languages\")\n      public void testData(String language) {\n        System.out.println(language);\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "DataProviderReturnType",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExpectedExceptionNeverThrownTestNG",
                "shortDescription": {
                  "text": "从未在测试方法正文中抛出预期异常"
                },
                "fullDescription": {
                  "text": "报告 TestNG 测试方法预期但从未在方法主体内抛出的已检查的异常。 示例： '@Test(expectedExceptions = Exception.class) // 警告：从未抛出预期的 ‘Exception'\n  public void testEngineIsRunning() {\n    assertTrue(engine.isRunning());\n  }'",
                  "markdown": "报告 TestNG 测试方法预期但从未在方法主体内抛出的已检查的异常。\n\n**示例：**\n\n\n      @Test(expectedExceptions = Exception.class) // 警告：从未抛出预期的 'Exception'\n      public void testEngineIsRunning() {\n        assertTrue(engine.isRunning());\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExpectedExceptionNeverThrownTestNG",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UndeclaredTests",
                "shortDescription": {
                  "text": "未声明的测试"
                },
                "fullDescription": {
                  "text": "报告未在 'testing.xml' 中注册的测试类。 这通常是一个错误，因为此类测试不会被执行。",
                  "markdown": "报告未在 `testing.xml` 中注册的测试类。 这通常是一个错误，因为此类测试不会被执行。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UndeclaredTests",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertOldAnnotations",
                "shortDescription": {
                  "text": "使用了旧的 TestNG 注解 @Configuration"
                },
                "fullDescription": {
                  "text": "报告 TestNG 'org.testng.annotations.Configuration' 注解。 最好使用现代 '@BeforeXXX'/'@AfterXXX' 注解来配置测试套件。 示例： 'public class Test {\n    @Configuration(beforeSuite = true, afterTest = true)\n    public void afterBefore(){\n    }\n  }' 在应用快速修复后： 'public class Test {\n    @AfterTest()\n    @BeforeSuite()\n    public void afterBefore(){\n    }\n  }'",
                  "markdown": "报告 TestNG `org.testng.annotations.Configuration` 注解。\n\n最好使用现代 `@BeforeXXX`/`@AfterXXX` 注解来配置测试套件。\n\n示例：\n\n\n      public class Test {\n        @Configuration(beforeSuite = true, afterTest = true)\n        public void afterBefore(){\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Test {\n        @AfterTest()\n        @BeforeSuite()\n        public void afterBefore(){\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConvertOldAnnotations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicatedDataProviderNames",
                "shortDescription": {
                  "text": "数据提供程序名称重复"
                },
                "fullDescription": {
                  "text": "如果发生 'org.testng.TestNGException'，则报告具有相同名称的 'TestNG' 数据提供者。 示例： 'public class DuplicatedDataProviders {\n    @DataProvider\n    public Object[][] intTestData() { // 重复项 1\n      return new Integer[][]{\n        new Integer[]{1, 1},\n      };\n    }\n\n    @DataProvider(name = \"intTestData\")\n    public Object[][] someTestData() { // 重复项 2\n      return new Integer[][]{\n        new Integer[]{1, 1},\n      };\n    }\n\n    @Test(dataProvider = \"intTestData\")\n    public void testIsOK(Integer key, Integer value) {\n      assertEquals(key, value);\n    }\n  }'",
                  "markdown": "如果发生 `org.testng.TestNGException`，则报告具有相同名称的 `TestNG` 数据提供者。\n\n示例：\n\n\n      public class DuplicatedDataProviders {\n        @DataProvider\n        public Object[][] intTestData() { // 重复项 1\n          return new Integer[][]{\n            new Integer[]{1, 1},\n          };\n        }\n\n        @DataProvider(name = \"intTestData\")\n        public Object[][] someTestData() { // 重复项 2\n          return new Integer[][]{\n            new Integer[]{1, 1},\n          };\n        }\n\n        @Test(dataProvider = \"intTestData\")\n        public void testIsOK(Integer key, Integer value) {\n          assertEquals(key, value);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "DuplicatedDataProviderNames",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "dependsOnMethodTestNG",
                "shortDescription": {
                  "text": "传递给 'dependsOnMethods' 的方法名称非法"
                },
                "fullDescription": {
                  "text": "报告传递给 '@Test' 注解中的 'dependsOnMethods' 特性的非法方法名称。 如果方法名称不能解析为当前类或其任何父类中的有效、可访问的 '@Test' 注解方法，则该方法名称被认为是非法的。 示例： 'public class SampleTest {\n    @Test(dependsOnMethods = \"testSpellignError\")\n    public void testSample() {}\n    @Test\n    public void testSpellingError(){}\n  }'",
                  "markdown": "报告传递给 `@Test` 注解中的 `dependsOnMethods` 特性的非法方法名称。\n\n如果方法名称不能解析为当前类或其任何父类中的有效、可访问的 `@Test` 注解方法，则该方法名称被认为是非法的。\n\n示例：\n\n\n      public class SampleTest {\n        @Test(dependsOnMethods = \"testSpellignError\")\n        public void testSample() {}\n        @Test\n        public void testSpellingError(){}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "dependsOnMethodTestNG",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MalformedDataProvider",
                "shortDescription": {
                  "text": "数据提供程序问题"
                },
                "fullDescription": {
                  "text": "报告对不存在或不可访问的数据提供者方法的引用。 示例： 'public class InstanceDataProviderFromForeignClass {\n  // 方法 data() 在类 A 中不存在\n  @Test(dataProvider = \"data\", dataProviderClass = A.class)\n  public void test() {\n  }\n}\nclass A { }' 在应用快速修复后： '//所需的 data() 方法在类 A 中创建\nclass A {\n  @DataProvider\n  public Object[][] data() {\n    return new Object[][]{};\n  }\n}'",
                  "markdown": "报告对不存在或不可访问的数据提供者方法的引用。\n\n示例：\n\n\n    public class InstanceDataProviderFromForeignClass {\n      // 方法 data() 在类 A 中不存在\n      @Test(dataProvider = \"data\", dataProviderClass = A.class)\n      public void test() {\n      }\n    }\n    class A { }\n\n在应用快速修复后：\n\n\n    //所需的 data() 方法在类 A 中创建\n    class A {\n      @DataProvider\n      public Object[][] data() {\n        return new Object[][]{};\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MalformedDataProvider",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "JUnit",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "MultipleExceptionsDeclaredOnTestMethod",
                "shortDescription": {
                  "text": "在测试方法上声明的多个异常"
                },
                "fullDescription": {
                  "text": "报告具有多个异常的 JUnit 测试方法的 'throws' 子句。 此类子句会造成不必要的冗余。 不会从其他项目代码调用测试方法，因此无需单独处理这些异常。 示例： '@Test\n  public void testReflection() throws NoSuchMethodException,\n      InvocationTargetException, IllegalAccessException {\n    String result = (String) String.class.getMethod(\"trim\")\n        .invoke(\" hello \");\n    assertEquals(\"hello\", result);\n  }' 通过快速修复将异常声明替换为单个异常： '@Test\n  public void testReflection() throws Exception {\n    String result = (String) String.class.getMethod(\"trim\")\n        .invoke(\" hello \");\n    assertEquals(\"hello\", result);\n  }'",
                  "markdown": "报告具有多个异常的 JUnit 测试方法的 `throws` 子句。 此类子句会造成不必要的冗余。 不会从其他项目代码调用测试方法，因此无需单独处理这些异常。\n\n示例：\n\n\n      @Test\n      public void testReflection() throws NoSuchMethodException,\n          InvocationTargetException, IllegalAccessException {\n        String result = (String) String.class.getMethod(\"trim\")\n            .invoke(\" hello \");\n        assertEquals(\"hello\", result);\n      }\n\n通过快速修复将异常声明替换为单个异常：\n\n\n      @Test\n      public void testReflection() throws Exception {\n        String result = (String) String.class.getMethod(\"trim\")\n            .invoke(\" hello \");\n        assertEquals(\"hello\", result);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultipleExceptionsDeclaredOnTestMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExpectedExceptionNeverThrown",
                "shortDescription": {
                  "text": "从未在测试方法正文中抛出预期异常"
                },
                "fullDescription": {
                  "text": "报告 JUnit 4 测试方法预期但从未在方法体内抛出的已检查的异常。 此类测试方法永远不会成功。 示例： '@Test(expected = CloneNotSupportedException.class)\n  public void testIt() { }'",
                  "markdown": "报告 JUnit 4 测试方法预期但从未在方法体内抛出的已检查的异常。 此类测试方法永远不会成功。\n\n**示例：**\n\n\n      @Test(expected = CloneNotSupportedException.class)\n      public void testIt() { }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExpectedExceptionNeverThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfObsoleteAssert",
                "shortDescription": {
                  "text": "使用废弃的 'junit.framework.Assert' 方法"
                },
                "fullDescription": {
                  "text": "报告对 'junit.framework.Assert' 类中方法的任何调用。 此类已废弃，这些调用可以替换为对 'org.junit.Assert' 类中方法的调用。 示例： 'import org.junit.*;\n  public class NecessaryTest {\n    @Test\n    public void testIt() {\n      junit.framework.Assert.assertEquals(\"expected\", \"actual\");\n    }\n  }' 应用快速修复后，结果如下所示： 'import org.junit;\n  public class NecessaryTest {\n\n    public void testIt() {\n      Assert.assertEquals(\"expected\", \"actual\");\n    }\n  }'",
                  "markdown": "报告对 `junit.framework.Assert` 类中方法的任何调用。 此类已废弃，这些调用可以替换为对 `org.junit.Assert` 类中方法的调用。\n\n示例：\n\n\n      import org.junit.*;\n      public class NecessaryTest {\n        @Test\n        public void testIt() {\n          junit.framework.Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\n应用快速修复后，结果如下所示：\n\n\n      import org.junit;\n      public class NecessaryTest {\n\n        public void testIt() {\n          Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfObsoleteAssert",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnitMixedFramework",
                "shortDescription": {
                  "text": "在单个 TestCase 中使用多个版本的 JUnit API"
                },
                "fullDescription": {
                  "text": "当在不同 JUnit 版本的测试用例中使用时，报告 JUnit 注解的方法。 为了确定测试用例的框架版本，该检查会在可用时检查超类的框架版本。 当某个超类不可用时，它将在测试用例中使用最常用的框架。 示例（JUnit 3 测试用例中的 JUnit 4 注解）： 'public class MyTest extends TestCase {\n      @Test\n      public void foo() { }\n\n      @Test\n      @Ignore\n      public void testBar() { }\n  }' 在应用快速修复后： 'public class MyTest extends TestCase {\n      public void testFoo() {}\n\n      public void _testBar() {}\n  }' 示例（JUnit 4 测试用例中的 JUnit 5 注解）： 'public class MyTest {\n      @BeforeAll // JUnit 5 生命周期方法\n      public void initialize() { }\n\n      @org.junit.Test  // JUnit 4 测试注解\n      public void test() {}\n\n      @org.junit.Test  // JUnit 4 测试注解\n      public void testWouldBeExecuted() {}\n  }' 在应用快速修复后： 'public class MyTest {\n      @BeforeClass // JUnit 4 生命周期方法\n      public void initialize() { }\n\n      @org.junit.Test  // JUnit 4 测试注解\n      public void test() {}\n\n      @org.junit.Test  // JUnit 4 测试注解\n      public void testWouldBeExecuted() {}\n  }'",
                  "markdown": "当在不同 JUnit 版本的测试用例中使用时，报告 JUnit 注解的方法。 为了确定测试用例的框架版本，该检查会在可用时检查超类的框架版本。 当某个超类不可用时，它将在测试用例中使用最常用的框架。\n\n示例（JUnit 3 测试用例中的 JUnit 4 注解）：\n\n\n      public class MyTest extends TestCase {\n          @Test\n          public void foo() { }\n\n          @Test\n          @Ignore\n          public void testBar() { }\n      }\n\n在应用快速修复后：\n\n\n      public class MyTest extends TestCase {\n          public void testFoo() {}\n\n          public void _testBar() {}\n      }\n\n示例（JUnit 4 测试用例中的 JUnit 5 注解）：\n\n\n      public class MyTest {\n          @BeforeAll // JUnit 5 生命周期方法\n          public void initialize() { }\n\n          @org.junit.Test  // JUnit 4 测试注解\n          public void test() {}\n\n          @org.junit.Test  // JUnit 4 测试注解\n          public void testWouldBeExecuted() {}\n      }\n\n在应用快速修复后：\n\n\n      public class MyTest {\n          @BeforeClass // JUnit 4 生命周期方法\n          public void initialize() { }\n\n          @org.junit.Test  // JUnit 4 测试注解\n          public void test() {}\n\n          @org.junit.Test  // JUnit 4 测试注解\n          public void testWouldBeExecuted() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitMixedFramework",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnit3StyleTestMethodInJUnit4Class",
                "shortDescription": {
                  "text": "JUnit 4 类中的旧样式 JUnit 测试方法"
                },
                "fullDescription": {
                  "text": "报告位于不扩展 JUnit 3 'TestCase' 类并包含 JUnit 4 或 JUnit 5 '@Test' 注解方法的类中的 JUnit 3 样式测试方法。 无法运行此类测试方法。",
                  "markdown": "报告位于不扩展 JUnit 3 `TestCase` 类并包含 JUnit 4 或 JUnit 5 `@Test` 注解方法的类中的 JUnit 3 样式测试方法。 无法运行此类测试方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnit3StyleTestMethodInJUnit4Class",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertEqualsMayBeAssertSame",
                "shortDescription": {
                  "text": "'assertEquals()' 可能是 'assertSame()'"
                },
                "fullDescription": {
                  "text": "报告可被替换为等效 'assertSame()' 调用的 JUnit 'assertEquals()' 调用。 当实参是不重写 'Object.equals()' 方法并显式比较对象标识的 'final' 类的实例时，可能发生这种情况。 建议将 'assertEquals()' 替换为 'assertSame()'。 示例： '@Test\n  public void testObjectType() {\n    Object o = getObject();\n    Assert.assertEquals(String.class, o.getClass());\n  }' 在应用快速修复后： '@Test\n  public void testSort() {\n    Object o = getObject();\n    Assert.assertSame(String.class, o.getClass());\n  }'",
                  "markdown": "报告可被替换为等效 `assertSame()` 调用的 JUnit `assertEquals()` 调用。 当实参是不重写 `Object.equals()` 方法并显式比较对象标识的 `final` 类的实例时，可能发生这种情况。\n\n建议将 `assertEquals()` 替换为 `assertSame()`。\n\n**示例：**\n\n\n      @Test\n      public void testObjectType() {\n        Object o = getObject();\n        Assert.assertEquals(String.class, o.getClass());\n      }\n\n在应用快速修复后：\n\n\n      @Test\n      public void testSort() {\n        Object o = getObject();\n        Assert.assertSame(String.class, o.getClass());\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertEqualsMayBeAssertSame",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuperTearDownInFinally",
                "shortDescription": {
                  "text": "未从 'finally' 块调用 JUnit 3 'super.tearDown()'"
                },
                "fullDescription": {
                  "text": "报告未在 'finally' 块内执行的 JUnit 3 的 'super.tearDown()' 方法的调用。 如果在调用 'super.tearDown()' 之前抛出异常，可能会导致不一致和泄露。 示例： 'public class AnotherTest extends CompanyTestCase {\n    private Path path;\n\n    @Override\n    protected void setUp() throws Exception {\n      super.setUp();\n      path = Files.createTempFile(\"File\", \".tmp\");\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n      Files.delete(path);\n      super.tearDown();\n    }\n  }' 改进后的代码： 'public class AnotherTest extends CompanyTestCase {\n    private Path path;\n\n    @Override\n    protected void setUp() throws Exception {\n      super.setUp();\n      path = Files.createTempFile(\"File\", \".tmp\");\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n      try {\n        Files.delete(path);\n      } finally {\n        super.tearDown();\n      }\n    }\n  }'",
                  "markdown": "报告未在 `finally` 块内执行的 JUnit 3 的 `super.tearDown()` 方法的调用。 如果在调用 `super.tearDown()` 之前抛出异常，可能会导致不一致和泄露。\n\n**示例：**\n\n\n      public class AnotherTest extends CompanyTestCase {\n        private Path path;\n\n        @Override\n        protected void setUp() throws Exception {\n          super.setUp();\n          path = Files.createTempFile(\"File\", \".tmp\");\n        }\n\n        @Override\n        protected void tearDown() throws Exception {\n          Files.delete(path);\n          super.tearDown();\n        }\n      }\n\n改进后的代码：\n\n\n      public class AnotherTest extends CompanyTestCase {\n        private Path path;\n\n        @Override\n        protected void setUp() throws Exception {\n          super.setUp();\n          path = Files.createTempFile(\"File\", \".tmp\");\n        }\n\n        @Override\n        protected void tearDown() throws Exception {\n          try {\n            Files.delete(path);\n          } finally {\n            super.tearDown();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuperTearDownInFinally",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnitMalformedDeclaration",
                "shortDescription": {
                  "text": "JUnit 格式错误的声明"
                },
                "fullDescription": {
                  "text": "报告格式错误且可能无法被 JUnit 测试框架识别的 JUnit 测试成员声明。 此检查会报告的问题如下： 无法构造的测试类 由 '@RegisterExtension' 注解的类型错误或在需要时未被声明为 static 的字段 使用 '@Nested' 注解的 static 或 private 内部类 在没有源的情况下定义的形参化测试 具有包含未知、非 static 或无实参目标的 '@MethodSource' 的形参化测试。 形参化测试方法形参与指定的 '@ValueSource' 或 '@EnumSource' 值之间的类型不匹配 由 '@Test'、'@ParameterizedTest' 或 '@RepeatedTest' 中的多个注解的测试 非 public 的 'setup()' 或 'tearDown()'方法，其返回值类型不是 void 或接受实参 为 private，接受实参或为非 static 的 'suite()' 方法 由 '@BeforeClass'、'@AfterClass'、'@BeforeAll' 或 '@AfterAll' 注解的非 public、非 static 方法，其返回值类型不是 void 或没有有效的形参列表 由 '@Before'、'@After'、'@BeforeEach' 或 '@AfterEach' 注解的非 public 方法，其返回值类型不是 void 或接受实参。 在 '@BeforeAll' 或 '@AfterAll' 方法中注入的 'RepetitionInfo' 由 '@Test' 注解测试使用，在 '@BeforeEach' 或 '@AfterEach'方法中注入的 'RepetitionInfo' 由 '@DataPoint' 或 '@DataPoints' 注解的非 public 或非 static 字段和方法 由 '@Rule' 注解的非 public 或者非 'TestRule' 或 'MethodRule' 的子类型的字段和方法 由 '@ClassRule' 注解的非 public、非 static 或非 'TestRule' 的子类型的字段和方法 'TestCase' 子类内带有 'test' 前缀的非 public 方法，其返回值类型不是 void，接受实参或为 static。 由 '@Test' 注解的非 public 方法，其返回值类型不是 void，接受实参或为 static 请注意，在 Kotlin 中，挂起函数确实有实参和非 void 返回值类型。 因此，它们也不会由 JUnit 测试运行程序执行。 此检查也将报告这一问题。 格式错误的 '@Before' 方法示例： '@Before private int foo(int arg) { }' 在应用快速修复后： '@Before public void foo() { }' 缺少方法源代码示例 (Kotlin)： 'class Example {\n    @MethodSource(\"parameters\")\n    @ParameterizedTest\n    fun foo(param: String) { ... }\n  }' 在应用快速修复后： 'class Example {\n    @MethodSource(\"parameters\")\n    @ParameterizedTest\n    fun foo(param: String) { ... }\n\n    companion object {\n      @JvmStatic\n      fun parameters(): Stream<Arguments> {\n        TODO(\"Not yet implemented\")\n      }\n    }\n  }' 使用检查选项可以指定注解。 不会报告任何使用其中一种注解进行注解的形参。",
                  "markdown": "报告格式错误且可能无法被 JUnit 测试框架识别的 JUnit 测试成员声明。 此检查会报告的问题如下：\n\n* 无法构造的测试类\n* 由 `@RegisterExtension` 注解的类型错误或在需要时未被声明为 static 的字段\n* 使用 `@Nested` 注解的 static 或 private 内部类\n* 在没有源的情况下定义的形参化测试\n* 具有包含未知、非 static 或无实参目标的 `@MethodSource` 的形参化测试。\n* 形参化测试方法形参与指定的 `@ValueSource` 或 `@EnumSource` 值之间的类型不匹配\n* 由 `@Test`、`@ParameterizedTest` 或 `@RepeatedTest` 中的多个注解的测试\n* 非 public 的 `setup()` 或 `tearDown()`方法，其返回值类型不是 void 或接受实参\n* 为 private，接受实参或为非 static 的 `suite()` 方法\n* 由 `@BeforeClass`、`@AfterClass`、`@BeforeAll` 或 `@AfterAll` 注解的非 public、非 static 方法，其返回值类型不是 void 或没有有效的形参列表\n* 由 `@Before`、`@After`、`@BeforeEach` 或 `@AfterEach` 注解的非 public 方法，其返回值类型不是 void 或接受实参。\n* 在 `@BeforeAll` 或 `@AfterAll` 方法中注入的 `RepetitionInfo`\n* 由 `@Test` 注解测试使用，在 `@BeforeEach` 或 `@AfterEach`方法中注入的 `RepetitionInfo`\n* 由 `@DataPoint` 或 `@DataPoints` 注解的非 public 或非 static 字段和方法\n* 由 `@Rule` 注解的非 public 或者非 `TestRule` 或 `MethodRule` 的子类型的字段和方法\n* 由 `@ClassRule` 注解的非 public、非 static 或非 `TestRule` 的子类型的字段和方法\n* `TestCase` 子类内带有 `test` 前缀的非 public 方法，其返回值类型不是 void，接受实参或为 static。\n* 由 `@Test` 注解的非 public 方法，其返回值类型不是 void，接受实参或为 static\n\n请注意，在 Kotlin 中，挂起函数确实有实参和非 void 返回值类型。 因此，它们也不会由 JUnit 测试运行程序执行。 此检查也将报告这一问题。\n\n**格式错误的 `@Before` 方法示例：**\n\n\n      @Before private int foo(int arg) { }\n\n在应用快速修复后：\n\n\n      @Before public void foo() { }\n\n**缺少方法源代码示例 (Kotlin)：**\n\n\n      class Example {\n        @MethodSource(\"parameters\")\n        @ParameterizedTest\n        fun foo(param: String) { ... }\n      }\n\n在应用快速修复后：\n\n\n      class Example {\n        @MethodSource(\"parameters\")\n        @ParameterizedTest\n        fun foo(param: String) { ... }\n\n        companion object {\n          @JvmStatic\n          fun parameters(): Stream<Arguments> {\n            TODO(\"Not yet implemented\")\n          }\n        }\n      }\n\n使用检查选项可以指定注解。 不会报告任何使用其中一种注解进行注解的形参。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JUnitMalformedDeclaration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertEqualsCalledOnArray",
                "shortDescription": {
                  "text": "在数组上调用了 'assertEquals()'"
                },
                "fullDescription": {
                  "text": "报告带有数组类型实参的 JUnit 'assertEquals()' 调用。 此类方法会比较数组的标识，而不是数组的内容。 应使用 'assertArrayEquals()' 方法检查数组内容。 示例： '@Test\n  public void testSort() {\n    int[] actual = {248, 496, 0, 56};\n    Arrays.sort(actual);\n    Assert.assertEquals(new int[] {0, 56, 248, 496}, actual);\n  }' 在应用快速修复后： '@Test\n  public void testSort() {\n    int[] actual = {248, 496, 0, 56};\n    Arrays.sort(actual);\n    Assert.assertArrayEquals(new int[] {0, 56, 248, 496}, actual);\n  }'",
                  "markdown": "报告带有数组类型实参的 JUnit `assertEquals()` 调用。 此类方法会比较数组的标识，而不是数组的内容。 应使用 `assertArrayEquals()` 方法检查数组内容。\n\n**示例：**\n\n\n      @Test\n      public void testSort() {\n        int[] actual = {248, 496, 0, 56};\n        Arrays.sort(actual);\n        Assert.assertEquals(new int[] {0, 56, 248, 496}, actual);\n      }\n\n在应用快速修复后：\n\n\n      @Test\n      public void testSort() {\n        int[] actual = {248, 496, 0, 56};\n        Arrays.sort(actual);\n        Assert.assertArrayEquals(new int[] {0, 56, 248, 496}, actual);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertEqualsCalledOnArray",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnit5AssertionsConverter",
                "shortDescription": {
                  "text": "JUnit 5 已废弃断言"
                },
                "fullDescription": {
                  "text": "报告 JUnit 5 测试中对任何'junit.framework.Assert'、'org.junit.Assert' 或 'org.junit.Assume' 类中的方法的调用。 尽管这些测试正常工作，但迁移到 'org.junit.jupiter.api.Assertions'/'org.junit.jupiter.api.Assumptions' 有助于避免对旧版 JUnit 的依赖。 示例： 'import org.junit.Assert;\n  import org.junit.jupiter.api.Test;\n\n  public class MyTest {\n    @Test\n    public void simpleTest() {\n      Assert.assertEquals(4, 2 + 2);\n    }\n  }' 在应用快速修复后： 'import org.junit.jupiter.api.Assertions;\n  import org.junit.jupiter.api.Test;\n\n  public class MyTest {\n    @Test\n    public void simpleTest() {\n      Assertions.assertEquals(4, 2 + 2);\n    }\n  }'",
                  "markdown": "报告 JUnit 5 测试中对任何`junit.framework.Assert`、`org.junit.Assert` 或 `org.junit.Assume` 类中的方法的调用。\n\n尽管这些测试正常工作，但迁移到 `org.junit.jupiter.api.Assertions`/`org.junit.jupiter.api.Assumptions` 有助于避免对旧版 JUnit 的依赖。\n\n**示例：**\n\n\n      import org.junit.Assert;\n      import org.junit.jupiter.api.Test;\n\n      public class MyTest {\n        @Test\n        public void simpleTest() {\n          Assert.assertEquals(4, 2 + 2);\n        }\n      }\n\n在应用快速修复后：\n\n\n      import org.junit.jupiter.api.Assertions;\n      import org.junit.jupiter.api.Test;\n\n      public class MyTest {\n        @Test\n        public void simpleTest() {\n          Assertions.assertEquals(4, 2 + 2);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnit5AssertionsConverter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterizedParametersStaticCollection",
                "shortDescription": {
                  "text": "没有数据提供程序方法的形参化测试类"
                },
                "fullDescription": {
                  "text": "报告使用 '@RunWith(Parameterized.class)' 注解，但要么不包括使用 '@Parameterized.Parameters' 注解的数据提供程序方法，要么此方法的签名不正确的 JUnit 4 形参化测试类。 这种测试类无法运行。 数据提供程序方法应为 'public' 和 'static' 并具有 'Iterable' 或 'Object[]' 的返回类型。 建议创建一个空的形参提供程序方法或更改不正确的数据提供程序方法的签名。 示例： '@RunWith(Parameterized.class)\n  public class ImportantTest {\n    private int input;\n    private int expected;\n\n    ImportantTest(int input, int expected) {\n      this.input = input;\n      this.expected = expected;\n    }\n\n    // …测试用例\n  }' 在应用快速修复后： '@RunWith(Parameterized.class)\n  public class ImportantTest {\n    private int input;\n    private int expected;\n\n    ImportantTest(int input, int expected) {\n      this.input = input;\n      this.expected = expected;\n    }\n\n    @Parameters\n    public static Iterable<Object[]> parameters() {\n      return null;\n    }\n\n    // ... test cases\n  }'",
                  "markdown": "报告使用 `@RunWith(Parameterized.class)` 注解，但要么不包括使用 `@Parameterized.Parameters` 注解的数据提供程序方法，要么此方法的签名不正确的 JUnit 4 [形参化测试](https://github.com/junit-team/junit4/wiki/parameterized-tests)类。 这种测试类无法运行。 数据提供程序方法应为 `public` 和 `static` 并具有 `Iterable` 或 `Object[]` 的返回类型。\n\n建议创建一个空的形参提供程序方法或更改不正确的数据提供程序方法的签名。\n\n**示例：**\n\n\n\n      @RunWith(Parameterized.class)\n      public class ImportantTest {\n        private int input;\n        private int expected;\n\n        ImportantTest(int input, int expected) {\n          this.input = input;\n          this.expected = expected;\n        }\n\n        // ...测试用例\n      }\n\n在应用快速修复后：\n\n\n      @RunWith(Parameterized.class)\n      public class ImportantTest {\n        private int input;\n        private int expected;\n\n        ImportantTest(int input, int expected) {\n          this.input = input;\n          this.expected = expected;\n        }\n\n        @Parameters\n        public static Iterable<Object[]> parameters() {\n          return null;\n        }\n\n        // ... test cases\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterizedParametersStaticCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Junit4RunWithInspection",
                "shortDescription": {
                  "text": "'@RunWith' 注解已存在于父类中"
                },
                "fullDescription": {
                  "text": "在 JUnit 测试层次结构中的父类和子类使用 '@RunWith' 进行注解时报告。 它可能导致意外的测试行为。 示例： '@RunWith(Suite.class)\n  @SuiteClasses(MySuiteClass.class)\n  public abstract Parent {\n  }\n\n  @RunWith(Parameterized.class)\n  public MyTest {\n  }' 2024.1 最新变化",
                  "markdown": "在 JUnit 测试层次结构中的父类和子类使用 `@RunWith` 进行注解时报告。 它可能导致意外的测试行为。\n\n**示例：**\n\n\n      @RunWith(Suite.class)\n      @SuiteClasses(MySuiteClass.class)\n      public abstract Parent {\n      }\n\n      @RunWith(Parameterized.class)\n      public MyTest {\n      }\n\n\n2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Junit4RunWithInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnit5Converter",
                "shortDescription": {
                  "text": "JUnit 4 测试可以为 JUnit 5"
                },
                "fullDescription": {
                  "text": "报告可以自动迁移到 JUnit 5 的 JUnit 4 测试。 虽然默认运行程序可以自动转换，但自定义运行程序、方法规则和字段规则不能自动转换，需要手动更改。 示例： 'import org.junit.Assert;\n  import org.junit.Test;\n\n  public class RelevantTest {\n    @Test\n    public void testIt() {\n      Assert.assertEquals(\"expected\", \"actual\");\n    }\n  }' 在应用快速修复后： 'import org.junit.jupiter.api.Assertions;\n  import org.junit.jupiter.api.Test;\n\n  public class RelevantTest {\n    @Test\n    public void testIt() {\n      Assertions.assertEquals(\"expected\", \"actual\");\n    }\n  }' 此检查要求类路径中提供 JUnit 5 库，并且为项目配置了 JDK 1.8 或更高版本。",
                  "markdown": "报告可以自动迁移到 JUnit 5 的 JUnit 4 测试。 虽然默认运行程序可以自动转换，但自定义运行程序、方法规则和字段规则不能自动转换，需要手动更改。\n\n**示例：**\n\n\n      import org.junit.Assert;\n      import org.junit.Test;\n\n      public class RelevantTest {\n        @Test\n        public void testIt() {\n          Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\n在应用快速修复后：\n\n\n      import org.junit.jupiter.api.Assertions;\n      import org.junit.jupiter.api.Test;\n\n      public class RelevantTest {\n        @Test\n        public void testIt() {\n          Assertions.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\n此检查要求类路径中提供 JUnit 5 库，并且为项目配置了 JDK 1.8 或更高版本。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnit5Converter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Junit4Converter",
                "shortDescription": {
                  "text": "JUnit 3 测试可以是 JUnit 4"
                },
                "fullDescription": {
                  "text": "报告可以转换为 JUnit 4 测试类的 JUnit 3 测试类。 示例： 'public class MainTestCase extends junit.framework.TestCase {\n    public void test() {\n      Assert.assertTrue(true);\n    }\n  }' 在应用快速修复后： 'public class MainTestCase {\n    @org.junit.Test\n    public void test() {\n      Assert.assertTrue(true);\n    }\n  }' 当项目或模块的语言级别为 5 或更高级别并且在类路径上可以使用 JUnit 4 时，此检查才会报告。",
                  "markdown": "报告可以转换为 JUnit 4 测试类的 JUnit 3 测试类。\n\n**示例：**\n\n\n      public class MainTestCase extends junit.framework.TestCase {\n        public void test() {\n          Assert.assertTrue(true);\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class MainTestCase {\n        @org.junit.Test\n        public void test() {\n          Assert.assertTrue(true);\n        }\n      }\n\n当项目或模块的语言级别为 5 或更高级别并且在类路径上可以使用 JUnit 4 时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Junit4Converter",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IgnoredJUnitTest",
                "shortDescription": {
                  "text": "使用 '@Ignore'/'@Disabled' 注解的 JUnit 测试"
                },
                "fullDescription": {
                  "text": "报告 JUnit 4 的 '@Ignore' 或 JUnit 5 的 '@Disabled' 注解的用法。 长时间使用这些注解来注解测试会被认为是代码异味，特别是在没有指定原因的情况下。 示例： '@Ignore\n  public class UrgentTest {\n\n    @Test\n    public void testIt() {\n      Assert.assertEquals(\"expected\", \"actual\");\n    }\n  }' 配置检查： 使用仅报告没有原因的注解选项可以仅报告没有原因被指定为注解的 'value' 特性的情况。",
                  "markdown": "报告 JUnit 4 的 `@Ignore` 或 JUnit 5 的 `@Disabled` 注解的用法。 长时间使用这些注解来注解测试会被认为是代码异味，特别是在没有指定原因的情况下。\n\n**示例：**\n\n\n      @Ignore\n      public class UrgentTest {\n\n        @Test\n        public void testIt() {\n          Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\n\n配置检查：\n\n* 使用**仅报告没有原因的注解** 选项可以仅报告没有原因被指定为注解的 `value` 特性的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IgnoredJUnitTest",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MigrateAssertToMatcherAssert",
                "shortDescription": {
                  "text": "JUnit 断言可以是 'assertThat()' 调用"
                },
                "fullDescription": {
                  "text": "报告对可以迁移到 Hamcrest 声明式样式 'Assert.assertThat()' 调用的 'Assert.assertEquals()'、'Assert.assertTrue()' 等方法的调用。 示例： 'public class SubstantialTest {\n    @Test\n    public void testContents(Collection<String> c, String s) {\n      Assert.assertTrue(c.contains(s));\n      Assert.assertEquals(c, s);\n      Assert.assertNotNull(c);\n      Assert.assertNull(c);\n      Assert.assertFalse(c.contains(s));\n    }\n  }' 为执行迁移提供了快速修复： 'public class SubstantialTest {\n    @Test\n    public void testContents(Collection<String> c, String s) {\n      assertThat(c, hasItem(o));\n      assertThat(o, is(c));\n      assertThat(c, notNullValue());\n      assertThat(c, nullValue());\n      assertThat(c, not(hasItem(o)));\n    }\n  }' 此检查要求类路径上有可用的 Hamcrest 库。 使用静态导入匹配程序的方法选项，可指定是否希望该快速修复静态导入 Hamcrest 匹配程序方法。",
                  "markdown": "报告对可以迁移到 Hamcrest 声明式样式 `Assert.assertThat()` 调用的 `Assert.assertEquals()`、`Assert.assertTrue()` 等方法的调用。\n\n示例：\n\n\n      public class SubstantialTest {\n        @Test\n        public void testContents(Collection<String> c, String s) {\n          Assert.assertTrue(c.contains(s));\n          Assert.assertEquals(c, s);\n          Assert.assertNotNull(c);\n          Assert.assertNull(c);\n          Assert.assertFalse(c.contains(s));\n        }\n      }\n\n为执行迁移提供了快速修复：\n\n\n      public class SubstantialTest {\n        @Test\n        public void testContents(Collection<String> c, String s) {\n          assertThat(c, hasItem(o));\n          assertThat(o, is(c));\n          assertThat(c, notNullValue());\n          assertThat(c, nullValue());\n          assertThat(c, not(hasItem(o)));\n        }\n      }\n\n此检查要求类路径上有可用的 Hamcrest 库。\n\n使用**静态导入匹配程序的方法**选项，可指定是否希望该快速修复静态导入 Hamcrest 匹配程序方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MigrateAssertToMatcherAssert",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.properties",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "UseEllipsisInPropertyInspection",
                "shortDescription": {
                  "text": "使用三点字符而不是省略号"
                },
                "fullDescription": {
                  "text": "报告 UTF-8 属性文件中用于代替省略号字符的三个“点”字符。",
                  "markdown": "报告 UTF-8 属性文件中用于代替省略号字符的三个\"点\"字符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseEllipsisInPropertyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AlphaUnsortedPropertiesFile",
                "shortDescription": {
                  "text": "属性文件或资源包未按字母顺序排序"
                },
                "fullDescription": {
                  "text": "报告未按字母顺序排序的资源包或 .properties 文件。",
                  "markdown": "报告未按字母顺序排序的资源包或 .properties 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AlphaUnsortedPropertiesFile",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrailingSpacesInProperty",
                "shortDescription": {
                  "text": "属性中有尾随空格"
                },
                "fullDescription": {
                  "text": "报告键或值以空格结尾的所有属性。",
                  "markdown": "报告键或值以空格结尾的所有属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TrailingSpacesInProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedProperty",
                "shortDescription": {
                  "text": "未使用的属性"
                },
                "fullDescription": {
                  "text": "报告未在包含它们的 .properties 文件外部引用的属性。",
                  "markdown": "报告未在包含它们的 .properties 文件外部引用的属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrongPropertyKeyValueDelimiter",
                "shortDescription": {
                  "text": "属性键/值分隔符与代码样式设置不匹配"
                },
                "fullDescription": {
                  "text": "报告键或值分隔符与代码样式设置不匹配的属性。",
                  "markdown": "报告键或值分隔符与代码样式设置不匹配的属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WrongPropertyKeyValueDelimiter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicatePropertyInspection",
                "shortDescription": {
                  "text": "重复属性"
                },
                "fullDescription": {
                  "text": "报告具有不同值的重复属性键、重复键或重复属性值。 示例： 'property1=value;\nproperty2=value;' 选项 列表允许选择检查应搜索重复项的区域。",
                  "markdown": "报告具有不同值的重复属性键、重复键或重复属性值。\n\n示例：\n\n\n    property1=value;\n    property2=value;\n\n**选项** 列表允许选择检查应搜索重复项的区域。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicatePropertyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.javaFX",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "JavaFxEventHandler",
                "shortDescription": {
                  "text": "事件处理程序方法签名问题"
                },
                "fullDescription": {
                  "text": "报告事件处理程序问题，包括不兼容的实参类型、模糊的事件处理程序方法和错误的返回类型。",
                  "markdown": "报告事件处理程序问题，包括不兼容的实参类型、模糊的事件处理程序方法和错误的返回类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxEventHandler",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxRedundantPropertyValue",
                "shortDescription": {
                  "text": "JavaFX 冗余属性值"
                },
                "fullDescription": {
                  "text": "报告 .fxml 文件中具有默认值并因此变得冗余的属性（特性和标记）。",
                  "markdown": "报告 .fxml 文件中具有默认值并因此变得冗余的属性（特性和标记）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxRedundantPropertyValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxUnresolvedFxIdReference",
                "shortDescription": {
                  "text": "未解析的 fx:id 特性引用"
                },
                "fullDescription": {
                  "text": "报告未解析 fx: id 引用。 快速修复将创建相应的字段。",
                  "markdown": "报告未解析 fx: id 引用。 快速修复将创建相应的字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxUnresolvedFxIdReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxColorRgb",
                "shortDescription": {
                  "text": "颜色分量超出范围"
                },
                "fullDescription": {
                  "text": "报告有效范围之外的 RGB 颜色分量。",
                  "markdown": "报告有效范围之外的 RGB 颜色分量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxColorRgb",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxUnusedImports",
                "shortDescription": {
                  "text": "JavaFX 未使用的 import"
                },
                "fullDescription": {
                  "text": "报告 .fxml 文件中未使用的 import。",
                  "markdown": "报告 .fxml 文件中未使用的 import。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxUnusedImports",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxResourcePropertyValue",
                "shortDescription": {
                  "text": "属性文件中的值与特性类型不兼容"
                },
                "fullDescription": {
                  "text": "报告 .properties 文件中定义的与特性类型不匹配的特性值。",
                  "markdown": "报告 .properties 文件中定义的与特性类型不匹配的特性值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxResourcePropertyValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxDefaultTag",
                "shortDescription": {
                  "text": "不必要的默认标记"
                },
                "fullDescription": {
                  "text": "报告 .fxml 文件中的冗余标签。 这些标记对应于 @DefaultProperty 类注解中声明的类属性，因此可以省略它们。",
                  "markdown": "报告 .fxml 文件中的冗余标签。 这些标记对应于 @DefaultProperty 类注解中声明的类属性，因此可以省略它们。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxDefaultTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.uiDesigner",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "NoLabelFor",
                "shortDescription": {
                  "text": "无组件标签"
                },
                "fullDescription": {
                  "text": "报告没有任何静态文本并且没有为此组件使用 'setLabelFor' 标记的任何标签的组件。 没有静态文本的组件包括编辑字段与组合框。 无法使用键盘快捷键激活此类组件。 此检查的快速修复允许您自动将相邻标签与有问题的组件相关联。",
                  "markdown": "报告没有任何静态文本并且没有为此组件使用 `setLabelFor` 标记的任何标签的组件。\n\n没有静态文本的组件包括编辑字段与组合框。\n无法使用键盘快捷键激活此类组件。 此检查的快速修复允许您自动将相邻标签与有问题的组件相关联。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NoLabelFor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InvalidPropertyKeyForm",
                "shortDescription": {
                  "text": "UI 表单中的无效属性键"
                },
                "fullDescription": {
                  "text": "报告对 .properties 文件的未解析引用。",
                  "markdown": "报告对 .properties 文件的未解析引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InvalidPropertyKeyForm",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingMnemonic",
                "shortDescription": {
                  "text": "缺少助记键"
                },
                "fullDescription": {
                  "text": "报告具有 'text' 属性的可聚焦组件或具有分配的 'labelFor' 属性但没有助记符的标签。 该快速修复会为此类组件分配独一无二的助记符。",
                  "markdown": "报告具有 `text` 属性的可聚焦组件或具有分配的 `labelFor` 属性但没有助记符的标签。 该快速修复会为此类组件分配独一无二的助记符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingMnemonic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OneButtonGroup",
                "shortDescription": {
                  "text": "包含一个按钮的按钮组"
                },
                "fullDescription": {
                  "text": "报告仅包含一个 'JRadioButton' 的 'ButtonGroup' 实例。",
                  "markdown": "报告仅包含一个 `JRadioButton` 的 `ButtonGroup` 实例。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OneButtonGroup",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoScrollPane",
                "shortDescription": {
                  "text": "可滚动的组件不在 JScrollPane 中"
                },
                "fullDescription": {
                  "text": "报告未放置在 'JScrollPane' 中的 'Scrollable' 组件（'JTextField' 除外）。 该快速修复会使用滚动窗格围绕有问题的组件。",
                  "markdown": "报告未放置在 `JScrollPane` 中的 `Scrollable` 组件（`JTextField` 除外）。 该快速修复会使用滚动窗格围绕有问题的组件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NoScrollPane",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FormSpellChecking",
                "shortDescription": {
                  "text": "UI 表单中拼写错误"
                },
                "fullDescription": {
                  "text": "报告 UI 表单中的拼写错误（例如，'JLabel' 文本或 'JPanel' 标题）并一键修正。",
                  "markdown": "报告 UI 表单中的拼写错误（例如，`JLabel` 文本或 `JPanel` 标题）并一键修正。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FormSpellChecking",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateMnemonic",
                "shortDescription": {
                  "text": "助记键重复"
                },
                "fullDescription": {
                  "text": "报告具有重复助记符的组件。 该快速修复会为每个组件分配独一无二的助记符。",
                  "markdown": "报告具有重复助记符的组件。\n\n该快速修复会为每个组件分配独一无二的助记符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateMnemonic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "I18nForm",
                "shortDescription": {
                  "text": "UI 表单中的硬编码字符串文字"
                },
                "fullDescription": {
                  "text": "报告 UI 窗体中硬编码字符串的任何实例。 硬编码的字符串文字在国际化环境中通常是错误。 此检查不报告空字符串和仅包含空格的字符串。 该快速修复会将字符串文字转换为对资源包中属性的引用。",
                  "markdown": "报告 UI 窗体中硬编码字符串的任何实例。\n\n硬编码的字符串文字在国际化环境中通常是错误。\n此检查不报告空字符串和仅包含空格的字符串。\n\n该快速修复会将字符串文字转换为对资源包中属性的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "I18nForm",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoButtonGroup",
                "shortDescription": {
                  "text": "单选按钮不在组中"
                },
                "fullDescription": {
                  "text": "报告未放置在 'ButtonGroup' 中的 'JRadioButton' 组件。 可以通过快速修复对放置在相邻网格单元格中的单选按钮进行分组。",
                  "markdown": "报告未放置在 `ButtonGroup` 中的 `JRadioButton` 组件。 可以通过快速修复对放置在相邻网格单元格中的单选按钮进行分组。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NoButtonGroup",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BoundFieldAssignment",
                "shortDescription": {
                  "text": "赋值给 UI 绑定字段"
                },
                "fullDescription": {
                  "text": "报告绑定到 UI Designer 窗体中的组件的字段赋值。 此类赋值将导致 UI Designer 为此类字段生成的组件设置代码被忽略。",
                  "markdown": "报告绑定到 UI Designer 窗体中的组件的字段赋值。\n\n此类赋值将导致 UI Designer 为此类字段生成的组件设置代码被忽略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BoundFieldAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "UI 窗体",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.intellij.qodana",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "QodanaJavaSanity",
                "shortDescription": {
                  "text": "Java 健全性"
                },
                "fullDescription": {
                  "text": "报告 Java 代码中未解析的引用。",
                  "markdown": "报告 Java 代码中未解析的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "QodanaJavaSanity",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaAnnotator",
                "shortDescription": {
                  "text": "Java 注解器"
                },
                "fullDescription": {
                  "text": "允许查看 Java 注解器报告的问题：编译问题、IDEA 引用未解析等。",
                  "markdown": "允许查看 Java 注解器报告的问题：编译问题、IDEA 引用未解析等。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JavaAnnotator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JvmCoverageInspection",
                "shortDescription": {
                  "text": "检查 Kotlin 和 Java 源代码覆盖率"
                },
                "fullDescription": {
                  "text": "报告覆盖率低于某个阈值的方法和类。",
                  "markdown": "报告覆盖率低于某个阈值的方法和类。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JvmCoverageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "代码覆盖率",
                      "index": 100,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "QodanaKotlinSanity",
                "shortDescription": {
                  "text": "Kotlin 健全性"
                },
                "fullDescription": {
                  "text": "报告 Kotlin 代码中未解析的引用。",
                  "markdown": "报告 Kotlin 代码中未解析的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "QodanaKotlinSanity",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "QodanaSanity",
                "shortDescription": {
                  "text": "健全性"
                },
                "fullDescription": {
                  "text": "报告对此文件至关重要的问题，如语法错误、未解析的方法和变量等…",
                  "markdown": "报告对此文件至关重要的问题，如语法错误、未解析的方法和变量等..."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "QodanaSanity",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Qodana",
                      "index": 126,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.intellij.plugins.markdown",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "MarkdownLinkDestinationWithSpaces",
                "shortDescription": {
                  "text": "链接不应包含空格"
                },
                "fullDescription": {
                  "text": "为确保不同工具之间的一致性，文件链接不应包含空格。 示例： '[Some file link](some file.md)' 快速修复会将空格替换为它们的 URL 编码等效项： '[Some file link](some%20file.md)'",
                  "markdown": "为确保不同工具之间的一致性，文件链接不应包含空格。\n\n**示例：**\n\n\n      [Some file link](some file.md)\n\n快速修复会将空格替换为它们的 URL 编码等效项：\n\n\n      [Some file link](some%20file.md)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownLinkDestinationWithSpaces",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownNoTableBorders",
                "shortDescription": {
                  "text": "表没有边框"
                },
                "fullDescription": {
                  "text": "检查表是否有正确的边框。 出于兼容性原因，所有表行的开头和结尾都应该有边框（管道符号）。",
                  "markdown": "检查表是否有正确的边框。 出于兼容性原因，所有表行的开头和结尾都应该有边框（管道符号）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownNoTableBorders",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownOutdatedTableOfContents",
                "shortDescription": {
                  "text": "过期的目录部分"
                },
                "fullDescription": {
                  "text": "检查特定目录部分是否与文档的实际结构相对应。",
                  "markdown": "检查特定目录部分是否与文档的实际结构相对应。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownOutdatedTableOfContents",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownUnresolvedLinkLabel",
                "shortDescription": {
                  "text": "未解析的链接标签"
                },
                "fullDescription": {
                  "text": "报告 Markdown 文件中的未解析链接标签。",
                  "markdown": "报告 Markdown 文件中的未解析链接标签。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownUnresolvedLinkLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownIncorrectTableFormatting",
                "shortDescription": {
                  "text": "表格式设置不正确"
                },
                "fullDescription": {
                  "text": "检查表的格式是否正确。",
                  "markdown": "检查表的格式是否正确。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MarkdownIncorrectTableFormatting",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownIncorrectlyNumberedListItem",
                "shortDescription": {
                  "text": "列表项编号错误"
                },
                "fullDescription": {
                  "text": "排序列表项应从 1 开始连续编号。 这背后的动机是，大多数 Markdown 处理器会忽略有序列表的编号。 处理器将为此类列表生成 '<ol>' 元素，该元素将从 1 开始对条目进行连续编号。",
                  "markdown": "排序列表项应从 1 开始连续编号。\n\n这背后的动机是，大多数 Markdown 处理器会忽略有序列表的编号。 处理器将为此类列表生成 `<ol>` 元素，该元素将从 1 开始对条目进行连续编号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownIncorrectlyNumberedListItem",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownUnresolvedFileReference",
                "shortDescription": {
                  "text": "未解析的文件引用"
                },
                "fullDescription": {
                  "text": "报告 Markdown 文件中的未解析文件引用。",
                  "markdown": "报告 Markdown 文件中的未解析文件引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownUnresolvedFileReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownUnresolvedHeaderReference",
                "shortDescription": {
                  "text": "未解析的头引用"
                },
                "fullDescription": {
                  "text": "报告 Markdown 文件中的未解析头引用。",
                  "markdown": "报告 Markdown 文件中的未解析头引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownUnresolvedHeaderReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.security.package-checker",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "MaliciousLibrariesLocal",
                "shortDescription": {
                  "text": "恶意依赖项"
                },
                "fullDescription": {
                  "text": "报告在项目中声明的恶意 NPM 和 PyPI 依赖项。 修正报告的问题有助于防止您的软件受到攻击者的破坏。 移除恶意软件包以解决问题。",
                  "markdown": "报告在项目中声明的恶意 NPM 和 PyPI 依赖项。\n\n修正报告的问题有助于防止您的软件受到攻击者的破坏。\n\n移除恶意软件包以解决问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MaliciousLibrariesLocal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "安全性",
                      "index": 96,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VulnerableCodeUsages",
                "shortDescription": {
                  "text": "易受攻击的 API 用法"
                },
                "fullDescription": {
                  "text": "报告导入依赖项的脆弱 API 的用法。 修正报告的问题有助于防止您的软件受到攻击者的破坏。 要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。",
                  "markdown": "报告导入依赖项的脆弱 API 的用法。\n\n修正报告的问题有助于防止您的软件受到攻击者的破坏。\n\n要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VulnerableCodeUsages",
                    "cweIds": [
                      1395
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "安全性",
                      "index": 96,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VulnerableLibrariesGlobal",
                "shortDescription": {
                  "text": "易受攻击的导入依赖项"
                },
                "fullDescription": {
                  "text": "报告导入到项目中的 Gradle 和 Maven 依赖项中的漏洞。 Gradle 和 Maven 依赖项的完整列表显示在“项目”工具窗口的“外部库”下。 修正报告的问题有助于防止您的软件受到攻击者的破坏。 要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。 可用的快速修复可能会建议更新到安全版本或访问网站以详细了解特定漏洞。",
                  "markdown": "报告导入到项目中的 Gradle 和 Maven 依赖项中的漏洞。\nGradle 和 Maven 依赖项的完整列表显示在\"项目\"工具窗口的\"外部库\"下。\n\n修正报告的问题有助于防止您的软件受到攻击者的破坏。\n\n要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。\n\n可用的快速修复可能会建议更新到安全版本或访问网站以详细了解特定漏洞。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VulnerableLibrariesGlobal",
                    "cweIds": [
                      1395
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "安全性",
                      "index": 96,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VulnerableLibrariesLocal",
                "shortDescription": {
                  "text": "易受攻击的声明依赖项"
                },
                "fullDescription": {
                  "text": "报告在项目中声明的 Gradle、Maven、NPM 和 PyPI 依赖项中的漏洞。 Gradle 和 Maven 依赖项的完整列表显示在“项目”工具窗口的“外部库”下。 修正报告的问题有助于防止您的软件受到攻击者的破坏。 要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。 可用的快速修复可能会建议更新到安全版本或访问网站以详细了解特定漏洞。",
                  "markdown": "报告在项目中声明的 Gradle、Maven、NPM 和 PyPI 依赖项中的漏洞。\nGradle 和 Maven 依赖项的完整列表显示在\"项目\"工具窗口的\"外部库\"下。\n\n修正报告的问题有助于防止您的软件受到攻击者的破坏。\n\n要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。\n\n可用的快速修复可能会建议更新到安全版本或访问网站以详细了解特定漏洞。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VulnerableLibrariesLocal",
                    "cweIds": [
                      1395
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "安全性",
                      "index": 96,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "tanvd.grazi",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "LanguageDetectionInspection",
                "shortDescription": {
                  "text": "自然语言检测"
                },
                "fullDescription": {
                  "text": "检测自然语言并建议启用相应的语法和拼写检查。",
                  "markdown": "检测自然语言并建议启用相应的语法和拼写检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LanguageDetectionInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "校对",
                      "index": 90,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrazieInspection",
                "shortDescription": {
                  "text": "语法"
                },
                "fullDescription": {
                  "text": "报告文本中的语法错误。 您可以在设置 | 编辑器 | 自然语言 | 语法中配置检查。",
                  "markdown": "报告文本中的语法错误。 您可以在[设置 \\| 编辑器 \\| 自然语言 \\| 语法](settings://reference.settingsdialog.project.grazie)中配置检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrazieInspection",
                    "ideaSeverity": "GRAMMAR_ERROR",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "校对",
                      "index": 90,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.toml.lang",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "TomlUnresolvedReference",
                "shortDescription": {
                  "text": "未解析的引用"
                },
                "fullDescription": {
                  "text": "报告 TOML 文件中未解析的引用。",
                  "markdown": "报告 TOML 文件中未解析的引用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TomlUnresolvedReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "TOML",
                      "index": 115,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.idea.gradle.dsl",
            "version": "242.23339.11",
            "rules": [
              {
                "id": "DeclarativeUnresolvedReference",
                "shortDescription": {
                  "text": "未解析的引用"
                },
                "fullDescription": {
                  "text": "No description available",
                  "markdown": "No description available"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeclarativeUnresolvedReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "声明式 Gradle",
                      "index": 129,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          }
        ]
      },
      "invocations": [
        {
          "startTimeUtc": "2024-12-24T15:47:26.1551774Z",
          "exitCode": 0,
          "executionSuccessful": true
        }
      ],
      "language": "en-US",
      "versionControlProvenance": [
        {
          "repositoryUri": "https://github.com/muelovo/BookManager_JavaHW.git",
          "revisionId": "f6b92bfed65d4bf7da967e0ee669eb851be2c106",
          "branch": "master",
          "properties": {
            "repoUrl": "https://github.com/muelovo/BookManager_JavaHW.git",
            "lastAuthorName": "xpipi2019",
            "vcsType": "Git",
            "lastAuthorEmail": "1193820217@qq.com"
          }
        }
      ],
      "results": [],
      "automationDetails": {
        "id": "BookManager_JavaHW/qodana/2024-12-24",
        "guid": "af98998c-d799-4287-8397-20e38e22e719",
        "properties": {
          "jobUrl": "",
          "analysisKind": "ide"
        }
      },
      "newlineSequences": [
        "\r\n",
        "\n"
      ],
      "properties": {
        "configProfile": "starter",
        "deviceId": "19102411c44730e-1f1b-4a72-8df6-86ba5508fc88",
        "qodanaNewResultSummary": {
          "high": 20,
          "moderate": 3,
          "total": 23
        }
      }
    }
  ],
  "properties": {
    "runTimestamp": "1735055248055"
  }
}